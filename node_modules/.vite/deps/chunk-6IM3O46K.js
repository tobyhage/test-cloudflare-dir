import {
  require_jsx_runtime
} from "./chunk-6EJBKNQI.js";
import {
  require_react_dom
} from "./chunk-LMF45TQU.js";
import {
  require_react
} from "./chunk-YOU5AYP3.js";
import {
  bytesToHex,
  require_cookie,
  z
} from "./chunk-7KTIU2EK.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-KGMB3LMK.js";

// node_modules/.pnpm/is-hotkey@0.2.0/node_modules/is-hotkey/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/is-hotkey@0.2.0/node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f5 = 1; f5 < 20; f5++) {
      CODES["f" + f5] = 111 + f5;
    }
    var f5;
    function isHotkey2(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array = hotkey.map(function(string) {
        return parseHotkey(string, options);
      });
      var check = function check2(e6) {
        return array.some(function(object2) {
          return compareHotkey(object2, e6);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey2(hotkey, event);
    }
    function isKeyHotkey2(hotkey, event) {
      return isHotkey2(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values2 = hotkey.split("+");
      var length2 = values2.length;
      for (var k2 in MODIFIERS) {
        ret[MODIFIERS[k2]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value2 = _step.value;
          var optional = value2.endsWith("?") && value2.length > 1;
          if (optional) {
            value2 = value2.slice(0, -1);
          }
          var name2 = toKeyName(value2);
          var modifier = MODIFIERS[name2];
          if (value2.length > 1 && !modifier && !ALIASES[value2] && !CODES[name2]) {
            throw new TypeError('Unknown modifier: "' + value2 + '"');
          }
          if (length2 === 1 || !modifier) {
            if (byKey) {
              ret.key = name2;
            } else {
              ret.which = toKeyCode(value2);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key in object2) {
        var expected = object2[key];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name2) {
      name2 = toKeyName(name2);
      var code2 = CODES[name2] || name2.toUpperCase().charCodeAt(0);
      return code2;
    }
    function toKeyName(name2) {
      name2 = name2.toLowerCase();
      name2 = ALIASES[name2] || name2;
      return name2;
    }
    exports.default = isHotkey2;
    exports.isHotkey = isHotkey2;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey2;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type2) {
          return typeof type2 === "string" || typeof type2 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object2.type;
                switch (type2) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element4 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment11 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement3(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense2(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element4;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment11;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement3;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense2;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i6 = 0; i6 < 10; i6++) {
          test2["_" + String.fromCharCode(i6)] = i6;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n6) {
          return test2[n6];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s4 = 1; s4 < arguments.length; s4++) {
        from2 = Object(arguments[s4]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i6 = 0; i6 < symbols.length; i6++) {
            if (propIsEnumerable.call(from2, symbols[i6])) {
              to[symbols[i6]] = from2[symbols[i6]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text3) {
        var message = "Warning: " + text3;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values2, location2, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error3;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error3 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
            } catch (ex) {
              error3 = ex;
            }
            if (error3 && !(error3 instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error3 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error3 instanceof Error && !(error3.message in loggedTypeFailures)) {
              loggedTypeFailures[error3.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location2 + " type: " + error3.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign2 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text3) {
        var message = "Warning: " + text3;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x3) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x3, y4) {
        if (x3 === y4) {
          return x3 !== 0 || 1 / x3 === 1 / y4;
        } else {
          return x3 !== x3 && y4 !== y4;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate3) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate3(props, propName, componentName, location2, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate3(props, propName, componentName, location2, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate3(props, propName, componentName, location2, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i6 = 0; i6 < propValue.length; i6++) {
            var error3 = typeChecker(propValue, i6, componentName, location2, propFullName + "[" + i6 + "]", ReactPropTypesSecret);
            if (error3 instanceof Error) {
              return error3;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createElementTypeChecker() {
        function validate3(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createElementTypeTypeChecker() {
        function validate3(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate3(props, propName, componentName, location2, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate3(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          for (var i6 = 0; i6 < expectedValues.length; i6++) {
            if (is(propValue, expectedValues[i6])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value2) {
            var type2 = getPreciseType(value2);
            if (type2 === "symbol") {
              return String(value2);
            }
            return value2;
          });
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate3);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate3(props, propName, componentName, location2, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error3 = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error3 instanceof Error) {
                return error3;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i6 = 0; i6 < arrayOfTypeCheckers.length; i6++) {
          var checker = arrayOfTypeCheckers[i6];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i6 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate3(props, propName, componentName, location2, propFullName) {
          var expectedTypes = [];
          for (var i7 = 0; i7 < arrayOfTypeCheckers.length; i7++) {
            var checker2 = arrayOfTypeCheckers[i7];
            var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate3);
      }
      function createNodeChecker() {
        function validate3(props, propName, componentName, location2, propFullName) {
          if (!isNode2(props[propName])) {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function invalidValidatorError(componentName, location2, propFullName, key, type2) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate3(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
            }
            var error3 = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
            if (error3) {
              return error3;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate3(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error3 = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
            if (error3) {
              return error3;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function isNode2(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode2);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode2(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode2(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value2) {
        var type2 = getPreciseType(value2);
        switch (type2) {
          case "array":
          case "object":
            return "an " + type2;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type2;
          default:
            return type2;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/.pnpm/@braintree+sanitize-url@6.0.4/node_modules/@braintree/sanitize-url/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@braintree+sanitize-url@6.0.4/node_modules/@braintree/sanitize-url/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeUrl = exports.BLANK_URL = void 0;
    var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
    var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
    var htmlCtrlEntityRegex = /&(newline|tab);/gi;
    var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    var urlSchemeRegex = /^.+(:|&colon;)/gim;
    var relativeFirstCharacters = [".", "/"];
    exports.BLANK_URL = "about:blank";
    function isRelativeUrlWithoutProtocol(url) {
      return relativeFirstCharacters.indexOf(url[0]) > -1;
    }
    function decodeHtmlCharacters(str) {
      var removedNullByte = str.replace(ctrlCharactersRegex, "");
      return removedNullByte.replace(htmlEntitiesRegex, function(match3, dec) {
        return String.fromCharCode(dec);
      });
    }
    function sanitizeUrl2(url) {
      if (!url) {
        return exports.BLANK_URL;
      }
      var sanitizedUrl = decodeHtmlCharacters(url).replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
      if (!sanitizedUrl) {
        return exports.BLANK_URL;
      }
      if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
        return sanitizedUrl;
      }
      var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
      if (!urlSchemeParseResults) {
        return sanitizedUrl;
      }
      var urlScheme = urlSchemeParseResults[0];
      if (invalidProtocolRegex.test(urlScheme)) {
        return exports.BLANK_URL;
      }
      return sanitizedUrl;
    }
    exports.sanitizeUrl = sanitizeUrl2;
  }
});

// node_modules/.pnpm/direction@1.0.4/node_modules/direction/index.js
var require_direction = __commonJS({
  "node_modules/.pnpm/direction@1.0.4/node_modules/direction/index.js"(exports, module) {
    "use strict";
    module.exports = direction;
    var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
    var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
    var rtl = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    var ltr = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    function direction(value2) {
      value2 = String(value2 || "");
      if (rtl.test(value2)) {
        return "rtl";
      }
      if (ltr.test(value2)) {
        return "ltr";
      }
      return "neutral";
    }
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports, module) {
    function isObject2(value2) {
      var type2 = typeof value2;
      return value2 != null && (type2 == "object" || type2 == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js"(exports, module) {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module.exports = baseTrim;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value2) {
      var isOwn = hasOwnProperty2.call(value2, symToStringTag), tag = value2[symToStringTag];
      try {
        value2[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e6) {
      }
      var result = nativeObjectToString.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag] = tag;
        } else {
          delete value2[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value2) {
      return nativeObjectToString.call(value2);
    }
    module.exports = objectToString;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value2) {
      if (value2 == null) {
        return value2 === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike2(value2) {
      return value2 != null && typeof value2 == "object";
    }
    module.exports = isObjectLike2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike2(value2) && baseGetTag(value2) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject2 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber2(value2) {
      if (typeof value2 == "number") {
        return value2;
      }
      if (isSymbol(value2)) {
        return NAN;
      }
      if (isObject2(value2)) {
        var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
        value2 = isObject2(other) ? other + "" : other;
      }
      if (typeof value2 != "string") {
        return value2 === 0 ? value2 : +value2;
      }
      value2 = baseTrim(value2);
      var isBinary = reIsBinary.test(value2);
      return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
    }
    module.exports = toNumber2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js"(exports, module) {
    var isObject2 = require_isObject();
    var now = require_now();
    var toNumber2 = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber2(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush2() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time2 = now(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush2;
      return debounced;
    }
    module.exports = debounce2;
  }
});

// node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/throttle.js"(exports, module) {
    var debounce2 = require_debounce();
    var isObject2 = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject2(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module.exports = throttle2;
  }
});

// node_modules/.pnpm/is-hotkey@0.1.8/node_modules/is-hotkey/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/.pnpm/is-hotkey@0.1.8/node_modules/is-hotkey/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f5 = 1; f5 < 20; f5++) {
      CODES["f" + f5] = 111 + f5;
    }
    var f5;
    function isHotkey2(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array = hotkey.map(function(string) {
        return parseHotkey(string, options);
      });
      var check = function check2(e6) {
        return array.some(function(object2) {
          return compareHotkey(object2, e6);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey2(hotkey, event);
    }
    function isKeyHotkey2(hotkey, event) {
      return isHotkey2(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values2 = hotkey.split("+");
      var length2 = values2.length;
      for (var k2 in MODIFIERS) {
        ret[MODIFIERS[k2]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value2 = _step.value;
          var optional = value2.endsWith("?") && value2.length > 1;
          if (optional) {
            value2 = value2.slice(0, -1);
          }
          var name2 = toKeyName(value2);
          var modifier = MODIFIERS[name2];
          if (length2 === 1 || !modifier) {
            if (byKey) {
              ret.key = name2;
            } else {
              ret.which = toKeyCode(value2);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key in object2) {
        var expected = object2[key];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name2) {
      name2 = toKeyName(name2);
      var code2 = CODES[name2] || name2.toUpperCase().charCodeAt(0);
      return code2;
    }
    function toKeyName(name2) {
      name2 = name2.toLowerCase();
      name2 = ALIASES[name2] || name2;
      return name2;
    }
    exports.default = isHotkey2;
    exports.isHotkey = isHotkey2;
    exports.isCodeHotkey = isCodeHotkey;
    exports.isKeyHotkey = isKeyHotkey2;
    exports.parseHotkey = parseHotkey;
    exports.compareHotkey = compareHotkey;
    exports.toKeyCode = toKeyCode;
    exports.toKeyName = toKeyName;
  }
});

// node_modules/.pnpm/remove-accents@0.4.2/node_modules/remove-accents/index.js
var require_remove_accents = __commonJS({
  "node_modules/.pnpm/remove-accents@0.4.2/node_modules/remove-accents/index.js"(exports, module) {
    var characterMap = {
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "Ấ": "A",
      "Ắ": "A",
      "Ẳ": "A",
      "Ẵ": "A",
      "Ặ": "A",
      "Æ": "AE",
      "Ầ": "A",
      "Ằ": "A",
      "Ȃ": "A",
      "Ç": "C",
      "Ḉ": "C",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "Ế": "E",
      "Ḗ": "E",
      "Ề": "E",
      "Ḕ": "E",
      "Ḝ": "E",
      "Ȇ": "E",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "Ḯ": "I",
      "Ȋ": "I",
      "Ð": "D",
      "Ñ": "N",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "Ố": "O",
      "Ṍ": "O",
      "Ṓ": "O",
      "Ȏ": "O",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "Ý": "Y",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "ấ": "a",
      "ắ": "a",
      "ẳ": "a",
      "ẵ": "a",
      "ặ": "a",
      "æ": "ae",
      "ầ": "a",
      "ằ": "a",
      "ȃ": "a",
      "ç": "c",
      "ḉ": "c",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "ế": "e",
      "ḗ": "e",
      "ề": "e",
      "ḕ": "e",
      "ḝ": "e",
      "ȇ": "e",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "ḯ": "i",
      "ȋ": "i",
      "ð": "d",
      "ñ": "n",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "ố": "o",
      "ṍ": "o",
      "ṓ": "o",
      "ȏ": "o",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "ý": "y",
      "ÿ": "y",
      "Ā": "A",
      "ā": "a",
      "Ă": "A",
      "ă": "a",
      "Ą": "A",
      "ą": "a",
      "Ć": "C",
      "ć": "c",
      "Ĉ": "C",
      "ĉ": "c",
      "Ċ": "C",
      "ċ": "c",
      "Č": "C",
      "č": "c",
      "C̆": "C",
      "c̆": "c",
      "Ď": "D",
      "ď": "d",
      "Đ": "D",
      "đ": "d",
      "Ē": "E",
      "ē": "e",
      "Ĕ": "E",
      "ĕ": "e",
      "Ė": "E",
      "ė": "e",
      "Ę": "E",
      "ę": "e",
      "Ě": "E",
      "ě": "e",
      "Ĝ": "G",
      "Ǵ": "G",
      "ĝ": "g",
      "ǵ": "g",
      "Ğ": "G",
      "ğ": "g",
      "Ġ": "G",
      "ġ": "g",
      "Ģ": "G",
      "ģ": "g",
      "Ĥ": "H",
      "ĥ": "h",
      "Ħ": "H",
      "ħ": "h",
      "Ḫ": "H",
      "ḫ": "h",
      "Ĩ": "I",
      "ĩ": "i",
      "Ī": "I",
      "ī": "i",
      "Ĭ": "I",
      "ĭ": "i",
      "Į": "I",
      "į": "i",
      "İ": "I",
      "ı": "i",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "Ḱ": "K",
      "ḱ": "k",
      "K̆": "K",
      "k̆": "k",
      "Ĺ": "L",
      "ĺ": "l",
      "Ļ": "L",
      "ļ": "l",
      "Ľ": "L",
      "ľ": "l",
      "Ŀ": "L",
      "ŀ": "l",
      "Ł": "l",
      "ł": "l",
      "Ḿ": "M",
      "ḿ": "m",
      "M̆": "M",
      "m̆": "m",
      "Ń": "N",
      "ń": "n",
      "Ņ": "N",
      "ņ": "n",
      "Ň": "N",
      "ň": "n",
      "ŉ": "n",
      "N̆": "N",
      "n̆": "n",
      "Ō": "O",
      "ō": "o",
      "Ŏ": "O",
      "ŏ": "o",
      "Ő": "O",
      "ő": "o",
      "Œ": "OE",
      "œ": "oe",
      "P̆": "P",
      "p̆": "p",
      "Ŕ": "R",
      "ŕ": "r",
      "Ŗ": "R",
      "ŗ": "r",
      "Ř": "R",
      "ř": "r",
      "R̆": "R",
      "r̆": "r",
      "Ȓ": "R",
      "ȓ": "r",
      "Ś": "S",
      "ś": "s",
      "Ŝ": "S",
      "ŝ": "s",
      "Ş": "S",
      "Ș": "S",
      "ș": "s",
      "ş": "s",
      "Š": "S",
      "š": "s",
      "Ţ": "T",
      "ţ": "t",
      "ț": "t",
      "Ț": "T",
      "Ť": "T",
      "ť": "t",
      "Ŧ": "T",
      "ŧ": "t",
      "T̆": "T",
      "t̆": "t",
      "Ũ": "U",
      "ũ": "u",
      "Ū": "U",
      "ū": "u",
      "Ŭ": "U",
      "ŭ": "u",
      "Ů": "U",
      "ů": "u",
      "Ű": "U",
      "ű": "u",
      "Ų": "U",
      "ų": "u",
      "Ȗ": "U",
      "ȗ": "u",
      "V̆": "V",
      "v̆": "v",
      "Ŵ": "W",
      "ŵ": "w",
      "Ẃ": "W",
      "ẃ": "w",
      "X̆": "X",
      "x̆": "x",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Y̆": "Y",
      "y̆": "y",
      "Ź": "Z",
      "ź": "z",
      "Ż": "Z",
      "ż": "z",
      "Ž": "Z",
      "ž": "z",
      "ſ": "s",
      "ƒ": "f",
      "Ơ": "O",
      "ơ": "o",
      "Ư": "U",
      "ư": "u",
      "Ǎ": "A",
      "ǎ": "a",
      "Ǐ": "I",
      "ǐ": "i",
      "Ǒ": "O",
      "ǒ": "o",
      "Ǔ": "U",
      "ǔ": "u",
      "Ǖ": "U",
      "ǖ": "u",
      "Ǘ": "U",
      "ǘ": "u",
      "Ǚ": "U",
      "ǚ": "u",
      "Ǜ": "U",
      "ǜ": "u",
      "Ứ": "U",
      "ứ": "u",
      "Ṹ": "U",
      "ṹ": "u",
      "Ǻ": "A",
      "ǻ": "a",
      "Ǽ": "AE",
      "ǽ": "ae",
      "Ǿ": "O",
      "ǿ": "o",
      "Þ": "TH",
      "þ": "th",
      "Ṕ": "P",
      "ṕ": "p",
      "Ṥ": "S",
      "ṥ": "s",
      "X́": "X",
      "x́": "x",
      "Ѓ": "Г",
      "ѓ": "г",
      "Ќ": "К",
      "ќ": "к",
      "A̋": "A",
      "a̋": "a",
      "E̋": "E",
      "e̋": "e",
      "I̋": "I",
      "i̋": "i",
      "Ǹ": "N",
      "ǹ": "n",
      "Ồ": "O",
      "ồ": "o",
      "Ṑ": "O",
      "ṑ": "o",
      "Ừ": "U",
      "ừ": "u",
      "Ẁ": "W",
      "ẁ": "w",
      "Ỳ": "Y",
      "ỳ": "y",
      "Ȁ": "A",
      "ȁ": "a",
      "Ȅ": "E",
      "ȅ": "e",
      "Ȉ": "I",
      "ȉ": "i",
      "Ȍ": "O",
      "ȍ": "o",
      "Ȑ": "R",
      "ȑ": "r",
      "Ȕ": "U",
      "ȕ": "u",
      "B̌": "B",
      "b̌": "b",
      "Č̣": "C",
      "č̣": "c",
      "Ê̌": "E",
      "ê̌": "e",
      "F̌": "F",
      "f̌": "f",
      "Ǧ": "G",
      "ǧ": "g",
      "Ȟ": "H",
      "ȟ": "h",
      "J̌": "J",
      "ǰ": "j",
      "Ǩ": "K",
      "ǩ": "k",
      "M̌": "M",
      "m̌": "m",
      "P̌": "P",
      "p̌": "p",
      "Q̌": "Q",
      "q̌": "q",
      "Ř̩": "R",
      "ř̩": "r",
      "Ṧ": "S",
      "ṧ": "s",
      "V̌": "V",
      "v̌": "v",
      "W̌": "W",
      "w̌": "w",
      "X̌": "X",
      "x̌": "x",
      "Y̌": "Y",
      "y̌": "y",
      "A̧": "A",
      "a̧": "a",
      "B̧": "B",
      "b̧": "b",
      "Ḑ": "D",
      "ḑ": "d",
      "Ȩ": "E",
      "ȩ": "e",
      "Ɛ̧": "E",
      "ɛ̧": "e",
      "Ḩ": "H",
      "ḩ": "h",
      "I̧": "I",
      "i̧": "i",
      "Ɨ̧": "I",
      "ɨ̧": "i",
      "M̧": "M",
      "m̧": "m",
      "O̧": "O",
      "o̧": "o",
      "Q̧": "Q",
      "q̧": "q",
      "U̧": "U",
      "u̧": "u",
      "X̧": "X",
      "x̧": "x",
      "Z̧": "Z",
      "z̧": "z"
    };
    var chars = Object.keys(characterMap).join("|");
    var allAccents = new RegExp(chars, "g");
    var firstAccent = new RegExp(chars, "");
    var removeAccents2 = function(string) {
      return string.replace(allAccents, function(match3) {
        return characterMap[match3];
      });
    };
    var hasAccents = function(string) {
      return !!string.match(firstAccent);
    };
    module.exports = removeAccents2;
    module.exports.has = hasAccents;
    module.exports.remove = removeAccents2;
  }
});

// node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a3, b2, str) {
      if (a3 instanceof RegExp)
        a3 = maybeMatch(a3, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r7 = range(a3, b2, str);
      return r7 && {
        start: r7[0],
        end: r7[1],
        pre: str.slice(0, r7[0]),
        body: str.slice(r7[0] + a3.length, r7[1]),
        post: str.slice(r7[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m2 = str.match(reg);
      return m2 ? m2[0] : null;
    }
    balanced.range = range;
    function range(a3, b2, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a3);
      var bi = str.indexOf(b2, ai + 1);
      var i6 = ai;
      if (ai >= 0 && bi > 0) {
        if (a3 === b2) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i6 >= 0 && !result) {
          if (i6 == ai) {
            begs.push(i6);
            ai = str.indexOf(a3, i6 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b2, i6 + 1);
          }
          i6 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m2 = balanced("{", "}", str);
      if (!m2)
        return str.split(",");
      var pre = m2.pre;
      var body = m2.body;
      var post = m2.post;
      var p5 = pre.split(",");
      p5[p5.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p5[p5.length - 1] += postParts.shift();
        p5.push.apply(p5, postParts);
      }
      parts.push.apply(parts, p5);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i6, y4) {
      return i6 <= y4;
    }
    function gte(i6, y4) {
      return i6 >= y4;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m2 = balanced("{", "}", str);
      if (!m2)
        return [str];
      var pre = m2.pre;
      var post = m2.post.length ? expand2(m2.post, false) : [""];
      if (/\$$/.test(m2.pre)) {
        for (var k2 = 0; k2 < post.length; k2++) {
          var expansion = pre + "{" + m2.body + "}" + post[k2];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m2.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m2.post.match(/,.*\}/)) {
            str = m2.pre + "{" + m2.body + escClose + m2.post;
            return expand2(str);
          }
          return [str];
        }
        var n6;
        if (isSequence) {
          n6 = m2.body.split(/\.\./);
        } else {
          n6 = parseCommaParts(m2.body);
          if (n6.length === 1) {
            n6 = expand2(n6[0], false).map(embrace);
            if (n6.length === 1) {
              return post.map(function(p5) {
                return m2.pre + n6[0] + p5;
              });
            }
          }
        }
        var N2;
        if (isSequence) {
          var x3 = numeric(n6[0]);
          var y4 = numeric(n6[1]);
          var width = Math.max(n6[0].length, n6[1].length);
          var incr = n6.length == 3 ? Math.abs(numeric(n6[2])) : 1;
          var test = lte;
          var reverse = y4 < x3;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n6.some(isPadded);
          N2 = [];
          for (var i6 = x3; test(i6, y4); i6 += incr) {
            var c5;
            if (isAlphaSequence) {
              c5 = String.fromCharCode(i6);
              if (c5 === "\\")
                c5 = "";
            } else {
              c5 = String(i6);
              if (pad) {
                var need = width - c5.length;
                if (need > 0) {
                  var z3 = new Array(need + 1).join("0");
                  if (i6 < 0)
                    c5 = "-" + z3 + c5.slice(1);
                  else
                    c5 = z3 + c5;
                }
              }
            }
            N2.push(c5);
          }
        } else {
          N2 = [];
          for (var j3 = 0; j3 < n6.length; j3++) {
            N2.push.apply(N2, expand2(n6[j3], false));
          }
        }
        for (var j3 = 0; j3 < N2.length; j3++) {
          for (var k2 = 0; k2 < post.length; k2++) {
            var expansion = pre + N2[j3] + post[k2];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/.pnpm/escape-string-regexp@4.0.0/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/.pnpm/lodash.deburr@4.1.0/node_modules/lodash.deburr/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.deburr@4.1.0/node_modules/lodash.deburr/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value2) {
      if (typeof value2 == "string") {
        return value2;
      }
      if (isSymbol(value2)) {
        return symbolToString ? symbolToString.call(value2) : "";
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
    }
    function isObjectLike2(value2) {
      return !!value2 && typeof value2 == "object";
    }
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike2(value2) && objectToString.call(value2) == symbolTag;
    }
    function toString2(value2) {
      return value2 == null ? "" : baseToString(value2);
    }
    function deburr(string) {
      string = toString2(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/.pnpm/@sindresorhus+transliterate@0.1.2/node_modules/@sindresorhus/transliterate/replacements.js
var require_replacements2 = __commonJS({
  "node_modules/.pnpm/@sindresorhus+transliterate@0.1.2/node_modules/@sindresorhus/transliterate/replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      // German umlauts
      ["ß", "ss"],
      ["ä", "ae"],
      ["Ä", "Ae"],
      ["ö", "oe"],
      ["Ö", "Oe"],
      ["ü", "ue"],
      ["Ü", "Ue"],
      // Latin
      ["À", "A"],
      ["Á", "A"],
      ["Â", "A"],
      ["Ã", "A"],
      ["Ä", "Ae"],
      ["Å", "A"],
      ["Æ", "AE"],
      ["Ç", "C"],
      ["È", "E"],
      ["É", "E"],
      ["Ê", "E"],
      ["Ë", "E"],
      ["Ì", "I"],
      ["Í", "I"],
      ["Î", "I"],
      ["Ï", "I"],
      ["Ð", "D"],
      ["Ñ", "N"],
      ["Ò", "O"],
      ["Ó", "O"],
      ["Ô", "O"],
      ["Õ", "O"],
      ["Ö", "Oe"],
      ["Ő", "O"],
      ["Ø", "O"],
      ["Ù", "U"],
      ["Ú", "U"],
      ["Û", "U"],
      ["Ü", "Ue"],
      ["Ű", "U"],
      ["Ý", "Y"],
      ["Þ", "TH"],
      ["ß", "ss"],
      ["à", "a"],
      ["á", "a"],
      ["â", "a"],
      ["ã", "a"],
      ["ä", "ae"],
      ["å", "a"],
      ["æ", "ae"],
      ["ç", "c"],
      ["è", "e"],
      ["é", "e"],
      ["ê", "e"],
      ["ë", "e"],
      ["ì", "i"],
      ["í", "i"],
      ["î", "i"],
      ["ï", "i"],
      ["ð", "d"],
      ["ñ", "n"],
      ["ò", "o"],
      ["ó", "o"],
      ["ô", "o"],
      ["õ", "o"],
      ["ö", "oe"],
      ["ő", "o"],
      ["ø", "o"],
      ["ù", "u"],
      ["ú", "u"],
      ["û", "u"],
      ["ü", "ue"],
      ["ű", "u"],
      ["ý", "y"],
      ["þ", "th"],
      ["ÿ", "y"],
      ["ẞ", "SS"],
      // Vietnamese
      ["à", "a"],
      ["À", "A"],
      ["á", "a"],
      ["Á", "A"],
      ["â", "a"],
      ["Â", "A"],
      ["ã", "a"],
      ["Ã", "A"],
      ["è", "e"],
      ["È", "E"],
      ["é", "e"],
      ["É", "E"],
      ["ê", "e"],
      ["Ê", "E"],
      ["ì", "i"],
      ["Ì", "I"],
      ["í", "i"],
      ["Í", "I"],
      ["ò", "o"],
      ["Ò", "O"],
      ["ó", "o"],
      ["Ó", "O"],
      ["ô", "o"],
      ["Ô", "O"],
      ["õ", "o"],
      ["Õ", "O"],
      ["ù", "u"],
      ["Ù", "U"],
      ["ú", "u"],
      ["Ú", "U"],
      ["ý", "y"],
      ["Ý", "Y"],
      ["ă", "a"],
      ["Ă", "A"],
      ["Đ", "D"],
      ["đ", "d"],
      ["ĩ", "i"],
      ["Ĩ", "I"],
      ["ũ", "u"],
      ["Ũ", "U"],
      ["ơ", "o"],
      ["Ơ", "O"],
      ["ư", "u"],
      ["Ư", "U"],
      ["ạ", "a"],
      ["Ạ", "A"],
      ["ả", "a"],
      ["Ả", "A"],
      ["ấ", "a"],
      ["Ấ", "A"],
      ["ầ", "a"],
      ["Ầ", "A"],
      ["ẩ", "a"],
      ["Ẩ", "A"],
      ["ẫ", "a"],
      ["Ẫ", "A"],
      ["ậ", "a"],
      ["Ậ", "A"],
      ["ắ", "a"],
      ["Ắ", "A"],
      ["ằ", "a"],
      ["Ằ", "A"],
      ["ẳ", "a"],
      ["Ẳ", "A"],
      ["ẵ", "a"],
      ["Ẵ", "A"],
      ["ặ", "a"],
      ["Ặ", "A"],
      ["ẹ", "e"],
      ["Ẹ", "E"],
      ["ẻ", "e"],
      ["Ẻ", "E"],
      ["ẽ", "e"],
      ["Ẽ", "E"],
      ["ế", "e"],
      ["Ế", "E"],
      ["ề", "e"],
      ["Ề", "E"],
      ["ể", "e"],
      ["Ể", "E"],
      ["ễ", "e"],
      ["Ễ", "E"],
      ["ệ", "e"],
      ["Ệ", "E"],
      ["ỉ", "i"],
      ["Ỉ", "I"],
      ["ị", "i"],
      ["Ị", "I"],
      ["ọ", "o"],
      ["Ọ", "O"],
      ["ỏ", "o"],
      ["Ỏ", "O"],
      ["ố", "o"],
      ["Ố", "O"],
      ["ồ", "o"],
      ["Ồ", "O"],
      ["ổ", "o"],
      ["Ổ", "O"],
      ["ỗ", "o"],
      ["Ỗ", "O"],
      ["ộ", "o"],
      ["Ộ", "O"],
      ["ớ", "o"],
      ["Ớ", "O"],
      ["ờ", "o"],
      ["Ờ", "O"],
      ["ở", "o"],
      ["Ở", "O"],
      ["ỡ", "o"],
      ["Ỡ", "O"],
      ["ợ", "o"],
      ["Ợ", "O"],
      ["ụ", "u"],
      ["Ụ", "U"],
      ["ủ", "u"],
      ["Ủ", "U"],
      ["ứ", "u"],
      ["Ứ", "U"],
      ["ừ", "u"],
      ["Ừ", "U"],
      ["ử", "u"],
      ["Ử", "U"],
      ["ữ", "u"],
      ["Ữ", "U"],
      ["ự", "u"],
      ["Ự", "U"],
      ["ỳ", "y"],
      ["Ỳ", "Y"],
      ["ỵ", "y"],
      ["Ỵ", "Y"],
      ["ỷ", "y"],
      ["Ỷ", "Y"],
      ["ỹ", "y"],
      ["Ỹ", "Y"],
      // Arabic
      ["ء", "e"],
      ["آ", "a"],
      ["أ", "a"],
      ["ؤ", "w"],
      ["إ", "i"],
      ["ئ", "y"],
      ["ا", "a"],
      ["ب", "b"],
      ["ة", "t"],
      ["ت", "t"],
      ["ث", "th"],
      ["ج", "j"],
      ["ح", "h"],
      ["خ", "kh"],
      ["د", "d"],
      ["ذ", "dh"],
      ["ر", "r"],
      ["ز", "z"],
      ["س", "s"],
      ["ش", "sh"],
      ["ص", "s"],
      ["ض", "d"],
      ["ط", "t"],
      ["ظ", "z"],
      ["ع", "e"],
      ["غ", "gh"],
      ["ـ", "_"],
      ["ف", "f"],
      ["ق", "q"],
      ["ك", "k"],
      ["ل", "l"],
      ["م", "m"],
      ["ن", "n"],
      ["ه", "h"],
      ["و", "w"],
      ["ى", "a"],
      ["ي", "y"],
      ["َ‎", "a"],
      ["ُ", "u"],
      ["ِ‎", "i"],
      ["٠", "0"],
      ["١", "1"],
      ["٢", "2"],
      ["٣", "3"],
      ["٤", "4"],
      ["٥", "5"],
      ["٦", "6"],
      ["٧", "7"],
      ["٨", "8"],
      ["٩", "9"],
      // Persian / Farsi
      ["چ", "ch"],
      ["ک", "k"],
      ["گ", "g"],
      ["پ", "p"],
      ["ژ", "zh"],
      ["ی", "y"],
      ["۰", "0"],
      ["۱", "1"],
      ["۲", "2"],
      ["۳", "3"],
      ["۴", "4"],
      ["۵", "5"],
      ["۶", "6"],
      ["۷", "7"],
      ["۸", "8"],
      ["۹", "9"],
      // Pashto
      ["ټ", "p"],
      ["ځ", "z"],
      ["څ", "c"],
      ["ډ", "d"],
      ["ﺫ", "d"],
      ["ﺭ", "r"],
      ["ړ", "r"],
      ["ﺯ", "z"],
      ["ږ", "g"],
      ["ښ", "x"],
      ["ګ", "g"],
      ["ڼ", "n"],
      ["ۀ", "e"],
      ["ې", "e"],
      ["ۍ", "ai"],
      // Urdu
      ["ٹ", "t"],
      ["ڈ", "d"],
      ["ڑ", "r"],
      ["ں", "n"],
      ["ہ", "h"],
      ["ھ", "h"],
      ["ے", "e"],
      // Russian
      ["А", "A"],
      ["а", "a"],
      ["Б", "B"],
      ["б", "b"],
      ["В", "V"],
      ["в", "v"],
      ["Г", "G"],
      ["г", "g"],
      ["Д", "D"],
      ["д", "d"],
      ["Е", "E"],
      ["е", "e"],
      ["Ж", "Zh"],
      ["ж", "zh"],
      ["З", "Z"],
      ["з", "z"],
      ["И", "I"],
      ["и", "i"],
      ["Й", "J"],
      ["й", "j"],
      ["К", "K"],
      ["к", "k"],
      ["Л", "L"],
      ["л", "l"],
      ["М", "M"],
      ["м", "m"],
      ["Н", "N"],
      ["н", "n"],
      ["О", "O"],
      ["о", "o"],
      ["П", "P"],
      ["п", "p"],
      ["Р", "R"],
      ["р", "r"],
      ["С", "S"],
      ["с", "s"],
      ["Т", "T"],
      ["т", "t"],
      ["У", "U"],
      ["у", "u"],
      ["Ф", "F"],
      ["ф", "f"],
      ["Х", "H"],
      ["х", "h"],
      ["Ц", "Cz"],
      ["ц", "cz"],
      ["Ч", "Ch"],
      ["ч", "ch"],
      ["Ш", "Sh"],
      ["ш", "sh"],
      ["Щ", "Shh"],
      ["щ", "shh"],
      ["Ъ", ""],
      ["ъ", ""],
      ["Ы", "Y"],
      ["ы", "y"],
      ["Ь", ""],
      ["ь", ""],
      ["Э", "E"],
      ["э", "e"],
      ["Ю", "Yu"],
      ["ю", "yu"],
      ["Я", "Ya"],
      ["я", "ya"],
      ["Ё", "Yo"],
      ["ё", "yo"],
      // Romanian
      ["ă", "a"],
      ["Ă", "A"],
      ["ș", "s"],
      ["Ș", "S"],
      ["ț", "t"],
      ["Ț", "T"],
      ["ţ", "t"],
      ["Ţ", "T"],
      // Turkish
      ["ş", "s"],
      ["Ş", "S"],
      ["ç", "c"],
      ["Ç", "C"],
      ["ğ", "g"],
      ["Ğ", "G"],
      ["ı", "i"],
      ["İ", "I"],
      // Armenian
      ["ա", "a"],
      ["Ա", "A"],
      ["բ", "b"],
      ["Բ", "B"],
      ["գ", "g"],
      ["Գ", "G"],
      ["դ", "d"],
      ["Դ", "D"],
      ["ե", "ye"],
      ["Ե", "Ye"],
      ["զ", "z"],
      ["Զ", "Z"],
      ["է", "e"],
      ["Է", "E"],
      ["ը", "y"],
      ["Ը", "Y"],
      ["թ", "t"],
      ["Թ", "T"],
      ["ժ", "zh"],
      ["Ժ", "Zh"],
      ["ի", "i"],
      ["Ի", "I"],
      ["լ", "l"],
      ["Լ", "L"],
      ["խ", "kh"],
      ["Խ", "Kh"],
      ["ծ", "ts"],
      ["Ծ", "Ts"],
      ["կ", "k"],
      ["Կ", "K"],
      ["հ", "h"],
      ["Հ", "H"],
      ["ձ", "dz"],
      ["Ձ", "Dz"],
      ["ղ", "gh"],
      ["Ղ", "Gh"],
      ["ճ", "tch"],
      ["Ճ", "Tch"],
      ["մ", "m"],
      ["Մ", "M"],
      ["յ", "y"],
      ["Յ", "Y"],
      ["ն", "n"],
      ["Ն", "N"],
      ["շ", "sh"],
      ["Շ", "Sh"],
      ["ո", "vo"],
      ["Ո", "Vo"],
      ["չ", "ch"],
      ["Չ", "Ch"],
      ["պ", "p"],
      ["Պ", "P"],
      ["ջ", "j"],
      ["Ջ", "J"],
      ["ռ", "r"],
      ["Ռ", "R"],
      ["ս", "s"],
      ["Ս", "S"],
      ["վ", "v"],
      ["Վ", "V"],
      ["տ", "t"],
      ["Տ", "T"],
      ["ր", "r"],
      ["Ր", "R"],
      ["ց", "c"],
      ["Ց", "C"],
      ["ու", "u"],
      ["ՈՒ", "U"],
      ["Ու", "U"],
      ["փ", "p"],
      ["Փ", "P"],
      ["ք", "q"],
      ["Ք", "Q"],
      ["օ", "o"],
      ["Օ", "O"],
      ["ֆ", "f"],
      ["Ֆ", "F"],
      ["և", "yev"],
      // Georgian
      ["ა", "a"],
      ["ბ", "b"],
      ["გ", "g"],
      ["დ", "d"],
      ["ე", "e"],
      ["ვ", "v"],
      ["ზ", "z"],
      ["თ", "t"],
      ["ი", "i"],
      ["კ", "k"],
      ["ლ", "l"],
      ["მ", "m"],
      ["ნ", "n"],
      ["ო", "o"],
      ["პ", "p"],
      ["ჟ", "zh"],
      ["რ", "r"],
      ["ს", "s"],
      ["ტ", "t"],
      ["უ", "u"],
      ["ფ", "ph"],
      ["ქ", "q"],
      ["ღ", "gh"],
      ["ყ", "k"],
      ["შ", "sh"],
      ["ჩ", "ch"],
      ["ც", "ts"],
      ["ძ", "dz"],
      ["წ", "ts"],
      ["ჭ", "tch"],
      ["ხ", "kh"],
      ["ჯ", "j"],
      ["ჰ", "h"],
      // Czech
      ["č", "c"],
      ["ď", "d"],
      ["ě", "e"],
      ["ň", "n"],
      ["ř", "r"],
      ["š", "s"],
      ["ť", "t"],
      ["ů", "u"],
      ["ž", "z"],
      ["Č", "C"],
      ["Ď", "D"],
      ["Ě", "E"],
      ["Ň", "N"],
      ["Ř", "R"],
      ["Š", "S"],
      ["Ť", "T"],
      ["Ů", "U"],
      ["Ž", "Z"],
      // Dhivehi
      ["ހ", "h"],
      ["ށ", "sh"],
      ["ނ", "n"],
      ["ރ", "r"],
      ["ބ", "b"],
      ["ޅ", "lh"],
      ["ކ", "k"],
      ["އ", "a"],
      ["ވ", "v"],
      ["މ", "m"],
      ["ފ", "f"],
      ["ދ", "dh"],
      ["ތ", "th"],
      ["ލ", "l"],
      ["ގ", "g"],
      ["ޏ", "gn"],
      ["ސ", "s"],
      ["ޑ", "d"],
      ["ޒ", "z"],
      ["ޓ", "t"],
      ["ޔ", "y"],
      ["ޕ", "p"],
      ["ޖ", "j"],
      ["ޗ", "ch"],
      ["ޘ", "tt"],
      ["ޙ", "hh"],
      ["ޚ", "kh"],
      ["ޛ", "th"],
      ["ޜ", "z"],
      ["ޝ", "sh"],
      ["ޞ", "s"],
      ["ޟ", "d"],
      ["ޠ", "t"],
      ["ޡ", "z"],
      ["ޢ", "a"],
      ["ޣ", "gh"],
      ["ޤ", "q"],
      ["ޥ", "w"],
      ["ަ", "a"],
      ["ާ", "aa"],
      ["ި", "i"],
      ["ީ", "ee"],
      ["ު", "u"],
      ["ޫ", "oo"],
      ["ެ", "e"],
      ["ޭ", "ey"],
      ["ޮ", "o"],
      ["ޯ", "oa"],
      ["ް", ""],
      // Greek
      ["α", "a"],
      ["β", "v"],
      ["γ", "g"],
      ["δ", "d"],
      ["ε", "e"],
      ["ζ", "z"],
      ["η", "i"],
      ["θ", "th"],
      ["ι", "i"],
      ["κ", "k"],
      ["λ", "l"],
      ["μ", "m"],
      ["ν", "n"],
      ["ξ", "ks"],
      ["ο", "o"],
      ["π", "p"],
      ["ρ", "r"],
      ["σ", "s"],
      ["τ", "t"],
      ["υ", "y"],
      ["φ", "f"],
      ["χ", "x"],
      ["ψ", "ps"],
      ["ω", "o"],
      ["ά", "a"],
      ["έ", "e"],
      ["ί", "i"],
      ["ό", "o"],
      ["ύ", "y"],
      ["ή", "i"],
      ["ώ", "o"],
      ["ς", "s"],
      ["ϊ", "i"],
      ["ΰ", "y"],
      ["ϋ", "y"],
      ["ΐ", "i"],
      ["Α", "A"],
      ["Β", "B"],
      ["Γ", "G"],
      ["Δ", "D"],
      ["Ε", "E"],
      ["Ζ", "Z"],
      ["Η", "I"],
      ["Θ", "TH"],
      ["Ι", "I"],
      ["Κ", "K"],
      ["Λ", "L"],
      ["Μ", "M"],
      ["Ν", "N"],
      ["Ξ", "KS"],
      ["Ο", "O"],
      ["Π", "P"],
      ["Ρ", "R"],
      ["Σ", "S"],
      ["Τ", "T"],
      ["Υ", "Y"],
      ["Φ", "F"],
      ["Χ", "X"],
      ["Ψ", "PS"],
      ["Ω", "O"],
      ["Ά", "A"],
      ["Έ", "E"],
      ["Ί", "I"],
      ["Ό", "O"],
      ["Ύ", "Y"],
      ["Ή", "I"],
      ["Ώ", "O"],
      ["Ϊ", "I"],
      ["Ϋ", "Y"],
      // Disabled as it conflicts with German and Latin.
      // Hungarian
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ö', 'o'],
      // ['Ö', 'O'],
      // ['ü', 'u'],
      // ['Ü', 'U'],
      // ['ű', 'u'],
      // ['Ű', 'U'],
      // Latvian
      ["ā", "a"],
      ["ē", "e"],
      ["ģ", "g"],
      ["ī", "i"],
      ["ķ", "k"],
      ["ļ", "l"],
      ["ņ", "n"],
      ["ū", "u"],
      ["Ā", "A"],
      ["Ē", "E"],
      ["Ģ", "G"],
      ["Ī", "I"],
      ["Ķ", "K"],
      ["Ļ", "L"],
      ["Ņ", "N"],
      ["Ū", "U"],
      ["č", "c"],
      ["š", "s"],
      ["ž", "z"],
      ["Č", "C"],
      ["Š", "S"],
      ["Ž", "Z"],
      // Lithuanian
      ["ą", "a"],
      ["č", "c"],
      ["ę", "e"],
      ["ė", "e"],
      ["į", "i"],
      ["š", "s"],
      ["ų", "u"],
      ["ū", "u"],
      ["ž", "z"],
      ["Ą", "A"],
      ["Č", "C"],
      ["Ę", "E"],
      ["Ė", "E"],
      ["Į", "I"],
      ["Š", "S"],
      ["Ų", "U"],
      ["Ū", "U"],
      // Macedonian
      ["Ќ", "Kj"],
      ["ќ", "kj"],
      ["Љ", "Lj"],
      ["љ", "lj"],
      ["Њ", "Nj"],
      ["њ", "nj"],
      ["Тс", "Ts"],
      ["тс", "ts"],
      // Polish
      ["ą", "a"],
      ["ć", "c"],
      ["ę", "e"],
      ["ł", "l"],
      ["ń", "n"],
      ["ś", "s"],
      ["ź", "z"],
      ["ż", "z"],
      ["Ą", "A"],
      ["Ć", "C"],
      ["Ę", "E"],
      ["Ł", "L"],
      ["Ń", "N"],
      ["Ś", "S"],
      ["Ź", "Z"],
      ["Ż", "Z"],
      // Disabled as it conflicts with Vietnamese.
      // Serbian
      // ['љ', 'lj'],
      // ['њ', 'nj'],
      // ['Љ', 'Lj'],
      // ['Њ', 'Nj'],
      // ['đ', 'dj'],
      // ['Đ', 'Dj'],
      // ['ђ', 'dj'],
      // ['ј', 'j'],
      // ['ћ', 'c'],
      // ['џ', 'dz'],
      // ['Ђ', 'Dj'],
      // ['Ј', 'j'],
      // ['Ћ', 'C'],
      // ['Џ', 'Dz'],
      // Disabled as it conflicts with German and Latin.
      // Slovak
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ľ', 'l'],
      // ['ĺ', 'l'],
      // ['ŕ', 'r'],
      // ['Ľ', 'L'],
      // ['Ĺ', 'L'],
      // ['Ŕ', 'R'],
      // Disabled as it conflicts with German and Latin.
      // Swedish
      // ['å', 'o'],
      // ['Å', 'o'],
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ë', 'e'],
      // ['Ë', 'E'],
      // ['ö', 'o'],
      // ['Ö', 'O'],
      // Ukrainian
      ["Є", "Ye"],
      ["І", "I"],
      ["Ї", "Yi"],
      ["Ґ", "G"],
      ["є", "ye"],
      ["і", "i"],
      ["ї", "yi"],
      ["ґ", "g"]
      // Danish
      // ['Æ', 'Ae'],
      // ['Ø', 'Oe'],
      // ['Å', 'Aa'],
      // ['æ', 'ae'],
      // ['ø', 'oe'],
      // ['å', 'aa']
    ];
  }
});

// node_modules/.pnpm/@sindresorhus+transliterate@0.1.2/node_modules/@sindresorhus/transliterate/index.js
var require_transliterate = __commonJS({
  "node_modules/.pnpm/@sindresorhus+transliterate@0.1.2/node_modules/@sindresorhus/transliterate/index.js"(exports, module) {
    "use strict";
    var deburr = require_lodash();
    var escapeStringRegexp = require_escape_string_regexp2();
    var builtinReplacements = require_replacements2();
    var doCustomReplacements = (string, replacements) => {
      for (const [key, value2] of replacements) {
        string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value2);
      }
      return string;
    };
    module.exports = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = {
        customReplacements: [],
        ...options
      };
      const customReplacements = new Map([
        ...builtinReplacements,
        ...options.customReplacements
      ]);
      string = string.normalize();
      string = doCustomReplacements(string, customReplacements);
      string = deburr(string);
      return string;
    };
  }
});

// node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/overridable-replacements.js
var require_overridable_replacements = __commonJS({
  "node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/overridable-replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      ["&", " and "],
      ["🦄", " unicorn "],
      ["♥", " love "]
    ];
  }
});

// node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/index.js
var require_slugify = __commonJS({
  "node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var transliterate = require_transliterate();
    var builtinOverridableReplacements = require_overridable_replacements();
    var decamelize = (string) => {
      return string.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
    };
    var removeMootSeparators = (string, separator) => {
      const escapedSeparator = escapeStringRegexp(separator);
      return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
    };
    var slugify = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = {
        separator: "-",
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false,
        ...options
      };
      const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
      const customReplacements = new Map([
        ...builtinOverridableReplacements,
        ...options.customReplacements
      ]);
      string = transliterate(string, { customReplacements });
      if (options.decamelize) {
        string = decamelize(string);
      }
      let patternSlug = /[^a-zA-Z\d]+/g;
      if (options.lowercase) {
        string = string.toLowerCase();
        patternSlug = /[^a-z\d]+/g;
      }
      string = string.replace(patternSlug, options.separator);
      string = string.replace(/\\/g, "");
      if (options.separator) {
        string = removeMootSeparators(string, options.separator);
      }
      if (shouldPrependUnderscore) {
        string = `_${string}`;
      }
      return string;
    };
    var counter2 = () => {
      const occurrences = /* @__PURE__ */ new Map();
      const countable = (string, options) => {
        string = slugify(string, options);
        if (!string) {
          return "";
        }
        const stringLower = string.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
        const counter3 = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter3 === "number" ? counter3 + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
          string = `${string}-${newCounter}`;
        }
        return string;
      };
      countable.reset = () => {
        occurrences.clear();
      };
      return countable;
    };
    module.exports = slugify;
    module.exports.counter = counter2;
  }
});

// node_modules/.pnpm/mdast-util-to-string@2.0.0/node_modules/mdast-util-to-string/index.js
var require_mdast_util_to_string = __commonJS({
  "node_modules/.pnpm/mdast-util-to-string@2.0.0/node_modules/mdast-util-to-string/index.js"(exports, module) {
    "use strict";
    module.exports = toString2;
    function toString2(node3) {
      return node3 && (node3.value || node3.alt || node3.title || "children" in node3 && all(node3.children) || "length" in node3 && all(node3)) || "";
    }
    function all(values2) {
      var result = [];
      var index2 = -1;
      while (++index2 < values2.length) {
        result[index2] = toString2(values2[index2]);
      }
      return result.join("");
    }
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/assign.js
var require_assign = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/assign.js"(exports, module) {
    "use strict";
    var assign2 = Object.assign;
    module.exports = assign2;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/has-own-property.js"(exports, module) {
    "use strict";
    var own = {}.hasOwnProperty;
    module.exports = own;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/normalize-identifier.js
var require_normalize_identifier = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/normalize-identifier.js"(exports, module) {
    "use strict";
    function normalizeIdentifier(value2) {
      return value2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
    }
    module.exports = normalizeIdentifier;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/from-char-code.js
var require_from_char_code = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/from-char-code.js"(exports, module) {
    "use strict";
    var fromCharCode = String.fromCharCode;
    module.exports = fromCharCode;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/safe-from-int.js
var require_safe_from_int = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/safe-from-int.js"(exports, module) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function safeFromInt(value2, base) {
      var code2 = parseInt(value2, base);
      if (
        // C0 except for HT, LF, FF, CR, space
        code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of the basic block and C1 controls.
        code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
        code2 > 55295 && code2 < 57344 || // Noncharacters.
        code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
        code2 > 1114111
      ) {
        return "�";
      }
      return fromCharCode(code2);
    }
    module.exports = safeFromInt;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/markdown-line-ending.js
var require_markdown_line_ending = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/markdown-line-ending.js"(exports, module) {
    "use strict";
    function markdownLineEnding(code2) {
      return code2 < -2;
    }
    module.exports = markdownLineEnding;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/markdown-space.js
var require_markdown_space = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/markdown-space.js"(exports, module) {
    "use strict";
    function markdownSpace(code2) {
      return code2 === -2 || code2 === -1 || code2 === 32;
    }
    module.exports = markdownSpace;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-space.js
var require_factory_space = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-space.js"(exports, module) {
    "use strict";
    var markdownSpace = require_markdown_space();
    function spaceFactory(effects, ok, type2, max2) {
      var limit = max2 ? max2 - 1 : Infinity;
      var size3 = 0;
      return start2;
      function start2(code2) {
        if (markdownSpace(code2)) {
          effects.enter(type2);
          return prefix3(code2);
        }
        return ok(code2);
      }
      function prefix3(code2) {
        if (markdownSpace(code2) && size3++ < limit) {
          effects.consume(code2);
          return prefix3;
        }
        effects.exit(type2);
        return ok(code2);
      }
    }
    module.exports = spaceFactory;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/initialize/content.js
var require_content = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/initialize/content.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var tokenize2 = initializeContent;
    function initializeContent(effects) {
      var contentStart = effects.attempt(
        this.parser.constructs.contentInitial,
        afterContentStartConstruct,
        paragraphInitial
      );
      var previous;
      return contentStart;
      function afterContentStartConstruct(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(effects, contentStart, "linePrefix");
      }
      function paragraphInitial(code2) {
        effects.enter("paragraph");
        return lineStart(code2);
      }
      function lineStart(code2) {
        var token2 = effects.enter("chunkText", {
          contentType: "text",
          previous
        });
        if (previous) {
          previous.next = token2;
        }
        previous = token2;
        return data(code2);
      }
      function data(code2) {
        if (code2 === null) {
          effects.exit("chunkText");
          effects.exit("paragraph");
          effects.consume(code2);
          return;
        }
        if (markdownLineEnding(code2)) {
          effects.consume(code2);
          effects.exit("chunkText");
          return lineStart;
        }
        effects.consume(code2);
        return data;
      }
    }
    exports.tokenize = tokenize2;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/partial-blank-line.js
var require_partial_blank_line = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/partial-blank-line.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var partialBlankLine = {
      tokenize: tokenizePartialBlankLine,
      partial: true
    };
    function tokenizePartialBlankLine(effects, ok, nok) {
      return factorySpace(effects, afterWhitespace, "linePrefix");
      function afterWhitespace(code2) {
        return code2 === null || markdownLineEnding(code2) ? ok(code2) : nok(code2);
      }
    }
    module.exports = partialBlankLine;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/initialize/document.js
var require_document = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/initialize/document.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var tokenize2 = initializeDocument;
    var containerConstruct = {
      tokenize: tokenizeContainer
    };
    var lazyFlowConstruct = {
      tokenize: tokenizeLazyFlow
    };
    function initializeDocument(effects) {
      var self2 = this;
      var stack = [];
      var continued = 0;
      var inspectConstruct = {
        tokenize: tokenizeInspect,
        partial: true
      };
      var inspectResult;
      var childFlow;
      var childToken;
      return start2;
      function start2(code2) {
        if (continued < stack.length) {
          self2.containerState = stack[continued][1];
          return effects.attempt(
            stack[continued][0].continuation,
            documentContinue,
            documentContinued
          )(code2);
        }
        return documentContinued(code2);
      }
      function documentContinue(code2) {
        continued++;
        return start2(code2);
      }
      function documentContinued(code2) {
        if (inspectResult && inspectResult.flowContinue) {
          return flowStart(code2);
        }
        self2.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
        self2.containerState = {};
        return effects.attempt(
          containerConstruct,
          containerContinue,
          flowStart
        )(code2);
      }
      function containerContinue(code2) {
        stack.push([self2.currentConstruct, self2.containerState]);
        self2.containerState = void 0;
        return documentContinued(code2);
      }
      function flowStart(code2) {
        if (code2 === null) {
          exitContainers(0, true);
          effects.consume(code2);
          return;
        }
        childFlow = childFlow || self2.parser.flow(self2.now());
        effects.enter("chunkFlow", {
          contentType: "flow",
          previous: childToken,
          _tokenizer: childFlow
        });
        return flowContinue(code2);
      }
      function flowContinue(code2) {
        if (code2 === null) {
          continueFlow(effects.exit("chunkFlow"));
          return flowStart(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.consume(code2);
          continueFlow(effects.exit("chunkFlow"));
          return effects.check(inspectConstruct, documentAfterPeek);
        }
        effects.consume(code2);
        return flowContinue;
      }
      function documentAfterPeek(code2) {
        exitContainers(
          inspectResult.continued,
          inspectResult && inspectResult.flowEnd
        );
        continued = 0;
        return start2(code2);
      }
      function continueFlow(token2) {
        if (childToken)
          childToken.next = token2;
        childToken = token2;
        childFlow.lazy = inspectResult && inspectResult.lazy;
        childFlow.defineSkip(token2.start);
        childFlow.write(self2.sliceStream(token2));
      }
      function exitContainers(size3, end) {
        var index2 = stack.length;
        if (childFlow && end) {
          childFlow.write([null]);
          childToken = childFlow = void 0;
        }
        while (index2-- > size3) {
          self2.containerState = stack[index2][1];
          stack[index2][0].exit.call(self2, effects);
        }
        stack.length = size3;
      }
      function tokenizeInspect(effects2, ok) {
        var subcontinued = 0;
        inspectResult = {};
        return inspectStart;
        function inspectStart(code2) {
          if (subcontinued < stack.length) {
            self2.containerState = stack[subcontinued][1];
            return effects2.attempt(
              stack[subcontinued][0].continuation,
              inspectContinue,
              inspectLess
            )(code2);
          }
          if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
            inspectResult.flowContinue = true;
            return inspectDone(code2);
          }
          self2.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
          self2.containerState = {};
          return effects2.attempt(
            containerConstruct,
            inspectFlowEnd,
            inspectDone
          )(code2);
        }
        function inspectContinue(code2) {
          subcontinued++;
          return self2.containerState._closeFlow ? inspectFlowEnd(code2) : inspectStart(code2);
        }
        function inspectLess(code2) {
          if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
            self2.containerState = {};
            return effects2.attempt(
              containerConstruct,
              inspectFlowEnd,
              // Maybe flow, or a blank line?
              effects2.attempt(
                lazyFlowConstruct,
                inspectFlowEnd,
                effects2.check(partialBlankLine, inspectFlowEnd, inspectLazy)
              )
            )(code2);
          }
          return inspectFlowEnd(code2);
        }
        function inspectLazy(code2) {
          subcontinued = stack.length;
          inspectResult.lazy = true;
          inspectResult.flowContinue = true;
          return inspectDone(code2);
        }
        function inspectFlowEnd(code2) {
          inspectResult.flowEnd = true;
          return inspectDone(code2);
        }
        function inspectDone(code2) {
          inspectResult.continued = subcontinued;
          self2.interrupt = self2.containerState = void 0;
          return ok(code2);
        }
      }
    }
    function tokenizeContainer(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.attempt(this.parser.constructs.document, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    function tokenizeLazyFlow(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.lazy(this.parser.constructs.flow, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    exports.tokenize = tokenize2;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/size-chunks.js
var require_size_chunks = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/size-chunks.js"(exports, module) {
    "use strict";
    function sizeChunks(chunks) {
      var index2 = -1;
      var size3 = 0;
      while (++index2 < chunks.length) {
        size3 += typeof chunks[index2] === "string" ? chunks[index2].length : 1;
      }
      return size3;
    }
    module.exports = sizeChunks;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/prefix-size.js
var require_prefix_size = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/prefix-size.js"(exports, module) {
    "use strict";
    var sizeChunks = require_size_chunks();
    function prefixSize(events2, type2) {
      var tail = events2[events2.length - 1];
      if (!tail || tail[1].type !== type2)
        return 0;
      return sizeChunks(tail[2].sliceStream(tail[1]));
    }
    module.exports = prefixSize;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/splice.js
var require_splice = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/splice.js"(exports, module) {
    "use strict";
    var splice = [].splice;
    module.exports = splice;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/chunked-splice.js
var require_chunked_splice = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/chunked-splice.js"(exports, module) {
    "use strict";
    var splice = require_splice();
    function chunkedSplice(list2, start2, remove, items) {
      var end = list2.length;
      var chunkStart = 0;
      var parameters;
      if (start2 < 0) {
        start2 = -start2 > end ? 0 : end + start2;
      } else {
        start2 = start2 > end ? end : start2;
      }
      remove = remove > 0 ? remove : 0;
      if (items.length < 1e4) {
        parameters = Array.from(items);
        parameters.unshift(start2, remove);
        splice.apply(list2, parameters);
      } else {
        if (remove)
          splice.apply(list2, [start2, remove]);
        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 1e4);
          parameters.unshift(start2, 0);
          splice.apply(list2, parameters);
          chunkStart += 1e4;
          start2 += 1e4;
        }
      }
    }
    module.exports = chunkedSplice;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/shallow.js
var require_shallow = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/shallow.js"(exports, module) {
    "use strict";
    var assign2 = require_assign();
    function shallow(object2) {
      return assign2({}, object2);
    }
    module.exports = shallow;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/subtokenize.js
var require_subtokenize = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/subtokenize.js"(exports, module) {
    "use strict";
    var assign2 = require_assign();
    var chunkedSplice = require_chunked_splice();
    var shallow = require_shallow();
    function subtokenize(events2) {
      var jumps = {};
      var index2 = -1;
      var event;
      var lineIndex;
      var otherIndex;
      var otherEvent;
      var parameters;
      var subevents;
      var more;
      while (++index2 < events2.length) {
        while (index2 in jumps) {
          index2 = jumps[index2];
        }
        event = events2[index2];
        if (index2 && event[1].type === "chunkFlow" && events2[index2 - 1][1].type === "listItemPrefix") {
          subevents = event[1]._tokenizer.events;
          otherIndex = 0;
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
            otherIndex += 2;
          }
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
            while (++otherIndex < subevents.length) {
              if (subevents[otherIndex][1].type === "content") {
                break;
              }
              if (subevents[otherIndex][1].type === "chunkText") {
                subevents[otherIndex][1].isInFirstContentOfListItem = true;
                otherIndex++;
              }
            }
          }
        }
        if (event[0] === "enter") {
          if (event[1].contentType) {
            assign2(jumps, subcontent(events2, index2));
            index2 = jumps[index2];
            more = true;
          }
        } else if (event[1]._container || event[1]._movePreviousLineEndings) {
          otherIndex = index2;
          lineIndex = void 0;
          while (otherIndex--) {
            otherEvent = events2[otherIndex];
            if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
              if (otherEvent[0] === "enter") {
                if (lineIndex) {
                  events2[lineIndex][1].type = "lineEndingBlank";
                }
                otherEvent[1].type = "lineEnding";
                lineIndex = otherIndex;
              }
            } else {
              break;
            }
          }
          if (lineIndex) {
            event[1].end = shallow(events2[lineIndex][1].start);
            parameters = events2.slice(lineIndex, index2);
            parameters.unshift(event);
            chunkedSplice(events2, lineIndex, index2 - lineIndex + 1, parameters);
          }
        }
      }
      return !more;
    }
    function subcontent(events2, eventIndex) {
      var token2 = events2[eventIndex][1];
      var context = events2[eventIndex][2];
      var startPosition = eventIndex - 1;
      var startPositions = [];
      var tokenizer2 = token2._tokenizer || context.parser[token2.contentType](token2.start);
      var childEvents = tokenizer2.events;
      var jumps = [];
      var gaps = {};
      var stream;
      var previous;
      var index2;
      var entered;
      var end;
      var adjust;
      while (token2) {
        while (events2[++startPosition][1] !== token2) {
        }
        startPositions.push(startPosition);
        if (!token2._tokenizer) {
          stream = context.sliceStream(token2);
          if (!token2.next) {
            stream.push(null);
          }
          if (previous) {
            tokenizer2.defineSkip(token2.start);
          }
          if (token2.isInFirstContentOfListItem) {
            tokenizer2._gfmTasklistFirstContentOfListItem = true;
          }
          tokenizer2.write(stream);
          if (token2.isInFirstContentOfListItem) {
            tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
          }
        }
        previous = token2;
        token2 = token2.next;
      }
      token2 = previous;
      index2 = childEvents.length;
      while (index2--) {
        if (childEvents[index2][0] === "enter") {
          entered = true;
        } else if (
          // Find a void token that includes a break.
          entered && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
        ) {
          add(childEvents.slice(index2 + 1, end));
          token2._tokenizer = token2.next = void 0;
          token2 = token2.previous;
          end = index2 + 1;
        }
      }
      tokenizer2.events = token2._tokenizer = token2.next = void 0;
      add(childEvents.slice(0, end));
      index2 = -1;
      adjust = 0;
      while (++index2 < jumps.length) {
        gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
        adjust += jumps[index2][1] - jumps[index2][0] - 1;
      }
      return gaps;
      function add(slice2) {
        var start2 = startPositions.pop();
        jumps.unshift([start2, start2 + slice2.length - 1]);
        chunkedSplice(events2, start2, 2, slice2);
      }
    }
    module.exports = subtokenize;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/content.js
var require_content2 = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/content.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var prefixSize = require_prefix_size();
    var subtokenize = require_subtokenize();
    var factorySpace = require_factory_space();
    var content = {
      tokenize: tokenizeContent,
      resolve: resolveContent,
      interruptible: true,
      lazy: true
    };
    var continuationConstruct = {
      tokenize: tokenizeContinuation,
      partial: true
    };
    function resolveContent(events2) {
      subtokenize(events2);
      return events2;
    }
    function tokenizeContent(effects, ok) {
      var previous;
      return start2;
      function start2(code2) {
        effects.enter("content");
        previous = effects.enter("chunkContent", {
          contentType: "content"
        });
        return data(code2);
      }
      function data(code2) {
        if (code2 === null) {
          return contentEnd(code2);
        }
        if (markdownLineEnding(code2)) {
          return effects.check(
            continuationConstruct,
            contentContinue,
            contentEnd
          )(code2);
        }
        effects.consume(code2);
        return data;
      }
      function contentEnd(code2) {
        effects.exit("chunkContent");
        effects.exit("content");
        return ok(code2);
      }
      function contentContinue(code2) {
        effects.consume(code2);
        effects.exit("chunkContent");
        previous = previous.next = effects.enter("chunkContent", {
          contentType: "content",
          previous
        });
        return data;
      }
    }
    function tokenizeContinuation(effects, ok, nok) {
      var self2 = this;
      return startLookahead;
      function startLookahead(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(effects, prefixed, "linePrefix");
      }
      function prefixed(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return nok(code2);
        }
        if (self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 || prefixSize(self2.events, "linePrefix") < 4) {
          return effects.interrupt(self2.parser.constructs.flow, nok, ok)(code2);
        }
        return ok(code2);
      }
    }
    module.exports = content;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/initialize/flow.js
var require_flow = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/initialize/flow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var content = require_content2();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var tokenize2 = initializeFlow;
    function initializeFlow(effects) {
      var self2 = this;
      var initial = effects.attempt(
        // Try to parse a blank line.
        partialBlankLine,
        atBlankEnding,
        // Try to parse initial flow (essentially, only code).
        effects.attempt(
          this.parser.constructs.flowInitial,
          afterConstruct,
          factorySpace(
            effects,
            effects.attempt(
              this.parser.constructs.flow,
              afterConstruct,
              effects.attempt(content, afterConstruct)
            ),
            "linePrefix"
          )
        )
      );
      return initial;
      function atBlankEnding(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEndingBlank");
        effects.consume(code2);
        effects.exit("lineEndingBlank");
        self2.currentConstruct = void 0;
        return initial;
      }
      function afterConstruct(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        self2.currentConstruct = void 0;
        return initial;
      }
    }
    exports.tokenize = tokenize2;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/initialize/text.js
var require_text2 = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/initialize/text.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assign2 = require_assign();
    var shallow = require_shallow();
    var text3 = initializeFactory("text");
    var string = initializeFactory("string");
    var resolver = {
      resolveAll: createResolver()
    };
    function initializeFactory(field2) {
      return {
        tokenize: initializeText,
        resolveAll: createResolver(
          field2 === "text" ? resolveAllLineSuffixes : void 0
        )
      };
      function initializeText(effects) {
        var self2 = this;
        var constructs = this.parser.constructs[field2];
        var text4 = effects.attempt(constructs, start2, notText);
        return start2;
        function start2(code2) {
          return atBreak(code2) ? text4(code2) : notText(code2);
        }
        function notText(code2) {
          if (code2 === null) {
            effects.consume(code2);
            return;
          }
          effects.enter("data");
          effects.consume(code2);
          return data;
        }
        function data(code2) {
          if (atBreak(code2)) {
            effects.exit("data");
            return text4(code2);
          }
          effects.consume(code2);
          return data;
        }
        function atBreak(code2) {
          var list2 = constructs[code2];
          var index2 = -1;
          if (code2 === null) {
            return true;
          }
          if (list2) {
            while (++index2 < list2.length) {
              if (!list2[index2].previous || list2[index2].previous.call(self2, self2.previous)) {
                return true;
              }
            }
          }
        }
      }
    }
    function createResolver(extraResolver) {
      return resolveAllText;
      function resolveAllText(events2, context) {
        var index2 = -1;
        var enter;
        while (++index2 <= events2.length) {
          if (enter === void 0) {
            if (events2[index2] && events2[index2][1].type === "data") {
              enter = index2;
              index2++;
            }
          } else if (!events2[index2] || events2[index2][1].type !== "data") {
            if (index2 !== enter + 2) {
              events2[enter][1].end = events2[index2 - 1][1].end;
              events2.splice(enter + 2, index2 - enter - 2);
              index2 = enter + 2;
            }
            enter = void 0;
          }
        }
        return extraResolver ? extraResolver(events2, context) : events2;
      }
    }
    function resolveAllLineSuffixes(events2, context) {
      var eventIndex = -1;
      var chunks;
      var data;
      var chunk;
      var index2;
      var bufferIndex;
      var size3;
      var tabs;
      var token2;
      while (++eventIndex <= events2.length) {
        if ((eventIndex === events2.length || events2[eventIndex][1].type === "lineEnding") && events2[eventIndex - 1][1].type === "data") {
          data = events2[eventIndex - 1][1];
          chunks = context.sliceStream(data);
          index2 = chunks.length;
          bufferIndex = -1;
          size3 = 0;
          tabs = void 0;
          while (index2--) {
            chunk = chunks[index2];
            if (typeof chunk === "string") {
              bufferIndex = chunk.length;
              while (chunk.charCodeAt(bufferIndex - 1) === 32) {
                size3++;
                bufferIndex--;
              }
              if (bufferIndex)
                break;
              bufferIndex = -1;
            } else if (chunk === -2) {
              tabs = true;
              size3++;
            } else if (chunk === -1)
              ;
            else {
              index2++;
              break;
            }
          }
          if (size3) {
            token2 = {
              type: eventIndex === events2.length || tabs || size3 < 2 ? "lineSuffix" : "hardBreakTrailing",
              start: {
                line: data.end.line,
                column: data.end.column - size3,
                offset: data.end.offset - size3,
                _index: data.start._index + index2,
                _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
              },
              end: shallow(data.end)
            };
            data.end = shallow(token2.start);
            if (data.start.offset === data.end.offset) {
              assign2(data, token2);
            } else {
              events2.splice(
                eventIndex,
                0,
                ["enter", token2, context],
                ["exit", token2, context]
              );
              eventIndex += 2;
            }
          }
          eventIndex++;
        }
      }
      return events2;
    }
    exports.resolver = resolver;
    exports.string = string;
    exports.text = text3;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/miniflat.js
var require_miniflat = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/miniflat.js"(exports, module) {
    "use strict";
    function miniflat(value2) {
      return value2 === null || value2 === void 0 ? [] : "length" in value2 ? value2 : [value2];
    }
    module.exports = miniflat;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/combine-extensions.js
var require_combine_extensions = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/combine-extensions.js"(exports, module) {
    "use strict";
    var hasOwnProperty2 = require_has_own_property();
    var chunkedSplice = require_chunked_splice();
    var miniflat = require_miniflat();
    function combineExtensions(extensions) {
      var all = {};
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension(all, extensions[index2]);
      }
      return all;
    }
    function extension(all, extension2) {
      var hook;
      var left;
      var right;
      var code2;
      for (hook in extension2) {
        left = hasOwnProperty2.call(all, hook) ? all[hook] : all[hook] = {};
        right = extension2[hook];
        for (code2 in right) {
          left[code2] = constructs(
            miniflat(right[code2]),
            hasOwnProperty2.call(left, code2) ? left[code2] : []
          );
        }
      }
    }
    function constructs(list2, existing) {
      var index2 = -1;
      var before = [];
      while (++index2 < list2.length) {
        ;
        (list2[index2].add === "after" ? existing : before).push(list2[index2]);
      }
      chunkedSplice(existing, 0, 0, before);
      return existing;
    }
    module.exports = combineExtensions;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/chunked-push.js
var require_chunked_push = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/chunked-push.js"(exports, module) {
    "use strict";
    var chunkedSplice = require_chunked_splice();
    function chunkedPush(list2, items) {
      if (list2.length) {
        chunkedSplice(list2, list2.length, 0, items);
        return list2;
      }
      return items;
    }
    module.exports = chunkedPush;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/resolve-all.js
var require_resolve_all = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/resolve-all.js"(exports, module) {
    "use strict";
    function resolveAll(constructs, events2, context) {
      var called = [];
      var index2 = -1;
      var resolve3;
      while (++index2 < constructs.length) {
        resolve3 = constructs[index2].resolveAll;
        if (resolve3 && called.indexOf(resolve3) < 0) {
          events2 = resolve3(events2, context);
          called.push(resolve3);
        }
      }
      return events2;
    }
    module.exports = resolveAll;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/serialize-chunks.js
var require_serialize_chunks = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/serialize-chunks.js"(exports, module) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function serializeChunks(chunks) {
      var index2 = -1;
      var result = [];
      var chunk;
      var value2;
      var atTab;
      while (++index2 < chunks.length) {
        chunk = chunks[index2];
        if (typeof chunk === "string") {
          value2 = chunk;
        } else if (chunk === -5) {
          value2 = "\r";
        } else if (chunk === -4) {
          value2 = "\n";
        } else if (chunk === -3) {
          value2 = "\r\n";
        } else if (chunk === -2) {
          value2 = "	";
        } else if (chunk === -1) {
          if (atTab)
            continue;
          value2 = " ";
        } else {
          value2 = fromCharCode(chunk);
        }
        atTab = chunk === -2;
        result.push(value2);
      }
      return result.join("");
    }
    module.exports = serializeChunks;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/slice-chunks.js
var require_slice_chunks = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/slice-chunks.js"(exports, module) {
    "use strict";
    function sliceChunks(chunks, token2) {
      var startIndex = token2.start._index;
      var startBufferIndex = token2.start._bufferIndex;
      var endIndex = token2.end._index;
      var endBufferIndex = token2.end._bufferIndex;
      var view;
      if (startIndex === endIndex) {
        view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
      } else {
        view = chunks.slice(startIndex, endIndex);
        if (startBufferIndex > -1) {
          view[0] = view[0].slice(startBufferIndex);
        }
        if (endBufferIndex > 0) {
          view.push(chunks[endIndex].slice(0, endBufferIndex));
        }
      }
      return view;
    }
    module.exports = sliceChunks;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/create-tokenizer.js
var require_create_tokenizer = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/create-tokenizer.js"(exports, module) {
    "use strict";
    var assign2 = require_assign();
    var markdownLineEnding = require_markdown_line_ending();
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var miniflat = require_miniflat();
    var resolveAll = require_resolve_all();
    var serializeChunks = require_serialize_chunks();
    var shallow = require_shallow();
    var sliceChunks = require_slice_chunks();
    function createTokenizer(parser2, initialize, from2) {
      var point = from2 ? shallow(from2) : {
        line: 1,
        column: 1,
        offset: 0
      };
      var columnStart = {};
      var resolveAllConstructs = [];
      var chunks = [];
      var stack = [];
      var effects = {
        consume,
        enter,
        exit,
        attempt: constructFactory(onsuccessfulconstruct),
        check: constructFactory(onsuccessfulcheck),
        interrupt: constructFactory(onsuccessfulcheck, {
          interrupt: true
        }),
        lazy: constructFactory(onsuccessfulcheck, {
          lazy: true
        })
      };
      var context = {
        previous: null,
        events: [],
        parser: parser2,
        sliceStream,
        sliceSerialize,
        now,
        defineSkip: skip,
        write
      };
      var state = initialize.tokenize.call(context, effects);
      if (initialize.resolveAll) {
        resolveAllConstructs.push(initialize);
      }
      point._index = 0;
      point._bufferIndex = -1;
      return context;
      function write(slice2) {
        chunks = chunkedPush(chunks, slice2);
        main();
        if (chunks[chunks.length - 1] !== null) {
          return [];
        }
        addResult(initialize, 0);
        context.events = resolveAll(resolveAllConstructs, context.events, context);
        return context.events;
      }
      function sliceSerialize(token2) {
        return serializeChunks(sliceStream(token2));
      }
      function sliceStream(token2) {
        return sliceChunks(chunks, token2);
      }
      function now() {
        return shallow(point);
      }
      function skip(value2) {
        columnStart[value2.line] = value2.column;
        accountForPotentialSkip();
      }
      function main() {
        var chunkIndex;
        var chunk;
        while (point._index < chunks.length) {
          chunk = chunks[point._index];
          if (typeof chunk === "string") {
            chunkIndex = point._index;
            if (point._bufferIndex < 0) {
              point._bufferIndex = 0;
            }
            while (point._index === chunkIndex && point._bufferIndex < chunk.length) {
              go(chunk.charCodeAt(point._bufferIndex));
            }
          } else {
            go(chunk);
          }
        }
      }
      function go(code2) {
        state = state(code2);
      }
      function consume(code2) {
        if (markdownLineEnding(code2)) {
          point.line++;
          point.column = 1;
          point.offset += code2 === -3 ? 2 : 1;
          accountForPotentialSkip();
        } else if (code2 !== -1) {
          point.column++;
          point.offset++;
        }
        if (point._bufferIndex < 0) {
          point._index++;
        } else {
          point._bufferIndex++;
          if (point._bufferIndex === chunks[point._index].length) {
            point._bufferIndex = -1;
            point._index++;
          }
        }
        context.previous = code2;
      }
      function enter(type2, fields) {
        var token2 = fields || {};
        token2.type = type2;
        token2.start = now();
        context.events.push(["enter", token2, context]);
        stack.push(token2);
        return token2;
      }
      function exit(type2) {
        var token2 = stack.pop();
        token2.end = now();
        context.events.push(["exit", token2, context]);
        return token2;
      }
      function onsuccessfulconstruct(construct, info) {
        addResult(construct, info.from);
      }
      function onsuccessfulcheck(construct, info) {
        info.restore();
      }
      function constructFactory(onreturn, fields) {
        return hook;
        function hook(constructs, returnState, bogusState) {
          var listOfConstructs;
          var constructIndex;
          var currentConstruct;
          var info;
          return constructs.tokenize || "length" in constructs ? handleListOfConstructs(miniflat(constructs)) : handleMapOfConstructs;
          function handleMapOfConstructs(code2) {
            if (code2 in constructs || null in constructs) {
              return handleListOfConstructs(
                constructs.null ? (
                  /* c8 ignore next */
                  miniflat(constructs[code2]).concat(miniflat(constructs.null))
                ) : constructs[code2]
              )(code2);
            }
            return bogusState(code2);
          }
          function handleListOfConstructs(list2) {
            listOfConstructs = list2;
            constructIndex = 0;
            return handleConstruct(list2[constructIndex]);
          }
          function handleConstruct(construct) {
            return start2;
            function start2(code2) {
              info = store();
              currentConstruct = construct;
              if (!construct.partial) {
                context.currentConstruct = construct;
              }
              if (construct.name && context.parser.constructs.disable.null.indexOf(construct.name) > -1) {
                return nok();
              }
              return construct.tokenize.call(
                fields ? assign2({}, context, fields) : context,
                effects,
                ok,
                nok
              )(code2);
            }
          }
          function ok(code2) {
            onreturn(currentConstruct, info);
            return returnState;
          }
          function nok(code2) {
            info.restore();
            if (++constructIndex < listOfConstructs.length) {
              return handleConstruct(listOfConstructs[constructIndex]);
            }
            return bogusState;
          }
        }
      }
      function addResult(construct, from3) {
        if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
          resolveAllConstructs.push(construct);
        }
        if (construct.resolve) {
          chunkedSplice(
            context.events,
            from3,
            context.events.length - from3,
            construct.resolve(context.events.slice(from3), context)
          );
        }
        if (construct.resolveTo) {
          context.events = construct.resolveTo(context.events, context);
        }
      }
      function store() {
        var startPoint = now();
        var startPrevious = context.previous;
        var startCurrentConstruct = context.currentConstruct;
        var startEventsIndex = context.events.length;
        var startStack = Array.from(stack);
        return {
          restore,
          from: startEventsIndex
        };
        function restore() {
          point = startPoint;
          context.previous = startPrevious;
          context.currentConstruct = startCurrentConstruct;
          context.events.length = startEventsIndex;
          stack = startStack;
          accountForPotentialSkip();
        }
      }
      function accountForPotentialSkip() {
        if (point.line in columnStart && point.column < 2) {
          point.column = columnStart[point.line];
          point.offset += columnStart[point.line] - 1;
        }
      }
    }
    module.exports = createTokenizer;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/markdown-line-ending-or-space.js
var require_markdown_line_ending_or_space = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/markdown-line-ending-or-space.js"(exports, module) {
    "use strict";
    function markdownLineEndingOrSpace(code2) {
      return code2 < 0 || code2 === 32;
    }
    module.exports = markdownLineEndingOrSpace;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/unicode-punctuation-regex.js
var require_unicode_punctuation_regex = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/unicode-punctuation-regex.js"(exports, module) {
    "use strict";
    var unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    module.exports = unicodePunctuation;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/regex-check.js
var require_regex_check = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/regex-check.js"(exports, module) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function regexCheck(regex) {
      return check;
      function check(code2) {
        return regex.test(fromCharCode(code2));
      }
    }
    module.exports = regexCheck;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/unicode-punctuation.js
var require_unicode_punctuation = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/unicode-punctuation.js"(exports, module) {
    "use strict";
    var unicodePunctuationRegex = require_unicode_punctuation_regex();
    var regexCheck = require_regex_check();
    var unicodePunctuation = regexCheck(unicodePunctuationRegex);
    module.exports = unicodePunctuation;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/unicode-whitespace.js
var require_unicode_whitespace = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/unicode-whitespace.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var unicodeWhitespace = regexCheck(/\s/);
    module.exports = unicodeWhitespace;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/classify-character.js
var require_classify_character = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/classify-character.js"(exports, module) {
    "use strict";
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var unicodePunctuation = require_unicode_punctuation();
    var unicodeWhitespace = require_unicode_whitespace();
    function classifyCharacter(code2) {
      if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
        return 1;
      }
      if (unicodePunctuation(code2)) {
        return 2;
      }
    }
    module.exports = classifyCharacter;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/move-point.js
var require_move_point = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/util/move-point.js"(exports, module) {
    "use strict";
    function movePoint(point, offset) {
      point.column += offset;
      point.offset += offset;
      point._bufferIndex += offset;
      return point;
    }
    module.exports = movePoint;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/attention.js
var require_attention = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/attention.js"(exports, module) {
    "use strict";
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var classifyCharacter = require_classify_character();
    var movePoint = require_move_point();
    var resolveAll = require_resolve_all();
    var shallow = require_shallow();
    var attention = {
      name: "attention",
      tokenize: tokenizeAttention,
      resolveAll: resolveAllAttention
    };
    function resolveAllAttention(events2, context) {
      var index2 = -1;
      var open;
      var group;
      var text3;
      var openingSequence;
      var closingSequence;
      var use;
      var nextEvents;
      var offset;
      while (++index2 < events2.length) {
        if (events2[index2][0] === "enter" && events2[index2][1].type === "attentionSequence" && events2[index2][1]._close) {
          open = index2;
          while (open--) {
            if (events2[open][0] === "exit" && events2[open][1].type === "attentionSequence" && events2[open][1]._open && // If the markers are the same:
            context.sliceSerialize(events2[open][1]).charCodeAt(0) === context.sliceSerialize(events2[index2][1]).charCodeAt(0)) {
              if ((events2[open][1]._close || events2[index2][1]._open) && (events2[index2][1].end.offset - events2[index2][1].start.offset) % 3 && !((events2[open][1].end.offset - events2[open][1].start.offset + events2[index2][1].end.offset - events2[index2][1].start.offset) % 3)) {
                continue;
              }
              use = events2[open][1].end.offset - events2[open][1].start.offset > 1 && events2[index2][1].end.offset - events2[index2][1].start.offset > 1 ? 2 : 1;
              openingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start: movePoint(shallow(events2[open][1].end), -use),
                end: shallow(events2[open][1].end)
              };
              closingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start: shallow(events2[index2][1].start),
                end: movePoint(shallow(events2[index2][1].start), use)
              };
              text3 = {
                type: use > 1 ? "strongText" : "emphasisText",
                start: shallow(events2[open][1].end),
                end: shallow(events2[index2][1].start)
              };
              group = {
                type: use > 1 ? "strong" : "emphasis",
                start: shallow(openingSequence.start),
                end: shallow(closingSequence.end)
              };
              events2[open][1].end = shallow(openingSequence.start);
              events2[index2][1].start = shallow(closingSequence.end);
              nextEvents = [];
              if (events2[open][1].end.offset - events2[open][1].start.offset) {
                nextEvents = chunkedPush(nextEvents, [
                  ["enter", events2[open][1], context],
                  ["exit", events2[open][1], context]
                ]);
              }
              nextEvents = chunkedPush(nextEvents, [
                ["enter", group, context],
                ["enter", openingSequence, context],
                ["exit", openingSequence, context],
                ["enter", text3, context]
              ]);
              nextEvents = chunkedPush(
                nextEvents,
                resolveAll(
                  context.parser.constructs.insideSpan.null,
                  events2.slice(open + 1, index2),
                  context
                )
              );
              nextEvents = chunkedPush(nextEvents, [
                ["exit", text3, context],
                ["enter", closingSequence, context],
                ["exit", closingSequence, context],
                ["exit", group, context]
              ]);
              if (events2[index2][1].end.offset - events2[index2][1].start.offset) {
                offset = 2;
                nextEvents = chunkedPush(nextEvents, [
                  ["enter", events2[index2][1], context],
                  ["exit", events2[index2][1], context]
                ]);
              } else {
                offset = 0;
              }
              chunkedSplice(events2, open - 1, index2 - open + 3, nextEvents);
              index2 = open + nextEvents.length - offset - 2;
              break;
            }
          }
        }
      }
      index2 = -1;
      while (++index2 < events2.length) {
        if (events2[index2][1].type === "attentionSequence") {
          events2[index2][1].type = "data";
        }
      }
      return events2;
    }
    function tokenizeAttention(effects, ok) {
      var before = classifyCharacter(this.previous);
      var marker;
      return start2;
      function start2(code2) {
        effects.enter("attentionSequence");
        marker = code2;
        return sequence(code2);
      }
      function sequence(code2) {
        var token2;
        var after;
        var open;
        var close;
        if (code2 === marker) {
          effects.consume(code2);
          return sequence;
        }
        token2 = effects.exit("attentionSequence");
        after = classifyCharacter(code2);
        open = !after || after === 2 && before;
        close = !before || before === 2 && after;
        token2._open = marker === 42 ? open : open && (before || !close);
        token2._close = marker === 42 ? close : close && (after || !open);
        return ok(code2);
      }
    }
    module.exports = attention;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-alpha.js
var require_ascii_alpha = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-alpha.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAlpha = regexCheck(/[A-Za-z]/);
    module.exports = asciiAlpha;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-alphanumeric.js
var require_ascii_alphanumeric = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-alphanumeric.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
    module.exports = asciiAlphanumeric;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-atext.js
var require_ascii_atext = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-atext.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
    module.exports = asciiAtext;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-control.js
var require_ascii_control = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-control.js"(exports, module) {
    "use strict";
    function asciiControl(code2) {
      return (
        // Special whitespace codes (which have negative values), C0 and Control
        // character DEL
        code2 < 32 || code2 === 127
      );
    }
    module.exports = asciiControl;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/autolink.js
var require_autolink2 = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/autolink.js"(exports, module) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var asciiAtext = require_ascii_atext();
    var asciiControl = require_ascii_control();
    var autolink = {
      name: "autolink",
      tokenize: tokenizeAutolink
    };
    function tokenizeAutolink(effects, ok, nok) {
      var size3 = 1;
      return start2;
      function start2(code2) {
        effects.enter("autolink");
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.enter("autolinkProtocol");
        return open;
      }
      function open(code2) {
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return schemeOrEmailAtext;
        }
        return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
      }
      function schemeOrEmailAtext(code2) {
        return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
      }
      function schemeInsideOrEmailAtext(code2) {
        if (code2 === 58) {
          effects.consume(code2);
          return urlInside;
        }
        if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size3++ < 32) {
          effects.consume(code2);
          return schemeInsideOrEmailAtext;
        }
        return emailAtext(code2);
      }
      function urlInside(code2) {
        if (code2 === 62) {
          effects.exit("autolinkProtocol");
          return end(code2);
        }
        if (code2 === 32 || code2 === 60 || asciiControl(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return urlInside;
      }
      function emailAtext(code2) {
        if (code2 === 64) {
          effects.consume(code2);
          size3 = 0;
          return emailAtSignOrDot;
        }
        if (asciiAtext(code2)) {
          effects.consume(code2);
          return emailAtext;
        }
        return nok(code2);
      }
      function emailAtSignOrDot(code2) {
        return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
      }
      function emailLabel(code2) {
        if (code2 === 46) {
          effects.consume(code2);
          size3 = 0;
          return emailAtSignOrDot;
        }
        if (code2 === 62) {
          effects.exit("autolinkProtocol").type = "autolinkEmail";
          return end(code2);
        }
        return emailValue(code2);
      }
      function emailValue(code2) {
        if ((code2 === 45 || asciiAlphanumeric(code2)) && size3++ < 63) {
          effects.consume(code2);
          return code2 === 45 ? emailValue : emailLabel;
        }
        return nok(code2);
      }
      function end(code2) {
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok;
      }
    }
    module.exports = autolink;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/block-quote.js
var require_block_quote = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/block-quote.js"(exports, module) {
    "use strict";
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var blockQuote = {
      name: "blockQuote",
      tokenize: tokenizeBlockQuoteStart,
      continuation: {
        tokenize: tokenizeBlockQuoteContinuation
      },
      exit
    };
    function tokenizeBlockQuoteStart(effects, ok, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        if (code2 === 62) {
          if (!self2.containerState.open) {
            effects.enter("blockQuote", {
              _container: true
            });
            self2.containerState.open = true;
          }
          effects.enter("blockQuotePrefix");
          effects.enter("blockQuoteMarker");
          effects.consume(code2);
          effects.exit("blockQuoteMarker");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        if (markdownSpace(code2)) {
          effects.enter("blockQuotePrefixWhitespace");
          effects.consume(code2);
          effects.exit("blockQuotePrefixWhitespace");
          effects.exit("blockQuotePrefix");
          return ok;
        }
        effects.exit("blockQuotePrefix");
        return ok(code2);
      }
    }
    function tokenizeBlockQuoteContinuation(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.attempt(blockQuote, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    function exit(effects) {
      effects.exit("blockQuote");
    }
    module.exports = blockQuote;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-punctuation.js
var require_ascii_punctuation = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-punctuation.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
    module.exports = asciiPunctuation;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/character-escape.js
var require_character_escape = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/character-escape.js"(exports, module) {
    "use strict";
    var asciiPunctuation = require_ascii_punctuation();
    var characterEscape = {
      name: "characterEscape",
      tokenize: tokenizeCharacterEscape
    };
    function tokenizeCharacterEscape(effects, ok, nok) {
      return start2;
      function start2(code2) {
        effects.enter("characterEscape");
        effects.enter("escapeMarker");
        effects.consume(code2);
        effects.exit("escapeMarker");
        return open;
      }
      function open(code2) {
        if (asciiPunctuation(code2)) {
          effects.enter("characterEscapeValue");
          effects.consume(code2);
          effects.exit("characterEscapeValue");
          effects.exit("characterEscape");
          return ok;
        }
        return nok(code2);
      }
    }
    module.exports = characterEscape;
  }
});

// node_modules/.pnpm/parse-entities@2.0.0/node_modules/parse-entities/decode-entity.browser.js
var require_decode_entity_browser = __commonJS({
  "node_modules/.pnpm/parse-entities@2.0.0/node_modules/parse-entities/decode-entity.browser.js"(exports, module) {
    "use strict";
    var el;
    var semicolon = 59;
    module.exports = decodeEntity;
    function decodeEntity(characters2) {
      var entity = "&" + characters2 + ";";
      var char2;
      el = el || document.createElement("i");
      el.innerHTML = entity;
      char2 = el.textContent;
      if (char2.charCodeAt(char2.length - 1) === semicolon && characters2 !== "semi") {
        return false;
      }
      return char2 === entity ? false : char2;
    }
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-digit.js
var require_ascii_digit = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-digit.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiDigit = regexCheck(/\d/);
    module.exports = asciiDigit;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-hex-digit.js
var require_ascii_hex_digit = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/character/ascii-hex-digit.js"(exports, module) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
    module.exports = asciiHexDigit;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/character-reference.js
var require_character_reference = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/character-reference.js"(exports, module) {
    "use strict";
    var decodeEntity = require_decode_entity_browser();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var asciiDigit = require_ascii_digit();
    var asciiHexDigit = require_ascii_hex_digit();
    function _interopDefaultLegacy(e6) {
      return e6 && typeof e6 === "object" && "default" in e6 ? e6 : { default: e6 };
    }
    var decodeEntity__default = _interopDefaultLegacy(decodeEntity);
    var characterReference = {
      name: "characterReference",
      tokenize: tokenizeCharacterReference
    };
    function tokenizeCharacterReference(effects, ok, nok) {
      var self2 = this;
      var size3 = 0;
      var max2;
      var test;
      return start2;
      function start2(code2) {
        effects.enter("characterReference");
        effects.enter("characterReferenceMarker");
        effects.consume(code2);
        effects.exit("characterReferenceMarker");
        return open;
      }
      function open(code2) {
        if (code2 === 35) {
          effects.enter("characterReferenceMarkerNumeric");
          effects.consume(code2);
          effects.exit("characterReferenceMarkerNumeric");
          return numeric;
        }
        effects.enter("characterReferenceValue");
        max2 = 31;
        test = asciiAlphanumeric;
        return value2(code2);
      }
      function numeric(code2) {
        if (code2 === 88 || code2 === 120) {
          effects.enter("characterReferenceMarkerHexadecimal");
          effects.consume(code2);
          effects.exit("characterReferenceMarkerHexadecimal");
          effects.enter("characterReferenceValue");
          max2 = 6;
          test = asciiHexDigit;
          return value2;
        }
        effects.enter("characterReferenceValue");
        max2 = 7;
        test = asciiDigit;
        return value2(code2);
      }
      function value2(code2) {
        var token2;
        if (code2 === 59 && size3) {
          token2 = effects.exit("characterReferenceValue");
          if (test === asciiAlphanumeric && !decodeEntity__default["default"](self2.sliceSerialize(token2))) {
            return nok(code2);
          }
          effects.enter("characterReferenceMarker");
          effects.consume(code2);
          effects.exit("characterReferenceMarker");
          effects.exit("characterReference");
          return ok;
        }
        if (test(code2) && size3++ < max2) {
          effects.consume(code2);
          return value2;
        }
        return nok(code2);
      }
    }
    module.exports = characterReference;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/code-fenced.js
var require_code_fenced = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/code-fenced.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var prefixSize = require_prefix_size();
    var factorySpace = require_factory_space();
    var codeFenced = {
      name: "codeFenced",
      tokenize: tokenizeCodeFenced,
      concrete: true
    };
    function tokenizeCodeFenced(effects, ok, nok) {
      var self2 = this;
      var closingFenceConstruct = {
        tokenize: tokenizeClosingFence,
        partial: true
      };
      var initialPrefix = prefixSize(this.events, "linePrefix");
      var sizeOpen = 0;
      var marker;
      return start2;
      function start2(code2) {
        effects.enter("codeFenced");
        effects.enter("codeFencedFence");
        effects.enter("codeFencedFenceSequence");
        marker = code2;
        return sequenceOpen(code2);
      }
      function sequenceOpen(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          sizeOpen++;
          return sequenceOpen;
        }
        effects.exit("codeFencedFenceSequence");
        return sizeOpen < 3 ? nok(code2) : factorySpace(effects, infoOpen, "whitespace")(code2);
      }
      function infoOpen(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return openAfter(code2);
        }
        effects.enter("codeFencedFenceInfo");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return info(code2);
      }
      function info(code2) {
        if (code2 === null || markdownLineEndingOrSpace(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceInfo");
          return factorySpace(effects, infoAfter, "whitespace")(code2);
        }
        if (code2 === 96 && code2 === marker)
          return nok(code2);
        effects.consume(code2);
        return info;
      }
      function infoAfter(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return openAfter(code2);
        }
        effects.enter("codeFencedFenceMeta");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return meta(code2);
      }
      function meta(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceMeta");
          return openAfter(code2);
        }
        if (code2 === 96 && code2 === marker)
          return nok(code2);
        effects.consume(code2);
        return meta;
      }
      function openAfter(code2) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok(code2) : content(code2);
      }
      function content(code2) {
        if (code2 === null) {
          return after(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return effects.attempt(
            closingFenceConstruct,
            after,
            initialPrefix ? factorySpace(effects, content, "linePrefix", initialPrefix + 1) : content
          );
        }
        effects.enter("codeFlowValue");
        return contentContinue(code2);
      }
      function contentContinue(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("codeFlowValue");
          return content(code2);
        }
        effects.consume(code2);
        return contentContinue;
      }
      function after(code2) {
        effects.exit("codeFenced");
        return ok(code2);
      }
      function tokenizeClosingFence(effects2, ok2, nok2) {
        var size3 = 0;
        return factorySpace(
          effects2,
          closingSequenceStart,
          "linePrefix",
          this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        );
        function closingSequenceStart(code2) {
          effects2.enter("codeFencedFence");
          effects2.enter("codeFencedFenceSequence");
          return closingSequence(code2);
        }
        function closingSequence(code2) {
          if (code2 === marker) {
            effects2.consume(code2);
            size3++;
            return closingSequence;
          }
          if (size3 < sizeOpen)
            return nok2(code2);
          effects2.exit("codeFencedFenceSequence");
          return factorySpace(effects2, closingSequenceEnd, "whitespace")(code2);
        }
        function closingSequenceEnd(code2) {
          if (code2 === null || markdownLineEnding(code2)) {
            effects2.exit("codeFencedFence");
            return ok2(code2);
          }
          return nok2(code2);
        }
      }
    }
    module.exports = codeFenced;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/code-indented.js
var require_code_indented = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/code-indented.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var chunkedSplice = require_chunked_splice();
    var prefixSize = require_prefix_size();
    var factorySpace = require_factory_space();
    var codeIndented = {
      name: "codeIndented",
      tokenize: tokenizeCodeIndented,
      resolve: resolveCodeIndented
    };
    var indentedContentConstruct = {
      tokenize: tokenizeIndentedContent,
      partial: true
    };
    function resolveCodeIndented(events2, context) {
      var code2 = {
        type: "codeIndented",
        start: events2[0][1].start,
        end: events2[events2.length - 1][1].end
      };
      chunkedSplice(events2, 0, 0, [["enter", code2, context]]);
      chunkedSplice(events2, events2.length, 0, [["exit", code2, context]]);
      return events2;
    }
    function tokenizeCodeIndented(effects, ok, nok) {
      return effects.attempt(indentedContentConstruct, afterPrefix, nok);
      function afterPrefix(code2) {
        if (code2 === null) {
          return ok(code2);
        }
        if (markdownLineEnding(code2)) {
          return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code2);
        }
        effects.enter("codeFlowValue");
        return content(code2);
      }
      function content(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("codeFlowValue");
          return afterPrefix(code2);
        }
        effects.consume(code2);
        return content;
      }
    }
    function tokenizeIndentedContent(effects, ok, nok) {
      var self2 = this;
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1);
      function afterPrefix(code2) {
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1);
        }
        return prefixSize(self2.events, "linePrefix") < 4 ? nok(code2) : ok(code2);
      }
    }
    module.exports = codeIndented;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/code-text.js
var require_code_text = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/code-text.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var codeText = {
      name: "codeText",
      tokenize: tokenizeCodeText,
      resolve: resolveCodeText,
      previous
    };
    function resolveCodeText(events2) {
      var tailExitIndex = events2.length - 4;
      var headEnterIndex = 3;
      var index2;
      var enter;
      if ((events2[headEnterIndex][1].type === "lineEnding" || events2[headEnterIndex][1].type === "space") && (events2[tailExitIndex][1].type === "lineEnding" || events2[tailExitIndex][1].type === "space")) {
        index2 = headEnterIndex;
        while (++index2 < tailExitIndex) {
          if (events2[index2][1].type === "codeTextData") {
            events2[tailExitIndex][1].type = events2[headEnterIndex][1].type = "codeTextPadding";
            headEnterIndex += 2;
            tailExitIndex -= 2;
            break;
          }
        }
      }
      index2 = headEnterIndex - 1;
      tailExitIndex++;
      while (++index2 <= tailExitIndex) {
        if (enter === void 0) {
          if (index2 !== tailExitIndex && events2[index2][1].type !== "lineEnding") {
            enter = index2;
          }
        } else if (index2 === tailExitIndex || events2[index2][1].type === "lineEnding") {
          events2[enter][1].type = "codeTextData";
          if (index2 !== enter + 2) {
            events2[enter][1].end = events2[index2 - 1][1].end;
            events2.splice(enter + 2, index2 - enter - 2);
            tailExitIndex -= index2 - enter - 2;
            index2 = enter + 2;
          }
          enter = void 0;
        }
      }
      return events2;
    }
    function previous(code2) {
      return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
    }
    function tokenizeCodeText(effects, ok, nok) {
      var sizeOpen = 0;
      var size3;
      var token2;
      return start2;
      function start2(code2) {
        effects.enter("codeText");
        effects.enter("codeTextSequence");
        return openingSequence(code2);
      }
      function openingSequence(code2) {
        if (code2 === 96) {
          effects.consume(code2);
          sizeOpen++;
          return openingSequence;
        }
        effects.exit("codeTextSequence");
        return gap(code2);
      }
      function gap(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 96) {
          token2 = effects.enter("codeTextSequence");
          size3 = 0;
          return closingSequence(code2);
        }
        if (code2 === 32) {
          effects.enter("space");
          effects.consume(code2);
          effects.exit("space");
          return gap;
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return gap;
        }
        effects.enter("codeTextData");
        return data(code2);
      }
      function data(code2) {
        if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
          effects.exit("codeTextData");
          return gap(code2);
        }
        effects.consume(code2);
        return data;
      }
      function closingSequence(code2) {
        if (code2 === 96) {
          effects.consume(code2);
          size3++;
          return closingSequence;
        }
        if (size3 === sizeOpen) {
          effects.exit("codeTextSequence");
          effects.exit("codeText");
          return ok(code2);
        }
        token2.type = "codeTextData";
        return data(code2);
      }
    }
    module.exports = codeText;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-destination.js
var require_factory_destination = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-destination.js"(exports, module) {
    "use strict";
    var asciiControl = require_ascii_control();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownLineEnding = require_markdown_line_ending();
    function destinationFactory(effects, ok, nok, type2, literalType, literalMarkerType, rawType, stringType, max2) {
      var limit = max2 || Infinity;
      var balance = 0;
      return start2;
      function start2(code2) {
        if (code2 === 60) {
          effects.enter(type2);
          effects.enter(literalType);
          effects.enter(literalMarkerType);
          effects.consume(code2);
          effects.exit(literalMarkerType);
          return destinationEnclosedBefore;
        }
        if (asciiControl(code2) || code2 === 41) {
          return nok(code2);
        }
        effects.enter(type2);
        effects.enter(rawType);
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationRaw(code2);
      }
      function destinationEnclosedBefore(code2) {
        if (code2 === 62) {
          effects.enter(literalMarkerType);
          effects.consume(code2);
          effects.exit(literalMarkerType);
          effects.exit(literalType);
          effects.exit(type2);
          return ok;
        }
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationEnclosed(code2);
      }
      function destinationEnclosed(code2) {
        if (code2 === 62) {
          effects.exit("chunkString");
          effects.exit(stringType);
          return destinationEnclosedBefore(code2);
        }
        if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
      }
      function destinationEnclosedEscape(code2) {
        if (code2 === 60 || code2 === 62 || code2 === 92) {
          effects.consume(code2);
          return destinationEnclosed;
        }
        return destinationEnclosed(code2);
      }
      function destinationRaw(code2) {
        if (code2 === 40) {
          if (++balance > limit)
            return nok(code2);
          effects.consume(code2);
          return destinationRaw;
        }
        if (code2 === 41) {
          if (!balance--) {
            effects.exit("chunkString");
            effects.exit(stringType);
            effects.exit(rawType);
            effects.exit(type2);
            return ok(code2);
          }
          effects.consume(code2);
          return destinationRaw;
        }
        if (code2 === null || markdownLineEndingOrSpace(code2)) {
          if (balance)
            return nok(code2);
          effects.exit("chunkString");
          effects.exit(stringType);
          effects.exit(rawType);
          effects.exit(type2);
          return ok(code2);
        }
        if (asciiControl(code2))
          return nok(code2);
        effects.consume(code2);
        return code2 === 92 ? destinationRawEscape : destinationRaw;
      }
      function destinationRawEscape(code2) {
        if (code2 === 40 || code2 === 41 || code2 === 92) {
          effects.consume(code2);
          return destinationRaw;
        }
        return destinationRaw(code2);
      }
    }
    module.exports = destinationFactory;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-label.js
var require_factory_label = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-label.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    function labelFactory(effects, ok, nok, type2, markerType, stringType) {
      var self2 = this;
      var size3 = 0;
      var data;
      return start2;
      function start2(code2) {
        effects.enter(type2);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.enter(stringType);
        return atBreak;
      }
      function atBreak(code2) {
        if (code2 === null || code2 === 91 || code2 === 93 && !data || /* c8 ignore next */
        code2 === 94 && /* c8 ignore next */
        !size3 && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs || size3 > 999) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.exit(stringType);
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          effects.exit(type2);
          return ok;
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return atBreak;
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return label(code2);
      }
      function label(code2) {
        if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size3++ > 999) {
          effects.exit("chunkString");
          return atBreak(code2);
        }
        effects.consume(code2);
        data = data || !markdownSpace(code2);
        return code2 === 92 ? labelEscape : label;
      }
      function labelEscape(code2) {
        if (code2 === 91 || code2 === 92 || code2 === 93) {
          effects.consume(code2);
          size3++;
          return label;
        }
        return label(code2);
      }
    }
    module.exports = labelFactory;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-whitespace.js
var require_factory_whitespace = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-whitespace.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    function whitespaceFactory(effects, ok) {
      var seen;
      return start2;
      function start2(code2) {
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          seen = true;
          return start2;
        }
        if (markdownSpace(code2)) {
          return factorySpace(
            effects,
            start2,
            seen ? "linePrefix" : "lineSuffix"
          )(code2);
        }
        return ok(code2);
      }
    }
    module.exports = whitespaceFactory;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-title.js
var require_factory_title = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/factory-title.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    function titleFactory(effects, ok, nok, type2, markerType, stringType) {
      var marker;
      return start2;
      function start2(code2) {
        effects.enter(type2);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        marker = code2 === 40 ? 41 : code2;
        return atFirstTitleBreak;
      }
      function atFirstTitleBreak(code2) {
        if (code2 === marker) {
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          effects.exit(type2);
          return ok;
        }
        effects.enter(stringType);
        return atTitleBreak(code2);
      }
      function atTitleBreak(code2) {
        if (code2 === marker) {
          effects.exit(stringType);
          return atFirstTitleBreak(marker);
        }
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return factorySpace(effects, atTitleBreak, "linePrefix");
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return title(code2);
      }
      function title(code2) {
        if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
          effects.exit("chunkString");
          return atTitleBreak(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? titleEscape : title;
      }
      function titleEscape(code2) {
        if (code2 === marker || code2 === 92) {
          effects.consume(code2);
          return title;
        }
        return title(code2);
      }
    }
    module.exports = titleFactory;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/definition.js
var require_definition = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/definition.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var normalizeIdentifier = require_normalize_identifier();
    var factoryDestination = require_factory_destination();
    var factoryLabel = require_factory_label();
    var factorySpace = require_factory_space();
    var factoryWhitespace = require_factory_whitespace();
    var factoryTitle = require_factory_title();
    var definition = {
      name: "definition",
      tokenize: tokenizeDefinition
    };
    var titleConstruct = {
      tokenize: tokenizeTitle,
      partial: true
    };
    function tokenizeDefinition(effects, ok, nok) {
      var self2 = this;
      var identifier2;
      return start2;
      function start2(code2) {
        effects.enter("definition");
        return factoryLabel.call(
          self2,
          effects,
          labelAfter,
          nok,
          "definitionLabel",
          "definitionLabelMarker",
          "definitionLabelString"
        )(code2);
      }
      function labelAfter(code2) {
        identifier2 = normalizeIdentifier(
          self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
        );
        if (code2 === 58) {
          effects.enter("definitionMarker");
          effects.consume(code2);
          effects.exit("definitionMarker");
          return factoryWhitespace(
            effects,
            factoryDestination(
              effects,
              effects.attempt(
                titleConstruct,
                factorySpace(effects, after, "whitespace"),
                factorySpace(effects, after, "whitespace")
              ),
              nok,
              "definitionDestination",
              "definitionDestinationLiteral",
              "definitionDestinationLiteralMarker",
              "definitionDestinationRaw",
              "definitionDestinationString"
            )
          );
        }
        return nok(code2);
      }
      function after(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("definition");
          if (self2.parser.defined.indexOf(identifier2) < 0) {
            self2.parser.defined.push(identifier2);
          }
          return ok(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeTitle(effects, ok, nok) {
      return start2;
      function start2(code2) {
        return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, before)(code2) : nok(code2);
      }
      function before(code2) {
        if (code2 === 34 || code2 === 39 || code2 === 40) {
          return factoryTitle(
            effects,
            factorySpace(effects, after, "whitespace"),
            nok,
            "definitionTitle",
            "definitionTitleMarker",
            "definitionTitleString"
          )(code2);
        }
        return nok(code2);
      }
      function after(code2) {
        return code2 === null || markdownLineEnding(code2) ? ok(code2) : nok(code2);
      }
    }
    module.exports = definition;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/hard-break-escape.js
var require_hard_break_escape = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/hard-break-escape.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var hardBreakEscape = {
      name: "hardBreakEscape",
      tokenize: tokenizeHardBreakEscape
    };
    function tokenizeHardBreakEscape(effects, ok, nok) {
      return start2;
      function start2(code2) {
        effects.enter("hardBreakEscape");
        effects.enter("escapeMarker");
        effects.consume(code2);
        return open;
      }
      function open(code2) {
        if (markdownLineEnding(code2)) {
          effects.exit("escapeMarker");
          effects.exit("hardBreakEscape");
          return ok(code2);
        }
        return nok(code2);
      }
    }
    module.exports = hardBreakEscape;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/heading-atx.js
var require_heading_atx = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/heading-atx.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var chunkedSplice = require_chunked_splice();
    var factorySpace = require_factory_space();
    var headingAtx = {
      name: "headingAtx",
      tokenize: tokenizeHeadingAtx,
      resolve: resolveHeadingAtx
    };
    function resolveHeadingAtx(events2, context) {
      var contentEnd = events2.length - 2;
      var contentStart = 3;
      var content;
      var text3;
      if (events2[contentStart][1].type === "whitespace") {
        contentStart += 2;
      }
      if (contentEnd - 2 > contentStart && events2[contentEnd][1].type === "whitespace") {
        contentEnd -= 2;
      }
      if (events2[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events2[contentEnd - 2][1].type === "whitespace")) {
        contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
      }
      if (contentEnd > contentStart) {
        content = {
          type: "atxHeadingText",
          start: events2[contentStart][1].start,
          end: events2[contentEnd][1].end
        };
        text3 = {
          type: "chunkText",
          start: events2[contentStart][1].start,
          end: events2[contentEnd][1].end,
          contentType: "text"
        };
        chunkedSplice(events2, contentStart, contentEnd - contentStart + 1, [
          ["enter", content, context],
          ["enter", text3, context],
          ["exit", text3, context],
          ["exit", content, context]
        ]);
      }
      return events2;
    }
    function tokenizeHeadingAtx(effects, ok, nok) {
      var self2 = this;
      var size3 = 0;
      return start2;
      function start2(code2) {
        effects.enter("atxHeading");
        effects.enter("atxHeadingSequence");
        return fenceOpenInside(code2);
      }
      function fenceOpenInside(code2) {
        if (code2 === 35 && size3++ < 6) {
          effects.consume(code2);
          return fenceOpenInside;
        }
        if (code2 === null || markdownLineEndingOrSpace(code2)) {
          effects.exit("atxHeadingSequence");
          return self2.interrupt ? ok(code2) : headingBreak(code2);
        }
        return nok(code2);
      }
      function headingBreak(code2) {
        if (code2 === 35) {
          effects.enter("atxHeadingSequence");
          return sequence(code2);
        }
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("atxHeading");
          return ok(code2);
        }
        if (markdownSpace(code2)) {
          return factorySpace(effects, headingBreak, "whitespace")(code2);
        }
        effects.enter("atxHeadingText");
        return data(code2);
      }
      function sequence(code2) {
        if (code2 === 35) {
          effects.consume(code2);
          return sequence;
        }
        effects.exit("atxHeadingSequence");
        return headingBreak(code2);
      }
      function data(code2) {
        if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
          effects.exit("atxHeadingText");
          return headingBreak(code2);
        }
        effects.consume(code2);
        return data;
      }
    }
    module.exports = headingAtx;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/html-block-names.js
var require_html_block_names = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/html-block-names.js"(exports, module) {
    "use strict";
    var basics = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    module.exports = basics;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/html-raw-names.js
var require_html_raw_names = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constant/html-raw-names.js"(exports, module) {
    "use strict";
    var raws = ["pre", "script", "style", "textarea"];
    module.exports = raws;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/html-flow.js
var require_html_flow = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/html-flow.js"(exports, module) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var fromCharCode = require_from_char_code();
    var htmlBlockNames = require_html_block_names();
    var htmlRawNames = require_html_raw_names();
    var partialBlankLine = require_partial_blank_line();
    var htmlFlow = {
      name: "htmlFlow",
      tokenize: tokenizeHtmlFlow,
      resolveTo: resolveToHtmlFlow,
      concrete: true
    };
    var nextBlankConstruct = {
      tokenize: tokenizeNextBlank,
      partial: true
    };
    function resolveToHtmlFlow(events2) {
      var index2 = events2.length;
      while (index2--) {
        if (events2[index2][0] === "enter" && events2[index2][1].type === "htmlFlow") {
          break;
        }
      }
      if (index2 > 1 && events2[index2 - 2][1].type === "linePrefix") {
        events2[index2][1].start = events2[index2 - 2][1].start;
        events2[index2 + 1][1].start = events2[index2 - 2][1].start;
        events2.splice(index2 - 2, 2);
      }
      return events2;
    }
    function tokenizeHtmlFlow(effects, ok, nok) {
      var self2 = this;
      var kind;
      var startTag;
      var buffer;
      var index2;
      var marker;
      return start2;
      function start2(code2) {
        effects.enter("htmlFlow");
        effects.enter("htmlFlowData");
        effects.consume(code2);
        return open;
      }
      function open(code2) {
        if (code2 === 33) {
          effects.consume(code2);
          return declarationStart;
        }
        if (code2 === 47) {
          effects.consume(code2);
          return tagCloseStart;
        }
        if (code2 === 63) {
          effects.consume(code2);
          kind = 3;
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          buffer = fromCharCode(code2);
          startTag = true;
          return tagName3;
        }
        return nok(code2);
      }
      function declarationStart(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          kind = 2;
          return commentOpenInside;
        }
        if (code2 === 91) {
          effects.consume(code2);
          kind = 5;
          buffer = "CDATA[";
          index2 = 0;
          return cdataOpenInside;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          kind = 4;
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        return nok(code2);
      }
      function commentOpenInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        return nok(code2);
      }
      function cdataOpenInside(code2) {
        if (code2 === buffer.charCodeAt(index2++)) {
          effects.consume(code2);
          return index2 === buffer.length ? self2.interrupt ? ok : continuation : cdataOpenInside;
        }
        return nok(code2);
      }
      function tagCloseStart(code2) {
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          buffer = fromCharCode(code2);
          return tagName3;
        }
        return nok(code2);
      }
      function tagName3(code2) {
        if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
          if (code2 !== 47 && startTag && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
            kind = 1;
            return self2.interrupt ? ok(code2) : continuation(code2);
          }
          if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {
            kind = 6;
            if (code2 === 47) {
              effects.consume(code2);
              return basicSelfClosing;
            }
            return self2.interrupt ? ok(code2) : continuation(code2);
          }
          kind = 7;
          return self2.interrupt ? nok(code2) : startTag ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
        }
        if (code2 === 45 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          buffer += fromCharCode(code2);
          return tagName3;
        }
        return nok(code2);
      }
      function basicSelfClosing(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return self2.interrupt ? ok : continuation;
        }
        return nok(code2);
      }
      function completeClosingTagAfter(code2) {
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeClosingTagAfter;
        }
        return completeEnd(code2);
      }
      function completeAttributeNameBefore(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return completeEnd;
        }
        if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
          effects.consume(code2);
          return completeAttributeName;
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeAttributeNameBefore;
        }
        return completeEnd(code2);
      }
      function completeAttributeName(code2) {
        if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return completeAttributeName;
        }
        return completeAttributeNameAfter(code2);
      }
      function completeAttributeNameAfter(code2) {
        if (code2 === 61) {
          effects.consume(code2);
          return completeAttributeValueBefore;
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeAttributeNameAfter;
        }
        return completeAttributeNameBefore(code2);
      }
      function completeAttributeValueBefore(code2) {
        if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 34 || code2 === 39) {
          effects.consume(code2);
          marker = code2;
          return completeAttributeValueQuoted;
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeAttributeValueBefore;
        }
        marker = void 0;
        return completeAttributeValueUnquoted(code2);
      }
      function completeAttributeValueQuoted(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return completeAttributeValueQuotedAfter;
        }
        if (code2 === null || markdownLineEnding(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return completeAttributeValueQuoted;
      }
      function completeAttributeValueUnquoted(code2) {
        if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
          return completeAttributeNameAfter(code2);
        }
        effects.consume(code2);
        return completeAttributeValueUnquoted;
      }
      function completeAttributeValueQuotedAfter(code2) {
        if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
          return completeAttributeNameBefore(code2);
        }
        return nok(code2);
      }
      function completeEnd(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return completeAfter;
        }
        return nok(code2);
      }
      function completeAfter(code2) {
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return completeAfter;
        }
        return code2 === null || markdownLineEnding(code2) ? continuation(code2) : nok(code2);
      }
      function continuation(code2) {
        if (code2 === 45 && kind === 2) {
          effects.consume(code2);
          return continuationCommentInside;
        }
        if (code2 === 60 && kind === 1) {
          effects.consume(code2);
          return continuationRawTagOpen;
        }
        if (code2 === 62 && kind === 4) {
          effects.consume(code2);
          return continuationClose;
        }
        if (code2 === 63 && kind === 3) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        if (code2 === 93 && kind === 5) {
          effects.consume(code2);
          return continuationCharacterDataInside;
        }
        if (markdownLineEnding(code2) && (kind === 6 || kind === 7)) {
          return effects.check(
            nextBlankConstruct,
            continuationClose,
            continuationAtLineEnding
          )(code2);
        }
        if (code2 === null || markdownLineEnding(code2)) {
          return continuationAtLineEnding(code2);
        }
        effects.consume(code2);
        return continuation;
      }
      function continuationAtLineEnding(code2) {
        effects.exit("htmlFlowData");
        return htmlContinueStart(code2);
      }
      function htmlContinueStart(code2) {
        if (code2 === null) {
          return done(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return htmlContinueStart;
        }
        effects.enter("htmlFlowData");
        return continuation(code2);
      }
      function continuationCommentInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationRawTagOpen(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          buffer = "";
          return continuationRawEndTag;
        }
        return continuation(code2);
      }
      function continuationRawEndTag(code2) {
        if (code2 === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
          effects.consume(code2);
          return continuationClose;
        }
        if (asciiAlpha(code2) && buffer.length < 8) {
          effects.consume(code2);
          buffer += fromCharCode(code2);
          return continuationRawEndTag;
        }
        return continuation(code2);
      }
      function continuationCharacterDataInside(code2) {
        if (code2 === 93) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationDeclarationInside(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return continuationClose;
        }
        return continuation(code2);
      }
      function continuationClose(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("htmlFlowData");
          return done(code2);
        }
        effects.consume(code2);
        return continuationClose;
      }
      function done(code2) {
        effects.exit("htmlFlow");
        return ok(code2);
      }
    }
    function tokenizeNextBlank(effects, ok, nok) {
      return start2;
      function start2(code2) {
        effects.exit("htmlFlowData");
        effects.enter("lineEndingBlank");
        effects.consume(code2);
        effects.exit("lineEndingBlank");
        return effects.attempt(partialBlankLine, ok, nok);
      }
    }
    module.exports = htmlFlow;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/html-text.js
var require_html_text = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/html-text.js"(exports, module) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var htmlText = {
      name: "htmlText",
      tokenize: tokenizeHtmlText
    };
    function tokenizeHtmlText(effects, ok, nok) {
      var self2 = this;
      var marker;
      var buffer;
      var index2;
      var returnState;
      return start2;
      function start2(code2) {
        effects.enter("htmlText");
        effects.enter("htmlTextData");
        effects.consume(code2);
        return open;
      }
      function open(code2) {
        if (code2 === 33) {
          effects.consume(code2);
          return declarationOpen;
        }
        if (code2 === 47) {
          effects.consume(code2);
          return tagCloseStart;
        }
        if (code2 === 63) {
          effects.consume(code2);
          return instruction;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return tagOpen;
        }
        return nok(code2);
      }
      function declarationOpen(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentOpen;
        }
        if (code2 === 91) {
          effects.consume(code2);
          buffer = "CDATA[";
          index2 = 0;
          return cdataOpen;
        }
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return declaration2;
        }
        return nok(code2);
      }
      function commentOpen(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentStart;
        }
        return nok(code2);
      }
      function commentStart(code2) {
        if (code2 === null || code2 === 62) {
          return nok(code2);
        }
        if (code2 === 45) {
          effects.consume(code2);
          return commentStartDash;
        }
        return comment3(code2);
      }
      function commentStartDash(code2) {
        if (code2 === null || code2 === 62) {
          return nok(code2);
        }
        return comment3(code2);
      }
      function comment3(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 45) {
          effects.consume(code2);
          return commentClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = comment3;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return comment3;
      }
      function commentClose(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return end;
        }
        return comment3(code2);
      }
      function cdataOpen(code2) {
        if (code2 === buffer.charCodeAt(index2++)) {
          effects.consume(code2);
          return index2 === buffer.length ? cdata : cdataOpen;
        }
        return nok(code2);
      }
      function cdata(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.consume(code2);
          return cdataClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = cdata;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return cdata;
      }
      function cdataClose(code2) {
        if (code2 === 93) {
          effects.consume(code2);
          return cdataEnd;
        }
        return cdata(code2);
      }
      function cdataEnd(code2) {
        if (code2 === 62) {
          return end(code2);
        }
        if (code2 === 93) {
          effects.consume(code2);
          return cdataEnd;
        }
        return cdata(code2);
      }
      function declaration2(code2) {
        if (code2 === null || code2 === 62) {
          return end(code2);
        }
        if (markdownLineEnding(code2)) {
          returnState = declaration2;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return declaration2;
      }
      function instruction(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 63) {
          effects.consume(code2);
          return instructionClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = instruction;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return instruction;
      }
      function instructionClose(code2) {
        return code2 === 62 ? end(code2) : instruction(code2);
      }
      function tagCloseStart(code2) {
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return tagClose;
        }
        return nok(code2);
      }
      function tagClose(code2) {
        if (code2 === 45 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return tagClose;
        }
        return tagCloseBetween(code2);
      }
      function tagCloseBetween(code2) {
        if (markdownLineEnding(code2)) {
          returnState = tagCloseBetween;
          return atLineEnding(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return tagCloseBetween;
        }
        return end(code2);
      }
      function tagOpen(code2) {
        if (code2 === 45 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return tagOpen;
        }
        if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
          return tagOpenBetween(code2);
        }
        return nok(code2);
      }
      function tagOpenBetween(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return end;
        }
        if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
          effects.consume(code2);
          return tagOpenAttributeName;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenBetween;
          return atLineEnding(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return tagOpenBetween;
        }
        return end(code2);
      }
      function tagOpenAttributeName(code2) {
        if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return tagOpenAttributeName;
        }
        return tagOpenAttributeNameAfter(code2);
      }
      function tagOpenAttributeNameAfter(code2) {
        if (code2 === 61) {
          effects.consume(code2);
          return tagOpenAttributeValueBefore;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeNameAfter;
          return atLineEnding(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return tagOpenAttributeNameAfter;
        }
        return tagOpenBetween(code2);
      }
      function tagOpenAttributeValueBefore(code2) {
        if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 34 || code2 === 39) {
          effects.consume(code2);
          marker = code2;
          return tagOpenAttributeValueQuoted;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeValueBefore;
          return atLineEnding(code2);
        }
        if (markdownSpace(code2)) {
          effects.consume(code2);
          return tagOpenAttributeValueBefore;
        }
        effects.consume(code2);
        marker = void 0;
        return tagOpenAttributeValueUnquoted;
      }
      function tagOpenAttributeValueQuoted(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return tagOpenAttributeValueQuotedAfter;
        }
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeValueQuoted;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return tagOpenAttributeValueQuoted;
      }
      function tagOpenAttributeValueQuotedAfter(code2) {
        if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace(code2)) {
          return tagOpenBetween(code2);
        }
        return nok(code2);
      }
      function tagOpenAttributeValueUnquoted(code2) {
        if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 62 || markdownLineEndingOrSpace(code2)) {
          return tagOpenBetween(code2);
        }
        effects.consume(code2);
        return tagOpenAttributeValueUnquoted;
      }
      function atLineEnding(code2) {
        effects.exit("htmlTextData");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(
          effects,
          afterPrefix,
          "linePrefix",
          self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        );
      }
      function afterPrefix(code2) {
        effects.enter("htmlTextData");
        return returnState(code2);
      }
      function end(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          effects.exit("htmlTextData");
          effects.exit("htmlText");
          return ok;
        }
        return nok(code2);
      }
    }
    module.exports = htmlText;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/label-end.js
var require_label_end = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/label-end.js"(exports, module) {
    "use strict";
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var normalizeIdentifier = require_normalize_identifier();
    var resolveAll = require_resolve_all();
    var shallow = require_shallow();
    var factoryDestination = require_factory_destination();
    var factoryLabel = require_factory_label();
    var factoryTitle = require_factory_title();
    var factoryWhitespace = require_factory_whitespace();
    var labelEnd = {
      name: "labelEnd",
      tokenize: tokenizeLabelEnd,
      resolveTo: resolveToLabelEnd,
      resolveAll: resolveAllLabelEnd
    };
    var resourceConstruct = {
      tokenize: tokenizeResource
    };
    var fullReferenceConstruct = {
      tokenize: tokenizeFullReference
    };
    var collapsedReferenceConstruct = {
      tokenize: tokenizeCollapsedReference
    };
    function resolveAllLabelEnd(events2) {
      var index2 = -1;
      var token2;
      while (++index2 < events2.length) {
        token2 = events2[index2][1];
        if (!token2._used && (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd")) {
          events2.splice(index2 + 1, token2.type === "labelImage" ? 4 : 2);
          token2.type = "data";
          index2++;
        }
      }
      return events2;
    }
    function resolveToLabelEnd(events2, context) {
      var index2 = events2.length;
      var offset = 0;
      var group;
      var label;
      var text3;
      var token2;
      var open;
      var close;
      var media;
      while (index2--) {
        token2 = events2[index2][1];
        if (open) {
          if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
            break;
          }
          if (events2[index2][0] === "enter" && token2.type === "labelLink") {
            token2._inactive = true;
          }
        } else if (close) {
          if (events2[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
            open = index2;
            if (token2.type !== "labelLink") {
              offset = 2;
              break;
            }
          }
        } else if (token2.type === "labelEnd") {
          close = index2;
        }
      }
      group = {
        type: events2[open][1].type === "labelLink" ? "link" : "image",
        start: shallow(events2[open][1].start),
        end: shallow(events2[events2.length - 1][1].end)
      };
      label = {
        type: "label",
        start: shallow(events2[open][1].start),
        end: shallow(events2[close][1].end)
      };
      text3 = {
        type: "labelText",
        start: shallow(events2[open + offset + 2][1].end),
        end: shallow(events2[close - 2][1].start)
      };
      media = [
        ["enter", group, context],
        ["enter", label, context]
      ];
      media = chunkedPush(media, events2.slice(open + 1, open + offset + 3));
      media = chunkedPush(media, [["enter", text3, context]]);
      media = chunkedPush(
        media,
        resolveAll(
          context.parser.constructs.insideSpan.null,
          events2.slice(open + offset + 4, close - 3),
          context
        )
      );
      media = chunkedPush(media, [
        ["exit", text3, context],
        events2[close - 2],
        events2[close - 1],
        ["exit", label, context]
      ]);
      media = chunkedPush(media, events2.slice(close + 1));
      media = chunkedPush(media, [["exit", group, context]]);
      chunkedSplice(events2, open, events2.length, media);
      return events2;
    }
    function tokenizeLabelEnd(effects, ok, nok) {
      var self2 = this;
      var index2 = self2.events.length;
      var labelStart;
      var defined;
      while (index2--) {
        if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
          labelStart = self2.events[index2][1];
          break;
        }
      }
      return start2;
      function start2(code2) {
        if (!labelStart) {
          return nok(code2);
        }
        if (labelStart._inactive)
          return balanced(code2);
        defined = self2.parser.defined.indexOf(
          normalizeIdentifier(
            self2.sliceSerialize({
              start: labelStart.end,
              end: self2.now()
            })
          )
        ) > -1;
        effects.enter("labelEnd");
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelEnd");
        return afterLabelEnd;
      }
      function afterLabelEnd(code2) {
        if (code2 === 40) {
          return effects.attempt(
            resourceConstruct,
            ok,
            defined ? ok : balanced
          )(code2);
        }
        if (code2 === 91) {
          return effects.attempt(
            fullReferenceConstruct,
            ok,
            defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced
          )(code2);
        }
        return defined ? ok(code2) : balanced(code2);
      }
      function balanced(code2) {
        labelStart._balanced = true;
        return nok(code2);
      }
    }
    function tokenizeResource(effects, ok, nok) {
      return start2;
      function start2(code2) {
        effects.enter("resource");
        effects.enter("resourceMarker");
        effects.consume(code2);
        effects.exit("resourceMarker");
        return factoryWhitespace(effects, open);
      }
      function open(code2) {
        if (code2 === 41) {
          return end(code2);
        }
        return factoryDestination(
          effects,
          destinationAfter,
          nok,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          3
        )(code2);
      }
      function destinationAfter(code2) {
        return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, between)(code2) : end(code2);
      }
      function between(code2) {
        if (code2 === 34 || code2 === 39 || code2 === 40) {
          return factoryTitle(
            effects,
            factoryWhitespace(effects, end),
            nok,
            "resourceTitle",
            "resourceTitleMarker",
            "resourceTitleString"
          )(code2);
        }
        return end(code2);
      }
      function end(code2) {
        if (code2 === 41) {
          effects.enter("resourceMarker");
          effects.consume(code2);
          effects.exit("resourceMarker");
          effects.exit("resource");
          return ok;
        }
        return nok(code2);
      }
    }
    function tokenizeFullReference(effects, ok, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        return factoryLabel.call(
          self2,
          effects,
          afterLabel,
          nok,
          "reference",
          "referenceMarker",
          "referenceString"
        )(code2);
      }
      function afterLabel(code2) {
        return self2.parser.defined.indexOf(
          normalizeIdentifier(
            self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
          )
        ) < 0 ? nok(code2) : ok(code2);
      }
    }
    function tokenizeCollapsedReference(effects, ok, nok) {
      return start2;
      function start2(code2) {
        effects.enter("reference");
        effects.enter("referenceMarker");
        effects.consume(code2);
        effects.exit("referenceMarker");
        return open;
      }
      function open(code2) {
        if (code2 === 93) {
          effects.enter("referenceMarker");
          effects.consume(code2);
          effects.exit("referenceMarker");
          effects.exit("reference");
          return ok;
        }
        return nok(code2);
      }
    }
    module.exports = labelEnd;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/label-start-image.js
var require_label_start_image = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/label-start-image.js"(exports, module) {
    "use strict";
    var labelEnd = require_label_end();
    var labelStartImage = {
      name: "labelStartImage",
      tokenize: tokenizeLabelStartImage,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartImage(effects, ok, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        effects.enter("labelImage");
        effects.enter("labelImageMarker");
        effects.consume(code2);
        effects.exit("labelImageMarker");
        return open;
      }
      function open(code2) {
        if (code2 === 91) {
          effects.enter("labelMarker");
          effects.consume(code2);
          effects.exit("labelMarker");
          effects.exit("labelImage");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        return code2 === 94 && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs ? (
          /* c8 ignore next */
          nok(code2)
        ) : ok(code2);
      }
    }
    module.exports = labelStartImage;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/label-start-link.js
var require_label_start_link = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/label-start-link.js"(exports, module) {
    "use strict";
    var labelEnd = require_label_end();
    var labelStartLink = {
      name: "labelStartLink",
      tokenize: tokenizeLabelStartLink,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartLink(effects, ok, nok) {
      var self2 = this;
      return start2;
      function start2(code2) {
        effects.enter("labelLink");
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelLink");
        return after;
      }
      function after(code2) {
        return code2 === 94 && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs ? (
          /* c8 ignore next */
          nok(code2)
        ) : ok(code2);
      }
    }
    module.exports = labelStartLink;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/line-ending.js
var require_line_ending = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/line-ending.js"(exports, module) {
    "use strict";
    var factorySpace = require_factory_space();
    var lineEnding = {
      name: "lineEnding",
      tokenize: tokenizeLineEnding
    };
    function tokenizeLineEnding(effects, ok) {
      return start2;
      function start2(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace(effects, ok, "linePrefix");
      }
    }
    module.exports = lineEnding;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/thematic-break.js
var require_thematic_break = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/thematic-break.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var thematicBreak = {
      name: "thematicBreak",
      tokenize: tokenizeThematicBreak
    };
    function tokenizeThematicBreak(effects, ok, nok) {
      var size3 = 0;
      var marker;
      return start2;
      function start2(code2) {
        effects.enter("thematicBreak");
        marker = code2;
        return atBreak(code2);
      }
      function atBreak(code2) {
        if (code2 === marker) {
          effects.enter("thematicBreakSequence");
          return sequence(code2);
        }
        if (markdownSpace(code2)) {
          return factorySpace(effects, atBreak, "whitespace")(code2);
        }
        if (size3 < 3 || code2 !== null && !markdownLineEnding(code2)) {
          return nok(code2);
        }
        effects.exit("thematicBreak");
        return ok(code2);
      }
      function sequence(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          size3++;
          return sequence;
        }
        effects.exit("thematicBreakSequence");
        return atBreak(code2);
      }
    }
    module.exports = thematicBreak;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/list.js
var require_list2 = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/list.js"(exports, module) {
    "use strict";
    var asciiDigit = require_ascii_digit();
    var markdownSpace = require_markdown_space();
    var prefixSize = require_prefix_size();
    var sizeChunks = require_size_chunks();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var thematicBreak = require_thematic_break();
    var list2 = {
      name: "list",
      tokenize: tokenizeListStart,
      continuation: {
        tokenize: tokenizeListContinuation
      },
      exit: tokenizeListEnd
    };
    var listItemPrefixWhitespaceConstruct = {
      tokenize: tokenizeListItemPrefixWhitespace,
      partial: true
    };
    var indentConstruct = {
      tokenize: tokenizeIndent,
      partial: true
    };
    function tokenizeListStart(effects, ok, nok) {
      var self2 = this;
      var initialSize = prefixSize(self2.events, "linePrefix");
      var size3 = 0;
      return start2;
      function start2(code2) {
        var kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
        if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
          if (!self2.containerState.type) {
            self2.containerState.type = kind;
            effects.enter(kind, {
              _container: true
            });
          }
          if (kind === "listUnordered") {
            effects.enter("listItemPrefix");
            return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
          }
          if (!self2.interrupt || code2 === 49) {
            effects.enter("listItemPrefix");
            effects.enter("listItemValue");
            return inside(code2);
          }
        }
        return nok(code2);
      }
      function inside(code2) {
        if (asciiDigit(code2) && ++size3 < 10) {
          effects.consume(code2);
          return inside;
        }
        if ((!self2.interrupt || size3 < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
          effects.exit("listItemValue");
          return atMarker(code2);
        }
        return nok(code2);
      }
      function atMarker(code2) {
        effects.enter("listItemMarker");
        effects.consume(code2);
        effects.exit("listItemMarker");
        self2.containerState.marker = self2.containerState.marker || code2;
        return effects.check(
          partialBlankLine,
          // Can’t be empty when interrupting.
          self2.interrupt ? nok : onBlank,
          effects.attempt(
            listItemPrefixWhitespaceConstruct,
            endOfPrefix,
            otherPrefix
          )
        );
      }
      function onBlank(code2) {
        self2.containerState.initialBlankLine = true;
        initialSize++;
        return endOfPrefix(code2);
      }
      function otherPrefix(code2) {
        if (markdownSpace(code2)) {
          effects.enter("listItemPrefixWhitespace");
          effects.consume(code2);
          effects.exit("listItemPrefixWhitespace");
          return endOfPrefix;
        }
        return nok(code2);
      }
      function endOfPrefix(code2) {
        self2.containerState.size = initialSize + sizeChunks(self2.sliceStream(effects.exit("listItemPrefix")));
        return ok(code2);
      }
    }
    function tokenizeListContinuation(effects, ok, nok) {
      var self2 = this;
      self2.containerState._closeFlow = void 0;
      return effects.check(partialBlankLine, onBlank, notBlank);
      function onBlank(code2) {
        self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
        return factorySpace(
          effects,
          ok,
          "listItemIndent",
          self2.containerState.size + 1
        )(code2);
      }
      function notBlank(code2) {
        if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
          self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
          return notInCurrentItem(code2);
        }
        self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
        return effects.attempt(indentConstruct, ok, notInCurrentItem)(code2);
      }
      function notInCurrentItem(code2) {
        self2.containerState._closeFlow = true;
        self2.interrupt = void 0;
        return factorySpace(
          effects,
          effects.attempt(list2, ok, nok),
          "linePrefix",
          self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        )(code2);
      }
    }
    function tokenizeIndent(effects, ok, nok) {
      var self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "listItemIndent",
        self2.containerState.size + 1
      );
      function afterPrefix(code2) {
        return prefixSize(self2.events, "listItemIndent") === self2.containerState.size ? ok(code2) : nok(code2);
      }
    }
    function tokenizeListEnd(effects) {
      effects.exit(this.containerState.type);
    }
    function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
      var self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "listItemPrefixWhitespace",
        self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4 + 1
      );
      function afterPrefix(code2) {
        return markdownSpace(code2) || !prefixSize(self2.events, "listItemPrefixWhitespace") ? nok(code2) : ok(code2);
      }
    }
    module.exports = list2;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/setext-underline.js
var require_setext_underline = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/tokenize/setext-underline.js"(exports, module) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var shallow = require_shallow();
    var factorySpace = require_factory_space();
    var setextUnderline = {
      name: "setextUnderline",
      tokenize: tokenizeSetextUnderline,
      resolveTo: resolveToSetextUnderline
    };
    function resolveToSetextUnderline(events2, context) {
      var index2 = events2.length;
      var content;
      var text3;
      var definition;
      var heading2;
      while (index2--) {
        if (events2[index2][0] === "enter") {
          if (events2[index2][1].type === "content") {
            content = index2;
            break;
          }
          if (events2[index2][1].type === "paragraph") {
            text3 = index2;
          }
        } else {
          if (events2[index2][1].type === "content") {
            events2.splice(index2, 1);
          }
          if (!definition && events2[index2][1].type === "definition") {
            definition = index2;
          }
        }
      }
      heading2 = {
        type: "setextHeading",
        start: shallow(events2[text3][1].start),
        end: shallow(events2[events2.length - 1][1].end)
      };
      events2[text3][1].type = "setextHeadingText";
      if (definition) {
        events2.splice(text3, 0, ["enter", heading2, context]);
        events2.splice(definition + 1, 0, ["exit", events2[content][1], context]);
        events2[content][1].end = shallow(events2[definition][1].end);
      } else {
        events2[content][1] = heading2;
      }
      events2.push(["exit", heading2, context]);
      return events2;
    }
    function tokenizeSetextUnderline(effects, ok, nok) {
      var self2 = this;
      var index2 = self2.events.length;
      var marker;
      var paragraph2;
      while (index2--) {
        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
          paragraph2 = self2.events[index2][1].type === "paragraph";
          break;
        }
      }
      return start2;
      function start2(code2) {
        if (!self2.lazy && (self2.interrupt || paragraph2)) {
          effects.enter("setextHeadingLine");
          effects.enter("setextHeadingLineSequence");
          marker = code2;
          return closingSequence(code2);
        }
        return nok(code2);
      }
      function closingSequence(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return closingSequence;
        }
        effects.exit("setextHeadingLineSequence");
        return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code2);
      }
      function closingSequenceEnd(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("setextHeadingLine");
          return ok(code2);
        }
        return nok(code2);
      }
    }
    module.exports = setextUnderline;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constructs.js
var require_constructs = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/constructs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var text$1 = require_text2();
    var attention = require_attention();
    var autolink = require_autolink2();
    var blockQuote = require_block_quote();
    var characterEscape = require_character_escape();
    var characterReference = require_character_reference();
    var codeFenced = require_code_fenced();
    var codeIndented = require_code_indented();
    var codeText = require_code_text();
    var definition = require_definition();
    var hardBreakEscape = require_hard_break_escape();
    var headingAtx = require_heading_atx();
    var htmlFlow = require_html_flow();
    var htmlText = require_html_text();
    var labelEnd = require_label_end();
    var labelStartImage = require_label_start_image();
    var labelStartLink = require_label_start_link();
    var lineEnding = require_line_ending();
    var list2 = require_list2();
    var setextUnderline = require_setext_underline();
    var thematicBreak = require_thematic_break();
    var document3 = {
      42: list2,
      // Asterisk
      43: list2,
      // Plus sign
      45: list2,
      // Dash
      48: list2,
      // 0
      49: list2,
      // 1
      50: list2,
      // 2
      51: list2,
      // 3
      52: list2,
      // 4
      53: list2,
      // 5
      54: list2,
      // 6
      55: list2,
      // 7
      56: list2,
      // 8
      57: list2,
      // 9
      62: blockQuote
      // Greater than
    };
    var contentInitial = {
      91: definition
      // Left square bracket
    };
    var flowInitial = {
      "-2": codeIndented,
      // Horizontal tab
      "-1": codeIndented,
      // Virtual space
      32: codeIndented
      // Space
    };
    var flow = {
      35: headingAtx,
      // Number sign
      42: thematicBreak,
      // Asterisk
      45: [setextUnderline, thematicBreak],
      // Dash
      60: htmlFlow,
      // Less than
      61: setextUnderline,
      // Equals to
      95: thematicBreak,
      // Underscore
      96: codeFenced,
      // Grave accent
      126: codeFenced
      // Tilde
    };
    var string = {
      38: characterReference,
      // Ampersand
      92: characterEscape
      // Backslash
    };
    var text3 = {
      "-5": lineEnding,
      // Carriage return
      "-4": lineEnding,
      // Line feed
      "-3": lineEnding,
      // Carriage return + line feed
      33: labelStartImage,
      // Exclamation mark
      38: characterReference,
      // Ampersand
      42: attention,
      // Asterisk
      60: [autolink, htmlText],
      // Less than
      91: labelStartLink,
      // Left square bracket
      92: [hardBreakEscape, characterEscape],
      // Backslash
      93: labelEnd,
      // Right square bracket
      95: attention,
      // Underscore
      96: codeText
      // Grave accent
    };
    var insideSpan = {
      null: [attention, text$1.resolver]
    };
    var disable = {
      null: []
    };
    exports.contentInitial = contentInitial;
    exports.disable = disable;
    exports.document = document3;
    exports.flow = flow;
    exports.flowInitial = flowInitial;
    exports.insideSpan = insideSpan;
    exports.string = string;
    exports.text = text3;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/parse.js
var require_parse2 = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/parse.js"(exports, module) {
    "use strict";
    var content = require_content();
    var document3 = require_document();
    var flow = require_flow();
    var text3 = require_text2();
    var combineExtensions = require_combine_extensions();
    var createTokenizer = require_create_tokenizer();
    var miniflat = require_miniflat();
    var constructs = require_constructs();
    function parse7(options) {
      var settings = options || {};
      var parser2 = {
        defined: [],
        constructs: combineExtensions(
          [constructs].concat(miniflat(settings.extensions))
        ),
        content: create3(content),
        document: create3(document3),
        flow: create3(flow),
        string: create3(text3.string),
        text: create3(text3.text)
      };
      return parser2;
      function create3(initializer) {
        return creator;
        function creator(from2) {
          return createTokenizer(parser2, initializer, from2);
        }
      }
    }
    module.exports = parse7;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/preprocess.js
var require_preprocess = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/preprocess.js"(exports, module) {
    "use strict";
    var search = /[\0\t\n\r]/g;
    function preprocess() {
      var start2 = true;
      var column2 = 1;
      var buffer = "";
      var atCarriageReturn;
      return preprocessor;
      function preprocessor(value2, encoding, end) {
        var chunks = [];
        var match3;
        var next2;
        var startPosition;
        var endPosition;
        var code2;
        value2 = buffer + value2.toString(encoding);
        startPosition = 0;
        buffer = "";
        if (start2) {
          if (value2.charCodeAt(0) === 65279) {
            startPosition++;
          }
          start2 = void 0;
        }
        while (startPosition < value2.length) {
          search.lastIndex = startPosition;
          match3 = search.exec(value2);
          endPosition = match3 ? match3.index : value2.length;
          code2 = value2.charCodeAt(endPosition);
          if (!match3) {
            buffer = value2.slice(startPosition);
            break;
          }
          if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
            chunks.push(-3);
            atCarriageReturn = void 0;
          } else {
            if (atCarriageReturn) {
              chunks.push(-5);
              atCarriageReturn = void 0;
            }
            if (startPosition < endPosition) {
              chunks.push(value2.slice(startPosition, endPosition));
              column2 += endPosition - startPosition;
            }
            if (code2 === 0) {
              chunks.push(65533);
              column2++;
            } else if (code2 === 9) {
              next2 = Math.ceil(column2 / 4) * 4;
              chunks.push(-2);
              while (column2++ < next2)
                chunks.push(-1);
            } else if (code2 === 10) {
              chunks.push(-4);
              column2 = 1;
            } else {
              atCarriageReturn = true;
              column2 = 1;
            }
          }
          startPosition = endPosition + 1;
        }
        if (end) {
          if (atCarriageReturn)
            chunks.push(-5);
          if (buffer)
            chunks.push(buffer);
          chunks.push(null);
        }
        return chunks;
      }
    }
    module.exports = preprocess;
  }
});

// node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/postprocess.js
var require_postprocess = __commonJS({
  "node_modules/.pnpm/micromark@2.11.4/node_modules/micromark/dist/postprocess.js"(exports, module) {
    "use strict";
    var subtokenize = require_subtokenize();
    function postprocess(events2) {
      while (!subtokenize(events2)) {
      }
      return events2;
    }
    module.exports = postprocess;
  }
});

// node_modules/.pnpm/unist-util-stringify-position@2.0.3/node_modules/unist-util-stringify-position/index.js
var require_unist_util_stringify_position = __commonJS({
  "node_modules/.pnpm/unist-util-stringify-position@2.0.3/node_modules/unist-util-stringify-position/index.js"(exports, module) {
    "use strict";
    var own = {}.hasOwnProperty;
    module.exports = stringify3;
    function stringify3(value2) {
      if (!value2 || typeof value2 !== "object") {
        return "";
      }
      if (own.call(value2, "position") || own.call(value2, "type")) {
        return position2(value2.position);
      }
      if (own.call(value2, "start") || own.call(value2, "end")) {
        return position2(value2);
      }
      if (own.call(value2, "line") || own.call(value2, "column")) {
        return point(value2);
      }
      return "";
    }
    function point(point2) {
      if (!point2 || typeof point2 !== "object") {
        point2 = {};
      }
      return index2(point2.line) + ":" + index2(point2.column);
    }
    function position2(pos) {
      if (!pos || typeof pos !== "object") {
        pos = {};
      }
      return point(pos.start) + "-" + point(pos.end);
    }
    function index2(value2) {
      return value2 && typeof value2 === "number" ? value2 : 1;
    }
  }
});

// node_modules/.pnpm/mdast-util-from-markdown@0.8.5/node_modules/mdast-util-from-markdown/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/mdast-util-from-markdown@0.8.5/node_modules/mdast-util-from-markdown/dist/index.js"(exports, module) {
    "use strict";
    module.exports = fromMarkdown;
    var toString2 = require_mdast_util_to_string();
    var assign2 = require_assign();
    var own = require_has_own_property();
    var normalizeIdentifier = require_normalize_identifier();
    var safeFromInt = require_safe_from_int();
    var parser2 = require_parse2();
    var preprocessor = require_preprocess();
    var postprocess = require_postprocess();
    var decode = require_decode_entity_browser();
    var stringifyPosition = require_unist_util_stringify_position();
    function fromMarkdown(value2, encoding, options) {
      if (typeof encoding !== "string") {
        options = encoding;
        encoding = void 0;
      }
      return compiler(options)(
        postprocess(
          parser2(options).document().write(preprocessor()(value2, encoding, true))
        )
      );
    }
    function compiler(options) {
      var settings = options || {};
      var config2 = configure(
        {
          transforms: [],
          canContainEols: [
            "emphasis",
            "fragment",
            "heading",
            "paragraph",
            "strong"
          ],
          enter: {
            autolink: opener(link2),
            autolinkProtocol: onenterdata,
            autolinkEmail: onenterdata,
            atxHeading: opener(heading2),
            blockQuote: opener(blockQuote),
            characterEscape: onenterdata,
            characterReference: onenterdata,
            codeFenced: opener(codeFlow),
            codeFencedFenceInfo: buffer,
            codeFencedFenceMeta: buffer,
            codeIndented: opener(codeFlow, buffer),
            codeText: opener(codeText, buffer),
            codeTextData: onenterdata,
            data: onenterdata,
            codeFlowValue: onenterdata,
            definition: opener(definition),
            definitionDestinationString: buffer,
            definitionLabelString: buffer,
            definitionTitleString: buffer,
            emphasis: opener(emphasis),
            hardBreakEscape: opener(hardBreak),
            hardBreakTrailing: opener(hardBreak),
            htmlFlow: opener(html, buffer),
            htmlFlowData: onenterdata,
            htmlText: opener(html, buffer),
            htmlTextData: onenterdata,
            image: opener(image2),
            label: buffer,
            link: opener(link2),
            listItem: opener(listItem),
            listItemValue: onenterlistitemvalue,
            listOrdered: opener(list2, onenterlistordered),
            listUnordered: opener(list2),
            paragraph: opener(paragraph2),
            reference: onenterreference,
            referenceString: buffer,
            resourceDestinationString: buffer,
            resourceTitleString: buffer,
            setextHeading: opener(heading2),
            strong: opener(strong2),
            thematicBreak: opener(thematicBreak)
          },
          exit: {
            atxHeading: closer(),
            atxHeadingSequence: onexitatxheadingsequence,
            autolink: closer(),
            autolinkEmail: onexitautolinkemail,
            autolinkProtocol: onexitautolinkprotocol,
            blockQuote: closer(),
            characterEscapeValue: onexitdata,
            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
            characterReferenceValue: onexitcharacterreferencevalue,
            codeFenced: closer(onexitcodefenced),
            codeFencedFence: onexitcodefencedfence,
            codeFencedFenceInfo: onexitcodefencedfenceinfo,
            codeFencedFenceMeta: onexitcodefencedfencemeta,
            codeFlowValue: onexitdata,
            codeIndented: closer(onexitcodeindented),
            codeText: closer(onexitcodetext),
            codeTextData: onexitdata,
            data: onexitdata,
            definition: closer(),
            definitionDestinationString: onexitdefinitiondestinationstring,
            definitionLabelString: onexitdefinitionlabelstring,
            definitionTitleString: onexitdefinitiontitlestring,
            emphasis: closer(),
            hardBreakEscape: closer(onexithardbreak),
            hardBreakTrailing: closer(onexithardbreak),
            htmlFlow: closer(onexithtmlflow),
            htmlFlowData: onexitdata,
            htmlText: closer(onexithtmltext),
            htmlTextData: onexitdata,
            image: closer(onexitimage),
            label: onexitlabel,
            labelText: onexitlabeltext,
            lineEnding: onexitlineending,
            link: closer(onexitlink),
            listItem: closer(),
            listOrdered: closer(),
            listUnordered: closer(),
            paragraph: closer(),
            referenceString: onexitreferencestring,
            resourceDestinationString: onexitresourcedestinationstring,
            resourceTitleString: onexitresourcetitlestring,
            resource: onexitresource,
            setextHeading: closer(onexitsetextheading),
            setextHeadingLineSequence: onexitsetextheadinglinesequence,
            setextHeadingText: onexitsetextheadingtext,
            strong: closer(),
            thematicBreak: closer()
          }
        },
        settings.mdastExtensions || []
      );
      var data = {};
      return compile2;
      function compile2(events2) {
        var tree2 = { type: "root", children: [] };
        var stack = [tree2];
        var tokenStack = [];
        var listStack = [];
        var index2 = -1;
        var handler;
        var listStart;
        var context = {
          stack,
          tokenStack,
          config: config2,
          enter,
          exit,
          buffer,
          resume,
          setData,
          getData
        };
        while (++index2 < events2.length) {
          if (events2[index2][1].type === "listOrdered" || events2[index2][1].type === "listUnordered") {
            if (events2[index2][0] === "enter") {
              listStack.push(index2);
            } else {
              listStart = listStack.pop(index2);
              index2 = prepareList(events2, listStart, index2);
            }
          }
        }
        index2 = -1;
        while (++index2 < events2.length) {
          handler = config2[events2[index2][0]];
          if (own.call(handler, events2[index2][1].type)) {
            handler[events2[index2][1].type].call(
              assign2({ sliceSerialize: events2[index2][2].sliceSerialize }, context),
              events2[index2][1]
            );
          }
        }
        if (tokenStack.length) {
          throw new Error(
            "Cannot close document, a token (`" + tokenStack[tokenStack.length - 1].type + "`, " + stringifyPosition({
              start: tokenStack[tokenStack.length - 1].start,
              end: tokenStack[tokenStack.length - 1].end
            }) + ") is still open"
          );
        }
        tree2.position = {
          start: point(
            events2.length ? events2[0][1].start : { line: 1, column: 1, offset: 0 }
          ),
          end: point(
            events2.length ? events2[events2.length - 2][1].end : { line: 1, column: 1, offset: 0 }
          )
        };
        index2 = -1;
        while (++index2 < config2.transforms.length) {
          tree2 = config2.transforms[index2](tree2) || tree2;
        }
        return tree2;
      }
      function prepareList(events2, start2, length2) {
        var index2 = start2 - 1;
        var containerBalance = -1;
        var listSpread = false;
        var listItem2;
        var tailIndex;
        var lineIndex;
        var tailEvent;
        var event;
        var firstBlankLineIndex;
        var atMarker;
        while (++index2 <= length2) {
          event = events2[index2];
          if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
          } else if (event[1].type === "lineEndingBlank") {
            if (event[0] === "enter") {
              if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index2;
              }
              atMarker = void 0;
            }
          } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
          } else {
            atMarker = void 0;
          }
          if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
            if (listItem2) {
              tailIndex = index2;
              lineIndex = void 0;
              while (tailIndex--) {
                tailEvent = events2[tailIndex];
                if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                  if (tailEvent[0] === "exit")
                    continue;
                  if (lineIndex) {
                    events2[lineIndex][1].type = "lineEndingBlank";
                    listSpread = true;
                  }
                  tailEvent[1].type = "lineEnding";
                  lineIndex = tailIndex;
                } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
                } else {
                  break;
                }
              }
              if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
                listItem2._spread = true;
              }
              listItem2.end = point(
                lineIndex ? events2[lineIndex][1].start : event[1].end
              );
              events2.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);
              index2++;
              length2++;
            }
            if (event[1].type === "listItemPrefix") {
              listItem2 = {
                type: "listItem",
                _spread: false,
                start: point(event[1].start)
              };
              events2.splice(index2, 0, ["enter", listItem2, event[2]]);
              index2++;
              length2++;
              firstBlankLineIndex = void 0;
              atMarker = true;
            }
          }
        }
        events2[start2][1]._spread = listSpread;
        return length2;
      }
      function setData(key, value2) {
        data[key] = value2;
      }
      function getData(key) {
        return data[key];
      }
      function point(d5) {
        return { line: d5.line, column: d5.column, offset: d5.offset };
      }
      function opener(create3, and2) {
        return open;
        function open(token2) {
          enter.call(this, create3(token2), token2);
          if (and2)
            and2.call(this, token2);
        }
      }
      function buffer() {
        this.stack.push({ type: "fragment", children: [] });
      }
      function enter(node3, token2) {
        this.stack[this.stack.length - 1].children.push(node3);
        this.stack.push(node3);
        this.tokenStack.push(token2);
        node3.position = { start: point(token2.start) };
        return node3;
      }
      function closer(and2) {
        return close;
        function close(token2) {
          if (and2)
            and2.call(this, token2);
          exit.call(this, token2);
        }
      }
      function exit(token2) {
        var node3 = this.stack.pop();
        var open = this.tokenStack.pop();
        if (!open) {
          throw new Error(
            "Cannot close `" + token2.type + "` (" + stringifyPosition({ start: token2.start, end: token2.end }) + "): it’s not open"
          );
        } else if (open.type !== token2.type) {
          throw new Error(
            "Cannot close `" + token2.type + "` (" + stringifyPosition({ start: token2.start, end: token2.end }) + "): a different token (`" + open.type + "`, " + stringifyPosition({ start: open.start, end: open.end }) + ") is open"
          );
        }
        node3.position.end = point(token2.end);
        return node3;
      }
      function resume() {
        return toString2(this.stack.pop());
      }
      function onenterlistordered() {
        setData("expectingFirstListItemValue", true);
      }
      function onenterlistitemvalue(token2) {
        if (getData("expectingFirstListItemValue")) {
          this.stack[this.stack.length - 2].start = parseInt(
            this.sliceSerialize(token2),
            10
          );
          setData("expectingFirstListItemValue");
        }
      }
      function onexitcodefencedfenceinfo() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].lang = data2;
      }
      function onexitcodefencedfencemeta() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].meta = data2;
      }
      function onexitcodefencedfence() {
        if (getData("flowCodeInside"))
          return;
        this.buffer();
        setData("flowCodeInside", true);
      }
      function onexitcodefenced() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2.replace(
          /^(\r?\n|\r)|(\r?\n|\r)$/g,
          ""
        );
        setData("flowCodeInside");
      }
      function onexitcodeindented() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitdefinitionlabelstring(token2) {
        var label = this.resume();
        this.stack[this.stack.length - 1].label = label;
        this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
      }
      function onexitdefinitiontitlestring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].title = data2;
      }
      function onexitdefinitiondestinationstring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].url = data2;
      }
      function onexitatxheadingsequence(token2) {
        if (!this.stack[this.stack.length - 1].depth) {
          this.stack[this.stack.length - 1].depth = this.sliceSerialize(
            token2
          ).length;
        }
      }
      function onexitsetextheadingtext() {
        setData("setextHeadingSlurpLineEnding", true);
      }
      function onexitsetextheadinglinesequence(token2) {
        this.stack[this.stack.length - 1].depth = this.sliceSerialize(token2).charCodeAt(0) === 61 ? 1 : 2;
      }
      function onexitsetextheading() {
        setData("setextHeadingSlurpLineEnding");
      }
      function onenterdata(token2) {
        var siblings = this.stack[this.stack.length - 1].children;
        var tail = siblings[siblings.length - 1];
        if (!tail || tail.type !== "text") {
          tail = text3();
          tail.position = { start: point(token2.start) };
          this.stack[this.stack.length - 1].children.push(tail);
        }
        this.stack.push(tail);
      }
      function onexitdata(token2) {
        var tail = this.stack.pop();
        tail.value += this.sliceSerialize(token2);
        tail.position.end = point(token2.end);
      }
      function onexitlineending(token2) {
        var context = this.stack[this.stack.length - 1];
        if (getData("atHardBreak")) {
          context.children[context.children.length - 1].position.end = point(
            token2.end
          );
          setData("atHardBreak");
          return;
        }
        if (!getData("setextHeadingSlurpLineEnding") && config2.canContainEols.indexOf(context.type) > -1) {
          onenterdata.call(this, token2);
          onexitdata.call(this, token2);
        }
      }
      function onexithardbreak() {
        setData("atHardBreak", true);
      }
      function onexithtmlflow() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexithtmltext() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitcodetext() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitlink() {
        var context = this.stack[this.stack.length - 1];
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
          delete context.referenceType;
        }
        setData("referenceType");
      }
      function onexitimage() {
        var context = this.stack[this.stack.length - 1];
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
          delete context.referenceType;
        }
        setData("referenceType");
      }
      function onexitlabeltext(token2) {
        this.stack[this.stack.length - 2].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
      }
      function onexitlabel() {
        var fragment = this.stack[this.stack.length - 1];
        var value2 = this.resume();
        this.stack[this.stack.length - 1].label = value2;
        setData("inReference", true);
        if (this.stack[this.stack.length - 1].type === "link") {
          this.stack[this.stack.length - 1].children = fragment.children;
        } else {
          this.stack[this.stack.length - 1].alt = value2;
        }
      }
      function onexitresourcedestinationstring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].url = data2;
      }
      function onexitresourcetitlestring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].title = data2;
      }
      function onexitresource() {
        setData("inReference");
      }
      function onenterreference() {
        setData("referenceType", "collapsed");
      }
      function onexitreferencestring(token2) {
        var label = this.resume();
        this.stack[this.stack.length - 1].label = label;
        this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
        setData("referenceType", "full");
      }
      function onexitcharacterreferencemarker(token2) {
        setData("characterReferenceType", token2.type);
      }
      function onexitcharacterreferencevalue(token2) {
        var data2 = this.sliceSerialize(token2);
        var type2 = getData("characterReferenceType");
        var value2;
        var tail;
        if (type2) {
          value2 = safeFromInt(
            data2,
            type2 === "characterReferenceMarkerNumeric" ? 10 : 16
          );
          setData("characterReferenceType");
        } else {
          value2 = decode(data2);
        }
        tail = this.stack.pop();
        tail.value += value2;
        tail.position.end = point(token2.end);
      }
      function onexitautolinkprotocol(token2) {
        onexitdata.call(this, token2);
        this.stack[this.stack.length - 1].url = this.sliceSerialize(token2);
      }
      function onexitautolinkemail(token2) {
        onexitdata.call(this, token2);
        this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(token2);
      }
      function blockQuote() {
        return { type: "blockquote", children: [] };
      }
      function codeFlow() {
        return { type: "code", lang: null, meta: null, value: "" };
      }
      function codeText() {
        return { type: "inlineCode", value: "" };
      }
      function definition() {
        return {
          type: "definition",
          identifier: "",
          label: null,
          title: null,
          url: ""
        };
      }
      function emphasis() {
        return { type: "emphasis", children: [] };
      }
      function heading2() {
        return { type: "heading", depth: void 0, children: [] };
      }
      function hardBreak() {
        return { type: "break" };
      }
      function html() {
        return { type: "html", value: "" };
      }
      function image2() {
        return { type: "image", title: null, url: "", alt: null };
      }
      function link2() {
        return { type: "link", title: null, url: "", children: [] };
      }
      function list2(token2) {
        return {
          type: "list",
          ordered: token2.type === "listOrdered",
          start: null,
          spread: token2._spread,
          children: []
        };
      }
      function listItem(token2) {
        return {
          type: "listItem",
          spread: token2._spread,
          checked: null,
          children: []
        };
      }
      function paragraph2() {
        return { type: "paragraph", children: [] };
      }
      function strong2() {
        return { type: "strong", children: [] };
      }
      function text3() {
        return { type: "text", value: "" };
      }
      function thematicBreak() {
        return { type: "thematicBreak" };
      }
    }
    function configure(config2, extensions) {
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension(config2, extensions[index2]);
      }
      return config2;
    }
    function extension(config2, extension2) {
      var key;
      var left;
      for (key in extension2) {
        left = own.call(config2, key) ? config2[key] : config2[key] = {};
        if (key === "canContainEols" || key === "transforms") {
          config2[key] = [].concat(left, extension2[key]);
        } else {
          Object.assign(left, extension2[key]);
        }
      }
    }
  }
});

// node_modules/.pnpm/mdast-util-from-markdown@0.8.5/node_modules/mdast-util-from-markdown/index.js
var require_mdast_util_from_markdown = __commonJS({
  "node_modules/.pnpm/mdast-util-from-markdown@0.8.5/node_modules/mdast-util-from-markdown/index.js"(exports, module) {
    "use strict";
    module.exports = require_dist2();
  }
});

// node_modules/.pnpm/ccount@1.1.0/node_modules/ccount/index.js
var require_ccount = __commonJS({
  "node_modules/.pnpm/ccount@1.1.0/node_modules/ccount/index.js"(exports, module) {
    "use strict";
    module.exports = ccount;
    function ccount(source, character2) {
      var value2 = String(source);
      var count = 0;
      var index2;
      if (typeof character2 !== "string") {
        throw new Error("Expected character");
      }
      index2 = value2.indexOf(character2);
      while (index2 !== -1) {
        count++;
        index2 = value2.indexOf(character2, index2 + character2.length);
      }
      return count;
    }
  }
});

// node_modules/.pnpm/unist-util-is@4.1.0/node_modules/unist-util-is/convert.js
var require_convert = __commonJS({
  "node_modules/.pnpm/unist-util-is@4.1.0/node_modules/unist-util-is/convert.js"(exports, module) {
    "use strict";
    module.exports = convert;
    function convert(test) {
      if (test == null) {
        return ok;
      }
      if (typeof test === "string") {
        return typeFactory(test);
      }
      if (typeof test === "object") {
        return "length" in test ? anyFactory(test) : allFactory(test);
      }
      if (typeof test === "function") {
        return test;
      }
      throw new Error("Expected function, string, or object as test");
    }
    function allFactory(test) {
      return all;
      function all(node3) {
        var key;
        for (key in test) {
          if (node3[key] !== test[key])
            return false;
        }
        return true;
      }
    }
    function anyFactory(tests) {
      var checks = [];
      var index2 = -1;
      while (++index2 < tests.length) {
        checks[index2] = convert(tests[index2]);
      }
      return any;
      function any() {
        var index3 = -1;
        while (++index3 < checks.length) {
          if (checks[index3].apply(this, arguments)) {
            return true;
          }
        }
        return false;
      }
    }
    function typeFactory(test) {
      return type2;
      function type2(node3) {
        return Boolean(node3 && node3.type === test);
      }
    }
    function ok() {
      return true;
    }
  }
});

// node_modules/.pnpm/unist-util-visit-parents@3.1.1/node_modules/unist-util-visit-parents/color.browser.js
var require_color_browser = __commonJS({
  "node_modules/.pnpm/unist-util-visit-parents@3.1.1/node_modules/unist-util-visit-parents/color.browser.js"(exports, module) {
    module.exports = identity3;
    function identity3(d5) {
      return d5;
    }
  }
});

// node_modules/.pnpm/unist-util-visit-parents@3.1.1/node_modules/unist-util-visit-parents/index.js
var require_unist_util_visit_parents = __commonJS({
  "node_modules/.pnpm/unist-util-visit-parents@3.1.1/node_modules/unist-util-visit-parents/index.js"(exports, module) {
    "use strict";
    module.exports = visitParents;
    var convert = require_convert();
    var color = require_color_browser();
    var CONTINUE = true;
    var SKIP = "skip";
    var EXIT = false;
    visitParents.CONTINUE = CONTINUE;
    visitParents.SKIP = SKIP;
    visitParents.EXIT = EXIT;
    function visitParents(tree2, test, visitor, reverse) {
      var step;
      var is;
      if (typeof test === "function" && typeof visitor !== "function") {
        reverse = visitor;
        visitor = test;
        test = null;
      }
      is = convert(test);
      step = reverse ? -1 : 1;
      factory(tree2, null, [])();
      function factory(node3, index2, parents) {
        var value2 = typeof node3 === "object" && node3 !== null ? node3 : {};
        var name2;
        if (typeof value2.type === "string") {
          name2 = typeof value2.tagName === "string" ? value2.tagName : typeof value2.name === "string" ? value2.name : void 0;
          visit2.displayName = "node (" + color(value2.type + (name2 ? "<" + name2 + ">" : "")) + ")";
        }
        return visit2;
        function visit2() {
          var grandparents = parents.concat(node3);
          var result = [];
          var subresult;
          var offset;
          if (!test || is(node3, index2, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node3, parents));
            if (result[0] === EXIT) {
              return result;
            }
          }
          if (node3.children && result[0] !== SKIP) {
            offset = (reverse ? node3.children.length : -1) + step;
            while (offset > -1 && offset < node3.children.length) {
              subresult = factory(node3.children[offset], offset, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
          return result;
        }
      }
    }
    function toResult(value2) {
      if (value2 !== null && typeof value2 === "object" && "length" in value2) {
        return value2;
      }
      if (typeof value2 === "number") {
        return [CONTINUE, value2];
      }
      return [value2];
    }
  }
});

// node_modules/.pnpm/mdast-util-find-and-replace@1.1.1/node_modules/mdast-util-find-and-replace/index.js
var require_mdast_util_find_and_replace = __commonJS({
  "node_modules/.pnpm/mdast-util-find-and-replace@1.1.1/node_modules/mdast-util-find-and-replace/index.js"(exports, module) {
    "use strict";
    module.exports = findAndReplace;
    var visit2 = require_unist_util_visit_parents();
    var convert = require_convert();
    var escape2 = require_escape_string_regexp();
    var splice = [].splice;
    function findAndReplace(tree2, find, replace2, options) {
      var settings;
      var schema;
      if (typeof find === "string" || find && typeof find.exec === "function") {
        schema = [[find, replace2]];
      } else {
        schema = find;
        options = replace2;
      }
      settings = options || {};
      search(tree2, settings, handlerFactory(toPairs(schema)));
      return tree2;
      function handlerFactory(pairs) {
        var pair = pairs[0];
        return handler;
        function handler(node3, parent) {
          var find2 = pair[0];
          var replace3 = pair[1];
          var nodes = [];
          var start2 = 0;
          var index2 = parent.children.indexOf(node3);
          var position2;
          var match3;
          var subhandler;
          var value2;
          find2.lastIndex = 0;
          match3 = find2.exec(node3.value);
          while (match3) {
            position2 = match3.index;
            value2 = replace3.apply(
              null,
              [].concat(match3, { index: match3.index, input: match3.input })
            );
            if (value2 !== false) {
              if (start2 !== position2) {
                nodes.push({ type: "text", value: node3.value.slice(start2, position2) });
              }
              if (typeof value2 === "string" && value2.length > 0) {
                value2 = { type: "text", value: value2 };
              }
              if (value2) {
                nodes = [].concat(nodes, value2);
              }
              start2 = position2 + match3[0].length;
            }
            if (!find2.global) {
              break;
            }
            match3 = find2.exec(node3.value);
          }
          if (position2 === void 0) {
            nodes = [node3];
            index2--;
          } else {
            if (start2 < node3.value.length) {
              nodes.push({ type: "text", value: node3.value.slice(start2) });
            }
            nodes.unshift(index2, 1);
            splice.apply(parent.children, nodes);
          }
          if (pairs.length > 1) {
            subhandler = handlerFactory(pairs.slice(1));
            position2 = -1;
            while (++position2 < nodes.length) {
              node3 = nodes[position2];
              if (node3.type === "text") {
                subhandler(node3, parent);
              } else {
                search(node3, settings, subhandler);
              }
            }
          }
          return index2 + nodes.length + 1;
        }
      }
    }
    function search(tree2, settings, handler) {
      var ignored2 = convert(settings.ignore || []);
      var result = [];
      visit2(tree2, "text", visitor);
      return result;
      function visitor(node3, parents) {
        var index2 = -1;
        var parent;
        var grandparent;
        while (++index2 < parents.length) {
          parent = parents[index2];
          if (ignored2(
            parent,
            grandparent ? grandparent.children.indexOf(parent) : void 0,
            grandparent
          )) {
            return;
          }
          grandparent = parent;
        }
        return handler(node3, grandparent);
      }
    }
    function toPairs(schema) {
      var result = [];
      var key;
      var index2;
      if (typeof schema !== "object") {
        throw new Error("Expected array or object as schema");
      }
      if ("length" in schema) {
        index2 = -1;
        while (++index2 < schema.length) {
          result.push([
            toExpression(schema[index2][0]),
            toFunction(schema[index2][1])
          ]);
        }
      } else {
        for (key in schema) {
          result.push([toExpression(key), toFunction(schema[key])]);
        }
      }
      return result;
    }
    function toExpression(find) {
      return typeof find === "string" ? new RegExp(escape2(find), "g") : find;
    }
    function toFunction(replace2) {
      return typeof replace2 === "function" ? replace2 : returner;
      function returner() {
        return replace2;
      }
    }
  }
});

// node_modules/.pnpm/mdast-util-gfm-autolink-literal@0.1.3/node_modules/mdast-util-gfm-autolink-literal/from-markdown.js
var require_from_markdown = __commonJS({
  "node_modules/.pnpm/mdast-util-gfm-autolink-literal@0.1.3/node_modules/mdast-util-gfm-autolink-literal/from-markdown.js"(exports) {
    var ccount = require_ccount();
    var findAndReplace = require_mdast_util_find_and_replace();
    var unicodePunctuation = require_unicode_punctuation();
    var unicodeWhitespace = require_unicode_whitespace();
    exports.transforms = [transformGfmAutolinkLiterals];
    exports.enter = {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    };
    exports.exit = {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    };
    function enterLiteralAutolink(token2) {
      this.enter({ type: "link", title: null, url: "", children: [] }, token2);
    }
    function enterLiteralAutolinkValue(token2) {
      this.config.enter.autolinkProtocol.call(this, token2);
    }
    function exitLiteralAutolinkHttp(token2) {
      this.config.exit.autolinkProtocol.call(this, token2);
    }
    function exitLiteralAutolinkWww(token2) {
      this.config.exit.data.call(this, token2);
      this.stack[this.stack.length - 1].url = "http://" + this.sliceSerialize(token2);
    }
    function exitLiteralAutolinkEmail(token2) {
      this.config.exit.autolinkEmail.call(this, token2);
    }
    function exitLiteralAutolink(token2) {
      this.exit(token2);
    }
    function transformGfmAutolinkLiterals(tree2) {
      findAndReplace(
        tree2,
        [
          [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/i, findUrl],
          [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/, findEmail]
        ],
        { ignore: ["link", "linkReference"] }
      );
    }
    function findUrl($0, protocol, domain, path2, match3) {
      var prefix3 = "";
      var parts;
      var result;
      if (!previous(match3)) {
        return false;
      }
      if (/^w/i.test(protocol)) {
        domain = protocol + domain;
        protocol = "";
        prefix3 = "http://";
      }
      if (!isCorrectDomain(domain)) {
        return false;
      }
      parts = splitUrl(domain + path2);
      if (!parts[0])
        return false;
      result = {
        type: "link",
        title: null,
        url: prefix3 + protocol + parts[0],
        children: [{ type: "text", value: protocol + parts[0] }]
      };
      if (parts[1]) {
        result = [result, { type: "text", value: parts[1] }];
      }
      return result;
    }
    function findEmail($0, atext, label, match3) {
      if (!previous(match3, true) || /[_-]$/.test(label)) {
        return false;
      }
      return {
        type: "link",
        title: null,
        url: "mailto:" + atext + "@" + label,
        children: [{ type: "text", value: atext + "@" + label }]
      };
    }
    function isCorrectDomain(domain) {
      var parts = domain.split(".");
      if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
        return false;
      }
      return true;
    }
    function splitUrl(url) {
      var trail = /[!"&'),.:;<>?\]}]+$/.exec(url);
      var closingParenIndex;
      var openingParens;
      var closingParens;
      if (trail) {
        url = url.slice(0, trail.index);
        trail = trail[0];
        closingParenIndex = trail.indexOf(")");
        openingParens = ccount(url, "(");
        closingParens = ccount(url, ")");
        while (closingParenIndex !== -1 && openingParens > closingParens) {
          url += trail.slice(0, closingParenIndex + 1);
          trail = trail.slice(closingParenIndex + 1);
          closingParenIndex = trail.indexOf(")");
          closingParens++;
        }
      }
      return [url, trail];
    }
    function previous(match3, email) {
      var code2 = match3.input.charCodeAt(match3.index - 1);
      return (code2 !== code2 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email || code2 !== 47);
    }
  }
});

// node_modules/.pnpm/micromark-extension-gfm-autolink-literal@0.5.7/node_modules/micromark-extension-gfm-autolink-literal/syntax.js
var require_syntax = __commonJS({
  "node_modules/.pnpm/micromark-extension-gfm-autolink-literal@0.5.7/node_modules/micromark-extension-gfm-autolink-literal/syntax.js"(exports) {
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var asciiControl = require_ascii_control();
    var markdownLineEnding = require_markdown_line_ending();
    var unicodePunctuation = require_unicode_punctuation();
    var unicodeWhitespace = require_unicode_whitespace();
    var www = { tokenize: tokenizeWww, partial: true };
    var domain = { tokenize: tokenizeDomain, partial: true };
    var path2 = { tokenize: tokenizePath, partial: true };
    var punctuation = { tokenize: tokenizePunctuation, partial: true };
    var namedCharacterReference = {
      tokenize: tokenizeNamedCharacterReference,
      partial: true
    };
    var wwwAutolink = { tokenize: tokenizeWwwAutolink, previous: previousWww };
    var httpAutolink = { tokenize: tokenizeHttpAutolink, previous: previousHttp };
    var emailAutolink = { tokenize: tokenizeEmailAutolink, previous: previousEmail };
    var text3 = {};
    exports.text = text3;
    var code2 = 48;
    while (code2 < 123) {
      text3[code2] = emailAutolink;
      code2++;
      if (code2 === 58)
        code2 = 65;
      else if (code2 === 91)
        code2 = 97;
    }
    text3[43] = emailAutolink;
    text3[45] = emailAutolink;
    text3[46] = emailAutolink;
    text3[95] = emailAutolink;
    text3[72] = [emailAutolink, httpAutolink];
    text3[104] = [emailAutolink, httpAutolink];
    text3[87] = [emailAutolink, wwwAutolink];
    text3[119] = [emailAutolink, wwwAutolink];
    function tokenizeEmailAutolink(effects, ok, nok) {
      var self2 = this;
      var hasDot;
      return start2;
      function start2(code3) {
        if (!gfmAtext(code3) || !previousEmail(self2.previous) || previous(self2.events)) {
          return nok(code3);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkEmail");
        return atext(code3);
      }
      function atext(code3) {
        if (gfmAtext(code3)) {
          effects.consume(code3);
          return atext;
        }
        if (code3 === 64) {
          effects.consume(code3);
          return label;
        }
        return nok(code3);
      }
      function label(code3) {
        if (code3 === 46) {
          return effects.check(punctuation, done, dotContinuation)(code3);
        }
        if (
          // `-`
          code3 === 45 || // `_`
          code3 === 95
        ) {
          return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code3);
        }
        if (asciiAlphanumeric(code3)) {
          effects.consume(code3);
          return label;
        }
        return done(code3);
      }
      function dotContinuation(code3) {
        effects.consume(code3);
        hasDot = true;
        return label;
      }
      function dashOrUnderscoreContinuation(code3) {
        effects.consume(code3);
        return afterDashOrUnderscore;
      }
      function afterDashOrUnderscore(code3) {
        if (code3 === 46) {
          return effects.check(punctuation, nok, dotContinuation)(code3);
        }
        return label(code3);
      }
      function done(code3) {
        if (hasDot) {
          effects.exit("literalAutolinkEmail");
          effects.exit("literalAutolink");
          return ok(code3);
        }
        return nok(code3);
      }
    }
    function tokenizeWwwAutolink(effects, ok, nok) {
      var self2 = this;
      return start2;
      function start2(code3) {
        if (code3 !== 87 && code3 - 32 !== 87 || !previousWww(self2.previous) || previous(self2.events)) {
          return nok(code3);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkWww");
        return effects.check(
          www,
          effects.attempt(domain, effects.attempt(path2, done), nok),
          nok
        )(code3);
      }
      function done(code3) {
        effects.exit("literalAutolinkWww");
        effects.exit("literalAutolink");
        return ok(code3);
      }
    }
    function tokenizeHttpAutolink(effects, ok, nok) {
      var self2 = this;
      return start2;
      function start2(code3) {
        if (code3 !== 72 && code3 - 32 !== 72 || !previousHttp(self2.previous) || previous(self2.events)) {
          return nok(code3);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkHttp");
        effects.consume(code3);
        return t1;
      }
      function t1(code3) {
        if (code3 === 84 || code3 - 32 === 84) {
          effects.consume(code3);
          return t22;
        }
        return nok(code3);
      }
      function t22(code3) {
        if (code3 === 84 || code3 - 32 === 84) {
          effects.consume(code3);
          return p5;
        }
        return nok(code3);
      }
      function p5(code3) {
        if (code3 === 80 || code3 - 32 === 80) {
          effects.consume(code3);
          return s4;
        }
        return nok(code3);
      }
      function s4(code3) {
        if (code3 === 83 || code3 - 32 === 83) {
          effects.consume(code3);
          return colon;
        }
        return colon(code3);
      }
      function colon(code3) {
        if (code3 === 58) {
          effects.consume(code3);
          return slash1;
        }
        return nok(code3);
      }
      function slash1(code3) {
        if (code3 === 47) {
          effects.consume(code3);
          return slash2;
        }
        return nok(code3);
      }
      function slash2(code3) {
        if (code3 === 47) {
          effects.consume(code3);
          return after;
        }
        return nok(code3);
      }
      function after(code3) {
        return asciiControl(code3) || unicodeWhitespace(code3) || unicodePunctuation(code3) ? nok(code3) : effects.attempt(domain, effects.attempt(path2, done), nok)(code3);
      }
      function done(code3) {
        effects.exit("literalAutolinkHttp");
        effects.exit("literalAutolink");
        return ok(code3);
      }
    }
    function tokenizeWww(effects, ok, nok) {
      return start2;
      function start2(code3) {
        effects.consume(code3);
        return w2;
      }
      function w2(code3) {
        if (code3 === 87 || code3 - 32 === 87) {
          effects.consume(code3);
          return w3;
        }
        return nok(code3);
      }
      function w3(code3) {
        if (code3 === 87 || code3 - 32 === 87) {
          effects.consume(code3);
          return dot;
        }
        return nok(code3);
      }
      function dot(code3) {
        if (code3 === 46) {
          effects.consume(code3);
          return after;
        }
        return nok(code3);
      }
      function after(code3) {
        return code3 === null || markdownLineEnding(code3) ? nok(code3) : ok(code3);
      }
    }
    function tokenizeDomain(effects, ok, nok) {
      var hasUnderscoreInLastSegment;
      var hasUnderscoreInLastLastSegment;
      return domain2;
      function domain2(code3) {
        if (code3 === 38) {
          return effects.check(
            namedCharacterReference,
            done,
            punctuationContinuation
          )(code3);
        }
        if (code3 === 46 || code3 === 95) {
          return effects.check(punctuation, done, punctuationContinuation)(code3);
        }
        if (asciiControl(code3) || unicodeWhitespace(code3) || code3 !== 45 && unicodePunctuation(code3)) {
          return done(code3);
        }
        effects.consume(code3);
        return domain2;
      }
      function punctuationContinuation(code3) {
        if (code3 === 46) {
          hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
          hasUnderscoreInLastSegment = void 0;
          effects.consume(code3);
          return domain2;
        }
        if (code3 === 95)
          hasUnderscoreInLastSegment = true;
        effects.consume(code3);
        return domain2;
      }
      function done(code3) {
        if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
          return ok(code3);
        }
        return nok(code3);
      }
    }
    function tokenizePath(effects, ok) {
      var balance = 0;
      return inPath;
      function inPath(code3) {
        if (code3 === 38) {
          return effects.check(
            namedCharacterReference,
            ok,
            continuedPunctuation
          )(code3);
        }
        if (code3 === 40) {
          balance++;
        }
        if (code3 === 41) {
          return effects.check(
            punctuation,
            parenAtPathEnd,
            continuedPunctuation
          )(code3);
        }
        if (pathEnd(code3)) {
          return ok(code3);
        }
        if (trailingPunctuation(code3)) {
          return effects.check(punctuation, ok, continuedPunctuation)(code3);
        }
        effects.consume(code3);
        return inPath;
      }
      function continuedPunctuation(code3) {
        effects.consume(code3);
        return inPath;
      }
      function parenAtPathEnd(code3) {
        balance--;
        return balance < 0 ? ok(code3) : continuedPunctuation(code3);
      }
    }
    function tokenizeNamedCharacterReference(effects, ok, nok) {
      return start2;
      function start2(code3) {
        effects.consume(code3);
        return inside;
      }
      function inside(code3) {
        if (asciiAlpha(code3)) {
          effects.consume(code3);
          return inside;
        }
        if (code3 === 59) {
          effects.consume(code3);
          return after;
        }
        return nok(code3);
      }
      function after(code3) {
        return pathEnd(code3) ? ok(code3) : nok(code3);
      }
    }
    function tokenizePunctuation(effects, ok, nok) {
      return start2;
      function start2(code3) {
        effects.consume(code3);
        return after;
      }
      function after(code3) {
        if (trailingPunctuation(code3)) {
          effects.consume(code3);
          return after;
        }
        return pathEnd(code3) ? ok(code3) : nok(code3);
      }
    }
    function trailingPunctuation(code3) {
      return (
        // `!`
        code3 === 33 || // `"`
        code3 === 34 || // `'`
        code3 === 39 || // `)`
        code3 === 41 || // `*`
        code3 === 42 || // `,`
        code3 === 44 || // `.`
        code3 === 46 || // `:`
        code3 === 58 || // `;`
        code3 === 59 || // `<`
        code3 === 60 || // `?`
        code3 === 63 || // `_`.
        code3 === 95 || // `~`
        code3 === 126
      );
    }
    function pathEnd(code3) {
      return (
        // EOF.
        code3 === null || // CR, LF, CRLF, HT, VS.
        code3 < 0 || // Space.
        code3 === 32 || // `<`
        code3 === 60
      );
    }
    function gfmAtext(code3) {
      return code3 === 43 || code3 === 45 || code3 === 46 || code3 === 95 || asciiAlphanumeric(code3);
    }
    function previousWww(code3) {
      return code3 === null || code3 < 0 || code3 === 32 || code3 === 40 || code3 === 42 || code3 === 95 || code3 === 126;
    }
    function previousHttp(code3) {
      return code3 === null || !asciiAlpha(code3);
    }
    function previousEmail(code3) {
      return code3 !== 47 && previousHttp(code3);
    }
    function previous(events2) {
      var index2 = events2.length;
      while (index2--) {
        if ((events2[index2][1].type === "labelLink" || events2[index2][1].type === "labelImage") && !events2[index2][1]._balanced) {
          return true;
        }
      }
    }
  }
});

// node_modules/.pnpm/micromark-extension-gfm-autolink-literal@0.5.7/node_modules/micromark-extension-gfm-autolink-literal/index.js
var require_micromark_extension_gfm_autolink_literal = __commonJS({
  "node_modules/.pnpm/micromark-extension-gfm-autolink-literal@0.5.7/node_modules/micromark-extension-gfm-autolink-literal/index.js"(exports, module) {
    module.exports = require_syntax();
  }
});

// node_modules/.pnpm/mdast-util-gfm-strikethrough@0.2.3/node_modules/mdast-util-gfm-strikethrough/from-markdown.js
var require_from_markdown2 = __commonJS({
  "node_modules/.pnpm/mdast-util-gfm-strikethrough@0.2.3/node_modules/mdast-util-gfm-strikethrough/from-markdown.js"(exports) {
    exports.canContainEols = ["delete"];
    exports.enter = { strikethrough: enterStrikethrough };
    exports.exit = { strikethrough: exitStrikethrough };
    function enterStrikethrough(token2) {
      this.enter({ type: "delete", children: [] }, token2);
    }
    function exitStrikethrough(token2) {
      this.exit(token2);
    }
  }
});

// node_modules/.pnpm/micromark-extension-gfm-strikethrough@0.6.5/node_modules/micromark-extension-gfm-strikethrough/index.js
var require_micromark_extension_gfm_strikethrough = __commonJS({
  "node_modules/.pnpm/micromark-extension-gfm-strikethrough@0.6.5/node_modules/micromark-extension-gfm-strikethrough/index.js"(exports, module) {
    module.exports = create3;
    var classifyCharacter = require_classify_character();
    var chunkedSplice = require_chunked_splice();
    var resolveAll = require_resolve_all();
    var shallow = require_shallow();
    function create3(options) {
      var settings = options || {};
      var single = settings.singleTilde;
      var tokenizer2 = {
        tokenize: tokenizeStrikethrough,
        resolveAll: resolveAllStrikethrough
      };
      if (single === null || single === void 0) {
        single = true;
      }
      return { text: { 126: tokenizer2 }, insideSpan: { null: tokenizer2 } };
      function resolveAllStrikethrough(events2, context) {
        var index2 = -1;
        var strikethrough;
        var text3;
        var open;
        var nextEvents;
        while (++index2 < events2.length) {
          if (events2[index2][0] === "enter" && events2[index2][1].type === "strikethroughSequenceTemporary" && events2[index2][1]._close) {
            open = index2;
            while (open--) {
              if (events2[open][0] === "exit" && events2[open][1].type === "strikethroughSequenceTemporary" && events2[open][1]._open && // If the sizes are the same:
              events2[index2][1].end.offset - events2[index2][1].start.offset === events2[open][1].end.offset - events2[open][1].start.offset) {
                events2[index2][1].type = "strikethroughSequence";
                events2[open][1].type = "strikethroughSequence";
                strikethrough = {
                  type: "strikethrough",
                  start: shallow(events2[open][1].start),
                  end: shallow(events2[index2][1].end)
                };
                text3 = {
                  type: "strikethroughText",
                  start: shallow(events2[open][1].end),
                  end: shallow(events2[index2][1].start)
                };
                nextEvents = [
                  ["enter", strikethrough, context],
                  ["enter", events2[open][1], context],
                  ["exit", events2[open][1], context],
                  ["enter", text3, context]
                ];
                chunkedSplice(
                  nextEvents,
                  nextEvents.length,
                  0,
                  resolveAll(
                    context.parser.constructs.insideSpan.null,
                    events2.slice(open + 1, index2),
                    context
                  )
                );
                chunkedSplice(nextEvents, nextEvents.length, 0, [
                  ["exit", text3, context],
                  ["enter", events2[index2][1], context],
                  ["exit", events2[index2][1], context],
                  ["exit", strikethrough, context]
                ]);
                chunkedSplice(events2, open - 1, index2 - open + 3, nextEvents);
                index2 = open + nextEvents.length - 2;
                break;
              }
            }
          }
        }
        return removeRemainingSequences(events2);
      }
      function removeRemainingSequences(events2) {
        var index2 = -1;
        var length2 = events2.length;
        while (++index2 < length2) {
          if (events2[index2][1].type === "strikethroughSequenceTemporary") {
            events2[index2][1].type = "data";
          }
        }
        return events2;
      }
      function tokenizeStrikethrough(effects, ok, nok) {
        var previous = this.previous;
        var events2 = this.events;
        var size3 = 0;
        return start2;
        function start2(code2) {
          if (code2 !== 126 || previous === 126 && events2[events2.length - 1][1].type !== "characterEscape") {
            return nok(code2);
          }
          effects.enter("strikethroughSequenceTemporary");
          return more(code2);
        }
        function more(code2) {
          var before = classifyCharacter(previous);
          var token2;
          var after;
          if (code2 === 126) {
            if (size3 > 1)
              return nok(code2);
            effects.consume(code2);
            size3++;
            return more;
          }
          if (size3 < 2 && !single)
            return nok(code2);
          token2 = effects.exit("strikethroughSequenceTemporary");
          after = classifyCharacter(code2);
          token2._open = !after || after === 2 && before;
          token2._close = !before || before === 2 && after;
          return ok(code2);
        }
      }
    }
  }
});

// node_modules/.pnpm/@react-stately+utils@3.9.0_react@18.2.0/node_modules/@react-stately/utils/dist/import.mjs
var import_react = __toESM(require_react(), 1);
function $458b0a5536c1a7cf$export$40bfa8c7b0832715(value2, defaultValue, onChange) {
  let [stateValue, setStateValue] = (0, import_react.useState)(value2 || defaultValue);
  let isControlledRef = (0, import_react.useRef)(value2 !== void 0);
  let isControlled = value2 !== void 0;
  (0, import_react.useEffect)(() => {
    let wasControlled = isControlledRef.current;
    if (wasControlled !== isControlled)
      console.warn(`WARN: A component changed from ${wasControlled ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`);
    isControlledRef.current = isControlled;
  }, [
    isControlled
  ]);
  let currentValue = isControlled ? value2 : stateValue;
  let setValue = (0, import_react.useCallback)((value3, ...args) => {
    let onChangeCaller = (value4, ...onChangeArgs) => {
      if (onChange) {
        if (!Object.is(currentValue, value4))
          onChange(value4, ...onChangeArgs);
      }
      if (!isControlled)
        currentValue = value4;
    };
    if (typeof value3 === "function") {
      console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320");
      let updateFunction = (oldValue, ...functionArgs) => {
        let interceptedValue = value3(isControlled ? currentValue : oldValue, ...functionArgs);
        onChangeCaller(interceptedValue, ...args);
        if (!isControlled)
          return interceptedValue;
        return oldValue;
      };
      setStateValue(updateFunction);
    } else {
      if (!isControlled)
        setStateValue(value3);
      onChangeCaller(value3, ...args);
    }
  }, [
    isControlled,
    currentValue,
    onChange
  ]);
  return [
    currentValue,
    setValue
  ];
}
function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, min = -Infinity, max2 = Infinity) {
  let newValue = Math.min(Math.max(value2, min), max2);
  return newValue;
}
function $9446cca9a3875146$export$cb6e0bb50bc19463(value2, min, max2, step) {
  min = Number(min);
  max2 = Number(max2);
  let remainder = (value2 - (isNaN(min) ? 0 : min)) % step;
  let snappedValue = Math.abs(remainder) * 2 >= step ? value2 + Math.sign(remainder) * (step - Math.abs(remainder)) : value2 - remainder;
  if (!isNaN(min)) {
    if (snappedValue < min)
      snappedValue = min;
    else if (!isNaN(max2) && snappedValue > max2)
      snappedValue = min + Math.floor((max2 - min) / step) * step;
  } else if (!isNaN(max2) && snappedValue > max2)
    snappedValue = Math.floor(max2 / step) * step;
  let string = step.toString();
  let index2 = string.indexOf(".");
  let precision = index2 >= 0 ? string.length - index2 : 0;
  if (precision > 0) {
    let pow = Math.pow(10, precision);
    snappedValue = Math.round(snappedValue * pow) / pow;
  }
  return snappedValue;
}

// node_modules/.pnpm/@react-aria+utils@3.22.0_react@18.2.0/node_modules/@react-aria/utils/dist/import.mjs
var import_react3 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+ssr@3.9.0_react@18.2.0/node_modules/@react-aria/ssr/dist/import.mjs
var import_react2 = __toESM(require_react(), 1);
var $b5e257d569688ac6$var$defaultContext = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
};
var $b5e257d569688ac6$var$SSRContext = (0, import_react2.default).createContext($b5e257d569688ac6$var$defaultContext);
var $b5e257d569688ac6$var$IsSSRContext = (0, import_react2.default).createContext(false);
var $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $b5e257d569688ac6$var$componentIds = /* @__PURE__ */ new WeakMap();
function $b5e257d569688ac6$var$useCounter(isDisabled = false) {
  let ctx = (0, import_react2.useContext)($b5e257d569688ac6$var$SSRContext);
  let ref = (0, import_react2.useRef)(null);
  if (ref.current === null && !isDisabled) {
    var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, import_react2.default).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
    if (currentOwner) {
      let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);
      if (prevComponentValue == null)
        $b5e257d569688ac6$var$componentIds.set(currentOwner, {
          id: ctx.current,
          state: currentOwner.memoizedState
        });
      else if (currentOwner.memoizedState !== prevComponentValue.state) {
        ctx.current = prevComponentValue.id;
        $b5e257d569688ac6$var$componentIds.delete(currentOwner);
      }
    }
    ref.current = ++ctx.current;
  }
  return ref.current;
}
function $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {
  let ctx = (0, import_react2.useContext)($b5e257d569688ac6$var$SSRContext);
  if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM)
    console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let counter2 = $b5e257d569688ac6$var$useCounter(!!defaultId);
  let prefix3 = ctx === $b5e257d569688ac6$var$defaultContext && false ? "react-aria" : `react-aria${ctx.prefix}`;
  return defaultId || `${prefix3}-${counter2}`;
}
function $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {
  let id = (0, import_react2.default).useId();
  let [didSSR] = (0, import_react2.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());
  let prefix3 = didSSR || false ? "react-aria" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;
  return defaultId || `${prefix3}-${id}`;
}
var $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, import_react2.default)["useId"] === "function" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;
function $b5e257d569688ac6$var$getSnapshot() {
  return false;
}
function $b5e257d569688ac6$var$getServerSnapshot() {
  return true;
}
function $b5e257d569688ac6$var$subscribe(onStoreChange) {
  return () => {
  };
}
function $b5e257d569688ac6$export$535bd6ca7f90a273() {
  if (typeof (0, import_react2.default)["useSyncExternalStore"] === "function")
    return (0, import_react2.default)["useSyncExternalStore"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);
  return (0, import_react2.useContext)($b5e257d569688ac6$var$IsSSRContext);
}

// node_modules/.pnpm/clsx@1.2.1/node_modules/clsx/dist/clsx.m.js
function r(e6) {
  var t5, f5, n6 = "";
  if ("string" == typeof e6 || "number" == typeof e6)
    n6 += e6;
  else if ("object" == typeof e6)
    if (Array.isArray(e6))
      for (t5 = 0; t5 < e6.length; t5++)
        e6[t5] && (f5 = r(e6[t5])) && (n6 && (n6 += " "), n6 += f5);
    else
      for (t5 in e6)
        e6[t5] && (n6 && (n6 += " "), n6 += t5);
  return n6;
}
function clsx() {
  for (var e6, t5, f5 = 0, n6 = ""; f5 < arguments.length; )
    (e6 = arguments[f5++]) && (t5 = r(e6)) && (n6 && (n6 += " "), n6 += t5);
  return n6;
}
var clsx_m_default = clsx;

// node_modules/.pnpm/@react-aria+utils@3.22.0_react@18.2.0/node_modules/@react-aria/utils/dist/import.mjs
var $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? (0, import_react3.default).useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn2) {
  const ref = (0, import_react3.useRef)(null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    ref.current = fn2;
  }, [
    fn2
  ]);
  return (0, import_react3.useCallback)((...args) => {
    const f5 = ref.current;
    return f5(...args);
  }, []);
}
function $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {
  let [value2, setValue] = (0, import_react3.useState)(defaultValue);
  let effect = (0, import_react3.useRef)(null);
  let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    let newValue = effect.current.next();
    if (newValue.done) {
      effect.current = null;
      return;
    }
    if (value2 === newValue.value)
      nextRef();
    else
      setValue(newValue.value);
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (effect.current)
      nextRef();
  });
  let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn2) => {
    effect.current = fn2(value2);
    nextRef();
  });
  return [
    value2,
    queue
  ];
}
var $bdb11010cef70236$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $bdb11010cef70236$var$idsUpdaterMap = /* @__PURE__ */ new Map();
function $bdb11010cef70236$export$f680877a34711e37(defaultId) {
  let [value2, setValue] = (0, import_react3.useState)(defaultId);
  let nextId = (0, import_react3.useRef)(null);
  let res = (0, $b5e257d569688ac6$export$619500959fc48b26)(value2);
  let updateValue2 = (0, import_react3.useCallback)((val) => {
    nextId.current = val;
  }, []);
  if ($bdb11010cef70236$var$canUseDOM)
    $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue2);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let r7 = res;
    return () => {
      $bdb11010cef70236$var$idsUpdaterMap.delete(r7);
    };
  }, [
    res
  ]);
  (0, import_react3.useEffect)(() => {
    let newId = nextId.current;
    if (newId) {
      nextId.current = null;
      setValue(newId);
    }
  });
  return res;
}
function $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {
  if (idA === idB)
    return idA;
  let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);
  if (setIdA) {
    setIdA(idB);
    return idB;
  }
  let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);
  if (setIdB) {
    setIdB(idA);
    return idA;
  }
  return idB;
}
function $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {
  let id = $bdb11010cef70236$export$f680877a34711e37();
  let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id);
  let updateId = (0, import_react3.useCallback)(() => {
    setResolvedId(function* () {
      yield id;
      yield document.getElementById(id) ? id : void 0;
    });
  }, [
    id,
    setResolvedId
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [
    id,
    updateId,
    ...depArray
  ]);
  return resolvedId;
}
function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks2) {
  return (...args) => {
    for (let callback of callbacks2)
      if (typeof callback === "function")
        callback(...args);
  };
}
var $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
var $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {
  if (el && "window" in el && el.window === el)
    return el;
  const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);
  return doc.defaultView || window;
};
function $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {
  let result = {
    ...args[0]
  };
  for (let i6 = 1; i6 < args.length; i6++) {
    let props = args[i6];
    for (let key in props) {
      let a3 = result[key];
      let b2 = props[key];
      if (typeof a3 === "function" && typeof b2 === "function" && // This is a lot faster than a regex.
      key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */
      65 && key.charCodeAt(2) <= /* 'Z' */
      90)
        result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a3, b2);
      else if ((key === "className" || key === "UNSAFE_className") && typeof a3 === "string" && typeof b2 === "string")
        result[key] = (0, clsx_m_default)(a3, b2);
      else if (key === "id" && a3 && b2)
        result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a3, b2);
      else
        result[key] = b2 !== void 0 ? b2 : a3;
    }
  }
  return result;
}
function $5dc95899b306f630$export$c9058316764c140e(...refs) {
  if (refs.length === 1)
    return refs[0];
  return (value2) => {
    for (let ref of refs) {
      if (typeof ref === "function")
        ref(value2);
      else if (ref != null)
        ref.current = value2;
    }
  };
}
var $65484d02dcb7eb3e$var$DOMPropNames = /* @__PURE__ */ new Set([
  "id"
]);
var $65484d02dcb7eb3e$var$labelablePropNames = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]);
var $65484d02dcb7eb3e$var$linkPropNames = /* @__PURE__ */ new Set([
  "href",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]);
var $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;
function $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {
  let { labelable, isLink, propNames } = opts;
  let filteredProps = {};
  for (const prop in props)
    if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop)))
      filteredProps[prop] = props[prop];
  return filteredProps;
}
function $7215afc6de606d6b$export$de79e2c695e052f3(element2) {
  if ($7215afc6de606d6b$var$supportsPreventScroll())
    element2.focus({
      preventScroll: true
    });
  else {
    let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element2);
    element2.focus();
    $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);
  }
}
var $7215afc6de606d6b$var$supportsPreventScrollCached = null;
function $7215afc6de606d6b$var$supportsPreventScroll() {
  if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {
    $7215afc6de606d6b$var$supportsPreventScrollCached = false;
    try {
      var focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          $7215afc6de606d6b$var$supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch (e6) {
    }
  }
  return $7215afc6de606d6b$var$supportsPreventScrollCached;
}
function $7215afc6de606d6b$var$getScrollableElements(element2) {
  var parent = element2.parentNode;
  var scrollableElements = [];
  var rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth)
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement)
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {
  for (let { element: element2, scrollTop, scrollLeft } of scrollableElements) {
    element2.scrollTop = scrollTop;
    element2.scrollLeft = scrollLeft;
  }
}
function $c87311424ea30a05$var$testUserAgent(re) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null)
    return false;
  return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$export$9ac100e40613ea10() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}
function $c87311424ea30a05$export$186c6964ca17d99() {
  return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
}
function $c87311424ea30a05$export$7bef049ce92e4224() {
  return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $c87311424ea30a05$export$fedb369cb70207f1() {
  return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
}
function $c87311424ea30a05$export$e1865c3bedcd822b() {
  return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
}
function $c87311424ea30a05$export$78551043582a6a98() {
  return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
}
function $c87311424ea30a05$export$6446a186d09e379e() {
  return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
}
function $c87311424ea30a05$export$a11b0059900ceec8() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
}
function $c87311424ea30a05$export$b7d78993b74f766d() {
  return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
}
var $ea8dcbcb9ea1b556$var$RouterContext = (0, import_react3.createContext)({
  isNative: true,
  open: $ea8dcbcb9ea1b556$var$openSyntheticLink
});
function $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {
  let { children, navigate } = props;
  let ctx = (0, import_react3.useMemo)(() => ({
    isNative: false,
    open: (target, modifiers) => {
      $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link2) => {
        if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link2, modifiers))
          navigate(link2.pathname + link2.search + link2.hash);
        else
          $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link2, modifiers);
      });
    }
  }), [
    navigate
  ]);
  return (0, import_react3.default).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {
    value: ctx
  }, children);
}
function $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {
  return (0, import_react3.useContext)($ea8dcbcb9ea1b556$var$RouterContext);
}
function $ea8dcbcb9ea1b556$export$efa8c9099e530235(link2, modifiers) {
  let target = link2.getAttribute("target");
  return (!target || target === "_self") && link2.origin === location.origin && !link2.hasAttribute("download") && !modifiers.metaKey && // open in new tab (mac)
  !modifiers.ctrlKey && // open in new tab (windows)
  !modifiers.altKey && // download
  !modifiers.shiftKey;
}
function $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {
  var _window_event_type, _window_event;
  let { metaKey, ctrlKey, altKey, shiftKey } = modifiers;
  if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
    if ((0, $c87311424ea30a05$export$9ac100e40613ea10)())
      metaKey = true;
    else
      ctrlKey = true;
  }
  let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey,
    ctrlKey,
    altKey,
    shiftKey
  }) : new MouseEvent("click", {
    metaKey,
    ctrlKey,
    altKey,
    shiftKey,
    bubbles: true,
    cancelable: true
  });
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;
  (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);
  target.dispatchEvent(event);
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
}
$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
function $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {
  if (target instanceof HTMLAnchorElement)
    open(target);
  else if (target.hasAttribute("data-href")) {
    let link2 = document.createElement("a");
    link2.href = target.getAttribute("data-href");
    if (target.hasAttribute("data-target"))
      link2.target = target.getAttribute("data-target");
    if (target.hasAttribute("data-rel"))
      link2.rel = target.getAttribute("data-rel");
    if (target.hasAttribute("data-download"))
      link2.download = target.getAttribute("data-download");
    if (target.hasAttribute("data-ping"))
      link2.ping = target.getAttribute("data-ping");
    if (target.hasAttribute("data-referrer-policy"))
      link2.referrerPolicy = target.getAttribute("data-referrer-policy");
    target.appendChild(link2);
    open(link2);
    target.removeChild(link2);
  }
}
function $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {
  $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link2) => $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link2, modifiers));
}
function $ea8dcbcb9ea1b556$export$51437d503373d223(props) {
  return {
    "data-href": props.href,
    "data-target": props.target,
    "data-rel": props.rel,
    "data-download": props.download,
    "data-ping": props.ping,
    "data-referrer-policy": props.referrerPolicy
  };
}
var $bbed8b41f857bcc0$var$transitionsByElement = /* @__PURE__ */ new Map();
var $bbed8b41f857bcc0$var$transitionCallbacks = /* @__PURE__ */ new Set();
function $bbed8b41f857bcc0$var$setupGlobalEvents() {
  if (typeof window === "undefined")
    return;
  let onTransitionStart = (e6) => {
    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e6.target);
    if (!transitions) {
      transitions = /* @__PURE__ */ new Set();
      $bbed8b41f857bcc0$var$transitionsByElement.set(e6.target, transitions);
      e6.target.addEventListener("transitioncancel", onTransitionEnd);
    }
    transitions.add(e6.propertyName);
  };
  let onTransitionEnd = (e6) => {
    let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e6.target);
    if (!properties)
      return;
    properties.delete(e6.propertyName);
    if (properties.size === 0) {
      e6.target.removeEventListener("transitioncancel", onTransitionEnd);
      $bbed8b41f857bcc0$var$transitionsByElement.delete(e6.target);
    }
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {
      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)
        cb();
      $bbed8b41f857bcc0$var$transitionCallbacks.clear();
    }
  };
  document.body.addEventListener("transitionrun", onTransitionStart);
  document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading")
    $bbed8b41f857bcc0$var$setupGlobalEvents();
  else
    document.addEventListener("DOMContentLoaded", $bbed8b41f857bcc0$var$setupGlobalEvents);
}
function $bbed8b41f857bcc0$export$24490316f764c430(fn2) {
  requestAnimationFrame(() => {
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0)
      fn2();
    else
      $bbed8b41f857bcc0$var$transitionCallbacks.add(fn2);
  });
}
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = (0, import_react3.useRef)(/* @__PURE__ */ new Map());
  let addGlobalListener = (0, import_react3.useCallback)((eventTarget, type2, listener, options) => {
    let fn2 = (options === null || options === void 0 ? void 0 : options.once) ? (...args) => {
      globalListeners.current.delete(listener);
      listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type: type2,
      eventTarget,
      fn: fn2,
      options
    });
    eventTarget.addEventListener(type2, listener, options);
  }, []);
  let removeGlobalListener = (0, import_react3.useCallback)((eventTarget, type2, listener, options) => {
    var _globalListeners_current_get;
    let fn2 = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type2, fn2, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = (0, import_react3.useCallback)(() => {
    globalListeners.current.forEach((value2, key) => {
      removeGlobalListener(value2.eventTarget, value2.type, key, value2.options);
    });
  }, [
    removeGlobalListener
  ]);
  (0, import_react3.useEffect)(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}
function $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {
  let { id, "aria-label": label, "aria-labelledby": labelledBy } = props;
  id = (0, $bdb11010cef70236$export$f680877a34711e37)(id);
  if (labelledBy && label) {
    let ids = /* @__PURE__ */ new Set([
      id,
      ...labelledBy.trim().split(/\s+/)
    ]);
    labelledBy = [
      ...ids
    ].join(" ");
  } else if (labelledBy)
    labelledBy = labelledBy.trim().split(/\s+/).join(" ");
  if (!label && !labelledBy && defaultLabel)
    label = defaultLabel;
  return {
    id,
    "aria-label": label,
    "aria-labelledby": labelledBy
  };
}
function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {
  const objRef = (0, import_react3.useRef)();
  return (0, import_react3.useMemo)(() => ({
    get current() {
      return objRef.current;
    },
    set current(value2) {
      objRef.current = value2;
      if (typeof forwardedRef === "function")
        forwardedRef(value2);
      else if (forwardedRef)
        forwardedRef.current = value2;
    }
  }), [
    forwardedRef
  ]);
}
function $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {
  const isInitialMount = (0, import_react3.useRef)(true);
  const lastDeps = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    isInitialMount.current = true;
    return () => {
      isInitialMount.current = false;
    };
  }, []);
  (0, import_react3.useEffect)(() => {
    if (isInitialMount.current)
      isInitialMount.current = false;
    else if (!lastDeps.current || dependencies.some((dep, i6) => !Object.is(dep, lastDeps[i6])))
      effect();
    lastDeps.current = dependencies;
  }, dependencies);
}
function $9daab02d461809db$var$hasResizeObserver() {
  return typeof window.ResizeObserver !== "undefined";
}
function $9daab02d461809db$export$683480f191c0e3ea(options) {
  const { ref, onResize } = options;
  (0, import_react3.useEffect)(() => {
    let element2 = ref === null || ref === void 0 ? void 0 : ref.current;
    if (!element2)
      return;
    if (!$9daab02d461809db$var$hasResizeObserver()) {
      window.addEventListener("resize", onResize, false);
      return () => {
        window.removeEventListener("resize", onResize, false);
      };
    } else {
      const resizeObserverInstance = new window.ResizeObserver((entries) => {
        if (!entries.length)
          return;
        onResize();
      });
      resizeObserverInstance.observe(element2);
      return () => {
        if (element2)
          resizeObserverInstance.unobserve(element2);
      };
    }
  }, [
    onResize,
    ref
  ]);
}
function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (context && context.ref && ref) {
      context.ref.current = ref.current;
      return () => {
        context.ref.current = null;
      };
    }
  });
}
function $62d8ded9296f3872$export$cfa2225e87938781(node3) {
  if ($62d8ded9296f3872$export$2bb74740c4e19def(node3))
    node3 = node3.parentElement;
  while (node3 && !$62d8ded9296f3872$export$2bb74740c4e19def(node3))
    node3 = node3.parentElement;
  return node3 || document.scrollingElement || document.documentElement;
}
function $62d8ded9296f3872$export$2bb74740c4e19def(node3) {
  let style = window.getComputedStyle(node3);
  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
}
var $5df64b3807dc15ee$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $5df64b3807dc15ee$export$d699905dd57c73ca() {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let [size3, setSize] = (0, import_react3.useState)(() => isSSR ? {
    width: 0,
    height: 0
  } : $5df64b3807dc15ee$var$getViewportSize());
  (0, import_react3.useEffect)(() => {
    let onResize = () => {
      setSize((size4) => {
        let newSize = $5df64b3807dc15ee$var$getViewportSize();
        if (newSize.width === size4.width && newSize.height === size4.height)
          return size4;
        return newSize;
      });
    };
    if (!$5df64b3807dc15ee$var$visualViewport)
      window.addEventListener("resize", onResize);
    else
      $5df64b3807dc15ee$var$visualViewport.addEventListener("resize", onResize);
    return () => {
      if (!$5df64b3807dc15ee$var$visualViewport)
        window.removeEventListener("resize", onResize);
      else
        $5df64b3807dc15ee$var$visualViewport.removeEventListener("resize", onResize);
    };
  }, []);
  return size3;
}
function $5df64b3807dc15ee$var$getViewportSize() {
  return {
    width: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,
    height: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight
  };
}
var $ef06256079686ba0$var$descriptionId = 0;
var $ef06256079686ba0$var$descriptionNodes = /* @__PURE__ */ new Map();
function $ef06256079686ba0$export$f8aeda7b10753fa1(description) {
  let [id, setId] = (0, import_react3.useState)(void 0);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (!description)
      return;
    let desc = $ef06256079686ba0$var$descriptionNodes.get(description);
    if (!desc) {
      let id2 = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;
      setId(id2);
      let node3 = document.createElement("div");
      node3.id = id2;
      node3.style.display = "none";
      node3.textContent = description;
      document.body.appendChild(node3);
      desc = {
        refCount: 0,
        element: node3
      };
      $ef06256079686ba0$var$descriptionNodes.set(description, desc);
    } else
      setId(desc.element.id);
    desc.refCount++;
    return () => {
      if (--desc.refCount === 0) {
        desc.element.remove();
        $ef06256079686ba0$var$descriptionNodes.delete(description);
      }
    };
  }, [
    description
  ]);
  return {
    "aria-describedby": description ? id : void 0
  };
}
function $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {
  let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);
  let isDisabled = handler == null;
  (0, import_react3.useEffect)(() => {
    if (isDisabled)
      return;
    let element2 = ref.current;
    element2.addEventListener(event, handleEvent, options);
    return () => {
      element2.removeEventListener(event, handleEvent, options);
    };
  }, [
    ref,
    event,
    options,
    isDisabled,
    handleEvent
  ]);
}
function $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element2) {
  let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element2, "left");
  let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element2, "top");
  let width = element2.offsetWidth;
  let height = element2.offsetHeight;
  let x3 = scrollView.scrollLeft;
  let y4 = scrollView.scrollTop;
  let { borderTopWidth, borderLeftWidth } = getComputedStyle(scrollView);
  let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
  let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
  let maxX = borderAdjustedX + scrollView.clientWidth;
  let maxY = borderAdjustedY + scrollView.clientHeight;
  if (offsetX <= x3)
    x3 = offsetX - parseInt(borderLeftWidth, 10);
  else if (offsetX + width > maxX)
    x3 += offsetX + width - maxX;
  if (offsetY <= borderAdjustedY)
    y4 = offsetY - parseInt(borderTopWidth, 10);
  else if (offsetY + height > maxY)
    y4 += offsetY + height - maxY;
  scrollView.scrollLeft = x3;
  scrollView.scrollTop = y4;
}
function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {
  const prop = axis === "left" ? "offsetLeft" : "offsetTop";
  let sum = 0;
  while (child.offsetParent) {
    sum += child[prop];
    if (child.offsetParent === ancestor)
      break;
    else if (child.offsetParent.contains(ancestor)) {
      sum -= ancestor[prop];
      break;
    }
    child = child.offsetParent;
  }
  return sum;
}
function $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {
  if (document.contains(targetElement)) {
    let root = document.scrollingElement || document.documentElement;
    let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
    if (!isScrollPrevented) {
      var _targetElement_scrollIntoView;
      let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();
      targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
        block: "nearest"
      });
      let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();
      if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
        var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;
        opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
          block: "center",
          inline: "center"
        });
        (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
          block: "nearest"
        });
      }
    } else {
      let scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);
      while (targetElement && scrollParent && targetElement !== root && scrollParent !== root) {
        $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);
        targetElement = scrollParent;
        scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);
      }
    }
  }
}
function $6a7db85432448f7f$export$60278871457622de(event) {
  if (event.mozInputSource === 0 && event.isTrusted)
    return true;
  if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType)
    return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
function $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {
  return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}
function $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {
  let resetValue = (0, import_react3.useRef)(initialValue);
  let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    if (onReset)
      onReset(resetValue.current);
  });
  (0, import_react3.useEffect)(() => {
    var _ref_current;
    let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;
    form === null || form === void 0 ? void 0 : form.addEventListener("reset", handleReset);
    return () => {
      form === null || form === void 0 ? void 0 : form.removeEventListener("reset", handleReset);
    };
  }, [
    ref,
    handleReset
  ]);
}

// node_modules/.pnpm/@react-aria+i18n@3.9.0_react@18.2.0/node_modules/@react-aria/i18n/dist/real-module.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/.pnpm/@internationalized+string@3.1.1/node_modules/@internationalized/string/dist/import.mjs
var $5b160d28a433310d$export$c17fa47878dc55b6 = class {
  /** Returns a localized string for the given key and locale. */
  getStringForLocale(key, locale) {
    let strings = this.strings[locale];
    if (!strings) {
      strings = $5b160d28a433310d$var$getStringsForLocale(locale, this.strings, this.defaultLocale);
      this.strings[locale] = strings;
    }
    let string = strings[key];
    if (!string)
      throw new Error(`Could not find intl message ${key} in ${locale} locale`);
    return string;
  }
  constructor(messages, defaultLocale = "en-US") {
    this.strings = {
      ...messages
    };
    this.defaultLocale = defaultLocale;
  }
};
function $5b160d28a433310d$var$getStringsForLocale(locale, strings, defaultLocale = "en-US") {
  if (strings[locale])
    return strings[locale];
  let language = $5b160d28a433310d$var$getLanguage(locale);
  if (strings[language])
    return strings[language];
  for (let key in strings) {
    if (key.startsWith(language + "-"))
      return strings[key];
  }
  return strings[defaultLocale];
}
function $5b160d28a433310d$var$getLanguage(locale) {
  if (Intl.Locale)
    return new Intl.Locale(locale).language;
  return locale.split("-")[0];
}
var $6db58dc88e78b024$var$pluralRulesCache = /* @__PURE__ */ new Map();
var $6db58dc88e78b024$var$numberFormatCache = /* @__PURE__ */ new Map();
var $6db58dc88e78b024$export$2f817fcdc4b89ae0 = class {
  /** Formats a localized string for the given key with the provided variables. */
  format(key, variables) {
    let message = this.strings.getStringForLocale(key, this.locale);
    return typeof message === "function" ? message(variables, this) : message;
  }
  plural(count, options, type2 = "cardinal") {
    let opt = options["=" + count];
    if (opt)
      return typeof opt === "function" ? opt() : opt;
    let key = this.locale + ":" + type2;
    let pluralRules = $6db58dc88e78b024$var$pluralRulesCache.get(key);
    if (!pluralRules) {
      pluralRules = new Intl.PluralRules(this.locale, {
        type: type2
      });
      $6db58dc88e78b024$var$pluralRulesCache.set(key, pluralRules);
    }
    let selected = pluralRules.select(count);
    opt = options[selected] || options.other;
    return typeof opt === "function" ? opt() : opt;
  }
  number(value2) {
    let numberFormat = $6db58dc88e78b024$var$numberFormatCache.get(this.locale);
    if (!numberFormat) {
      numberFormat = new Intl.NumberFormat(this.locale);
      $6db58dc88e78b024$var$numberFormatCache.set(this.locale, numberFormat);
    }
    return numberFormat.format(value2);
  }
  select(options, value2) {
    let opt = options[value2] || options.other;
    return typeof opt === "function" ? opt() : opt;
  }
  constructor(locale, strings) {
    this.locale = locale;
    this.strings = strings;
  }
};

// node_modules/.pnpm/@swc+helpers@0.5.3/node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/.pnpm/@swc+helpers@0.5.3/node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value2) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value2);
}

// node_modules/.pnpm/@internationalized+date@3.5.0/node_modules/@internationalized/date/dist/import.mjs
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/.pnpm/@internationalized+number@3.4.0/node_modules/@internationalized/number/dist/import.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch (e6) {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch (e6) {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value2) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null)
      res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value2);
    else
      res = this.numberFormatter.format(value2);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      let values2 = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values2[locale] || values2.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value2) {
    return this.numberFormatter.formatToParts(value2);
  }
  /** Formats a number range as a string. */
  formatRange(start2, end) {
    if (typeof this.numberFormatter.formatRange === "function")
      return this.numberFormatter.formatRange(start2, end);
    if (end < start2)
      throw new RangeError("End date must be >= start date");
    return `${this.format(start2)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start2, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function")
      return this.numberFormatter.formatRangeToParts(start2, end);
    if (end < start2)
      throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start2);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p5) => ({
        ...p5,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p5) => ({
        ...p5,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null)
      options = {
        ...options,
        signDisplay: this.options.signDisplay
      };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit")
      options = {
        ...options,
        style: "unit",
        unit: this.options.unit,
        unitDisplay: this.options.unitDisplay
      };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.indexOf("-u-nu-") === -1)
    locale = `${locale}-u-nu-${numberingSystem}`;
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit)
      throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay]))
      throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey))
    return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto")
    return numberFormat.format(num);
  else if (signDisplay === "never")
    return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always")
      needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0))
        num = Math.abs(num);
      else
        needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1)
        console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else
      return numberFormat.format(num);
  }
}
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).parse(value2);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value2, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).isValidPartialNumber(value2, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value2) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value2).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value2) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value2)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)
      if (numberingSystem !== defaultParser.options.numberingSystem) {
        let parser2 = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
        if (parser2.isValidPartialNumber(value2))
          return parser2;
      }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  let parser2 = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser2) {
    parser2 = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser2);
  }
  return parser2;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value2) {
    let fullySanitizedValue = this.sanitize(value2);
    fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "").replace(this.symbols.decimal, ".").replace(this.symbols.minusSign, "-").replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative2 = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index2 = fullySanitizedValue.indexOf(".");
      if (index2 === -1)
        index2 = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index2 - 2 === 0)
        fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index2 - 2 === -1)
        fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index2 - 2 === -2)
        fullySanitizedValue = "0.00";
      else
        fullySanitizedValue = `${fullySanitizedValue.slice(0, index2 - 2)}.${fullySanitizedValue.slice(index2 - 2)}`;
      if (isNegative2 > -1)
        fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue))
      return NaN;
    if (this.options.style === "percent") {
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(this.options.minimumFractionDigits + 2, 20),
        maximumFractionDigits: Math.min(this.options.maximumFractionDigits + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value2))
      newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value2) {
    value2 = value2.replace(this.symbols.literals, "");
    value2 = value2.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      value2 = value2.replace(",", this.symbols.decimal);
      value2 = value2.replace(String.fromCharCode(1548), this.symbols.decimal);
      value2 = $6c7bd7858deea686$var$replaceAll(value2, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR")
      value2 = $6c7bd7858deea686$var$replaceAll(value2, ".", String.fromCharCode(8239));
    return value2;
  }
  isValidPartialNumber(value2, minValue = -Infinity, maxValue = Infinity) {
    value2 = this.sanitize(value2);
    if (value2.startsWith(this.symbols.minusSign) && minValue < 0)
      value2 = value2.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value2.startsWith(this.symbols.plusSign) && maxValue > 0)
      value2 = value2.slice(this.symbols.plusSign.length);
    if (value2.startsWith(this.symbols.group))
      return false;
    if (value2.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0)
      return false;
    value2 = $6c7bd7858deea686$var$replaceAll(value2, this.symbols.group, "").replace(this.symbols.numeral, "").replace(this.symbols.decimal, "");
    return value2.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18))
      console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n6) => symbolFormatter.formatToParts(n6));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p5) => p5.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p5) => p5.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always"))
    plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p5) => p5.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group = (_allParts_find1 = allParts.find((p5) => p5.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p5) => !$6c7bd7858deea686$var$nonLiteralParts.has(p5.type)).map((p5) => $6c7bd7858deea686$var$escapeRegex(p5.value));
  let pluralPartsLiterals = pluralParts.flatMap((p5) => p5.filter((p6) => !$6c7bd7858deea686$var$nonLiteralParts.has(p6.type)).map((p6) => $6c7bd7858deea686$var$escapeRegex(p6.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a3, b2) => b2.length - a3.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d5, i6) => [
    d5,
    i6
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index2 = (d5) => String(indexes.get(d5));
  return {
    minusSign,
    plusSign,
    decimal,
    group,
    literals,
    numeral,
    index: index2
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace2) {
  if (str.replaceAll)
    return str.replaceAll(find, replace2);
  return str.split(find).join(replace2);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/.pnpm/@react-aria+i18n@3.9.0_react@18.2.0/node_modules/@react-aria/i18n/dist/real-module.mjs
var $148a7a147e38ea7f$var$RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Arab",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var $148a7a147e38ea7f$var$RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function $148a7a147e38ea7f$export$702d680b21cbd764(locale) {
  if (Intl.Locale) {
    let script = new Intl.Locale(locale).maximize().script;
    if (!script)
      return false;
    return $148a7a147e38ea7f$var$RTL_SCRIPTS.has(script);
  }
  let lang = locale.split("-")[0];
  return $148a7a147e38ea7f$var$RTL_LANGS.has(lang);
}
function $1e5a04cdaf7d1af8$export$f09106e7c6677ec5() {
  let locale = typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([
      locale
    ]);
  } catch (_err) {
    locale = "en-US";
  }
  return {
    locale,
    direction: (0, $148a7a147e38ea7f$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
  };
}
var $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();
var $1e5a04cdaf7d1af8$var$listeners = /* @__PURE__ */ new Set();
function $1e5a04cdaf7d1af8$var$updateLocale() {
  $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();
  for (let listener of $1e5a04cdaf7d1af8$var$listeners)
    listener($1e5a04cdaf7d1af8$var$currentLocale);
}
function $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a() {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let [defaultLocale, setDefaultLocale] = (0, import_react4.useState)($1e5a04cdaf7d1af8$var$currentLocale);
  (0, import_react4.useEffect)(() => {
    if ($1e5a04cdaf7d1af8$var$listeners.size === 0)
      window.addEventListener("languagechange", $1e5a04cdaf7d1af8$var$updateLocale);
    $1e5a04cdaf7d1af8$var$listeners.add(setDefaultLocale);
    return () => {
      $1e5a04cdaf7d1af8$var$listeners.delete(setDefaultLocale);
      if ($1e5a04cdaf7d1af8$var$listeners.size === 0)
        window.removeEventListener("languagechange", $1e5a04cdaf7d1af8$var$updateLocale);
    };
  }, []);
  if (isSSR)
    return {
      locale: "en-US",
      direction: "ltr"
    };
  return defaultLocale;
}
var $18f2051aff69b9bf$var$I18nContext = (0, import_react4.default).createContext(null);
function $18f2051aff69b9bf$export$a54013f0d02a8f82(props) {
  let { locale, children } = props;
  let defaultLocale = (0, $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a)();
  let value2 = locale ? {
    locale,
    direction: (0, $148a7a147e38ea7f$export$702d680b21cbd764)(locale) ? "rtl" : "ltr"
  } : defaultLocale;
  return (0, import_react4.default).createElement($18f2051aff69b9bf$var$I18nContext.Provider, {
    value: value2
  }, children);
}
function $18f2051aff69b9bf$export$43bb16f9c6d9e3f7() {
  let defaultLocale = (0, $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a)();
  let context = (0, import_react4.useContext)($18f2051aff69b9bf$var$I18nContext);
  return context || defaultLocale;
}
var $fca6afa0e843324b$var$cache = /* @__PURE__ */ new WeakMap();
function $fca6afa0e843324b$var$getCachedDictionary(strings) {
  let dictionary = $fca6afa0e843324b$var$cache.get(strings);
  if (!dictionary) {
    dictionary = new (0, $5b160d28a433310d$export$c17fa47878dc55b6)(strings);
    $fca6afa0e843324b$var$cache.set(strings, dictionary);
  }
  return dictionary;
}
function $fca6afa0e843324b$export$f12b703ca79dfbb1(strings) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let dictionary = (0, import_react4.useMemo)(() => $fca6afa0e843324b$var$getCachedDictionary(strings), [
    strings
  ]);
  return (0, import_react4.useMemo)(() => new (0, $6db58dc88e78b024$export$2f817fcdc4b89ae0)(locale, dictionary), [
    locale,
    dictionary
  ]);
}
function $a916eb452884faea$export$b7a616150fdb9f44(options = {}) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  return (0, import_react4.useMemo)(() => new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, options), [
    locale,
    options
  ]);
}
var $325a3faab7a68acd$var$cache = /* @__PURE__ */ new Map();
function $325a3faab7a68acd$export$a16aca283550c30d(options) {
  let { locale } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let cacheKey = locale + (options ? Object.entries(options).sort((a3, b2) => a3[0] < b2[0] ? -1 : 1).join() : "");
  if ($325a3faab7a68acd$var$cache.has(cacheKey))
    return $325a3faab7a68acd$var$cache.get(cacheKey);
  let formatter = new Intl.Collator(locale, options);
  $325a3faab7a68acd$var$cache.set(cacheKey, formatter);
  return formatter;
}
function $bb77f239b46e8c72$export$3274cf84b703fff(options) {
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    ...options
  });
  let startsWith4 = (0, import_react4.useCallback)((string, substring) => {
    if (substring.length === 0)
      return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.compare(string.slice(0, substring.length), substring) === 0;
  }, [
    collator
  ]);
  let endsWith = (0, import_react4.useCallback)((string, substring) => {
    if (substring.length === 0)
      return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.compare(string.slice(-substring.length), substring) === 0;
  }, [
    collator
  ]);
  let contains = (0, import_react4.useCallback)((string, substring) => {
    if (substring.length === 0)
      return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    let scan = 0;
    let sliceLen = substring.length;
    for (; scan + sliceLen <= string.length; scan++) {
      let slice2 = string.slice(scan, scan + sliceLen);
      if (collator.compare(substring, slice2) === 0)
        return true;
    }
    return false;
  }, [
    collator
  ]);
  return (0, import_react4.useMemo)(() => ({
    startsWith: startsWith4,
    endsWith,
    contains
  }), [
    startsWith4,
    endsWith,
    contains
  ]);
}

// node_modules/.pnpm/tslib@2.6.2/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d5, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d6, b3) {
    d6.__proto__ = b3;
  } || function(d6, b3) {
    for (var p5 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p5))
        d6[p5] = b3[p5];
  };
  return extendStatics(d5, b2);
};
function __extends(d5, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d5, b2);
  function __() {
    this.constructor = d5;
  }
  d5.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t5) {
    for (var s4, i6 = 1, n6 = arguments.length; i6 < n6; i6++) {
      s4 = arguments[i6];
      for (var p5 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p5))
          t5[p5] = s4[p5];
    }
    return t5;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e6) {
  var t5 = {};
  for (var p5 in s4)
    if (Object.prototype.hasOwnProperty.call(s4, p5) && e6.indexOf(p5) < 0)
      t5[p5] = s4[p5];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i6 = 0, p5 = Object.getOwnPropertySymbols(s4); i6 < p5.length; i6++) {
      if (e6.indexOf(p5[i6]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p5[i6]))
        t5[p5[i6]] = s4[p5[i6]];
    }
  return t5;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i6 = 0, l6 = from2.length, ar; i6 < l6; i6++) {
      if (ar || !(i6 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i6);
        ar[i6] = from2[i6];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/.pnpm/@formatjs+icu-messageformat-parser@2.7.3/node_modules/@formatjs/icu-messageformat-parser/lib/error.js
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));

// node_modules/.pnpm/@formatjs+icu-messageformat-parser@2.7.3/node_modules/@formatjs/icu-messageformat-parser/lib/types.js
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}

// node_modules/.pnpm/@formatjs+icu-messageformat-parser@2.7.3/node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

// node_modules/.pnpm/@formatjs+icu-skeleton-parser@1.7.0/node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match3) {
    var len = match3.length;
    switch (match3[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}

// node_modules/.pnpm/@formatjs+icu-skeleton-parser@1.7.0/node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

// node_modules/.pnpm/@formatjs+icu-skeleton-parser@1.7.0/node_modules/@formatjs/icu-skeleton-parser/lib/number.js
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x3) {
    return x3.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a2 = 0, options_1 = options; _a2 < options_1.length; _a2++) {
      var option = options_1[_a2];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g22) {
    if (typeof g22 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g22 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g22 === "string" ? g22.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token2 = tokens_1[_i];
    switch (token2.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token2.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token2.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token2.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token2.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token2.options[0]);
        continue;
      case "integer-width":
        if (token2.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token2.options[0].replace(INTEGER_WIDTH_REGEX, function(_2, g1, g22, g3, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g22.length;
          } else if (g3 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token2.stem)) {
      result.minimumIntegerDigits = token2.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token2.stem)) {
      if (token2.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token2.stem.replace(FRACTION_PRECISION_REGEX, function(_2, g1, g22, g3, g4, g5) {
        if (g22 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g3 && g3[0] === "#") {
          result.maximumFractionDigits = g3.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token2.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token2.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token2.stem));
      continue;
    }
    var signOpts = parseSign(token2.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token2.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}

// node_modules/.pnpm/@formatjs+icu-messageformat-parser@2.7.3/node_modules/@formatjs/icu-messageformat-parser/lib/time-data.generated.js
var timeData = {
  "001": [
    "H",
    "h"
  ],
  "AC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AD": [
    "H",
    "hB"
  ],
  "AE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "AF": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "AG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AL": [
    "h",
    "H",
    "hB"
  ],
  "AM": [
    "H",
    "hB"
  ],
  "AO": [
    "H",
    "hB"
  ],
  "AR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "AS": [
    "h",
    "H"
  ],
  "AT": [
    "H",
    "hB"
  ],
  "AU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AW": [
    "H",
    "hB"
  ],
  "AX": [
    "H"
  ],
  "AZ": [
    "H",
    "hB",
    "h"
  ],
  "BA": [
    "H",
    "hB",
    "h"
  ],
  "BB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BD": [
    "h",
    "hB",
    "H"
  ],
  "BE": [
    "H",
    "hB"
  ],
  "BF": [
    "H",
    "hB"
  ],
  "BG": [
    "H",
    "hB",
    "h"
  ],
  "BH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "BI": [
    "H",
    "h"
  ],
  "BJ": [
    "H",
    "hB"
  ],
  "BL": [
    "H",
    "hB"
  ],
  "BM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BN": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "BO": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "BQ": [
    "H"
  ],
  "BR": [
    "H",
    "hB"
  ],
  "BS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BT": [
    "h",
    "H"
  ],
  "BW": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BY": [
    "H",
    "h"
  ],
  "BZ": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CA": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "CC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CD": [
    "hB",
    "H"
  ],
  "CF": [
    "H",
    "h",
    "hB"
  ],
  "CG": [
    "H",
    "hB"
  ],
  "CH": [
    "H",
    "hB",
    "h"
  ],
  "CI": [
    "H",
    "hB"
  ],
  "CK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CL": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CM": [
    "H",
    "h",
    "hB"
  ],
  "CN": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "CO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CP": [
    "H"
  ],
  "CR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CU": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "CV": [
    "H",
    "hB"
  ],
  "CW": [
    "H",
    "hB"
  ],
  "CX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CY": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "CZ": [
    "H"
  ],
  "DE": [
    "H",
    "hB"
  ],
  "DG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "DJ": [
    "h",
    "H"
  ],
  "DK": [
    "H"
  ],
  "DM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "DO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "DZ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "EC": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "EE": [
    "H",
    "hB"
  ],
  "EG": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ER": [
    "h",
    "H"
  ],
  "ES": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "ET": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "FI": [
    "H"
  ],
  "FJ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "FM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FO": [
    "H",
    "h"
  ],
  "FR": [
    "H",
    "hB"
  ],
  "GA": [
    "H",
    "hB"
  ],
  "GB": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GD": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GE": [
    "H",
    "hB",
    "h"
  ],
  "GF": [
    "H",
    "hB"
  ],
  "GG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GH": [
    "h",
    "H"
  ],
  "GI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GL": [
    "H",
    "h"
  ],
  "GM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GN": [
    "H",
    "hB"
  ],
  "GP": [
    "H",
    "hB"
  ],
  "GQ": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "GR": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "GT": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "GU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GW": [
    "H",
    "hB"
  ],
  "GY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "HK": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "HN": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "HR": [
    "H",
    "hB"
  ],
  "HU": [
    "H",
    "h"
  ],
  "IC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ID": [
    "H"
  ],
  "IE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IL": [
    "H",
    "hB"
  ],
  "IM": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IN": [
    "h",
    "H"
  ],
  "IO": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IQ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "IR": [
    "hB",
    "H"
  ],
  "IS": [
    "H"
  ],
  "IT": [
    "H",
    "hB"
  ],
  "JE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "JM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "JO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "JP": [
    "H",
    "K",
    "h"
  ],
  "KE": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "KG": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KH": [
    "hB",
    "h",
    "H",
    "hb"
  ],
  "KI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KM": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KN": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KP": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KW": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "KY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KZ": [
    "H",
    "hB"
  ],
  "LA": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "LB": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LI": [
    "H",
    "hB",
    "h"
  ],
  "LK": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "LR": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LS": [
    "h",
    "H"
  ],
  "LT": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "LU": [
    "H",
    "h",
    "hB"
  ],
  "LV": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "LY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MC": [
    "H",
    "hB"
  ],
  "MD": [
    "H",
    "hB"
  ],
  "ME": [
    "H",
    "hB",
    "h"
  ],
  "MF": [
    "H",
    "hB"
  ],
  "MG": [
    "H",
    "h"
  ],
  "MH": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ML": [
    "H"
  ],
  "MM": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "MN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MP": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MQ": [
    "H",
    "hB"
  ],
  "MR": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MS": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MT": [
    "H",
    "h"
  ],
  "MU": [
    "H",
    "h"
  ],
  "MV": [
    "H",
    "h"
  ],
  "MW": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MX": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MY": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "MZ": [
    "H",
    "hB"
  ],
  "NA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NC": [
    "H",
    "hB"
  ],
  "NE": [
    "H"
  ],
  "NF": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NI": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "NL": [
    "H",
    "hB"
  ],
  "NO": [
    "H",
    "h"
  ],
  "NP": [
    "H",
    "h",
    "hB"
  ],
  "NR": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NU": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "OM": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PE": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "PF": [
    "H",
    "h",
    "hB"
  ],
  "PG": [
    "h",
    "H"
  ],
  "PH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PK": [
    "h",
    "hB",
    "H"
  ],
  "PL": [
    "H",
    "h"
  ],
  "PM": [
    "H",
    "hB"
  ],
  "PN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "PR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PS": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PT": [
    "H",
    "hB"
  ],
  "PW": [
    "h",
    "H"
  ],
  "PY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "QA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "RE": [
    "H",
    "hB"
  ],
  "RO": [
    "H",
    "hB"
  ],
  "RS": [
    "H",
    "hB",
    "h"
  ],
  "RU": [
    "H"
  ],
  "RW": [
    "H",
    "h"
  ],
  "SA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SC": [
    "H",
    "h",
    "hB"
  ],
  "SD": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SE": [
    "H"
  ],
  "SG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SH": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SI": [
    "H",
    "hB"
  ],
  "SJ": [
    "H"
  ],
  "SK": [
    "H"
  ],
  "SL": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SM": [
    "H",
    "h",
    "hB"
  ],
  "SN": [
    "H",
    "h",
    "hB"
  ],
  "SO": [
    "h",
    "H"
  ],
  "SR": [
    "H",
    "hB"
  ],
  "SS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ST": [
    "H",
    "hB"
  ],
  "SV": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "SX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "TC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TD": [
    "h",
    "H",
    "hB"
  ],
  "TF": [
    "H",
    "h",
    "hB"
  ],
  "TG": [
    "H",
    "hB"
  ],
  "TH": [
    "H",
    "h"
  ],
  "TJ": [
    "H",
    "h"
  ],
  "TL": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "TM": [
    "H",
    "h"
  ],
  "TN": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "TO": [
    "h",
    "H"
  ],
  "TR": [
    "H",
    "hB"
  ],
  "TT": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TW": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "TZ": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UA": [
    "H",
    "hB",
    "h"
  ],
  "UG": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "US": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "UY": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "UZ": [
    "H",
    "hB",
    "h"
  ],
  "VA": [
    "H",
    "h",
    "hB"
  ],
  "VC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "VG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VN": [
    "H",
    "h"
  ],
  "VU": [
    "h",
    "H"
  ],
  "WF": [
    "H",
    "hB"
  ],
  "WS": [
    "h",
    "H"
  ],
  "XK": [
    "H",
    "hB",
    "h"
  ],
  "YE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "YT": [
    "H",
    "hB"
  ],
  "ZA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ZM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ZW": [
    "H",
    "h"
  ],
  "af-ZA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ar-001": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ca-ES": [
    "H",
    "h",
    "hB"
  ],
  "en-001": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "es-BO": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-BR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-EC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-ES": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-GQ": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-PE": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "fr-CA": [
    "H",
    "h",
    "hB"
  ],
  "gl-ES": [
    "H",
    "h",
    "hB"
  ],
  "gu-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "hi-IN": [
    "hB",
    "h",
    "H"
  ],
  "it-CH": [
    "H",
    "h",
    "hB"
  ],
  "it-IT": [
    "H",
    "h",
    "hB"
  ],
  "kn-IN": [
    "hB",
    "h",
    "H"
  ],
  "ml-IN": [
    "hB",
    "h",
    "H"
  ],
  "mr-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "pa-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "ta-IN": [
    "hB",
    "h",
    "hb",
    "H"
  ],
  "te-IN": [
    "hB",
    "h",
    "H"
  ],
  "zu-ZA": [
    "H",
    "hB",
    "hb",
    "h"
  ]
};

// node_modules/.pnpm/@formatjs+icu-messageformat-parser@2.7.3/node_modules/@formatjs/icu-messageformat-parser/lib/date-time-pattern-generator.js
function getBestPattern(skeleton, locale) {
  var skeletonCopy = "";
  for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
    var patternChar = skeleton.charAt(patternPos);
    if (patternChar === "j") {
      var extraLength = 0;
      while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
        extraLength++;
        patternPos++;
      }
      var hourLen = 1 + (extraLength & 1);
      var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
      var dayPeriodChar = "a";
      var hourChar = getDefaultHourSymbolFromLocale(locale);
      if (hourChar == "H" || hourChar == "k") {
        dayPeriodLen = 0;
      }
      while (dayPeriodLen-- > 0) {
        skeletonCopy += dayPeriodChar;
      }
      while (hourLen-- > 0) {
        skeletonCopy = hourChar + skeletonCopy;
      }
    } else if (patternChar === "J") {
      skeletonCopy += "H";
    } else {
      skeletonCopy += patternChar;
    }
  }
  return skeletonCopy;
}
function getDefaultHourSymbolFromLocale(locale) {
  var hourCycle = locale.hourCycle;
  if (hourCycle === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  locale.hourCycles && // @ts-ignore
  locale.hourCycles.length) {
    hourCycle = locale.hourCycles[0];
  }
  if (hourCycle) {
    switch (hourCycle) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  }
  var languageTag = locale.language;
  var regionTag;
  if (languageTag !== "root") {
    regionTag = locale.maximize().region;
  }
  var hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData["".concat(languageTag, "-001")] || timeData["001"];
  return hourCycles[0];
}

// node_modules/.pnpm/@formatjs+icu-messageformat-parser@2.7.3/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start2, end) {
  return { start: start2, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith && "_a".startsWith("a", 1);
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n6) {
  return typeof n6 === "number" && isFinite(n6) && Math.floor(n6) === n6 && Math.abs(n6) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_2) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var re;
var startsWith = hasNativeStartsWith ? (
  // Native
  function startsWith2(s4, search, position2) {
    return s4.startsWith(search, position2);
  }
) : (
  // For IE11
  function startsWith3(s4, search, position2) {
    return s4.slice(position2, position2 + search.length) === search;
  }
);
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function fromCodePoint2() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    var elements = "";
    var length2 = codePoints.length;
    var i6 = 0;
    var code2;
    while (length2 > i6) {
      code2 = codePoints[i6++];
      if (code2 > 1114111)
        throw RangeError(code2 + " is not a valid code point");
      elements += code2 < 65536 ? String.fromCharCode(code2) : String.fromCharCode(((code2 -= 65536) >> 10) + 55296, code2 % 1024 + 56320);
    }
    return elements;
  }
);
var fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function fromEntries2(entries) {
      var obj = {};
      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var _a2 = entries_1[_i], k2 = _a2[0], v5 = _a2[1];
        obj[k2] = v5;
      }
      return obj;
    }
  )
);
var codePointAt = hasNativeCodePointAt ? (
  // Native
  function codePointAt2(s4, index2) {
    return s4.codePointAt(index2);
  }
) : (
  // IE 11
  function codePointAt3(s4, index2) {
    var size3 = s4.length;
    if (index2 < 0 || index2 >= size3) {
      return void 0;
    }
    var first = s4.charCodeAt(index2);
    var second;
    return first < 55296 || first > 56319 || index2 + 1 === size3 || (second = s4.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
  }
);
var trimStart = hasTrimStart ? (
  // Native
  function trimStart2(s4) {
    return s4.trimStart();
  }
) : (
  // Ponyfill
  function trimStart3(s4) {
    return s4.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
);
var trimEnd = hasTrimEnd ? (
  // Native
  function trimEnd2(s4) {
    return s4.trimEnd();
  }
) : (
  // Ponyfill
  function trimEnd3(s4) {
    return s4.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(s4, flag) {
  return new RegExp(s4, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s4, index2) {
    var _a2;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index2;
    var match3 = IDENTIFIER_PREFIX_RE_1.exec(s4);
    return (_a2 = match3[1]) !== null && _a2 !== void 0 ? _a2 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s4, index2) {
    var match3 = [];
    while (true) {
      var c5 = codePointAt(s4, index2);
      if (c5 === void 0 || _isWhiteSpace(c5) || _isPatternSyntax(c5)) {
        break;
      }
      match3.push(c5);
      index2 += c5 >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match3);
  };
}
var IDENTIFIER_PREFIX_RE_1;
var Parser = (
  /** @class */
  function() {
    function Parser3(message, options) {
      if (options === void 0) {
        options = {};
      }
      this.message = message;
      this.position = { offset: 0, line: 1, column: 1 };
      this.ignoreTag = !!options.ignoreTag;
      this.locale = options.locale;
      this.requiresOtherClause = !!options.requiresOtherClause;
      this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser3.prototype.parse = function() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    };
    Parser3.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
      var elements = [];
      while (!this.isEOF()) {
        var char2 = this.char();
        if (char2 === 123) {
          var result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char2 === 125 && nestingLevel > 0) {
          break;
        } else if (char2 === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          var position2 = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position2, this.clonePosition())
          });
        } else if (char2 === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char2 === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          var result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          var result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return { val: elements, err: null };
    };
    Parser3.prototype.parseTag = function(nestingLevel, parentArgType) {
      var startPosition = this.clonePosition();
      this.bump();
      var tagName3 = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(tagName3, "/>"),
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        var children = childrenResult.val;
        var endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          var closingTagNameStartPosition = this.clonePosition();
          var closingTagName = this.parseTagName();
          if (tagName3 !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName3,
              children,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    };
    Parser3.prototype.parseTagName = function() {
      var startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    };
    Parser3.prototype.parseLiteral = function(nestingLevel, parentArgType) {
      var start2 = this.clonePosition();
      var value2 = "";
      while (true) {
        var parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value2 += parseQuoteResult;
          continue;
        }
        var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value2 += parseUnquotedResult;
          continue;
        }
        var parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value2 += parseLeftAngleResult;
          continue;
        }
        break;
      }
      var location2 = createLocation(start2, this.clonePosition());
      return {
        val: { type: TYPE.literal, value: value2, location: location2 },
        err: null
      };
    };
    Parser3.prototype.tryParseLeftAngleBracket = function() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    };
    Parser3.prototype.tryParseQuote = function(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      var codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch);
        }
        this.bump();
      }
      return fromCodePoint.apply(void 0, codePoints);
    };
    Parser3.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      var ch = this.char();
      if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return fromCodePoint(ch);
      }
    };
    Parser3.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
      var openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      var value2 = this.parseIdentifierIfPossible().value;
      if (!value2) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value: value2,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value2, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    };
    Parser3.prototype.parseIdentifierIfPossible = function() {
      var startingPosition = this.clonePosition();
      var startOffset = this.offset();
      var value2 = matchIdentifierAtIndex(this.message, startOffset);
      var endOffset = startOffset + value2.length;
      this.bumpTo(endOffset);
      var endPosition = this.clonePosition();
      var location2 = createLocation(startingPosition, endPosition);
      return { value: value2, location: location2 };
    };
    Parser3.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value2, openingBracePosition) {
      var _a2;
      var typeStartPosition = this.clonePosition();
      var argType = this.parseIdentifierIfPossible().value;
      var typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var styleStartPosition = this.clonePosition();
            var result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            var style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = { style, styleLocation };
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_1 = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
            var skeleton = trimStart(styleAndLocation.style.slice(2));
            if (argType === "number") {
              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: { type: TYPE.number, value: value2, location: location_1, style: result.val },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
              }
              var dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              var style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              var type2 = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: { type: type2, value: value2, location: location_1, style },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value: value2,
              location: location_1,
              style: (_a2 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a2 !== void 0 ? _a2 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var typeEndPosition_1 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
          }
          this.bumpSpace();
          var identifierAndLocation = this.parseIdentifierIfPossible();
          var pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_2 = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value: value2,
                options: fromEntries(optionsResult.val),
                location: location_2
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value: value2,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location: location_2
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    };
    Parser3.prototype.tryParseArgumentClose = function(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return { val: true, err: null };
    };
    Parser3.prototype.parseSimpleArgStyleIfPossible = function() {
      var nestedBraces = 0;
      var startPosition = this.clonePosition();
      while (!this.isEOF()) {
        var ch = this.char();
        switch (ch) {
          case 39: {
            this.bump();
            var apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    };
    Parser3.prototype.parseNumberSkeletonFromString = function(skeleton, location2) {
      var tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e6) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location2);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location: location2,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    };
    Parser3.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      var _a2;
      var hasOtherClause = false;
      var options = [];
      var parsedSelectors = /* @__PURE__ */ new Set();
      var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
      while (true) {
        if (selector.length === 0) {
          var startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        var openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options.push([
          selector,
          {
            value: fragmentResult.val,
            location: createLocation(openingBracePosition, this.clonePosition())
          }
        ]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        _a2 = this.parseIdentifierIfPossible(), selector = _a2.value, selectorLocation = _a2.location;
      }
      if (options.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return { val: options, err: null };
    };
    Parser3.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
      var sign = 1;
      var startingPosition = this.clonePosition();
      if (this.bumpIf("+")) {
      } else if (this.bumpIf("-")) {
        sign = -1;
      }
      var hasDigits = false;
      var decimal = 0;
      while (!this.isEOF()) {
        var ch = this.char();
        if (ch >= 48 && ch <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch - 48);
          this.bump();
        } else {
          break;
        }
      }
      var location2 = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location2);
      }
      decimal *= sign;
      if (!isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location2);
      }
      return { val: decimal, err: null };
    };
    Parser3.prototype.offset = function() {
      return this.position.offset;
    };
    Parser3.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    };
    Parser3.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    };
    Parser3.prototype.char = function() {
      var offset = this.position.offset;
      if (offset >= this.message.length) {
        throw Error("out of bound");
      }
      var code2 = codePointAt(this.message, offset);
      if (code2 === void 0) {
        throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
      }
      return code2;
    };
    Parser3.prototype.error = function(kind, location2) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location: location2
        }
      };
    };
    Parser3.prototype.bump = function() {
      if (this.isEOF()) {
        return;
      }
      var code2 = this.char();
      if (code2 === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code2 < 65536 ? 1 : 2;
      }
    };
    Parser3.prototype.bumpIf = function(prefix3) {
      if (startsWith(this.message, prefix3, this.offset())) {
        for (var i6 = 0; i6 < prefix3.length; i6++) {
          this.bump();
        }
        return true;
      }
      return false;
    };
    Parser3.prototype.bumpUntil = function(pattern) {
      var currentOffset = this.offset();
      var index2 = this.message.indexOf(pattern, currentOffset);
      if (index2 >= 0) {
        this.bumpTo(index2);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    };
    Parser3.prototype.bumpTo = function(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        var offset = this.offset();
        if (offset === targetOffset) {
          break;
        }
        if (offset > targetOffset) {
          throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    };
    Parser3.prototype.bumpSpace = function() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    };
    Parser3.prototype.peek = function() {
      if (this.isEOF()) {
        return null;
      }
      var code2 = this.char();
      var offset = this.offset();
      var nextCode = this.message.charCodeAt(offset + (code2 >= 65536 ? 2 : 1));
      return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser3;
  }()
);
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c5) {
  return c5 === 45 || c5 === 46 || c5 >= 48 && c5 <= 57 || c5 === 95 || c5 >= 97 && c5 <= 122 || c5 >= 65 && c5 <= 90 || c5 == 183 || c5 >= 192 && c5 <= 214 || c5 >= 216 && c5 <= 246 || c5 >= 248 && c5 <= 893 || c5 >= 895 && c5 <= 8191 || c5 >= 8204 && c5 <= 8205 || c5 >= 8255 && c5 <= 8256 || c5 >= 8304 && c5 <= 8591 || c5 >= 11264 && c5 <= 12271 || c5 >= 12289 && c5 <= 55295 || c5 >= 63744 && c5 <= 64975 || c5 >= 65008 && c5 <= 65533 || c5 >= 65536 && c5 <= 983039;
}
function _isWhiteSpace(c5) {
  return c5 >= 9 && c5 <= 13 || c5 === 32 || c5 === 133 || c5 >= 8206 && c5 <= 8207 || c5 === 8232 || c5 === 8233;
}
function _isPatternSyntax(c5) {
  return c5 >= 33 && c5 <= 35 || c5 === 36 || c5 >= 37 && c5 <= 39 || c5 === 40 || c5 === 41 || c5 === 42 || c5 === 43 || c5 === 44 || c5 === 45 || c5 >= 46 && c5 <= 47 || c5 >= 58 && c5 <= 59 || c5 >= 60 && c5 <= 62 || c5 >= 63 && c5 <= 64 || c5 === 91 || c5 === 92 || c5 === 93 || c5 === 94 || c5 === 96 || c5 === 123 || c5 === 124 || c5 === 125 || c5 === 126 || c5 === 161 || c5 >= 162 && c5 <= 165 || c5 === 166 || c5 === 167 || c5 === 169 || c5 === 171 || c5 === 172 || c5 === 174 || c5 === 176 || c5 === 177 || c5 === 182 || c5 === 187 || c5 === 191 || c5 === 215 || c5 === 247 || c5 >= 8208 && c5 <= 8213 || c5 >= 8214 && c5 <= 8215 || c5 === 8216 || c5 === 8217 || c5 === 8218 || c5 >= 8219 && c5 <= 8220 || c5 === 8221 || c5 === 8222 || c5 === 8223 || c5 >= 8224 && c5 <= 8231 || c5 >= 8240 && c5 <= 8248 || c5 === 8249 || c5 === 8250 || c5 >= 8251 && c5 <= 8254 || c5 >= 8257 && c5 <= 8259 || c5 === 8260 || c5 === 8261 || c5 === 8262 || c5 >= 8263 && c5 <= 8273 || c5 === 8274 || c5 === 8275 || c5 >= 8277 && c5 <= 8286 || c5 >= 8592 && c5 <= 8596 || c5 >= 8597 && c5 <= 8601 || c5 >= 8602 && c5 <= 8603 || c5 >= 8604 && c5 <= 8607 || c5 === 8608 || c5 >= 8609 && c5 <= 8610 || c5 === 8611 || c5 >= 8612 && c5 <= 8613 || c5 === 8614 || c5 >= 8615 && c5 <= 8621 || c5 === 8622 || c5 >= 8623 && c5 <= 8653 || c5 >= 8654 && c5 <= 8655 || c5 >= 8656 && c5 <= 8657 || c5 === 8658 || c5 === 8659 || c5 === 8660 || c5 >= 8661 && c5 <= 8691 || c5 >= 8692 && c5 <= 8959 || c5 >= 8960 && c5 <= 8967 || c5 === 8968 || c5 === 8969 || c5 === 8970 || c5 === 8971 || c5 >= 8972 && c5 <= 8991 || c5 >= 8992 && c5 <= 8993 || c5 >= 8994 && c5 <= 9e3 || c5 === 9001 || c5 === 9002 || c5 >= 9003 && c5 <= 9083 || c5 === 9084 || c5 >= 9085 && c5 <= 9114 || c5 >= 9115 && c5 <= 9139 || c5 >= 9140 && c5 <= 9179 || c5 >= 9180 && c5 <= 9185 || c5 >= 9186 && c5 <= 9254 || c5 >= 9255 && c5 <= 9279 || c5 >= 9280 && c5 <= 9290 || c5 >= 9291 && c5 <= 9311 || c5 >= 9472 && c5 <= 9654 || c5 === 9655 || c5 >= 9656 && c5 <= 9664 || c5 === 9665 || c5 >= 9666 && c5 <= 9719 || c5 >= 9720 && c5 <= 9727 || c5 >= 9728 && c5 <= 9838 || c5 === 9839 || c5 >= 9840 && c5 <= 10087 || c5 === 10088 || c5 === 10089 || c5 === 10090 || c5 === 10091 || c5 === 10092 || c5 === 10093 || c5 === 10094 || c5 === 10095 || c5 === 10096 || c5 === 10097 || c5 === 10098 || c5 === 10099 || c5 === 10100 || c5 === 10101 || c5 >= 10132 && c5 <= 10175 || c5 >= 10176 && c5 <= 10180 || c5 === 10181 || c5 === 10182 || c5 >= 10183 && c5 <= 10213 || c5 === 10214 || c5 === 10215 || c5 === 10216 || c5 === 10217 || c5 === 10218 || c5 === 10219 || c5 === 10220 || c5 === 10221 || c5 === 10222 || c5 === 10223 || c5 >= 10224 && c5 <= 10239 || c5 >= 10240 && c5 <= 10495 || c5 >= 10496 && c5 <= 10626 || c5 === 10627 || c5 === 10628 || c5 === 10629 || c5 === 10630 || c5 === 10631 || c5 === 10632 || c5 === 10633 || c5 === 10634 || c5 === 10635 || c5 === 10636 || c5 === 10637 || c5 === 10638 || c5 === 10639 || c5 === 10640 || c5 === 10641 || c5 === 10642 || c5 === 10643 || c5 === 10644 || c5 === 10645 || c5 === 10646 || c5 === 10647 || c5 === 10648 || c5 >= 10649 && c5 <= 10711 || c5 === 10712 || c5 === 10713 || c5 === 10714 || c5 === 10715 || c5 >= 10716 && c5 <= 10747 || c5 === 10748 || c5 === 10749 || c5 >= 10750 && c5 <= 11007 || c5 >= 11008 && c5 <= 11055 || c5 >= 11056 && c5 <= 11076 || c5 >= 11077 && c5 <= 11078 || c5 >= 11079 && c5 <= 11084 || c5 >= 11085 && c5 <= 11123 || c5 >= 11124 && c5 <= 11125 || c5 >= 11126 && c5 <= 11157 || c5 === 11158 || c5 >= 11159 && c5 <= 11263 || c5 >= 11776 && c5 <= 11777 || c5 === 11778 || c5 === 11779 || c5 === 11780 || c5 === 11781 || c5 >= 11782 && c5 <= 11784 || c5 === 11785 || c5 === 11786 || c5 === 11787 || c5 === 11788 || c5 === 11789 || c5 >= 11790 && c5 <= 11798 || c5 === 11799 || c5 >= 11800 && c5 <= 11801 || c5 === 11802 || c5 === 11803 || c5 === 11804 || c5 === 11805 || c5 >= 11806 && c5 <= 11807 || c5 === 11808 || c5 === 11809 || c5 === 11810 || c5 === 11811 || c5 === 11812 || c5 === 11813 || c5 === 11814 || c5 === 11815 || c5 === 11816 || c5 === 11817 || c5 >= 11818 && c5 <= 11822 || c5 === 11823 || c5 >= 11824 && c5 <= 11833 || c5 >= 11834 && c5 <= 11835 || c5 >= 11836 && c5 <= 11839 || c5 === 11840 || c5 === 11841 || c5 === 11842 || c5 >= 11843 && c5 <= 11855 || c5 >= 11856 && c5 <= 11857 || c5 === 11858 || c5 >= 11859 && c5 <= 11903 || c5 >= 12289 && c5 <= 12291 || c5 === 12296 || c5 === 12297 || c5 === 12298 || c5 === 12299 || c5 === 12300 || c5 === 12301 || c5 === 12302 || c5 === 12303 || c5 === 12304 || c5 === 12305 || c5 >= 12306 && c5 <= 12307 || c5 === 12308 || c5 === 12309 || c5 === 12310 || c5 === 12311 || c5 === 12312 || c5 === 12313 || c5 === 12314 || c5 === 12315 || c5 === 12316 || c5 === 12317 || c5 >= 12318 && c5 <= 12319 || c5 === 12320 || c5 === 12336 || c5 === 64830 || c5 === 64831 || c5 >= 65093 && c5 <= 65094;
}

// node_modules/.pnpm/@formatjs+icu-messageformat-parser@2.7.3/node_modules/@formatjs/icu-messageformat-parser/lib/index.js
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k2 in el.options) {
        delete el.options[k2].location;
        pruneLocation(el.options[k2].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser(message, opts).parse();
  if (result.err) {
    var error3 = SyntaxError(ErrorKind[result.err.kind]);
    error3.location = result.err.location;
    error3.originalMessage = result.err.message;
    throw error3;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}

// node_modules/.pnpm/@formatjs+fast-memoize@2.2.0/node_modules/@formatjs/fast-memoize/lib/index.js
function memoize(fn2, options) {
  var cache3 = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn2, {
    cache: cache3,
    serializer
  });
}
function isPrimitive(value2) {
  return value2 == null || typeof value2 === "number" || typeof value2 === "boolean";
}
function monadic(fn2, cache3, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache3.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.call(this, arg);
    cache3.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn2, cache3, serializer) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args);
  var computedValue = cache3.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.apply(this, args);
    cache3.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn2, context, strategy, cache3, serialize2) {
  return strategy.bind(context, fn2, cache3, serialize2);
}
function strategyDefault(fn2, options) {
  var strategy = fn2.length === 1 ? monadic : variadic;
  return assemble(fn2, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn2, options) {
  return assemble(fn2, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn2, options) {
  return assemble(fn2, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value2) {
  this.cache[key] = value2;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};

// node_modules/.pnpm/intl-messageformat@10.5.8/node_modules/intl-messageformat/lib/src/error.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(_super) {
    __extends(FormatError2, _super);
    function FormatError2(msg2, code2, originalMessage) {
      var _this = _super.call(this, msg2) || this;
      _this.code = code2;
      _this.originalMessage = originalMessage;
      return _this;
    }
    FormatError2.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError2;
  }(Error)
);
var InvalidValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueError2, _super);
    function InvalidValueError2(variableId, value2, options, originalMessage) {
      return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value2, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError2;
  }(FormatError)
);
var InvalidValueTypeError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueTypeError2, _super);
    function InvalidValueTypeError2(value2, type2, originalMessage) {
      return _super.call(this, 'Value for "'.concat(value2, '" must be of type ').concat(type2), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError2;
  }(FormatError)
);
var MissingValueError = (
  /** @class */
  function(_super) {
    __extends(MissingValueError2, _super);
    function MissingValueError2(variableId, originalMessage) {
      return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError2;
  }(FormatError)
);

// node_modules/.pnpm/intl-messageformat@10.5.8/node_modules/intl-messageformat/lib/src/formatters.js
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values2, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values2 && varName in values2)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value2 = values2[varName];
    if (isArgumentElement(el)) {
      if (!value2 || typeof value2 === "string" || typeof value2 === "number") {
        value2 = typeof value2 === "string" || typeof value2 === "number" ? String(value2) : "";
      }
      result.push({
        type: typeof value2 === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value: value2
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value2 = value2 * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value2)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children = el.children, value_1 = el.value;
      var formatFn = values2[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children, locales, formatters, formats, values2, currentPluralValue);
      var chunks = formatFn(parts.map(function(p5) {
        return p5.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c5) {
        return {
          type: typeof c5 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c5
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value2] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value2, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values2));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value2)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value2 - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value2, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values2, value2 - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}

// node_modules/.pnpm/intl-messageformat@10.5.8/node_modules/intl-messageformat/lib/src/core.js
function mergeConfig(c1, c22) {
  if (!c22) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c22 || {}), Object.keys(c1).reduce(function(all, k2) {
    all[k2] = __assign(__assign({}, c1[k2]), c22[k2] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k2) {
    all[k2] = mergeConfig(defaultConfig[k2], configs[k2]);
    return all;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value2) {
          store[key] = value2;
        }
      };
    }
  };
}
function createDefaultFormatters(cache3) {
  if (cache3 === void 0) {
    cache3 = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache3.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function IntlMessageFormat2(message, locales, overrideFormats, opts) {
      var _this = this;
      if (locales === void 0) {
        locales = IntlMessageFormat2.defaultLocale;
      }
      this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      };
      this.format = function(values2) {
        var parts = _this.formatToParts(values2);
        if (parts.length === 1) {
          return parts[0].value;
        }
        var result = parts.reduce(function(all, part) {
          if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
            all.push(part.value);
          } else {
            all[all.length - 1] += part.value;
          }
          return all;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      };
      this.formatToParts = function(values2) {
        return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values2, void 0, _this.message);
      };
      this.resolvedOptions = function() {
        var _a3;
        return {
          locale: ((_a3 = _this.resolvedLocale) === null || _a3 === void 0 ? void 0 : _a3.toString()) || Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
        };
      };
      this.getAst = function() {
        return _this.ast;
      };
      this.locales = locales;
      this.resolvedLocale = IntlMessageFormat2.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!IntlMessageFormat2.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        var _a2 = opts || {}, formatters = _a2.formatters, parseOpts = __rest(_a2, ["formatters"]);
        this.ast = IntlMessageFormat2.__parse(message, __assign(__assign({}, parseOpts), { locale: this.resolvedLocale }));
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
      get: function() {
        if (!IntlMessageFormat2.memoizedDefaultLocale) {
          IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
        }
        return IntlMessageFormat2.memoizedDefaultLocale;
      },
      enumerable: false,
      configurable: true
    });
    IntlMessageFormat2.memoizedDefaultLocale = null;
    IntlMessageFormat2.resolveLocale = function(locales) {
      if (typeof Intl.Locale === "undefined") {
        return;
      }
      var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
      if (supportedLocales.length > 0) {
        return new Intl.Locale(supportedLocales[0]);
      }
      return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
    };
    IntlMessageFormat2.__parse = parse;
    IntlMessageFormat2.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    return IntlMessageFormat2;
  }()
);

// node_modules/.pnpm/@react-aria+i18n@3.9.0_react@18.2.0/node_modules/@react-aria/i18n/dist/useMessageFormatter.module.mjs
var import_react5 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+overlays@3.19.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/overlays/dist/import.mjs
var import_react9 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+focus@3.15.0_react@18.2.0/node_modules/@react-aria/focus/dist/import.mjs
var import_react7 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+interactions@3.20.0_react@18.2.0/node_modules/@react-aria/interactions/dist/import.mjs
var import_react6 = __toESM(require_react(), 1);

// node_modules/.pnpm/@swc+helpers@0.5.3/node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js
function _class_apply_descriptor_get(receiver, descriptor) {
  if (descriptor.get)
    return descriptor.get.call(receiver);
  return descriptor.value;
}

// node_modules/.pnpm/@swc+helpers@0.5.3/node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}

// node_modules/.pnpm/@swc+helpers@0.5.3/node_modules/@swc/helpers/esm/_class_private_field_get.js
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}

// node_modules/.pnpm/@swc+helpers@0.5.3/node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js
function _class_apply_descriptor_set(receiver, descriptor, value2) {
  if (descriptor.set)
    descriptor.set.call(receiver, value2);
  else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value2;
  }
}

// node_modules/.pnpm/@swc+helpers@0.5.3/node_modules/@swc/helpers/esm/_class_private_field_set.js
function _class_private_field_set(receiver, privateMap, value2) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  _class_apply_descriptor_set(receiver, descriptor, value2);
  return value2;
}

// node_modules/.pnpm/@react-aria+interactions@3.20.0_react@18.2.0/node_modules/@react-aria/interactions/dist/import.mjs
var $14c0b72509d70225$var$state = "default";
var $14c0b72509d70225$var$savedUserSelect = "";
var $14c0b72509d70225$var$modifiedElementMap = /* @__PURE__ */ new WeakMap();
function $14c0b72509d70225$export$16a4697467175487(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) {
    if ($14c0b72509d70225$var$state === "default") {
      const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(target);
      $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;
      documentObject.documentElement.style.webkitUserSelect = "none";
    }
    $14c0b72509d70225$var$state = "disabled";
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
}
function $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f1)()) {
    if ($14c0b72509d70225$var$state !== "disabled")
      return;
    $14c0b72509d70225$var$state = "restoring";
    setTimeout(() => {
      (0, $bbed8b41f857bcc0$export$24490316f764c430)(() => {
        if ($14c0b72509d70225$var$state === "restoring") {
          const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(target);
          if (documentObject.documentElement.style.webkitUserSelect === "none")
            documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || "";
          $14c0b72509d70225$var$savedUserSelect = "";
          $14c0b72509d70225$var$state = "default";
        }
      });
    }, 300);
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {
      let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);
      if (target.style.userSelect === "none" && targetOldUserSelect)
        target.style.userSelect = targetOldUserSelect;
      if (target.getAttribute("style") === "")
        target.removeAttribute("style");
      $14c0b72509d70225$var$modifiedElementMap.delete(target);
    }
  }
}
var $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, import_react6.default).createContext({
  register: () => {
  }
});
$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = "PressResponderContext";
function $f6c31cce2adf654f$var$usePressResponderContext(props) {
  let context = (0, import_react6.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  if (context) {
    let { register, ...contextProps } = context;
    props = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(contextProps, props);
    register();
  }
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(context, props.ref);
  return props;
}
var $f6c31cce2adf654f$var$_shouldStopPropagation = /* @__PURE__ */ new WeakMap();
var $f6c31cce2adf654f$var$PressEvent = class {
  continuePropagation() {
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);
  }
  get shouldStopPropagation() {
    return (0, _class_private_field_get)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);
  }
  constructor(type2, pointerType, originalEvent) {
    (0, _class_private_field_init)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {
      writable: true,
      value: void 0
    });
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);
    this.type = type2;
    this.pointerType = pointerType;
    this.target = originalEvent.currentTarget;
    this.shiftKey = originalEvent.shiftKey;
    this.metaKey = originalEvent.metaKey;
    this.ctrlKey = originalEvent.ctrlKey;
    this.altKey = originalEvent.altKey;
  }
};
var $f6c31cce2adf654f$var$LINK_CLICKED = Symbol("linkClicked");
function $f6c31cce2adf654f$export$45712eceda6fad21(props) {
  let {
    onPress,
    onPressChange,
    onPressStart,
    onPressEnd,
    onPressUp,
    isDisabled,
    isPressed: isPressedProp,
    preventFocusOnPress,
    shouldCancelOnPointerExit,
    allowTextSelectionOnPress,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _2,
    ...domProps
  } = $f6c31cce2adf654f$var$usePressResponderContext(props);
  let [isPressed, setPressed] = (0, import_react6.useState)(false);
  let ref = (0, import_react6.useRef)({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    ignoreClickAfterPress: false,
    didFirePressStart: false,
    isTriggeringEvent: false,
    activePointerId: null,
    target: null,
    isOverTarget: false,
    pointerType: null
  });
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let triggerPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled || state.didFirePressStart)
      return false;
    let shouldStopPropagation = true;
    state.isTriggeringEvent = true;
    if (onPressStart) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressstart", pointerType, originalEvent);
      onPressStart(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange)
      onPressChange(true);
    state.isTriggeringEvent = false;
    state.didFirePressStart = true;
    setPressed(true);
    return shouldStopPropagation;
  });
  let triggerPressEnd = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType, wasPressed = true) => {
    let state = ref.current;
    if (!state.didFirePressStart)
      return false;
    state.ignoreClickAfterPress = true;
    state.didFirePressStart = false;
    state.isTriggeringEvent = true;
    let shouldStopPropagation = true;
    if (onPressEnd) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressend", pointerType, originalEvent);
      onPressEnd(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange)
      onPressChange(false);
    setPressed(false);
    if (onPress && wasPressed && !isDisabled) {
      let event = new $f6c31cce2adf654f$var$PressEvent("press", pointerType, originalEvent);
      onPress(event);
      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);
    }
    state.isTriggeringEvent = false;
    return shouldStopPropagation;
  });
  let triggerPressUp = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled)
      return false;
    if (onPressUp) {
      state.isTriggeringEvent = true;
      let event = new $f6c31cce2adf654f$var$PressEvent("pressup", pointerType, originalEvent);
      onPressUp(event);
      state.isTriggeringEvent = false;
      return event.shouldStopPropagation;
    }
    return true;
  });
  let cancel = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    let state = ref.current;
    if (state.isPressed && state.target) {
      if (state.isOverTarget && state.pointerType != null)
        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType, false);
      state.isPressed = false;
      state.isOverTarget = false;
      state.activePointerId = null;
      state.pointerType = null;
      removeAllGlobalListeners();
      if (!allowTextSelectionOnPress)
        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
    }
  });
  let cancelOnPointerExit = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (shouldCancelOnPointerExit)
      cancel(e6);
  });
  let pressProps = (0, import_react6.useMemo)(() => {
    let state = ref.current;
    let pressProps2 = {
      onKeyDown(e6) {
        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e6.nativeEvent, e6.currentTarget) && e6.currentTarget.contains(e6.target)) {
          var _state_metaKeyEvents;
          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e6.target, e6.key))
            e6.preventDefault();
          let shouldStopPropagation = true;
          if (!state.isPressed && !e6.repeat) {
            state.target = e6.currentTarget;
            state.isPressed = true;
            shouldStopPropagation = triggerPressStart(e6, "keyboard");
            addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "keyup", onKeyUp, false);
          }
          if (shouldStopPropagation)
            e6.stopPropagation();
          if (e6.metaKey && (0, $c87311424ea30a05$export$9ac100e40613ea10)())
            (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e6.key, e6.nativeEvent);
        } else if (e6.key === "Meta")
          state.metaKeyEvents = /* @__PURE__ */ new Map();
      },
      onKeyUp(e6) {
        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e6.nativeEvent, e6.currentTarget) && !e6.repeat && e6.currentTarget.contains(e6.target) && state.target)
          triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e6), "keyboard");
      },
      onClick(e6) {
        if (e6 && !e6.currentTarget.contains(e6.target))
          return;
        if (e6 && e6.button === 0 && !state.isTriggeringEvent && !(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7).isOpening) {
          let shouldStopPropagation = true;
          if (isDisabled)
            e6.preventDefault();
          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === "virtual" || (0, $6a7db85432448f7f$export$60278871457622de)(e6.nativeEvent))) {
            if (!isDisabled && !preventFocusOnPress)
              (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e6.currentTarget);
            let stopPressStart = triggerPressStart(e6, "virtual");
            let stopPressUp = triggerPressUp(e6, "virtual");
            let stopPressEnd = triggerPressEnd(e6, "virtual");
            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;
          }
          state.ignoreEmulatedMouseEvents = false;
          state.ignoreClickAfterPress = false;
          if (shouldStopPropagation)
            e6.stopPropagation();
        }
      }
    };
    let onKeyUp = (e6) => {
      var _state_metaKeyEvents;
      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e6, state.target)) {
        var _state_metaKeyEvents1;
        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e6.target, e6.key))
          e6.preventDefault();
        let target = e6.target;
        let shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), "keyboard", state.target.contains(target));
        removeAllGlobalListeners();
        if (shouldStopPropagation)
          e6.stopPropagation();
        if (e6.key !== "Enter" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e6[$f6c31cce2adf654f$var$LINK_CLICKED]) {
          e6[$f6c31cce2adf654f$var$LINK_CLICKED] = true;
          (0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7)(state.target, e6, false);
        }
        state.isPressed = false;
        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e6.key);
      } else if (e6.key === "Meta" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {
        var _state_target;
        let events2 = state.metaKeyEvents;
        state.metaKeyEvents = void 0;
        for (let event of events2.values())
          (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent("keyup", event));
      }
    };
    if (typeof PointerEvent !== "undefined") {
      pressProps2.onPointerDown = (e6) => {
        if (e6.button !== 0 || !e6.currentTarget.contains(e6.target))
          return;
        if ((0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e6.nativeEvent)) {
          state.pointerType = "virtual";
          return;
        }
        if ($f6c31cce2adf654f$var$shouldPreventDefault(e6.currentTarget))
          e6.preventDefault();
        state.pointerType = e6.pointerType;
        let shouldStopPropagation = true;
        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e6.pointerId;
          state.target = e6.currentTarget;
          if (!isDisabled && !preventFocusOnPress)
            (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e6.currentTarget);
          if (!allowTextSelectionOnPress)
            (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
          shouldStopPropagation = triggerPressStart(e6, state.pointerType);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "pointermove", onPointerMove, false);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "pointerup", onPointerUp, false);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "pointercancel", onPointerCancel, false);
        }
        if (shouldStopPropagation)
          e6.stopPropagation();
      };
      pressProps2.onMouseDown = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        if (e6.button === 0) {
          if ($f6c31cce2adf654f$var$shouldPreventDefault(e6.currentTarget))
            e6.preventDefault();
          e6.stopPropagation();
        }
      };
      pressProps2.onPointerUp = (e6) => {
        if (!e6.currentTarget.contains(e6.target) || state.pointerType === "virtual")
          return;
        if (e6.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e6, e6.currentTarget))
          triggerPressUp(e6, state.pointerType || e6.pointerType);
      };
      let onPointerMove = (e6) => {
        if (e6.pointerId !== state.activePointerId)
          return;
        if (state.target && $f6c31cce2adf654f$var$isOverTarget(e6, state.target)) {
          if (!state.isOverTarget && state.pointerType != null) {
            state.isOverTarget = true;
            triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType);
          }
        } else if (state.target && state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType, false);
          cancelOnPointerExit(e6);
        }
      };
      let onPointerUp = (e6) => {
        if (e6.pointerId === state.activePointerId && state.isPressed && e6.button === 0 && state.target) {
          if ($f6c31cce2adf654f$var$isOverTarget(e6, state.target) && state.pointerType != null)
            triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType);
          else if (state.isOverTarget && state.pointerType != null)
            triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType, false);
          state.isPressed = false;
          state.isOverTarget = false;
          state.activePointerId = null;
          state.pointerType = null;
          removeAllGlobalListeners();
          if (!allowTextSelectionOnPress)
            (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
        }
      };
      let onPointerCancel = (e6) => {
        cancel(e6);
      };
      pressProps2.onDragStart = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        cancel(e6);
      };
    } else {
      pressProps2.onMouseDown = (e6) => {
        if (e6.button !== 0 || !e6.currentTarget.contains(e6.target))
          return;
        if ($f6c31cce2adf654f$var$shouldPreventDefault(e6.currentTarget))
          e6.preventDefault();
        if (state.ignoreEmulatedMouseEvents) {
          e6.stopPropagation();
          return;
        }
        state.isPressed = true;
        state.isOverTarget = true;
        state.target = e6.currentTarget;
        state.pointerType = (0, $6a7db85432448f7f$export$60278871457622de)(e6.nativeEvent) ? "virtual" : "mouse";
        if (!isDisabled && !preventFocusOnPress)
          (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e6.currentTarget);
        let shouldStopPropagation = triggerPressStart(e6, state.pointerType);
        if (shouldStopPropagation)
          e6.stopPropagation();
        addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac)(e6.currentTarget), "mouseup", onMouseUp, false);
      };
      pressProps2.onMouseEnter = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = true;
          shouldStopPropagation = triggerPressStart(e6, state.pointerType);
        }
        if (shouldStopPropagation)
          e6.stopPropagation();
      };
      pressProps2.onMouseLeave = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd(e6, state.pointerType, false);
          cancelOnPointerExit(e6);
        }
        if (shouldStopPropagation)
          e6.stopPropagation();
      };
      pressProps2.onMouseUp = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        if (!state.ignoreEmulatedMouseEvents && e6.button === 0)
          triggerPressUp(e6, state.pointerType || "mouse");
      };
      let onMouseUp = (e6) => {
        if (e6.button !== 0)
          return;
        state.isPressed = false;
        removeAllGlobalListeners();
        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
          return;
        }
        if (state.target && $f6c31cce2adf654f$var$isOverTarget(e6, state.target) && state.pointerType != null)
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType);
        else if (state.target && state.isOverTarget && state.pointerType != null)
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e6), state.pointerType, false);
        state.isOverTarget = false;
      };
      pressProps2.onTouchStart = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e6.nativeEvent);
        if (!touch)
          return;
        state.activePointerId = touch.identifier;
        state.ignoreEmulatedMouseEvents = true;
        state.isOverTarget = true;
        state.isPressed = true;
        state.target = e6.currentTarget;
        state.pointerType = "touch";
        if (!isDisabled && !preventFocusOnPress)
          (0, $7215afc6de606d6b$export$de79e2c695e052f3)(e6.currentTarget);
        if (!allowTextSelectionOnPress)
          (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
        let shouldStopPropagation = triggerPressStart(e6, state.pointerType);
        if (shouldStopPropagation)
          e6.stopPropagation();
        addGlobalListener((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e6.currentTarget), "scroll", onScroll, true);
      };
      pressProps2.onTouchMove = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        if (!state.isPressed) {
          e6.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e6.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e6.currentTarget)) {
          if (!state.isOverTarget && state.pointerType != null) {
            state.isOverTarget = true;
            shouldStopPropagation = triggerPressStart(e6, state.pointerType);
          }
        } else if (state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd(e6, state.pointerType, false);
          cancelOnPointerExit(e6);
        }
        if (shouldStopPropagation)
          e6.stopPropagation();
      };
      pressProps2.onTouchEnd = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        if (!state.isPressed) {
          e6.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e6.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e6.currentTarget) && state.pointerType != null) {
          triggerPressUp(e6, state.pointerType);
          shouldStopPropagation = triggerPressEnd(e6, state.pointerType);
        } else if (state.isOverTarget && state.pointerType != null)
          shouldStopPropagation = triggerPressEnd(e6, state.pointerType, false);
        if (shouldStopPropagation)
          e6.stopPropagation();
        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        state.ignoreEmulatedMouseEvents = true;
        if (state.target && !allowTextSelectionOnPress)
          (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
        removeAllGlobalListeners();
      };
      pressProps2.onTouchCancel = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        e6.stopPropagation();
        if (state.isPressed)
          cancel(e6);
      };
      let onScroll = (e6) => {
        if (state.isPressed && e6.target.contains(state.target))
          cancel({
            currentTarget: state.target,
            shiftKey: false,
            ctrlKey: false,
            metaKey: false,
            altKey: false
          });
      };
      pressProps2.onDragStart = (e6) => {
        if (!e6.currentTarget.contains(e6.target))
          return;
        cancel(e6);
      };
    }
    return pressProps2;
  }, [
    addGlobalListener,
    isDisabled,
    preventFocusOnPress,
    removeAllGlobalListeners,
    allowTextSelectionOnPress,
    cancel,
    cancelOnPointerExit,
    triggerPressEnd,
    triggerPressStart,
    triggerPressUp
  ]);
  (0, import_react6.useEffect)(() => {
    return () => {
      var _ref_current_target;
      if (!allowTextSelectionOnPress)
        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : void 0);
    };
  }, [
    allowTextSelectionOnPress
  ]);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, pressProps)
  };
}
function $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {
  const { key, code: code2 } = event;
  const element2 = currentTarget;
  const role = element2.getAttribute("role");
  return (key === "Enter" || key === " " || key === "Spacebar" || code2 === "Space") && !(element2 instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element2).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element2, key) || element2 instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element2).HTMLTextAreaElement || element2.isContentEditable) && // Links should only trigger with Enter key
  !((role === "link" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element2)) && key !== "Enter");
}
function $f6c31cce2adf654f$var$getTouchFromEvent(event) {
  const { targetTouches } = event;
  if (targetTouches.length > 0)
    return targetTouches[0];
  return null;
}
function $f6c31cce2adf654f$var$getTouchById(event, pointerId) {
  const changedTouches = event.changedTouches;
  for (let i6 = 0; i6 < changedTouches.length; i6++) {
    const touch = changedTouches[i6];
    if (touch.identifier === pointerId)
      return touch;
  }
  return null;
}
function $f6c31cce2adf654f$var$createEvent(target, e6) {
  return {
    currentTarget: target,
    shiftKey: e6.shiftKey,
    ctrlKey: e6.ctrlKey,
    metaKey: e6.metaKey,
    altKey: e6.altKey
  };
}
function $f6c31cce2adf654f$var$getPointClientRect(point) {
  let offsetX = 0;
  let offsetY = 0;
  if (point.width !== void 0)
    offsetX = point.width / 2;
  else if (point.radiusX !== void 0)
    offsetX = point.radiusX;
  if (point.height !== void 0)
    offsetY = point.height / 2;
  else if (point.radiusY !== void 0)
    offsetY = point.radiusY;
  return {
    top: point.clientY - offsetY,
    right: point.clientX + offsetX,
    bottom: point.clientY + offsetY,
    left: point.clientX - offsetX
  };
}
function $f6c31cce2adf654f$var$areRectanglesOverlapping(a3, b2) {
  if (a3.left > b2.right || b2.left > a3.right)
    return false;
  if (a3.top > b2.bottom || b2.top > a3.bottom)
    return false;
  return true;
}
function $f6c31cce2adf654f$var$isOverTarget(point, target) {
  let rect = target.getBoundingClientRect();
  let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);
  return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);
}
function $f6c31cce2adf654f$var$shouldPreventDefault(target) {
  return !(target instanceof HTMLElement) || !target.hasAttribute("draggable");
}
function $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {
  if (target instanceof HTMLInputElement)
    return !$f6c31cce2adf654f$var$isValidInputKey(target, key);
  if (target instanceof HTMLButtonElement)
    return target.type !== "submit" && target.type !== "reset";
  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target))
    return false;
  return true;
}
var $f6c31cce2adf654f$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $f6c31cce2adf654f$var$isValidInputKey(target, key) {
  return target.type === "checkbox" || target.type === "radio" ? key === " " : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);
}
var $3b117e43dc0ca95d$export$27c701ed9e449e99 = (0, import_react6.default).forwardRef(({ children, ...props }, ref) => {
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    ...props,
    ref
  });
  let child = (0, import_react6.default).Children.only(children);
  return (0, import_react6.default).cloneElement(
    child,
    // @ts-ignore
    {
      ref,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(child.props, pressProps)
    }
  );
});
var $f1ab8c75478c6f73$export$3351871ee4b288b8 = (0, import_react6.default).forwardRef(({ children, ...props }, ref) => {
  let isRegistered = (0, import_react6.useRef)(false);
  let prevContext = (0, import_react6.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  ref = (0, $df56164dff5785e2$export$4338b53315abf666)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));
  let context = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(prevContext || {}, {
    ...props,
    ref,
    register() {
      isRegistered.current = true;
      if (prevContext)
        prevContext.register();
    }
  });
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(prevContext, ref);
  (0, import_react6.useEffect)(() => {
    if (!isRegistered.current) {
      console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
      isRegistered.current = true;
    }
  }, []);
  return (0, import_react6.default).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
    value: context
  }, children);
});
function $f1ab8c75478c6f73$export$cf75428e0b9ed1ea({ children }) {
  let context = (0, import_react6.useMemo)(() => ({
    register: () => {
    }
  }), []);
  return (0, import_react6.default).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
    value: context
  }, children);
}
var $8a9cb279dc87e130$export$905e7fc544a71f36 = class {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = true;
    this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation();
    this.isPropagationStopped = () => true;
  }
  isPropagationStopped() {
    return false;
  }
  persist() {
  }
  constructor(type2, nativeEvent) {
    this.nativeEvent = nativeEvent;
    this.target = nativeEvent.target;
    this.currentTarget = nativeEvent.currentTarget;
    this.relatedTarget = nativeEvent.relatedTarget;
    this.bubbles = nativeEvent.bubbles;
    this.cancelable = nativeEvent.cancelable;
    this.defaultPrevented = nativeEvent.defaultPrevented;
    this.eventPhase = nativeEvent.eventPhase;
    this.isTrusted = nativeEvent.isTrusted;
    this.timeStamp = nativeEvent.timeStamp;
    this.type = type2;
  }
};
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = (0, import_react6.useRef)({
    isFocused: false,
    observer: null
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  let dispatchBlur = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e6);
  });
  return (0, import_react6.useCallback)((e6) => {
    if (e6.target instanceof HTMLButtonElement || e6.target instanceof HTMLInputElement || e6.target instanceof HTMLTextAreaElement || e6.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e6.target;
      let onBlurHandler = (e7) => {
        stateRef.current.isFocused = false;
        if (target.disabled)
          dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", e7));
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = (0, import_react6.useCallback)((e6) => {
    if (e6.target === e6.currentTarget) {
      if (onBlurProp)
        onBlurProp(e6);
      if (onFocusChange)
        onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  const onFocus = (0, import_react6.useCallback)((e6) => {
    if (e6.target === e6.currentTarget && document.activeElement === e6.target) {
      if (onFocusProp)
        onFocusProp(e6);
      if (onFocusChange)
        onFocusChange(true);
      onSyntheticFocus(e6);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}
var $507fabe10e71c6fb$var$currentModality = null;
var $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
var $507fabe10e71c6fb$var$hasSetupGlobalListeners = false;
var $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
var $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
var $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e6) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers)
    handler(modality, e6);
}
function $507fabe10e71c6fb$var$isValidKey(e6) {
  return !(e6.metaKey || !(0, $c87311424ea30a05$export$9ac100e40613ea10)() && e6.altKey || e6.ctrlKey || e6.key === "Control" || e6.key === "Shift" || e6.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e6) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if ($507fabe10e71c6fb$var$isValidKey(e6)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e6);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e6) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  if (e6.type === "mousedown" || e6.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e6);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e6) {
  if ((0, $6a7db85432448f7f$export$60278871457622de)(e6)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e6) {
  if (e6.target === window || e6.target === document)
    return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e6);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents() {
  if (typeof window === "undefined" || $507fabe10e71c6fb$var$hasSetupGlobalListeners)
    return;
  let focus = HTMLElement.prototype.focus;
  HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  document.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  document.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  document.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  window.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  window.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    document.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    document.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    document.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    document.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    document.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    document.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$var$hasSetupGlobalListeners = true;
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading")
    $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  else
    document.addEventListener("DOMContentLoaded", $507fabe10e71c6fb$var$setupGlobalFocusEvents);
}
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
function $507fabe10e71c6fb$export$630ff653c5ada6a9() {
  return $507fabe10e71c6fb$var$currentModality;
}
function $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {
  $507fabe10e71c6fb$var$currentModality = modality;
  $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);
}
function $507fabe10e71c6fb$export$98e20ec92f614cfe() {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  let [modality, setModality] = (0, import_react6.useState)($507fabe10e71c6fb$var$currentModality);
  (0, import_react6.useEffect)(() => {
    let handler = () => {
      setModality($507fabe10e71c6fb$var$currentModality);
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, []);
  return (0, $b5e257d569688ac6$export$535bd6ca7f90a273)() ? null : modality;
}
var $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e6) {
  var _e_target;
  isTextInput = isTextInput || (e6 === null || e6 === void 0 ? void 0 : e6.target) instanceof HTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e6 === null || e6 === void 0 ? void 0 : (_e_target = e6.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e6 === null || e6 === void 0 ? void 0 : e6.target) instanceof HTMLTextAreaElement || (e6 === null || e6 === void 0 ? void 0 : e6.target) instanceof HTMLElement && (e6 === null || e6 === void 0 ? void 0 : e6.target.isContentEditable);
  return !(isTextInput && modality === "keyboard" && e6 instanceof KeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e6.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn2, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  (0, import_react6.useEffect)(() => {
    let handler = (modality, e6) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e6))
        return;
      fn2($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = (0, import_react6.useRef)({
    isFocusWithin: false
  });
  let onBlur = (0, import_react6.useCallback)((e6) => {
    if (state.current.isFocusWithin && !e6.currentTarget.contains(e6.relatedTarget)) {
      state.current.isFocusWithin = false;
      if (onBlurWithin)
        onBlurWithin(e6);
      if (onFocusWithinChange)
        onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state
  ]);
  let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  let onFocus = (0, import_react6.useCallback)((e6) => {
    if (!state.current.isFocusWithin && document.activeElement === e6.target) {
      if (onFocusWithin)
        onFocusWithin(e6);
      if (onFocusWithinChange)
        onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e6);
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus
  ]);
  if (isDisabled)
    return {
      focusWithinProps: {
        // These should not have been null, that would conflict in mergeProps
        onFocus: void 0,
        onBlur: void 0
      }
    };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}
var $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
var $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e6) {
  if (e6.pointerType === "touch")
    $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined")
    return;
  if (typeof PointerEvent !== "undefined")
    document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  else
    document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0)
      return;
    if (typeof PointerEvent !== "undefined")
      document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else
      document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;
  let [isHovered, setHovered] = (0, import_react6.useState)(false);
  let state = (0, import_react6.useRef)({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  (0, import_react6.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { hoverProps, triggerHoverEnd } = (0, import_react6.useMemo)(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target))
        return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      if (onHoverStart)
        onHoverStart({
          type: "hoverstart",
          target,
          pointerType
        });
      if (onHoverChange)
        onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered)
        return;
      state.isHovered = false;
      let target = event.currentTarget;
      if (onHoverEnd)
        onHoverEnd({
          type: "hoverend",
          target,
          pointerType
        });
      if (onHoverChange)
        onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e6) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e6.pointerType === "mouse")
          return;
        triggerHoverStart(e6, e6.pointerType);
      };
      hoverProps2.onPointerLeave = (e6) => {
        if (!isDisabled && e6.currentTarget.contains(e6.target))
          triggerHoverEnd2(e6, e6.pointerType);
      };
    } else {
      hoverProps2.onTouchStart = () => {
        state.ignoreEmulatedMouseEvents = true;
      };
      hoverProps2.onMouseEnter = (e6) => {
        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents)
          triggerHoverStart(e6, "mouse");
        state.ignoreEmulatedMouseEvents = false;
      };
      hoverProps2.onMouseLeave = (e6) => {
        if (!isDisabled && e6.currentTarget.contains(e6.target))
          triggerHoverEnd2(e6, "mouse");
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state
  ]);
  (0, import_react6.useEffect)(() => {
    if (isDisabled)
      triggerHoverEnd({
        currentTarget: state.target
      }, state.pointerType);
  }, [
    isDisabled
  ]);
  return {
    hoverProps,
    isHovered
  };
}
function $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {
  let { ref, onInteractOutside, isDisabled, onInteractOutsideStart } = props;
  let stateRef = (0, import_react6.useRef)({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  let onPointerDown = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e6, ref)) {
      if (onInteractOutsideStart)
        onInteractOutsideStart(e6);
      stateRef.current.isPointerDown = true;
    }
  });
  let triggerInteractOutside = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (onInteractOutside)
      onInteractOutside(e6);
  });
  (0, import_react6.useEffect)(() => {
    let state = stateRef.current;
    if (isDisabled)
      return;
    const element2 = ref.current;
    const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element2);
    if (typeof PointerEvent !== "undefined") {
      let onPointerUp = (e6) => {
        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e6, ref))
          triggerInteractOutside(e6);
        state.isPointerDown = false;
      };
      documentObject.addEventListener("pointerdown", onPointerDown, true);
      documentObject.addEventListener("pointerup", onPointerUp, true);
      return () => {
        documentObject.removeEventListener("pointerdown", onPointerDown, true);
        documentObject.removeEventListener("pointerup", onPointerUp, true);
      };
    } else {
      let onMouseUp = (e6) => {
        if (state.ignoreEmulatedMouseEvents)
          state.ignoreEmulatedMouseEvents = false;
        else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e6, ref))
          triggerInteractOutside(e6);
        state.isPointerDown = false;
      };
      let onTouchEnd = (e6) => {
        state.ignoreEmulatedMouseEvents = true;
        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e6, ref))
          triggerInteractOutside(e6);
        state.isPointerDown = false;
      };
      documentObject.addEventListener("mousedown", onPointerDown, true);
      documentObject.addEventListener("mouseup", onMouseUp, true);
      documentObject.addEventListener("touchstart", onPointerDown, true);
      documentObject.addEventListener("touchend", onTouchEnd, true);
      return () => {
        documentObject.removeEventListener("mousedown", onPointerDown, true);
        documentObject.removeEventListener("mouseup", onMouseUp, true);
        documentObject.removeEventListener("touchstart", onPointerDown, true);
        documentObject.removeEventListener("touchend", onTouchEnd, true);
      };
    }
  }, [
    ref,
    isDisabled,
    onPointerDown,
    triggerInteractOutside
  ]);
}
function $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {
  if (event.button > 0)
    return false;
  if (event.target) {
    const ownerDocument = event.target.ownerDocument;
    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target))
      return false;
    if (event.target.closest("[data-react-aria-top-layer]"))
      return false;
  }
  return ref.current && !ref.current.contains(event.target);
}
function $93925083ecbb358c$export$48d1ea6320830260(handler) {
  if (!handler)
    return void 0;
  let shouldStopPropagation = true;
  return (e6) => {
    let event = {
      ...e6,
      preventDefault() {
        e6.preventDefault();
      },
      isDefaultPrevented() {
        return e6.isDefaultPrevented();
      },
      stopPropagation() {
        console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
      },
      continuePropagation() {
        shouldStopPropagation = false;
      }
    };
    handler(event);
    if (shouldStopPropagation)
      e6.stopPropagation();
  };
}
function $46d819fcbaf35654$export$8f71654801c2f7cd(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),
      onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)
    }
  };
}
function $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {
  let { onScroll, isDisabled } = props;
  let onScrollHandler = (0, import_react6.useCallback)((e6) => {
    if (e6.ctrlKey)
      return;
    e6.preventDefault();
    e6.stopPropagation();
    if (onScroll)
      onScroll({
        deltaX: e6.deltaX,
        deltaY: e6.deltaY
      });
  }, [
    onScroll
  ]);
  (0, $e9faafb641e167db$export$90fc3a17d93f704c)(ref, "wheel", isDisabled ? void 0 : onScrollHandler);
}
var $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;
function $8a26561d2877236e$export$c24ed0104d07eab9(props) {
  let { isDisabled, onLongPressStart, onLongPressEnd, onLongPress, threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD, accessibilityDescription } = props;
  const timeRef = (0, import_react6.useRef)();
  let { addGlobalListener, removeGlobalListener } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled,
    onPressStart(e6) {
      e6.continuePropagation();
      if (e6.pointerType === "mouse" || e6.pointerType === "touch") {
        if (onLongPressStart)
          onLongPressStart({
            ...e6,
            type: "longpressstart"
          });
        timeRef.current = setTimeout(() => {
          e6.target.dispatchEvent(new PointerEvent("pointercancel", {
            bubbles: true
          }));
          if (onLongPress)
            onLongPress({
              ...e6,
              type: "longpress"
            });
          timeRef.current = void 0;
        }, threshold);
        if (e6.pointerType === "touch") {
          let onContextMenu = (e7) => {
            e7.preventDefault();
          };
          addGlobalListener(e6.target, "contextmenu", onContextMenu, {
            once: true
          });
          addGlobalListener(window, "pointerup", () => {
            setTimeout(() => {
              removeGlobalListener(e6.target, "contextmenu", onContextMenu);
            }, 30);
          }, {
            once: true
          });
        }
      }
    },
    onPressEnd(e6) {
      if (timeRef.current)
        clearTimeout(timeRef.current);
      if (onLongPressEnd && (e6.pointerType === "mouse" || e6.pointerType === "touch"))
        onLongPressEnd({
          ...e6,
          type: "longpressend"
        });
    }
  });
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(onLongPress && !isDisabled ? accessibilityDescription : void 0);
  return {
    longPressProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, descriptionProps)
  };
}

// node_modules/.pnpm/@react-aria+focus@3.15.0_react@18.2.0/node_modules/@react-aria/focus/dist/import.mjs
function $6a99195332edec8b$export$80f3e147d781571c(element2) {
  if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "virtual") {
    let lastFocusedElement = document.activeElement;
    (0, $bbed8b41f857bcc0$export$24490316f764c430)(() => {
      if (document.activeElement === lastFocusedElement && document.contains(element2))
        (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element2);
    });
  } else
    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element2);
}
function $645f2e67b85a24c9$var$isStyleVisible(element2) {
  if (!(element2 instanceof HTMLElement) && !(element2 instanceof SVGElement))
    return false;
  let { display, visibility } = element2.style;
  let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
  if (isVisible) {
    const { getComputedStyle: getComputedStyle2 } = element2.ownerDocument.defaultView;
    let { display: computedDisplay, visibility: computedVisibility } = getComputedStyle2(element2);
    isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
  }
  return isVisible;
}
function $645f2e67b85a24c9$var$isAttributeVisible(element2, childElement) {
  return !element2.hasAttribute("hidden") && (element2.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element2.hasAttribute("open") : true);
}
function $645f2e67b85a24c9$export$e989c0fffaa6b27a(element2, childElement) {
  return element2.nodeName !== "#comment" && $645f2e67b85a24c9$var$isStyleVisible(element2) && $645f2e67b85a24c9$var$isAttributeVisible(element2, childElement) && (!element2.parentElement || $645f2e67b85a24c9$export$e989c0fffaa6b27a(element2.parentElement, element2));
}
var $9bf71ea28793e738$var$FocusContext = (0, import_react7.default).createContext(null);
var $9bf71ea28793e738$var$activeScope = null;
function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
  let { children, contain, restoreFocus, autoFocus } = props;
  let startRef = (0, import_react7.useRef)(null);
  let endRef = (0, import_react7.useRef)(null);
  let scopeRef = (0, import_react7.useRef)([]);
  let { parentNode } = (0, import_react7.useContext)($9bf71ea28793e738$var$FocusContext) || {};
  let node3 = (0, import_react7.useMemo)(() => new $9bf71ea28793e738$var$TreeNode({
    scopeRef
  }), [
    scopeRef
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let parent = parentNode || $9bf71ea28793e738$export$d06fae2ee68b101e.root;
    if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parent.scopeRef) && $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, parent.scopeRef)) {
      let activeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
      if (activeNode)
        parent = activeNode;
    }
    parent.addChild(node3);
    $9bf71ea28793e738$export$d06fae2ee68b101e.addNode(node3);
  }, [
    node3,
    parentNode
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let node4 = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
    if (node4)
      node4.contain = !!contain;
  }, [
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    var _startRef_current;
    let node4 = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;
    let nodes = [];
    while (node4 && node4 !== endRef.current) {
      nodes.push(node4);
      node4 = node4.nextSibling;
    }
    scopeRef.current = nodes;
  }, [
    children
  ]);
  $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);
  $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);
  $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);
  $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);
  (0, import_react7.useEffect)(() => {
    let activeElement = document.activeElement;
    let scope = null;
    if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {
      for (let node4 of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse())
        if (node4.scopeRef && $9bf71ea28793e738$var$isElementInScope(activeElement, node4.scopeRef.current))
          scope = node4;
      if (scope === $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef))
        $9bf71ea28793e738$var$activeScope = scope.scopeRef;
    }
  }, [
    scopeRef
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      var _focusScopeTree_getTreeNode_parent, _focusScopeTree_getTreeNode;
      var _focusScopeTree_getTreeNode_parent_scopeRef;
      let parentScope = (_focusScopeTree_getTreeNode_parent_scopeRef = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : (_focusScopeTree_getTreeNode_parent = _focusScopeTree_getTreeNode.parent) === null || _focusScopeTree_getTreeNode_parent === void 0 ? void 0 : _focusScopeTree_getTreeNode_parent.scopeRef) !== null && _focusScopeTree_getTreeNode_parent_scopeRef !== void 0 ? _focusScopeTree_getTreeNode_parent_scopeRef : null;
      if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope)))
        $9bf71ea28793e738$var$activeScope = parentScope;
      $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);
    };
  }, [
    scopeRef
  ]);
  let focusManager = (0, import_react7.useMemo)(() => $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef), []);
  let value2 = (0, import_react7.useMemo)(() => ({
    focusManager,
    parentNode: node3
  }), [
    node3,
    focusManager
  ]);
  return (0, import_react7.default).createElement($9bf71ea28793e738$var$FocusContext.Provider, {
    value: value2
  }, (0, import_react7.default).createElement("span", {
    "data-focus-scope-start": true,
    hidden: true,
    ref: startRef
  }), children, (0, import_react7.default).createElement("span", {
    "data-focus-scope-end": true,
    hidden: true,
    ref: endRef
  }));
}
function $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {
  return {
    focusNext(opts = {}) {
      let scope = scopeRef.current;
      let { from: from2, tabbable, wrap: wrap2, accept } = opts;
      let node3 = from2 || document.activeElement;
      let sentinel = scope[0].previousElementSibling;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node3, scope) ? node3 : sentinel;
      let nextNode = walker.nextNode();
      if (!nextNode && wrap2) {
        walker.currentNode = sentinel;
        nextNode = walker.nextNode();
      }
      if (nextNode)
        $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusPrevious(opts = {}) {
      let scope = scopeRef.current;
      let { from: from2, tabbable, wrap: wrap2, accept } = opts;
      let node3 = from2 || document.activeElement;
      let sentinel = scope[scope.length - 1].nextElementSibling;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node3, scope) ? node3 : sentinel;
      let previousNode = walker.previousNode();
      if (!previousNode && wrap2) {
        walker.currentNode = sentinel;
        previousNode = walker.previousNode();
      }
      if (previousNode)
        $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode;
    },
    focusFirst(opts = {}) {
      let scope = scopeRef.current;
      let { tabbable, accept } = opts;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = scope[0].previousElementSibling;
      let nextNode = walker.nextNode();
      if (nextNode)
        $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusLast(opts = {}) {
      let scope = scopeRef.current;
      let { tabbable, accept } = opts;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable,
        accept
      }, scope);
      walker.currentNode = scope[scope.length - 1].nextElementSibling;
      let previousNode = walker.previousNode();
      if (previousNode)
        $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode;
    }
  };
}
var $9bf71ea28793e738$var$focusableElements = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
];
var $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
var $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
function $9bf71ea28793e738$var$getScopeRoot(scope) {
  return scope[0].parentElement;
}
function $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {
  let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
  while (scope && scope.scopeRef !== scopeRef) {
    if (scope.contain)
      return false;
    scope = scope.parent;
  }
  return true;
}
function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
  let focusedNode = (0, import_react7.useRef)();
  let raf = (0, import_react7.useRef)();
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let scope = scopeRef.current;
    if (!contain) {
      if (raf.current) {
        cancelAnimationFrame(raf.current);
        raf.current = void 0;
      }
      return;
    }
    let onKeyDown = (e6) => {
      if (e6.key !== "Tab" || e6.altKey || e6.ctrlKey || e6.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef))
        return;
      let focusedElement = document.activeElement;
      let scope2 = scopeRef.current;
      if (!scope2 || !$9bf71ea28793e738$var$isElementInScope(focusedElement, scope2))
        return;
      let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope2);
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
        tabbable: true
      }, scope2);
      if (!focusedElement)
        return;
      walker.currentNode = focusedElement;
      let nextElement = e6.shiftKey ? walker.previousNode() : walker.nextNode();
      if (!nextElement) {
        walker.currentNode = e6.shiftKey ? scope2[scope2.length - 1].nextElementSibling : scope2[0].previousElementSibling;
        nextElement = e6.shiftKey ? walker.previousNode() : walker.nextNode();
      }
      e6.preventDefault();
      if (nextElement)
        $9bf71ea28793e738$var$focusElement(nextElement, true);
    };
    let onFocus = (e6) => {
      if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e6.target, scopeRef.current)) {
        $9bf71ea28793e738$var$activeScope = scopeRef;
        focusedNode.current = e6.target;
      } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e6.target, scopeRef)) {
        if (focusedNode.current)
          focusedNode.current.focus();
        else if ($9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$var$activeScope.current)
          $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);
      } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef))
        focusedNode.current = e6.target;
    };
    let onBlur = (e6) => {
      if (raf.current)
        cancelAnimationFrame(raf.current);
      raf.current = requestAnimationFrame(() => {
        if (document.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(document.activeElement, scopeRef)) {
          $9bf71ea28793e738$var$activeScope = scopeRef;
          if (document.body.contains(e6.target)) {
            var _focusedNode_current;
            focusedNode.current = e6.target;
            (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();
          } else if ($9bf71ea28793e738$var$activeScope.current)
            $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);
        }
      });
    };
    document.addEventListener("keydown", onKeyDown, false);
    document.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.addEventListener("focusin", onFocus, false));
    scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.addEventListener("focusout", onBlur, false));
    return () => {
      document.removeEventListener("keydown", onKeyDown, false);
      document.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.removeEventListener("focusin", onFocus, false));
      scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.removeEventListener("focusout", onBlur, false));
    };
  }, [
    scopeRef,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      if (raf.current)
        cancelAnimationFrame(raf.current);
    };
  }, [
    raf
  ]);
}
function $9bf71ea28793e738$var$isElementInAnyScope(element2) {
  return $9bf71ea28793e738$var$isElementInChildScope(element2);
}
function $9bf71ea28793e738$var$isElementInScope(element2, scope) {
  if (!element2)
    return false;
  if (!scope)
    return false;
  return scope.some((node3) => node3.contains(element2));
}
function $9bf71ea28793e738$var$isElementInChildScope(element2, scope = null) {
  if (element2 instanceof Element && element2.closest("[data-react-aria-top-layer]"))
    return true;
  for (let { scopeRef: s4 } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))) {
    if (s4 && $9bf71ea28793e738$var$isElementInScope(element2, s4.current))
      return true;
  }
  return false;
}
function $9bf71ea28793e738$export$1258395f99bf9cbf(element2) {
  return $9bf71ea28793e738$var$isElementInChildScope(element2, $9bf71ea28793e738$var$activeScope);
}
function $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {
  var _focusScopeTree_getTreeNode;
  let parent = (_focusScopeTree_getTreeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || _focusScopeTree_getTreeNode === void 0 ? void 0 : _focusScopeTree_getTreeNode.parent;
  while (parent) {
    if (parent.scopeRef === ancestor)
      return true;
    parent = parent.parent;
  }
  return false;
}
function $9bf71ea28793e738$var$focusElement(element2, scroll = false) {
  if (element2 != null && !scroll)
    try {
      (0, $6a99195332edec8b$export$80f3e147d781571c)(element2);
    } catch (err) {
    }
  else if (element2 != null)
    try {
      element2.focus();
    } catch (err) {
    }
}
function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
  let sentinel = scope[0].previousElementSibling;
  let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
  let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
    tabbable
  }, scope);
  walker.currentNode = sentinel;
  let nextNode = walker.nextNode();
  if (tabbable && !nextNode) {
    scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
    walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
      tabbable: false
    }, scope);
    walker.currentNode = sentinel;
    nextNode = walker.nextNode();
  }
  $9bf71ea28793e738$var$focusElement(nextNode);
}
function $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {
  const autoFocusRef = (0, import_react7.default).useRef(autoFocus);
  (0, import_react7.useEffect)(() => {
    if (autoFocusRef.current) {
      $9bf71ea28793e738$var$activeScope = scopeRef;
      if (!$9bf71ea28793e738$var$isElementInScope(document.activeElement, $9bf71ea28793e738$var$activeScope.current) && scopeRef.current)
        $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);
    }
    autoFocusRef.current = false;
  }, [
    scopeRef
  ]);
}
function $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (restore || contain)
      return;
    let scope = scopeRef.current;
    let onFocus = (e6) => {
      let target = e6.target;
      if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current))
        $9bf71ea28793e738$var$activeScope = scopeRef;
      else if (!$9bf71ea28793e738$var$isElementInAnyScope(target))
        $9bf71ea28793e738$var$activeScope = null;
    };
    document.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.addEventListener("focusin", onFocus, false));
    return () => {
      document.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.removeEventListener("focusin", onFocus, false));
    };
  }, [
    scopeRef,
    restore,
    contain
  ]);
}
function $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {
  let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);
  while (scope && scope.scopeRef !== scopeRef) {
    if (scope.nodeToRestore)
      return false;
    scope = scope.parent;
  }
  return (scope === null || scope === void 0 ? void 0 : scope.scopeRef) === scopeRef;
}
function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
  const nodeToRestoreRef = (0, import_react7.useRef)(typeof document !== "undefined" ? document.activeElement : null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let scope = scopeRef.current;
    if (!restoreFocus || contain)
      return;
    let onFocus = () => {
      if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(document.activeElement, scopeRef.current))
        $9bf71ea28793e738$var$activeScope = scopeRef;
    };
    document.addEventListener("focusin", onFocus, false);
    scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.addEventListener("focusin", onFocus, false));
    return () => {
      document.removeEventListener("focusin", onFocus, false);
      scope === null || scope === void 0 ? void 0 : scope.forEach((element2) => element2.removeEventListener("focusin", onFocus, false));
    };
  }, [
    scopeRef,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (!restoreFocus)
      return;
    let onKeyDown = (e6) => {
      if (e6.key !== "Tab" || e6.altKey || e6.ctrlKey || e6.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef))
        return;
      let focusedElement = document.activeElement;
      if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current))
        return;
      let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
      if (!treeNode)
        return;
      let nodeToRestore = treeNode.nodeToRestore;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(document.body, {
        tabbable: true
      });
      walker.currentNode = focusedElement;
      let nextElement = e6.shiftKey ? walker.previousNode() : walker.nextNode();
      if (!nodeToRestore || !document.body.contains(nodeToRestore) || nodeToRestore === document.body) {
        nodeToRestore = void 0;
        treeNode.nodeToRestore = void 0;
      }
      if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {
        walker.currentNode = nodeToRestore;
        do
          nextElement = e6.shiftKey ? walker.previousNode() : walker.nextNode();
        while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current));
        e6.preventDefault();
        e6.stopPropagation();
        if (nextElement)
          $9bf71ea28793e738$var$focusElement(nextElement, true);
        else if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore))
          focusedElement.blur();
        else
          $9bf71ea28793e738$var$focusElement(nodeToRestore, true);
      }
    };
    if (!contain)
      document.addEventListener("keydown", onKeyDown, true);
    return () => {
      if (!contain)
        document.removeEventListener("keydown", onKeyDown, true);
    };
  }, [
    scopeRef,
    restoreFocus,
    contain
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (!restoreFocus)
      return;
    let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
    if (!treeNode)
      return;
    var _nodeToRestoreRef_current;
    treeNode.nodeToRestore = (_nodeToRestoreRef_current = nodeToRestoreRef.current) !== null && _nodeToRestoreRef_current !== void 0 ? _nodeToRestoreRef_current : void 0;
    return () => {
      let treeNode2 = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
      if (!treeNode2)
        return;
      let nodeToRestore = treeNode2.nodeToRestore;
      if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
      ($9bf71ea28793e738$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {
        let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();
        requestAnimationFrame(() => {
          if (document.activeElement === document.body) {
            let treeNode3 = clonedTree.getTreeNode(scopeRef);
            while (treeNode3) {
              if (treeNode3.nodeToRestore && document.body.contains(treeNode3.nodeToRestore)) {
                $9bf71ea28793e738$var$focusElement(treeNode3.nodeToRestore);
                return;
              }
              treeNode3 = treeNode3.parent;
            }
            treeNode3 = clonedTree.getTreeNode(scopeRef);
            while (treeNode3) {
              if (treeNode3.scopeRef && treeNode3.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode3.scopeRef)) {
                $9bf71ea28793e738$var$focusFirstInScope(treeNode3.scopeRef.current, true);
                return;
              }
              treeNode3 = treeNode3.parent;
            }
          }
        });
      }
    };
  }, [
    scopeRef,
    restoreFocus
  ]);
}
function $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {
  let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;
  let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node3) {
      var _opts_from;
      if (opts === null || opts === void 0 ? void 0 : (_opts_from = opts.from) === null || _opts_from === void 0 ? void 0 : _opts_from.contains(node3))
        return NodeFilter.FILTER_REJECT;
      if (node3.matches(selector) && (0, $645f2e67b85a24c9$export$e989c0fffaa6b27a)(node3) && (!scope || $9bf71ea28793e738$var$isElementInScope(node3, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node3)))
        return NodeFilter.FILTER_ACCEPT;
      return NodeFilter.FILTER_SKIP;
    }
  });
  if (opts === null || opts === void 0 ? void 0 : opts.from)
    walker.currentNode = opts.from;
  return walker;
}
function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
  return {
    focusNext(opts = {}) {
      let root = ref.current;
      if (!root)
        return null;
      let { from: from2, tabbable = defaultOptions.tabbable, wrap: wrap2 = defaultOptions.wrap, accept = defaultOptions.accept } = opts;
      let node3 = from2 || document.activeElement;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      if (root.contains(node3))
        walker.currentNode = node3;
      let nextNode = walker.nextNode();
      if (!nextNode && wrap2) {
        walker.currentNode = root;
        nextNode = walker.nextNode();
      }
      if (nextNode)
        $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusPrevious(opts = defaultOptions) {
      let root = ref.current;
      if (!root)
        return null;
      let { from: from2, tabbable = defaultOptions.tabbable, wrap: wrap2 = defaultOptions.wrap, accept = defaultOptions.accept } = opts;
      let node3 = from2 || document.activeElement;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      if (root.contains(node3))
        walker.currentNode = node3;
      else {
        let next2 = $9bf71ea28793e738$var$last(walker);
        if (next2)
          $9bf71ea28793e738$var$focusElement(next2, true);
        return next2 !== null && next2 !== void 0 ? next2 : null;
      }
      let previousNode = walker.previousNode();
      if (!previousNode && wrap2) {
        walker.currentNode = root;
        let lastNode = $9bf71ea28793e738$var$last(walker);
        if (!lastNode)
          return null;
        previousNode = lastNode;
      }
      if (previousNode)
        $9bf71ea28793e738$var$focusElement(previousNode, true);
      return previousNode !== null && previousNode !== void 0 ? previousNode : null;
    },
    focusFirst(opts = defaultOptions) {
      let root = ref.current;
      if (!root)
        return null;
      let { tabbable = defaultOptions.tabbable, accept = defaultOptions.accept } = opts;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      let nextNode = walker.nextNode();
      if (nextNode)
        $9bf71ea28793e738$var$focusElement(nextNode, true);
      return nextNode;
    },
    focusLast(opts = defaultOptions) {
      let root = ref.current;
      if (!root)
        return null;
      let { tabbable = defaultOptions.tabbable, accept = defaultOptions.accept } = opts;
      let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
        tabbable,
        accept
      });
      let next2 = $9bf71ea28793e738$var$last(walker);
      if (next2)
        $9bf71ea28793e738$var$focusElement(next2, true);
      return next2 !== null && next2 !== void 0 ? next2 : null;
    }
  };
}
function $9bf71ea28793e738$var$last(walker) {
  let next2 = void 0;
  let last;
  do {
    last = walker.lastChild();
    if (last)
      next2 = last;
  } while (last);
  return next2;
}
var $9bf71ea28793e738$var$Tree = class _$9bf71ea28793e738$var$Tree {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(data) {
    return this.fastMap.get(data);
  }
  addTreeNode(scopeRef, parent, nodeToRestore) {
    let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
    if (!parentNode)
      return;
    let node3 = new $9bf71ea28793e738$var$TreeNode({
      scopeRef
    });
    parentNode.addChild(node3);
    node3.parent = parentNode;
    this.fastMap.set(scopeRef, node3);
    if (nodeToRestore)
      node3.nodeToRestore = nodeToRestore;
  }
  addNode(node3) {
    this.fastMap.set(node3.scopeRef, node3);
  }
  removeTreeNode(scopeRef) {
    if (scopeRef === null)
      return;
    let node3 = this.fastMap.get(scopeRef);
    if (!node3)
      return;
    let parentNode = node3.parent;
    for (let current of this.traverse())
      if (current !== node3 && node3.nodeToRestore && current.nodeToRestore && node3.scopeRef && node3.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node3.scopeRef.current))
        current.nodeToRestore = node3.nodeToRestore;
    let children = node3.children;
    if (parentNode) {
      parentNode.removeChild(node3);
      if (children.size > 0)
        children.forEach((child) => parentNode && parentNode.addChild(child));
    }
    this.fastMap.delete(node3.scopeRef);
  }
  // Pre Order Depth First
  *traverse(node3 = this.root) {
    if (node3.scopeRef != null)
      yield node3;
    if (node3.children.size > 0)
      for (let child of node3.children)
        yield* this.traverse(child);
  }
  clone() {
    var _node_parent;
    let newTree = new _$9bf71ea28793e738$var$Tree();
    var _node_parent_scopeRef;
    for (let node3 of this.traverse())
      newTree.addTreeNode(node3.scopeRef, (_node_parent_scopeRef = (_node_parent = node3.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node3.nodeToRestore);
    return newTree;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map();
    this.root = new $9bf71ea28793e738$var$TreeNode({
      scopeRef: null
    });
    this.fastMap.set(null, this.root);
  }
};
var $9bf71ea28793e738$var$TreeNode = class {
  addChild(node3) {
    this.children.add(node3);
    node3.parent = this;
  }
  removeChild(node3) {
    this.children.delete(node3);
    node3.parent = void 0;
  }
  constructor(props) {
    this.children = /* @__PURE__ */ new Set();
    this.contain = false;
    this.scopeRef = props.scopeRef;
  }
};
var $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = (0, import_react7.useRef)({
    isFocused: false,
    isFocusVisible: autoFocus || (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()
  });
  let [isFocused, setFocused] = (0, import_react7.useState)(false);
  let [isFocusVisibleState, setFocusVisible] = (0, import_react7.useState)(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = (0, import_react7.useCallback)(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = (0, import_react7.useCallback)((isFocused2) => {
    state.current.isFocused = isFocused2;
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  (0, $507fabe10e71c6fb$export$ec71b4b83ac08ec3)((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible;
    updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}
var $e6afbd83fe6ebbd2$var$FocusableContext = (0, import_react7.default).createContext(null);
function $e6afbd83fe6ebbd2$var$useFocusableContext(ref) {
  let context = (0, import_react7.useContext)($e6afbd83fe6ebbd2$var$FocusableContext) || {};
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e)(context, ref);
  let { ref: _2, ...otherProps } = context;
  return otherProps;
}
function $e6afbd83fe6ebbd2$var$FocusableProvider(props, ref) {
  let { children, ...otherProps } = props;
  let objRef = (0, $df56164dff5785e2$export$4338b53315abf666)(ref);
  let context = {
    ...otherProps,
    ref: objRef
  };
  return (0, import_react7.default).createElement($e6afbd83fe6ebbd2$var$FocusableContext.Provider, {
    value: context
  }, children);
}
var $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 = (0, import_react7.default).forwardRef($e6afbd83fe6ebbd2$var$FocusableProvider);
function $e6afbd83fe6ebbd2$export$4c014de7c8940b4c(props, domRef) {
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)(props);
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)(props);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusProps, keyboardProps);
  let domProps = $e6afbd83fe6ebbd2$var$useFocusableContext(domRef);
  let interactionProps = props.isDisabled ? {} : domProps;
  let autoFocusRef = (0, import_react7.useRef)(props.autoFocus);
  (0, import_react7.useEffect)(() => {
    if (autoFocusRef.current && domRef.current)
      (0, $6a99195332edec8b$export$80f3e147d781571c)(domRef.current);
    autoFocusRef.current = false;
  }, [
    domRef
  ]);
  return {
    focusableProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)({
      ...interactions,
      tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : void 0
    }, interactionProps)
  };
}
function $83013635b024ae3d$export$eac1895992b9f3d6(ref, options) {
  let isDisabled = options === null || options === void 0 ? void 0 : options.isDisabled;
  let [hasTabbableChild, setHasTabbableChild] = (0, import_react7.useState)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if ((ref === null || ref === void 0 ? void 0 : ref.current) && !isDisabled) {
      let update = () => {
        if (ref.current) {
          let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {
            tabbable: true
          });
          setHasTabbableChild(!!walker.nextNode());
        }
      };
      update();
      let observer = new MutationObserver(update);
      observer.observe(ref.current, {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: [
          "tabIndex",
          "disabled"
        ]
      });
      return () => {
        observer.disconnect();
      };
    }
  });
  return isDisabled ? false : hasTabbableChild;
}

// node_modules/.pnpm/@react-aria+overlays@3.19.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/overlays/dist/import.mjs
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/.pnpm/@react-aria+visually-hidden@3.8.7_react@18.2.0/node_modules/@react-aria/visually-hidden/dist/import.mjs
var import_react8 = __toESM(require_react(), 1);
var $5c3e21d68f1c4674$var$styles = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};
function $5c3e21d68f1c4674$export$a966af930f325cab(props = {}) {
  let { style, isFocusable } = props;
  let [isFocused, setFocused] = (0, import_react8.useState)(false);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !isFocusable,
    onFocusWithinChange: (val) => setFocused(val)
  });
  let combinedStyles = (0, import_react8.useMemo)(() => {
    if (isFocused)
      return style;
    else if (style)
      return {
        ...$5c3e21d68f1c4674$var$styles,
        ...style
      };
    else
      return $5c3e21d68f1c4674$var$styles;
  }, [
    isFocused
  ]);
  return {
    visuallyHiddenProps: {
      ...focusWithinProps,
      style: combinedStyles
    }
  };
}
function $5c3e21d68f1c4674$export$439d29a4e110a164(props) {
  let { children, elementType: Element4 = "div", isFocusable, style, ...otherProps } = props;
  let { visuallyHiddenProps } = $5c3e21d68f1c4674$export$a966af930f325cab(props);
  return (0, import_react8.default).createElement(Element4, (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(otherProps, visuallyHiddenProps), children);
}

// node_modules/.pnpm/@react-aria+overlays@3.19.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/overlays/dist/import.mjs
function $parcel$interopDefault(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $edcf132a9284368a$var$AXIS = {
  top: "top",
  bottom: "top",
  left: "left",
  right: "left"
};
var $edcf132a9284368a$var$FLIPPED_DIRECTION = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
var $edcf132a9284368a$var$CROSS_AXIS = {
  top: "left",
  left: "top"
};
var $edcf132a9284368a$var$AXIS_SIZE = {
  top: "height",
  left: "width"
};
var $edcf132a9284368a$var$TOTAL_SIZE = {
  width: "totalWidth",
  height: "totalHeight"
};
var $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE = {};
var $edcf132a9284368a$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $edcf132a9284368a$var$getContainerDimensions(containerNode) {
  let width = 0, height = 0, totalWidth = 0, totalHeight = 0, top = 0, left = 0;
  let scroll = {};
  if (containerNode.tagName === "BODY") {
    let documentElement = document.documentElement;
    totalWidth = documentElement.clientWidth;
    totalHeight = documentElement.clientHeight;
    var _visualViewport_width;
    width = (_visualViewport_width = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.width) !== null && _visualViewport_width !== void 0 ? _visualViewport_width : totalWidth;
    var _visualViewport_height;
    height = (_visualViewport_height = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : totalHeight;
    scroll.top = documentElement.scrollTop || containerNode.scrollTop;
    scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;
  } else {
    ({ width, height, top, left } = $edcf132a9284368a$var$getOffset(containerNode));
    scroll.top = containerNode.scrollTop;
    scroll.left = containerNode.scrollLeft;
    totalWidth = width;
    totalHeight = height;
  }
  return {
    width,
    height,
    totalWidth,
    totalHeight,
    scroll,
    top,
    left
  };
}
function $edcf132a9284368a$var$getScroll(node3) {
  return {
    top: node3.scrollTop,
    left: node3.scrollLeft,
    width: node3.scrollWidth,
    height: node3.scrollHeight
  };
}
function $edcf132a9284368a$var$getDelta(axis, offset, size3, boundaryDimensions, containerDimensions, padding) {
  let containerScroll = containerDimensions.scroll[axis];
  let boundaryHeight = boundaryDimensions[$edcf132a9284368a$var$AXIS_SIZE[axis]];
  let startEdgeOffset = offset - padding - containerScroll;
  let endEdgeOffset = offset + padding - containerScroll + size3;
  if (startEdgeOffset < 0)
    return -startEdgeOffset;
  else if (endEdgeOffset > boundaryHeight)
    return Math.max(boundaryHeight - endEdgeOffset, -startEdgeOffset);
  else
    return 0;
}
function $edcf132a9284368a$var$getMargins(node3) {
  let style = window.getComputedStyle(node3);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}
function $edcf132a9284368a$var$parsePlacement(input) {
  if ($edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input])
    return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];
  let [placement, crossPlacement] = input.split(" ");
  let axis = $edcf132a9284368a$var$AXIS[placement] || "right";
  let crossAxis = $edcf132a9284368a$var$CROSS_AXIS[axis];
  if (!$edcf132a9284368a$var$AXIS[crossPlacement])
    crossPlacement = "center";
  let size3 = $edcf132a9284368a$var$AXIS_SIZE[axis];
  let crossSize = $edcf132a9284368a$var$AXIS_SIZE[crossAxis];
  $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input] = {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size: size3,
    crossSize
  };
  return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];
}
function $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset) {
  let { placement, crossPlacement, axis, crossAxis, size: size3, crossSize } = placementInfo;
  let position2 = {};
  position2[crossAxis] = childOffset[crossAxis];
  if (crossPlacement === "center")
    position2[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  else if (crossPlacement !== crossAxis)
    position2[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  position2[crossAxis] += crossOffset;
  const minPosition = childOffset[crossAxis] - overlaySize[crossSize] + arrowSize + arrowBoundaryOffset;
  const maxPosition = childOffset[crossAxis] + childOffset[crossSize] - arrowSize - arrowBoundaryOffset;
  position2[crossAxis] = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(position2[crossAxis], minPosition, maxPosition);
  if (placement === axis) {
    const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size3] : boundaryDimensions[$edcf132a9284368a$var$TOTAL_SIZE[size3]];
    position2[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);
  } else
    position2[axis] = Math.floor(childOffset[axis] + childOffset[size3] + offset);
  return position2;
}
function $edcf132a9284368a$var$getMaxHeight(position2, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {
  return position2.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - (containerOffsetWithBoundary.top + position2.top) - (margins.top + margins.bottom + padding)) : Math.max(0, childOffset.top + containerOffsetWithBoundary.top - (boundaryDimensions.top + boundaryDimensions.scroll.top) - (margins.top + margins.bottom + padding));
}
function $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  let { placement, axis, size: size3 } = placementInfo;
  if (placement === axis)
    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);
  return Math.max(0, boundaryDimensions[size3] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size3] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);
}
function $edcf132a9284368a$export$6839422d1f33cee9(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, userSetMaxHeight, arrowSize, arrowBoundaryOffset) {
  let placementInfo = $edcf132a9284368a$var$parsePlacement(placementInput);
  let { size: size3, crossAxis, crossSize, placement, crossPlacement } = placementInfo;
  let position2 = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
  let normalizedOffset = offset;
  let space3 = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo);
  if (flip && scrollSize[size3] > space3) {
    let flippedPlacementInfo = $edcf132a9284368a$var$parsePlacement(`${$edcf132a9284368a$var$FLIPPED_DIRECTION[placement]} ${crossPlacement}`);
    let flippedPosition = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
    let flippedSpace = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo);
    if (flippedSpace > space3) {
      placementInfo = flippedPlacementInfo;
      position2 = flippedPosition;
      normalizedOffset = offset;
    }
  }
  let delta = $edcf132a9284368a$var$getDelta(crossAxis, position2[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding);
  position2[crossAxis] += delta;
  let maxHeight = $edcf132a9284368a$var$getMaxHeight(position2, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);
  if (userSetMaxHeight && userSetMaxHeight < maxHeight)
    maxHeight = userSetMaxHeight;
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position2 = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned, arrowSize, arrowBoundaryOffset);
  delta = $edcf132a9284368a$var$getDelta(crossAxis, position2[crossAxis], overlaySize[crossSize], boundaryDimensions, containerDimensions, padding);
  position2[crossAxis] += delta;
  let arrowPosition = {};
  let preferredArrowPosition = childOffset[crossAxis] + 0.5 * childOffset[crossSize] - overlaySize[crossAxis];
  const arrowMinPosition = arrowSize / 2 + arrowBoundaryOffset;
  const arrowMaxPosition = overlaySize[crossSize] - arrowSize / 2 - arrowBoundaryOffset;
  const arrowOverlappingChildMinEdge = childOffset[crossAxis] - overlaySize[crossAxis] + arrowSize / 2;
  const arrowOverlappingChildMaxEdge = childOffset[crossAxis] + childOffset[crossSize] - overlaySize[crossAxis] - arrowSize / 2;
  const arrowPositionOverlappingChild = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(preferredArrowPosition, arrowOverlappingChildMinEdge, arrowOverlappingChildMaxEdge);
  arrowPosition[crossAxis] = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(arrowPositionOverlappingChild, arrowMinPosition, arrowMaxPosition);
  return {
    position: position2,
    maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}
function $edcf132a9284368a$export$b3ceb0cbf1056d98(opts) {
  let { placement, targetNode, overlayNode, scrollNode, padding, shouldFlip, boundaryElement, offset, crossOffset, maxHeight, arrowSize = 0, arrowBoundaryOffset = 0 } = opts;
  let container = overlayNode instanceof HTMLElement ? $edcf132a9284368a$var$getContainingBlock(overlayNode) : document.documentElement;
  let isViewportContainer = container === document.documentElement;
  const containerPositionStyle = window.getComputedStyle(container).position;
  let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== "static";
  let childOffset = isViewportContainer ? $edcf132a9284368a$var$getOffset(targetNode) : $edcf132a9284368a$var$getPosition(targetNode, container);
  if (!isViewportContainer) {
    let { marginTop, marginLeft } = window.getComputedStyle(targetNode);
    childOffset.top += parseInt(marginTop, 10) || 0;
    childOffset.left += parseInt(marginLeft, 10) || 0;
  }
  let overlaySize = $edcf132a9284368a$var$getOffset(overlayNode);
  let margins = $edcf132a9284368a$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  let scrollSize = $edcf132a9284368a$var$getScroll(scrollNode);
  let boundaryDimensions = $edcf132a9284368a$var$getContainerDimensions(boundaryElement);
  let containerDimensions = $edcf132a9284368a$var$getContainerDimensions(container);
  let containerOffsetWithBoundary = boundaryElement.tagName === "BODY" ? $edcf132a9284368a$var$getOffset(container) : $edcf132a9284368a$var$getPosition(container, boundaryElement);
  return $edcf132a9284368a$export$6839422d1f33cee9(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, maxHeight, arrowSize, arrowBoundaryOffset);
}
function $edcf132a9284368a$var$getOffset(node3) {
  let { top, left, width, height } = node3.getBoundingClientRect();
  let { scrollTop, scrollLeft, clientTop, clientLeft } = document.documentElement;
  return {
    top: top + scrollTop - clientTop,
    left: left + scrollLeft - clientLeft,
    width,
    height
  };
}
function $edcf132a9284368a$var$getPosition(node3, parent) {
  let style = window.getComputedStyle(node3);
  let offset;
  if (style.position === "fixed") {
    let { top, left, width, height } = node3.getBoundingClientRect();
    offset = {
      top,
      left,
      width,
      height
    };
  } else {
    offset = $edcf132a9284368a$var$getOffset(node3);
    let parentOffset = $edcf132a9284368a$var$getOffset(parent);
    let parentStyle = window.getComputedStyle(parent);
    parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;
    parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;
    offset.top -= parentOffset.top;
    offset.left -= parentOffset.left;
  }
  offset.top -= parseInt(style.marginTop, 10) || 0;
  offset.left -= parseInt(style.marginLeft, 10) || 0;
  return offset;
}
function $edcf132a9284368a$var$getContainingBlock(node3) {
  let offsetParent = node3.offsetParent;
  if (offsetParent && offsetParent === document.body && window.getComputedStyle(offsetParent).position === "static" && !$edcf132a9284368a$var$isContainingBlock(offsetParent))
    offsetParent = document.documentElement;
  if (offsetParent == null) {
    offsetParent = node3.parentElement;
    while (offsetParent && !$edcf132a9284368a$var$isContainingBlock(offsetParent))
      offsetParent = offsetParent.parentElement;
  }
  return offsetParent || document.documentElement;
}
function $edcf132a9284368a$var$isContainingBlock(node3) {
  let style = window.getComputedStyle(node3);
  return style.transform !== "none" || /transform|perspective/.test(style.willChange) || style.filter !== "none" || style.contain === "paint" || // @ts-ignore
  "backdropFilter" in style && style.backdropFilter !== "none" || // @ts-ignore
  "WebkitBackdropFilter" in style && style.WebkitBackdropFilter !== "none";
}
var $dd149f63282afbbf$export$f6211563215e3b37 = /* @__PURE__ */ new WeakMap();
function $dd149f63282afbbf$export$18fc8428861184da(opts) {
  let { triggerRef, isOpen, onClose } = opts;
  (0, import_react9.useEffect)(() => {
    if (!isOpen || onClose === null)
      return;
    let onScroll = (e6) => {
      let target = e6.target;
      if (!triggerRef.current || target instanceof Node && !target.contains(triggerRef.current))
        return;
      let onCloseHandler = onClose || $dd149f63282afbbf$export$f6211563215e3b37.get(triggerRef.current);
      if (onCloseHandler)
        onCloseHandler();
    };
    window.addEventListener("scroll", onScroll, true);
    return () => {
      window.removeEventListener("scroll", onScroll, true);
    };
  }, [
    isOpen,
    onClose,
    triggerRef
  ]);
}
var $2a41e45df1593e64$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $2a41e45df1593e64$export$d39e1813b3bdd0e1(props) {
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { arrowSize = 0, targetRef, overlayRef, scrollRef = overlayRef, placement = "bottom", containerPadding = 12, shouldFlip = true, boundaryElement = typeof document !== "undefined" ? document.body : null, offset = 0, crossOffset = 0, shouldUpdatePosition = true, isOpen = true, onClose, maxHeight, arrowBoundaryOffset = 0 } = props;
  let [position2, setPosition] = (0, import_react9.useState)({
    position: {},
    arrowOffsetLeft: void 0,
    arrowOffsetTop: void 0,
    maxHeight: void 0,
    placement: void 0
  });
  let deps = [
    shouldUpdatePosition,
    placement,
    overlayRef.current,
    targetRef.current,
    scrollRef.current,
    containerPadding,
    shouldFlip,
    boundaryElement,
    offset,
    crossOffset,
    isOpen,
    direction,
    maxHeight,
    arrowBoundaryOffset,
    arrowSize
  ];
  let updatePosition = (0, import_react9.useCallback)(() => {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement)
      return;
    let position3 = (0, $edcf132a9284368a$export$b3ceb0cbf1056d98)({
      placement: $2a41e45df1593e64$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current,
      padding: containerPadding,
      shouldFlip,
      boundaryElement,
      offset,
      crossOffset,
      maxHeight,
      arrowSize,
      arrowBoundaryOffset
    });
    Object.keys(position3.position).forEach((key) => overlayRef.current.style[key] = position3.position[key] + "px");
    overlayRef.current.style.maxHeight = position3.maxHeight != null ? position3.maxHeight + "px" : void 0;
    setPosition(position3);
  }, deps);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updatePosition, deps);
  $2a41e45df1593e64$var$useResize(updatePosition);
  (0, $9daab02d461809db$export$683480f191c0e3ea)({
    ref: overlayRef,
    onResize: updatePosition
  });
  let isResizing = (0, import_react9.useRef)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let timeout2;
    let onResize = () => {
      isResizing.current = true;
      clearTimeout(timeout2);
      timeout2 = setTimeout(() => {
        isResizing.current = false;
      }, 500);
      updatePosition();
    };
    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener("resize", onResize);
    $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener("scroll", onResize);
    return () => {
      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener("resize", onResize);
      $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener("scroll", onResize);
    };
  }, [
    updatePosition
  ]);
  let close = (0, import_react9.useCallback)(() => {
    if (!isResizing.current)
      onClose();
  }, [
    onClose,
    isResizing
  ]);
  (0, $dd149f63282afbbf$export$18fc8428861184da)({
    triggerRef: targetRef,
    isOpen,
    onClose: onClose && close
  });
  return {
    overlayProps: {
      style: {
        position: "absolute",
        zIndex: 1e5,
        ...position2.position,
        maxHeight: position2.maxHeight
      }
    },
    placement: position2.placement,
    arrowProps: {
      "aria-hidden": "true",
      role: "presentation",
      style: {
        left: position2.arrowOffsetLeft,
        top: position2.arrowOffsetTop
      }
    },
    updatePosition
  };
}
function $2a41e45df1593e64$var$useResize(onResize) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    window.addEventListener("resize", onResize, false);
    return () => {
      window.removeEventListener("resize", onResize, false);
    };
  }, [
    onResize
  ]);
}
function $2a41e45df1593e64$var$translateRTL(position2, direction) {
  if (direction === "rtl")
    return position2.replace("start", "right").replace("end", "left");
  return position2.replace("start", "left").replace("end", "right");
}
var $a11501f3d1d39e6c$var$visibleOverlays = [];
function $a11501f3d1d39e6c$export$ea8f71083e90600f(props, ref) {
  let { onClose, shouldCloseOnBlur, isOpen, isDismissable = false, isKeyboardDismissDisabled = false, shouldCloseOnInteractOutside } = props;
  (0, import_react9.useEffect)(() => {
    if (isOpen)
      $a11501f3d1d39e6c$var$visibleOverlays.push(ref);
    return () => {
      let index2 = $a11501f3d1d39e6c$var$visibleOverlays.indexOf(ref);
      if (index2 >= 0)
        $a11501f3d1d39e6c$var$visibleOverlays.splice(index2, 1);
    };
  }, [
    isOpen,
    ref
  ]);
  let onHide = () => {
    if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref && onClose)
      onClose();
  };
  let onInteractOutsideStart = (e6) => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e6.target)) {
      if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {
        e6.stopPropagation();
        e6.preventDefault();
      }
    }
  };
  let onInteractOutside = (e6) => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e6.target)) {
      if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {
        e6.stopPropagation();
        e6.preventDefault();
      }
      onHide();
    }
  };
  let onKeyDown = (e6) => {
    if (e6.key === "Escape" && !isKeyboardDismissDisabled) {
      e6.stopPropagation();
      e6.preventDefault();
      onHide();
    }
  };
  (0, $e0b6e0b68ec7f50f$export$872b660ac5a1ff98)({
    ref,
    onInteractOutside: isDismissable && isOpen ? onInteractOutside : null,
    onInteractOutsideStart
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: (e6) => {
      if (!e6.relatedTarget || (0, $9bf71ea28793e738$export$1258395f99bf9cbf)(e6.relatedTarget))
        return;
      if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e6.relatedTarget))
        onClose();
    }
  });
  let onPointerDownUnderlay = (e6) => {
    if (e6.target === e6.currentTarget)
      e6.preventDefault();
  };
  return {
    overlayProps: {
      onKeyDown,
      ...focusWithinProps
    },
    underlayProps: {
      onPointerDown: onPointerDownUnderlay
    }
  };
}
function $628037886ba31236$export$f9d5c8beee7d008d(props, state, ref) {
  let { type: type2 } = props;
  let { isOpen } = state;
  (0, import_react9.useEffect)(() => {
    if (ref && ref.current)
      (0, $dd149f63282afbbf$export$f6211563215e3b37).set(ref.current, state.close);
  });
  let ariaHasPopup = void 0;
  if (type2 === "menu")
    ariaHasPopup = true;
  else if (type2 === "listbox")
    ariaHasPopup = "listbox";
  let overlayId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    triggerProps: {
      "aria-haspopup": ariaHasPopup,
      "aria-expanded": isOpen,
      "aria-controls": isOpen ? overlayId : null,
      onPress: state.toggle
    },
    overlayProps: {
      id: overlayId
    }
  };
}
var $49c51c25361d4cd2$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
var $49c51c25361d4cd2$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
var $49c51c25361d4cd2$var$preventScrollCount = 0;
var $49c51c25361d4cd2$var$restore;
function $49c51c25361d4cd2$export$ee0f7cc6afcd1c18(options = {}) {
  let { isDisabled } = options;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (isDisabled)
      return;
    $49c51c25361d4cd2$var$preventScrollCount++;
    if ($49c51c25361d4cd2$var$preventScrollCount === 1) {
      if ((0, $c87311424ea30a05$export$fedb369cb70207f1)())
        $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollMobileSafari();
      else
        $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollStandard();
    }
    return () => {
      $49c51c25361d4cd2$var$preventScrollCount--;
      if ($49c51c25361d4cd2$var$preventScrollCount === 0)
        $49c51c25361d4cd2$var$restore();
    };
  }, [
    isDisabled
  ]);
}
function $49c51c25361d4cd2$var$preventScrollStandard() {
  return (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, "overflow", "hidden"));
}
function $49c51c25361d4cd2$var$preventScrollMobileSafari() {
  let scrollable;
  let lastY = 0;
  let onTouchStart = (e6) => {
    scrollable = (0, $62d8ded9296f3872$export$cfa2225e87938781)(e6.target);
    if (scrollable === document.documentElement && scrollable === document.body)
      return;
    lastY = e6.changedTouches[0].pageY;
  };
  let onTouchMove = (e6) => {
    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {
      e6.preventDefault();
      return;
    }
    let y4 = e6.changedTouches[0].pageY;
    let scrollTop = scrollable.scrollTop;
    let bottom = scrollable.scrollHeight - scrollable.clientHeight;
    if (bottom === 0)
      return;
    if (scrollTop <= 0 && y4 > lastY || scrollTop >= bottom && y4 < lastY)
      e6.preventDefault();
    lastY = y4;
  };
  let onTouchEnd = (e6) => {
    let target = e6.target;
    if ($49c51c25361d4cd2$var$willOpenKeyboard(target) && target !== document.activeElement) {
      e6.preventDefault();
      target.style.transform = "translateY(-2000px)";
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = "";
      });
    }
  };
  let onFocus = (e6) => {
    let target = e6.target;
    if ($49c51c25361d4cd2$var$willOpenKeyboard(target)) {
      target.style.transform = "translateY(-2000px)";
      requestAnimationFrame(() => {
        target.style.transform = "";
        if ($49c51c25361d4cd2$var$visualViewport) {
          if ($49c51c25361d4cd2$var$visualViewport.height < window.innerHeight)
            requestAnimationFrame(() => {
              $49c51c25361d4cd2$var$scrollIntoView(target);
            });
          else
            $49c51c25361d4cd2$var$visualViewport.addEventListener("resize", () => $49c51c25361d4cd2$var$scrollIntoView(target), {
              once: true
            });
        }
      });
    }
  };
  let onWindowScroll = () => {
    window.scrollTo(0, 0);
  };
  let scrollX = window.pageXOffset;
  let scrollY = window.pageYOffset;
  let restoreStyles = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, "overflow", "hidden"), $49c51c25361d4cd2$var$setStyle(document.body, "marginTop", `-${scrollY}px`));
  window.scrollTo(0, 0);
  let removeEvents = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($49c51c25361d4cd2$var$addEvent(document, "touchstart", onTouchStart, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "touchmove", onTouchMove, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "touchend", onTouchEnd, {
    passive: false,
    capture: true
  }), $49c51c25361d4cd2$var$addEvent(document, "focus", onFocus, true), $49c51c25361d4cd2$var$addEvent(window, "scroll", onWindowScroll));
  return () => {
    restoreStyles();
    removeEvents();
    window.scrollTo(scrollX, scrollY);
  };
}
function $49c51c25361d4cd2$var$setStyle(element2, style, value2) {
  let cur = element2.style[style];
  element2.style[style] = value2;
  return () => {
    element2.style[style] = cur;
  };
}
function $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}
function $49c51c25361d4cd2$var$scrollIntoView(target) {
  let root = document.scrollingElement || document.documentElement;
  while (target && target !== root) {
    let scrollable = (0, $62d8ded9296f3872$export$cfa2225e87938781)(target);
    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {
      let scrollableTop = scrollable.getBoundingClientRect().top;
      let targetTop = target.getBoundingClientRect().top;
      if (targetTop > scrollableTop + target.clientHeight)
        scrollable.scrollTop += targetTop - scrollableTop;
    }
    target = scrollable.parentElement;
  }
}
function $49c51c25361d4cd2$var$willOpenKeyboard(target) {
  return target instanceof HTMLInputElement && !$49c51c25361d4cd2$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}
var $f57aed4a881a3485$var$Context = (0, import_react9.default).createContext(null);
function $f57aed4a881a3485$export$178405afcd8c5eb(props) {
  let { children } = props;
  let parent = (0, import_react9.useContext)($f57aed4a881a3485$var$Context);
  let [modalCount, setModalCount] = (0, import_react9.useState)(0);
  let context = (0, import_react9.useMemo)(() => ({
    parent,
    modalCount,
    addModal() {
      setModalCount((count) => count + 1);
      if (parent)
        parent.addModal();
    },
    removeModal() {
      setModalCount((count) => count - 1);
      if (parent)
        parent.removeModal();
    }
  }), [
    parent,
    modalCount
  ]);
  return (0, import_react9.default).createElement($f57aed4a881a3485$var$Context.Provider, {
    value: context
  }, children);
}
function $f57aed4a881a3485$export$d9aaed4c3ece1bc0() {
  let context = (0, import_react9.useContext)($f57aed4a881a3485$var$Context);
  return {
    modalProviderProps: {
      "aria-hidden": context && context.modalCount > 0 ? true : null
    }
  };
}
var $a2f21f5f14f60553$exports = {};
var $773d5888b972f1cf$exports = {};
$773d5888b972f1cf$exports = {
  "dismiss": `تجاهل`
};
var $d11f19852b941573$exports = {};
$d11f19852b941573$exports = {
  "dismiss": `Отхвърляне`
};
var $b983974c2ee1efb3$exports = {};
$b983974c2ee1efb3$exports = {
  "dismiss": `Odstranit`
};
var $5809cc9d4e92de73$exports = {};
$5809cc9d4e92de73$exports = {
  "dismiss": `Luk`
};
var $c68c2e4fc74398d1$exports = {};
$c68c2e4fc74398d1$exports = {
  "dismiss": `Schließen`
};
var $0898b4c153db2b77$exports = {};
$0898b4c153db2b77$exports = {
  "dismiss": `Απόρριψη`
};
var $6d74810286a15183$exports = {};
$6d74810286a15183$exports = {
  "dismiss": `Dismiss`
};
var $309d73dc65f78055$exports = {};
$309d73dc65f78055$exports = {
  "dismiss": `Descartar`
};
var $44ad94f7205cf593$exports = {};
$44ad94f7205cf593$exports = {
  "dismiss": `Lõpeta`
};
var $7c28f5687f0779a9$exports = {};
$7c28f5687f0779a9$exports = {
  "dismiss": `Hylkää`
};
var $e6d75df4b68bd73a$exports = {};
$e6d75df4b68bd73a$exports = {
  "dismiss": `Rejeter`
};
var $87505c9dab186d0f$exports = {};
$87505c9dab186d0f$exports = {
  "dismiss": `התעלם`
};
var $553439c3ffb3e492$exports = {};
$553439c3ffb3e492$exports = {
  "dismiss": `Odbaci`
};
var $74cf411061b983a2$exports = {};
$74cf411061b983a2$exports = {
  "dismiss": `Elutasítás`
};
var $e933f298574dc435$exports = {};
$e933f298574dc435$exports = {
  "dismiss": `Ignora`
};
var $ac91fc9fe02f71f6$exports = {};
$ac91fc9fe02f71f6$exports = {
  "dismiss": `閉じる`
};
var $52b96f86422025af$exports = {};
$52b96f86422025af$exports = {
  "dismiss": `무시`
};
var $c0d724c3e51dafa6$exports = {};
$c0d724c3e51dafa6$exports = {
  "dismiss": `Atmesti`
};
var $c92899672a3fe72e$exports = {};
$c92899672a3fe72e$exports = {
  "dismiss": `Nerādīt`
};
var $9f576b39d8e7a9d6$exports = {};
$9f576b39d8e7a9d6$exports = {
  "dismiss": `Lukk`
};
var $9d025808aeec81a7$exports = {};
$9d025808aeec81a7$exports = {
  "dismiss": `Negeren`
};
var $fce709921e2c0fa6$exports = {};
$fce709921e2c0fa6$exports = {
  "dismiss": `Zignoruj`
};
var $2599cf0c4ab37f59$exports = {};
$2599cf0c4ab37f59$exports = {
  "dismiss": `Descartar`
};
var $3c220ae7ef8a35fd$exports = {};
$3c220ae7ef8a35fd$exports = {
  "dismiss": `Dispensar`
};
var $93562b5094072f54$exports = {};
$93562b5094072f54$exports = {
  "dismiss": `Revocare`
};
var $cd9e2abd0d06c7b4$exports = {};
$cd9e2abd0d06c7b4$exports = {
  "dismiss": `Пропустить`
};
var $45375701f409adf1$exports = {};
$45375701f409adf1$exports = {
  "dismiss": `Zrušiť`
};
var $27fab53a576de9dd$exports = {};
$27fab53a576de9dd$exports = {
  "dismiss": `Opusti`
};
var $4438748d9952e7c7$exports = {};
$4438748d9952e7c7$exports = {
  "dismiss": `Odbaci`
};
var $0936d7347ef4da4c$exports = {};
$0936d7347ef4da4c$exports = {
  "dismiss": `Avvisa`
};
var $29700c92185d38f8$exports = {};
$29700c92185d38f8$exports = {
  "dismiss": `Kapat`
};
var $662ccaf2be4c25b3$exports = {};
$662ccaf2be4c25b3$exports = {
  "dismiss": `Скасувати`
};
var $d80a27deda7cdb3c$exports = {};
$d80a27deda7cdb3c$exports = {
  "dismiss": `取消`
};
var $2b2734393847c884$exports = {};
$2b2734393847c884$exports = {
  "dismiss": `關閉`
};
$a2f21f5f14f60553$exports = {
  "ar-AE": $773d5888b972f1cf$exports,
  "bg-BG": $d11f19852b941573$exports,
  "cs-CZ": $b983974c2ee1efb3$exports,
  "da-DK": $5809cc9d4e92de73$exports,
  "de-DE": $c68c2e4fc74398d1$exports,
  "el-GR": $0898b4c153db2b77$exports,
  "en-US": $6d74810286a15183$exports,
  "es-ES": $309d73dc65f78055$exports,
  "et-EE": $44ad94f7205cf593$exports,
  "fi-FI": $7c28f5687f0779a9$exports,
  "fr-FR": $e6d75df4b68bd73a$exports,
  "he-IL": $87505c9dab186d0f$exports,
  "hr-HR": $553439c3ffb3e492$exports,
  "hu-HU": $74cf411061b983a2$exports,
  "it-IT": $e933f298574dc435$exports,
  "ja-JP": $ac91fc9fe02f71f6$exports,
  "ko-KR": $52b96f86422025af$exports,
  "lt-LT": $c0d724c3e51dafa6$exports,
  "lv-LV": $c92899672a3fe72e$exports,
  "nb-NO": $9f576b39d8e7a9d6$exports,
  "nl-NL": $9d025808aeec81a7$exports,
  "pl-PL": $fce709921e2c0fa6$exports,
  "pt-BR": $2599cf0c4ab37f59$exports,
  "pt-PT": $3c220ae7ef8a35fd$exports,
  "ro-RO": $93562b5094072f54$exports,
  "ru-RU": $cd9e2abd0d06c7b4$exports,
  "sk-SK": $45375701f409adf1$exports,
  "sl-SI": $27fab53a576de9dd$exports,
  "sr-SP": $4438748d9952e7c7$exports,
  "sv-SE": $0936d7347ef4da4c$exports,
  "tr-TR": $29700c92185d38f8$exports,
  "uk-UA": $662ccaf2be4c25b3$exports,
  "zh-CN": $d80a27deda7cdb3c$exports,
  "zh-TW": $2b2734393847c884$exports
};
function $86ea4cb521eb2e37$export$2317d149ed6f78c4(props) {
  let { onDismiss, ...otherProps } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault($a2f21f5f14f60553$exports)));
  let labels = (0, $313b98861ee5dd6c$export$d6875122194c7b44)(otherProps, stringFormatter.format("dismiss"));
  let onClick = () => {
    if (onDismiss)
      onDismiss();
  };
  return (0, import_react9.default).createElement((0, $5c3e21d68f1c4674$export$439d29a4e110a164), null, (0, import_react9.default).createElement("button", {
    ...labels,
    tabIndex: -1,
    onClick
  }));
}
var $5e3802645cc19319$var$refCountMap = /* @__PURE__ */ new WeakMap();
var $5e3802645cc19319$var$observerStack = [];
function $5e3802645cc19319$export$1c3ebcada18427bf(targets, root = document.body) {
  let visibleNodes = new Set(targets);
  let hiddenNodes = /* @__PURE__ */ new Set();
  let walk = (root2) => {
    for (let element2 of root2.querySelectorAll("[data-live-announcer], [data-react-aria-top-layer]"))
      visibleNodes.add(element2);
    let acceptNode = (node3) => {
      if (visibleNodes.has(node3) || hiddenNodes.has(node3.parentElement) && node3.parentElement.getAttribute("role") !== "row")
        return NodeFilter.FILTER_REJECT;
      for (let target of visibleNodes) {
        if (node3.contains(target))
          return NodeFilter.FILTER_SKIP;
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    let walker = document.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT, {
      acceptNode
    });
    let acceptRoot = acceptNode(root2);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT)
      hide(root2);
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node3 = walker.nextNode();
      while (node3 != null) {
        hide(node3);
        node3 = walker.nextNode();
      }
    }
  };
  let hide = (node3) => {
    var _refCountMap_get;
    let refCount = (_refCountMap_get = $5e3802645cc19319$var$refCountMap.get(node3)) !== null && _refCountMap_get !== void 0 ? _refCountMap_get : 0;
    if (node3.getAttribute("aria-hidden") === "true" && refCount === 0)
      return;
    if (refCount === 0)
      node3.setAttribute("aria-hidden", "true");
    hiddenNodes.add(node3);
    $5e3802645cc19319$var$refCountMap.set(node3, refCount + 1);
  };
  if ($5e3802645cc19319$var$observerStack.length)
    $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].disconnect();
  walk(root);
  let observer = new MutationObserver((changes) => {
    for (let change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0)
        continue;
      if (![
        ...visibleNodes,
        ...hiddenNodes
      ].some((node3) => node3.contains(change.target))) {
        for (let node3 of change.removedNodes)
          if (node3 instanceof Element) {
            visibleNodes.delete(node3);
            hiddenNodes.delete(node3);
          }
        for (let node3 of change.addedNodes) {
          if ((node3 instanceof HTMLElement || node3 instanceof SVGElement) && (node3.dataset.liveAnnouncer === "true" || node3.dataset.reactAriaTopLayer === "true"))
            visibleNodes.add(node3);
          else if (node3 instanceof Element)
            walk(node3);
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  let observerWrapper = {
    observe() {
      observer.observe(root, {
        childList: true,
        subtree: true
      });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  $5e3802645cc19319$var$observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (let node3 of hiddenNodes) {
      let count = $5e3802645cc19319$var$refCountMap.get(node3);
      if (count === 1) {
        node3.removeAttribute("aria-hidden");
        $5e3802645cc19319$var$refCountMap.delete(node3);
      } else
        $5e3802645cc19319$var$refCountMap.set(node3, count - 1);
    }
    if (observerWrapper === $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1]) {
      $5e3802645cc19319$var$observerStack.pop();
      if ($5e3802645cc19319$var$observerStack.length)
        $5e3802645cc19319$var$observerStack[$5e3802645cc19319$var$observerStack.length - 1].observe();
    } else
      $5e3802645cc19319$var$observerStack.splice($5e3802645cc19319$var$observerStack.indexOf(observerWrapper), 1);
  };
}
function $f2f8a6077418541e$export$542a6fd13ac93354(props, state) {
  let { triggerRef, popoverRef, isNonModal, isKeyboardDismissDisabled, ...otherProps } = props;
  let { overlayProps, underlayProps } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({
    isOpen: state.isOpen,
    onClose: state.close,
    shouldCloseOnBlur: true,
    isDismissable: !isNonModal,
    isKeyboardDismissDisabled
  }, popoverRef);
  let { overlayProps: positionProps, arrowProps, placement } = (0, $2a41e45df1593e64$export$d39e1813b3bdd0e1)({
    ...otherProps,
    targetRef: triggerRef,
    overlayRef: popoverRef,
    isOpen: state.isOpen,
    onClose: null
  });
  (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({
    isDisabled: isNonModal
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (state.isOpen && !isNonModal && popoverRef.current)
      return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
        popoverRef.current
      ]);
  }, [
    isNonModal,
    state.isOpen,
    popoverRef
  ]);
  return {
    popoverProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(overlayProps, positionProps),
    arrowProps,
    underlayProps,
    placement
  };
}
var $337b884510726a0d$export$a2200b96afd16271 = (0, import_react9.default).createContext(null);
function $337b884510726a0d$export$c6fdb837b070b4ff(props) {
  let isSSR = (0, $b5e257d569688ac6$export$535bd6ca7f90a273)();
  let { portalContainer = isSSR ? null : document.body, isExiting } = props;
  let [contain, setContain] = (0, import_react9.useState)(false);
  let contextValue = (0, import_react9.useMemo)(() => ({
    contain,
    setContain
  }), [
    contain,
    setContain
  ]);
  if (!portalContainer)
    return null;
  let contents = props.children;
  if (!props.disableFocusManagement)
    contents = (0, import_react9.default).createElement((0, $9bf71ea28793e738$export$20e40289641fbbb6), {
      restoreFocus: true,
      contain: contain && !isExiting
    }, contents);
  contents = (0, import_react9.default).createElement($337b884510726a0d$export$a2200b96afd16271.Provider, {
    value: contextValue
  }, (0, import_react9.default).createElement((0, $f1ab8c75478c6f73$export$cf75428e0b9ed1ea), null, contents));
  return (0, import_react_dom.default).createPortal(contents, portalContainer);
}
function $337b884510726a0d$export$14c98a7594375490() {
  let ctx = (0, import_react9.useContext)($337b884510726a0d$export$a2200b96afd16271);
  let setContain = ctx === null || ctx === void 0 ? void 0 : ctx.setContain;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    setContain === null || setContain === void 0 ? void 0 : setContain(true);
  }, [
    setContain
  ]);
}
function $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, ref) {
  let { overlayProps, underlayProps } = (0, $a11501f3d1d39e6c$export$ea8f71083e90600f)({
    ...props,
    isOpen: state.isOpen,
    onClose: state.close
  }, ref);
  (0, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18)({
    isDisabled: !state.isOpen
  });
  (0, $337b884510726a0d$export$14c98a7594375490)();
  (0, import_react9.useEffect)(() => {
    if (state.isOpen)
      return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
        ref.current
      ]);
  }, [
    state.isOpen,
    ref
  ]);
  return {
    modalProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(overlayProps),
    underlayProps
  };
}

// node_modules/.pnpm/@emotion+weak-memoize@0.3.1/node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache3 = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache3.has(arg)) {
      return cache3.get(arg);
    }
    var ret = func(arg);
    cache3.set(arg, ret);
    return ret;
  };
};

// node_modules/.pnpm/@emotion+sheet@1.2.2/node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i6 = 0; i6 < document.styleSheets.length; i6++) {
    if (document.styleSheets[i6].ownerNode === tag) {
      return document.styleSheets[i6];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? false : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate2(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (true) {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet2 = sheetForTag(tag);
      try {
        sheet2.insertRule(rule, sheet2.cssRules.length);
      } catch (e6) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e6);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (true) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value2, length2) {
  return charat(value2, 0) ^ 45 ? (((length2 << 2 ^ charat(value2, 0)) << 2 ^ charat(value2, 1)) << 2 ^ charat(value2, 2)) << 2 ^ charat(value2, 3) : 0;
}
function trim(value2) {
  return value2.trim();
}
function match(value2, pattern) {
  return (value2 = pattern.exec(value2)) ? value2[0] : value2;
}
function replace(value2, pattern, replacement) {
  return value2.replace(pattern, replacement);
}
function indexof(value2, search) {
  return value2.indexOf(search);
}
function charat(value2, index2) {
  return value2.charCodeAt(index2) | 0;
}
function substr(value2, begin, end) {
  return value2.slice(begin, end);
}
function strlen(value2) {
  return value2.length;
}
function sizeof(value2) {
  return value2.length;
}
function append(value2, array) {
  return array.push(value2), value2;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value2, root, parent, type2, props, children, length2) {
  return { value: value2, root, parent, type: type2, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value2) {
  return line = column = 1, length = strlen(characters = value2), position = 0, [];
}
function dealloc(value2) {
  return characters = "", value2;
}
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}

// node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Parser.js
function compile(value2) {
  return dealloc(parse2("", null, null, null, [""], value2 = alloc(value2), 0, [0], value2));
}
function parse2(value2, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index2, offset, rules, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse2(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse2(value2, reference, reference, rule && append(ruleset(value2, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value2, root, parent, index2, offset, rules, points, type2, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size3 = sizeof(rule);
  for (var i6 = 0, j3 = 0, k2 = 0; i6 < index2; ++i6)
    for (var x3 = 0, y4 = substr(value2, post + 1, post = abs(j3 = points[i6])), z3 = value2; x3 < size3; ++x3)
      if (z3 = trim(j3 > 0 ? rule[x3] + " " + y4 : replace(y4, /&\f/g, rule[x3])))
        props[k2++] = z3;
  return node(value2, root, parent, offset === 0 ? RULESET : type2, props, children, length2);
}
function comment(value2, root, parent) {
  return node(value2, root, parent, COMMENT, from(char()), substr(value2, 2, -2), 0);
}
function declaration(value2, root, parent, length2) {
  return node(value2, root, parent, DECLARATION, substr(value2, 0, length2), substr(value2, length2 + 1, -1), length2);
}

// node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i6 = 0; i6 < length2; i6++)
    output += callback(children[i6], i6, children, callback) || "";
  return output;
}
function stringify(element2, index2, children, callback) {
  switch (element2.type) {
    case LAYER:
      if (element2.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element2.return = element2.return || element2.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element2.return = element2.value + "{" + serialize(element2.children, callback) + "}";
    case RULESET:
      element2.value = element2.props.join(",");
  }
  return strlen(children = serialize(element2.children, callback)) ? element2.return = element2.value + "{" + children + "}" : "";
}

// node_modules/.pnpm/stylis@4.2.0/node_modules/stylis/src/Middleware.js
function middleware(collection2) {
  var length2 = sizeof(collection2);
  return function(element2, index2, children, callback) {
    var output = "";
    for (var i6 = 0; i6 < length2; i6++)
      output += collection2[i6](element2, index2, children, callback) || "";
    return output;
  };
}

// node_modules/.pnpm/@emotion+memoize@0.8.1/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize2(fn2) {
  var cache3 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache3[arg] === void 0)
      cache3[arg] = fn2(arg);
    return cache3[arg];
  };
}

// node_modules/.pnpm/@emotion+cache@11.11.0/node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value2, points) {
  return dealloc(toRules(alloc(value2), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element2) {
  if (element2.type !== "rule" || !element2.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element2.length < 1) {
    return;
  }
  var value2 = element2.value, parent = element2.parent;
  var isImplicitRule = element2.column === parent.column && element2.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element2.props.length === 1 && value2.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element2, true);
  var points = [];
  var rules = getRules(value2, points);
  var parentRules = parent.props;
  for (var i6 = 0, k2 = 0; i6 < rules.length; i6++) {
    for (var j3 = 0; j3 < parentRules.length; j3++, k2++) {
      element2.props[k2] = points[i6] ? rules[i6].replace(/&\f/g, parentRules[j3]) : parentRules[j3] + " " + rules[i6];
    }
  }
};
var removeLabel = function removeLabel2(element2) {
  if (element2.type === "decl") {
    var value2 = element2.value;
    if (
      // charcode for l
      value2.charCodeAt(0) === 108 && // charcode for b
      value2.charCodeAt(2) === 98
    ) {
      element2["return"] = "";
      element2.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element2) {
  return element2.type === "comm" && element2.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache3) {
  return function(element2, index2, children) {
    if (element2.type !== "rule" || cache3.compat)
      return;
    var unsafePseudoClasses = element2.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element2.parent;
      var commentContainer = isNested ? element2.parent.children : (
        // global rule at the root level
        children
      );
      for (var i6 = commentContainer.length - 1; i6 >= 0; i6--) {
        var node3 = commentContainer[i6];
        if (node3.line < element2.line) {
          break;
        }
        if (node3.column < element2.column) {
          if (isIgnoringComment(node3)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element2) {
  return element2.type.charCodeAt(1) === 105 && element2.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index2, children) {
  for (var i6 = index2 - 1; i6 >= 0; i6--) {
    if (!isImportRule(children[i6])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element2) {
  element2.type = "";
  element2.value = "";
  element2["return"] = "";
  element2.children = "";
  element2.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element2, index2, children) {
  if (!isImportRule(element2)) {
    return;
  }
  if (element2.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element2);
  } else if (isPrependedWithRegularRules(index2, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element2);
  }
};
function prefix2(value2, length2) {
  switch (hash(value2, length2)) {
    case 5103:
      return WEBKIT + "print-" + value2 + value2;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value2 + value2;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value2 + MOZ + value2 + MS + value2 + value2;
    case 6828:
    case 4268:
      return WEBKIT + value2 + MS + value2 + value2;
    case 6165:
      return WEBKIT + value2 + MS + "flex-" + value2 + value2;
    case 5187:
      return WEBKIT + value2 + replace(value2, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value2;
    case 5443:
      return WEBKIT + value2 + MS + "flex-item-" + replace(value2, /flex-|-self/, "") + value2;
    case 4675:
      return WEBKIT + value2 + MS + "flex-line-pack" + replace(value2, /align-content|flex-|-self/, "") + value2;
    case 5548:
      return WEBKIT + value2 + MS + replace(value2, "shrink", "negative") + value2;
    case 5292:
      return WEBKIT + value2 + MS + replace(value2, "basis", "preferred-size") + value2;
    case 6060:
      return WEBKIT + "box-" + replace(value2, "-grow", "") + WEBKIT + value2 + MS + replace(value2, "grow", "positive") + value2;
    case 4554:
      return WEBKIT + replace(value2, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value2;
    case 6187:
      return replace(replace(replace(value2, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value2, "") + value2;
    case 5495:
    case 3959:
      return replace(value2, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value2, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value2 + value2;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value2, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value2;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value2) - 1 - length2 > 6)
        switch (charat(value2, length2 + 1)) {
          case 109:
            if (charat(value2, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value2, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value2, length2 + 3) == 108 ? "$3" : "$2-$3")) + value2;
          case 115:
            return ~indexof(value2, "stretch") ? prefix2(replace(value2, "stretch", "fill-available"), length2) + value2 : value2;
        }
      break;
    case 4949:
      if (charat(value2, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value2, strlen(value2) - 3 - (~indexof(value2, "!important") && 10))) {
        case 107:
          return replace(value2, ":", ":" + WEBKIT) + value2;
        case 101:
          return replace(value2, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value2, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value2;
      }
      break;
    case 5936:
      switch (charat(value2, length2 + 11)) {
        case 114:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb") + value2;
        case 108:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "tb-rl") + value2;
        case 45:
          return WEBKIT + value2 + MS + replace(value2, /[svh]\w+-[tblr]{2}/, "lr") + value2;
      }
      return WEBKIT + value2 + MS + value2 + value2;
  }
  return value2;
}
var prefixer = function prefixer2(element2, index2, children, callback) {
  if (element2.length > -1) {
    if (!element2["return"])
      switch (element2.type) {
        case DECLARATION:
          element2["return"] = prefix2(element2.value, element2.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element2, {
            value: replace(element2.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element2.length)
            return combine(element2.props, function(value2) {
              switch (match(value2, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element2, {
                    props: [replace(value2, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element2, {
                    props: [replace(value2, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element2, {
                    props: [replace(value2, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element2, {
                    props: [replace(value2, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node3) {
      var dataEmotionAttribute = node3.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node3);
      node3.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  if (true) {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node3) {
        var attrib = node3.getAttribute("data-emotion").split(" ");
        for (var i6 = 1; i6 < attrib.length; i6++) {
          inserted[attrib[i6]] = true;
        }
        nodesToHydrate.push(node3);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (true) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache3.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, true ? function(element2) {
      if (!element2.root) {
        if (element2["return"]) {
          currentSheet.insert(element2["return"]);
        } else if (element2.value && element2.type !== COMMENT) {
          currentSheet.insert(element2.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet2, shouldCache) {
      currentSheet = sheet2;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet2.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache3.inserted[serialized.name] = true;
      }
    };
  }
  var cache3 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache3.sheet.hydrate(nodesToHydrate);
  return cache3;
};

// node_modules/.pnpm/@emotion+hash@0.9.1/node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h3 = 0;
  var k2, i6 = 0, len = str.length;
  for (; len >= 4; ++i6, len -= 4) {
    k2 = str.charCodeAt(i6) & 255 | (str.charCodeAt(++i6) & 255) << 8 | (str.charCodeAt(++i6) & 255) << 16 | (str.charCodeAt(++i6) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h3 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h3 ^= (str.charCodeAt(i6 + 2) & 255) << 16;
    case 2:
      h3 ^= (str.charCodeAt(i6 + 1) & 255) << 8;
    case 1:
      h3 ^= str.charCodeAt(i6) & 255;
      h3 = /* Math.imul(h, m): */
      (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  }
  h3 ^= h3 >>> 13;
  h3 = /* Math.imul(h, m): */
  (h3 & 65535) * 1540483477 + ((h3 >>> 16) * 59797 << 16);
  return ((h3 ^ h3 >>> 15) >>> 0).toString(36);
}

// node_modules/.pnpm/@emotion+unitless@0.8.1/node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/.pnpm/@emotion+serialize@1.1.2/node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value2) {
  return value2 != null && typeof value2 !== "boolean";
};
var processStyleName = memoize2(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value2) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value2 === "string") {
        return value2.replace(animationRegex, function(match3, p1, p22) {
          cursor = {
            name: p1,
            styles: p22,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value2 === "number" && value2 !== 0) {
    return value2 + "px";
  }
  return value2;
};
if (true) {
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value2) {
    if (key === "content") {
      if (typeof value2 !== "string" || contentValues.indexOf(value2) === -1 && !contentValuePattern.test(value2) && (value2.charAt(0) !== value2.charAt(value2.length - 1) || value2.charAt(0) !== '"' && value2.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value2 + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value2);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        if (interpolation.map !== void 0) {
          styles2 += interpolation.map;
        }
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (true) {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (true) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match3, p1, p22) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p22.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i6 = 0; i6 < obj.length; i6++) {
      string += handleInterpolation(mergedProps, registered, obj[i6]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value2 = obj[_key];
      if (typeof value2 !== "object") {
        if (registered != null && registered[value2] !== void 0) {
          string += _key + "{" + registered[value2] + "}";
        } else if (isProcessableValue(value2)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value2) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && true) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value2) && typeof value2[0] === "string" && (registered == null || registered[value2[0]] === void 0)) {
          for (var _i = 0; _i < value2.length; _i++) {
            if (isProcessableValue(value2[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value2[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value2);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (_key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (true) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (strings[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles2 += strings[0];
  }
  for (var i6 = 1; i6 < args.length; i6++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i6]);
    if (stringMode) {
      if (strings[i6] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles2 += strings[i6];
    }
  }
  var sourceMap;
  if (true) {
    styles2 = styles2.replace(sourceMapPattern, function(match4) {
      sourceMap = match4;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match3;
  while ((match3 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match3[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  if (true) {
    return {
      name: name2,
      styles: styles2,
      map: sourceMap,
      next: cursor,
      toString: function toString2() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
};

// node_modules/.pnpm/@emotion+utils@1.2.1/node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache3, serialized, isStringTag) {
  var className = cache3.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache3.registered[className] === void 0
  ) {
    cache3.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache3, serialized, isStringTag) {
  registerStyles(cache3, serialized, isStringTag);
  var className = cache3.key + "-" + serialized.name;
  if (cache3.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache3.insert(serialized === current ? "." + className : "", current, cache3.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/.pnpm/@emotion+css@11.11.2/node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.esm.js
function insertWithoutScoping(cache3, serialized) {
  if (cache3.inserted[serialized.name] === void 0) {
    return cache3.insert("", serialized, cache3.sheet, true);
  }
}
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var createEmotion = function createEmotion2(options) {
  var cache3 = createCache(options);
  cache3.sheet.speedy = function(value2) {
    if (this.ctr !== 0) {
      throw new Error("speedy must be changed before any rules are inserted");
    }
    this.isSpeedy = value2;
  };
  cache3.compat = true;
  var css2 = function css3() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache3.registered, void 0);
    insertStyles(cache3, serialized, false);
    return cache3.key + "-" + serialized.name;
  };
  var keyframes2 = function keyframes3() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var serialized = serializeStyles(args, cache3.registered);
    var animation = "animation-" + serialized.name;
    insertWithoutScoping(cache3, {
      name: serialized.name,
      styles: "@keyframes " + animation + "{" + serialized.styles + "}"
    });
    return animation;
  };
  var injectGlobal2 = function injectGlobal3() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    var serialized = serializeStyles(args, cache3.registered);
    insertWithoutScoping(cache3, serialized);
  };
  var cx2 = function cx3() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return merge(cache3.registered, css2, classnames(args));
  };
  return {
    css: css2,
    cx: cx2,
    injectGlobal: injectGlobal2,
    keyframes: keyframes2,
    hydrate: function hydrate2(ids) {
      ids.forEach(function(key) {
        cache3.inserted[key] = true;
      });
    },
    flush: function flush2() {
      cache3.registered = {};
      cache3.inserted = {};
      cache3.sheet.flush();
    },
    // $FlowFixMe
    sheet: cache3.sheet,
    cache: cache3,
    getRegisteredStyles: getRegisteredStyles.bind(null, cache3.registered),
    merge: merge.bind(null, cache3.registered, css2)
  };
};
var classnames = function classnames2(args) {
  var cls = "";
  for (var i6 = 0; i6 < args.length; i6++) {
    var arg = args[i6];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};

// node_modules/.pnpm/@emotion+css@11.11.2/node_modules/@emotion/css/dist/emotion-css.esm.js
var _createEmotion = createEmotion({
  key: "css"
});
var flush = _createEmotion.flush;
var hydrate = _createEmotion.hydrate;
var cx = _createEmotion.cx;
var merge2 = _createEmotion.merge;
var getRegisteredStyles2 = _createEmotion.getRegisteredStyles;
var injectGlobal = _createEmotion.injectGlobal;
var keyframes = _createEmotion.keyframes;
var css = _createEmotion.css;
var sheet = _createEmotion.sheet;
var cache = _createEmotion.cache;

// node_modules/.pnpm/emery@1.4.2/node_modules/emery/assertions/dist/emery-assertions.esm.js
function assert(condition) {
  var message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Assert failed";
  if (!condition) {
    throw new TypeError(message);
  }
}
function assertNever(arg) {
  throw new Error("Expected never to be called, but received: " + JSON.stringify(arg));
}
function warning(condition, message) {
  if (true) {
    if (condition) {
      return;
    }
    var text3 = "Warning: ".concat(message);
    if (typeof console !== "undefined") {
      console.warn(text3);
    }
    try {
      throw Error(text3);
    } catch (x3) {
    }
  }
}

// node_modules/.pnpm/emery@1.4.2/node_modules/emery/dist/number-556a10ae.esm.js
function negate(predicate) {
  return function(value2) {
    return !predicate(value2);
  };
}
var isFinite2 = Number.isFinite;
var isInfinite = negate(isFinite2);
var isInteger = Number.isInteger;
var isFloat = negate(isInteger);

// node_modules/.pnpm/emery@1.4.2/node_modules/emery/guards/dist/emery-guards.esm.js
function isNumber(value2) {
  return typeof value2 === "number" && !isNaN(value2);
}
function isNullish(value2) {
  return value2 === null || value2 === void 0;
}
function isDefined(value2) {
  return !isNullish(value2);
}

// node_modules/.pnpm/emery@1.4.2/node_modules/emery/dist/object-d266a626.esm.js
function typedEntries(value2) {
  return Object.entries(value2);
}
function typedKeys(value2) {
  return Object.keys(value2);
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/primitives/dist/keystar-ui-primitives.esm.js
var TOKEN_PREFIX = "kui";
var THEME_DEFAULT = `${TOKEN_PREFIX}-theme`;
var SCHEME_AUTO = `${TOKEN_PREFIX}-scheme--auto`;
var SCHEME_LIGHT = `${TOKEN_PREFIX}-scheme--light`;
var SCHEME_DARK = `${TOKEN_PREFIX}-scheme--dark`;

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/style/dist/keystar-ui-style.esm.js
var import_react10 = __toESM(require_react());

// node_modules/.pnpm/facepaint@1.2.1/node_modules/facepaint/dist/index.es.js
var index = function(breakpoints2) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, literal = _ref.literal, overlap = _ref.overlap;
  var mq = literal ? breakpoints2 : ["&"].concat(breakpoints2);
  function flatten(obj) {
    if (typeof obj !== "object" || obj == null) {
      return [];
    }
    if (Array.isArray(obj)) {
      return obj.map(flatten);
    }
    var slots = {};
    var objects = {};
    var props = {};
    Object.keys(obj).forEach(function(key) {
      var item2 = obj[key];
      if (!Array.isArray(item2) && literal)
        item2 = [item2];
      if ((literal || Array.isArray(item2)) && key.charCodeAt(0) !== 38) {
        var prior = void 0;
        item2.forEach(function(v5, index2) {
          if (overlap && prior === v5) {
            return;
          }
          if (v5 == null) {
            return;
          }
          prior = v5;
          if (index2 === 0 && !literal) {
            props[key] = v5;
          } else if (slots[mq[index2]] === void 0) {
            var _slots$mq$index;
            slots[mq[index2]] = (_slots$mq$index = {}, _slots$mq$index[key] = v5, _slots$mq$index);
          } else {
            slots[mq[index2]][key] = v5;
          }
        });
      } else if (typeof item2 === "object") {
        objects[key] = flatten(item2);
      } else {
        props[key] = item2;
      }
    });
    mq.forEach(function(el) {
      if (slots[el]) {
        props[el] = slots[el];
      }
    });
    Object.assign(props, objects);
    return props;
  }
  return function() {
    for (var _len = arguments.length, values2 = Array(_len), _key = 0; _key < _len; _key++) {
      values2[_key] = arguments[_key];
    }
    return values2.map(flatten);
  };
};
var index_es_default = index;

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/style/dist/keystar-ui-style.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var tokenSchema = {
  animation: {
    duration: {
      short: "var(--kui-animation-duration-short)",
      regular: "var(--kui-animation-duration-regular)",
      long: "var(--kui-animation-duration-long)",
      xlong: "var(--kui-animation-duration-xlong)"
    },
    easing: {
      easeInOut: "var(--kui-animation-easing-ease-in-out)",
      easeIn: "var(--kui-animation-easing-ease-in)",
      easeOut: "var(--kui-animation-easing-ease-out)"
    }
  },
  size: {
    alias: {
      focusRing: "var(--kui-size-alias-focus-ring)",
      focusRingGap: "var(--kui-size-alias-focus-ring-gap)",
      singleLineHeight: "var(--kui-size-alias-single-line-height)",
      singleLineWidth: "var(--kui-size-alias-single-line-width)"
    },
    element: {
      xsmall: "var(--kui-size-element-xsmall)",
      small: "var(--kui-size-element-small)",
      regular: "var(--kui-size-element-regular)",
      medium: "var(--kui-size-element-medium)",
      large: "var(--kui-size-element-large)",
      xlarge: "var(--kui-size-element-xlarge)"
    },
    icon: {
      small: "var(--kui-size-icon-small)",
      regular: "var(--kui-size-icon-regular)",
      medium: "var(--kui-size-icon-medium)",
      large: "var(--kui-size-icon-large)"
    },
    container: {
      xsmall: "var(--kui-size-container-xsmall)",
      small: "var(--kui-size-container-small)",
      medium: "var(--kui-size-container-medium)",
      large: "var(--kui-size-container-large)",
      xlarge: "var(--kui-size-container-xlarge)"
    },
    dialog: {
      xsmall: "var(--kui-size-dialog-xsmall)",
      small: "var(--kui-size-dialog-small)",
      medium: "var(--kui-size-dialog-medium)",
      large: "var(--kui-size-dialog-large)"
    },
    border: {
      regular: "var(--kui-size-border-regular)",
      medium: "var(--kui-size-border-medium)",
      large: "var(--kui-size-border-large)"
    },
    radius: {
      full: "var(--kui-size-radius-full)",
      xsmall: "var(--kui-size-radius-xsmall)",
      small: "var(--kui-size-radius-small)",
      regular: "var(--kui-size-radius-regular)",
      medium: "var(--kui-size-radius-medium)",
      large: "var(--kui-size-radius-large)",
      xlarge: "var(--kui-size-radius-xlarge)"
    },
    shadow: {
      small: "var(--kui-size-shadow-small)",
      medium: "var(--kui-size-shadow-medium)",
      large: "var(--kui-size-shadow-large)"
    },
    space: {
      xsmall: "var(--kui-size-space-xsmall)",
      small: "var(--kui-size-space-small)",
      regular: "var(--kui-size-space-regular)",
      medium: "var(--kui-size-space-medium)",
      large: "var(--kui-size-space-large)",
      xlarge: "var(--kui-size-space-xlarge)",
      xxlarge: "var(--kui-size-space-xxlarge)"
    },
    scale: {
      "0": "var(--kui-size-scale-0)",
      "10": "var(--kui-size-scale-10)",
      "25": "var(--kui-size-scale-25)",
      "40": "var(--kui-size-scale-40)",
      "50": "var(--kui-size-scale-50)",
      "65": "var(--kui-size-scale-65)",
      "75": "var(--kui-size-scale-75)",
      "85": "var(--kui-size-scale-85)",
      "100": "var(--kui-size-scale-100)",
      "115": "var(--kui-size-scale-115)",
      "125": "var(--kui-size-scale-125)",
      "130": "var(--kui-size-scale-130)",
      "150": "var(--kui-size-scale-150)",
      "160": "var(--kui-size-scale-160)",
      "175": "var(--kui-size-scale-175)",
      "200": "var(--kui-size-scale-200)",
      "225": "var(--kui-size-scale-225)",
      "250": "var(--kui-size-scale-250)",
      "275": "var(--kui-size-scale-275)",
      "300": "var(--kui-size-scale-300)",
      "325": "var(--kui-size-scale-325)",
      "350": "var(--kui-size-scale-350)",
      "400": "var(--kui-size-scale-400)",
      "450": "var(--kui-size-scale-450)",
      "500": "var(--kui-size-scale-500)",
      "550": "var(--kui-size-scale-550)",
      "600": "var(--kui-size-scale-600)",
      "675": "var(--kui-size-scale-675)",
      "700": "var(--kui-size-scale-700)",
      "800": "var(--kui-size-scale-800)",
      "900": "var(--kui-size-scale-900)",
      "1000": "var(--kui-size-scale-1000)",
      "1200": "var(--kui-size-scale-1200)",
      "1250": "var(--kui-size-scale-1250)",
      "1600": "var(--kui-size-scale-1600)",
      "1700": "var(--kui-size-scale-1700)",
      "2000": "var(--kui-size-scale-2000)",
      "2400": "var(--kui-size-scale-2400)",
      "3000": "var(--kui-size-scale-3000)",
      "3400": "var(--kui-size-scale-3400)",
      "3600": "var(--kui-size-scale-3600)",
      "4600": "var(--kui-size-scale-4600)",
      "5000": "var(--kui-size-scale-5000)",
      "6000": "var(--kui-size-scale-6000)"
    }
  },
  typography: {
    fontFamily: {
      base: "var(--kui-typography-font-family-base)",
      code: "var(--kui-typography-font-family-code)"
    },
    fontWeight: {
      regular: "var(--kui-typography-font-weight-regular)",
      medium: "var(--kui-typography-font-weight-medium)",
      semibold: "var(--kui-typography-font-weight-semibold)",
      bold: "var(--kui-typography-font-weight-bold)"
    },
    lineheight: {
      large: "var(--kui-typography-lineheight-large)",
      medium: "var(--kui-typography-lineheight-medium)",
      small: "var(--kui-typography-lineheight-small)"
    },
    text: {
      small: {
        size: "var(--kui-typography-text-small-size)",
        lineheight: "var(--kui-typography-text-small-lineheight)",
        baselineTrim: "var(--kui-typography-text-small-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-small-capheight-trim)",
        capheight: "var(--kui-typography-text-small-capheight)"
      },
      regular: {
        size: "var(--kui-typography-text-regular-size)",
        lineheight: "var(--kui-typography-text-regular-lineheight)",
        baselineTrim: "var(--kui-typography-text-regular-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-regular-capheight-trim)",
        capheight: "var(--kui-typography-text-regular-capheight)"
      },
      medium: {
        size: "var(--kui-typography-text-medium-size)",
        lineheight: "var(--kui-typography-text-medium-lineheight)",
        baselineTrim: "var(--kui-typography-text-medium-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-medium-capheight-trim)",
        capheight: "var(--kui-typography-text-medium-capheight)"
      },
      large: {
        size: "var(--kui-typography-text-large-size)",
        lineheight: "var(--kui-typography-text-large-lineheight)",
        baselineTrim: "var(--kui-typography-text-large-baseline-trim)",
        capheightTrim: "var(--kui-typography-text-large-capheight-trim)",
        capheight: "var(--kui-typography-text-large-capheight)"
      }
    },
    heading: {
      small: {
        size: "var(--kui-typography-heading-small-size)",
        lineheight: "var(--kui-typography-heading-small-lineheight)",
        baselineTrim: "var(--kui-typography-heading-small-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-small-capheight-trim)",
        capheight: "var(--kui-typography-heading-small-capheight)"
      },
      regular: {
        size: "var(--kui-typography-heading-regular-size)",
        lineheight: "var(--kui-typography-heading-regular-lineheight)",
        baselineTrim: "var(--kui-typography-heading-regular-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-regular-capheight-trim)",
        capheight: "var(--kui-typography-heading-regular-capheight)"
      },
      medium: {
        size: "var(--kui-typography-heading-medium-size)",
        lineheight: "var(--kui-typography-heading-medium-lineheight)",
        baselineTrim: "var(--kui-typography-heading-medium-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-medium-capheight-trim)",
        capheight: "var(--kui-typography-heading-medium-capheight)"
      },
      large: {
        size: "var(--kui-typography-heading-large-size)",
        lineheight: "var(--kui-typography-heading-large-lineheight)",
        baselineTrim: "var(--kui-typography-heading-large-baseline-trim)",
        capheightTrim: "var(--kui-typography-heading-large-capheight-trim)",
        capheight: "var(--kui-typography-heading-large-capheight)"
      }
    }
  },
  color: {
    alias: {
      blanket: "var(--kui-color-alias-blanket)",
      backgroundIdle: "var(--kui-color-alias-background-idle)",
      backgroundDisabled: "var(--kui-color-alias-background-disabled)",
      backgroundHovered: "var(--kui-color-alias-background-hovered)",
      backgroundFocused: "var(--kui-color-alias-background-focused)",
      backgroundPressed: "var(--kui-color-alias-background-pressed)",
      backgroundSelected: "var(--kui-color-alias-background-selected)",
      backgroundSelectedHovered: "var(--kui-color-alias-background-selected-hovered)",
      focusRing: "var(--kui-color-alias-focus-ring)",
      borderIdle: "var(--kui-color-alias-border-idle)",
      borderHovered: "var(--kui-color-alias-border-hovered)",
      borderPressed: "var(--kui-color-alias-border-pressed)",
      borderFocused: "var(--kui-color-alias-border-focused)",
      borderDisabled: "var(--kui-color-alias-border-disabled)",
      borderSelected: "var(--kui-color-alias-border-selected)",
      borderInvalid: "var(--kui-color-alias-border-invalid)",
      foregroundIdle: "var(--kui-color-alias-foreground-idle)",
      foregroundHovered: "var(--kui-color-alias-foreground-hovered)",
      foregroundPressed: "var(--kui-color-alias-foreground-pressed)",
      foregroundFocused: "var(--kui-color-alias-foreground-focused)",
      foregroundDisabled: "var(--kui-color-alias-foreground-disabled)",
      foregroundSelected: "var(--kui-color-alias-foreground-selected)"
    },
    background: {
      canvas: "var(--kui-color-background-canvas)",
      surface: "var(--kui-color-background-surface)",
      surfaceSecondary: "var(--kui-color-background-surface-secondary)",
      surfaceTertiary: "var(--kui-color-background-surface-tertiary)",
      inverse: "var(--kui-color-background-inverse)",
      accent: "var(--kui-color-background-accent)",
      accentEmphasis: "var(--kui-color-background-accent-emphasis)",
      positive: "var(--kui-color-background-positive)",
      positiveEmphasis: "var(--kui-color-background-positive-emphasis)",
      caution: "var(--kui-color-background-caution)",
      cautionEmphasis: "var(--kui-color-background-caution-emphasis)",
      critical: "var(--kui-color-background-critical)",
      criticalEmphasis: "var(--kui-color-background-critical-emphasis)",
      pending: "var(--kui-color-background-pending)",
      pendingEmphasis: "var(--kui-color-background-pending-emphasis)",
      highlight: "var(--kui-color-background-highlight)",
      highlightEmphasis: "var(--kui-color-background-highlight-emphasis)"
    },
    border: {
      muted: "var(--kui-color-border-muted)",
      neutral: "var(--kui-color-border-neutral)",
      emphasis: "var(--kui-color-border-emphasis)",
      accent: "var(--kui-color-border-accent)",
      positive: "var(--kui-color-border-positive)",
      caution: "var(--kui-color-border-caution)",
      critical: "var(--kui-color-border-critical)",
      pending: "var(--kui-color-border-pending)",
      highlight: "var(--kui-color-border-highlight)"
    },
    foreground: {
      neutral: "var(--kui-color-foreground-neutral)",
      neutralEmphasis: "var(--kui-color-foreground-neutral-emphasis)",
      neutralSecondary: "var(--kui-color-foreground-neutral-secondary)",
      neutralTertiary: "var(--kui-color-foreground-neutral-tertiary)",
      onEmphasis: "var(--kui-color-foreground-on-emphasis)",
      inverse: "var(--kui-color-foreground-inverse)",
      inverseSecondary: "var(--kui-color-foreground-inverse-secondary)",
      accent: "var(--kui-color-foreground-accent)",
      positive: "var(--kui-color-foreground-positive)",
      caution: "var(--kui-color-foreground-caution)",
      critical: "var(--kui-color-foreground-critical)",
      pending: "var(--kui-color-foreground-pending)",
      highlight: "var(--kui-color-foreground-highlight)"
    },
    shadow: {
      muted: "var(--kui-color-shadow-muted)",
      regular: "var(--kui-color-shadow-regular)",
      emphasis: "var(--kui-color-shadow-emphasis)"
    },
    scale: {
      black: "var(--kui-color-scale-black)",
      white: "var(--kui-color-scale-white)",
      amber1: "var(--kui-color-scale-amber1)",
      amber2: "var(--kui-color-scale-amber2)",
      amber3: "var(--kui-color-scale-amber3)",
      amber4: "var(--kui-color-scale-amber4)",
      amber5: "var(--kui-color-scale-amber5)",
      amber6: "var(--kui-color-scale-amber6)",
      amber7: "var(--kui-color-scale-amber7)",
      amber8: "var(--kui-color-scale-amber8)",
      amber9: "var(--kui-color-scale-amber9)",
      amber10: "var(--kui-color-scale-amber10)",
      amber11: "var(--kui-color-scale-amber11)",
      green1: "var(--kui-color-scale-green1)",
      green2: "var(--kui-color-scale-green2)",
      green3: "var(--kui-color-scale-green3)",
      green4: "var(--kui-color-scale-green4)",
      green5: "var(--kui-color-scale-green5)",
      green6: "var(--kui-color-scale-green6)",
      green7: "var(--kui-color-scale-green7)",
      green8: "var(--kui-color-scale-green8)",
      green9: "var(--kui-color-scale-green9)",
      green10: "var(--kui-color-scale-green10)",
      green11: "var(--kui-color-scale-green11)",
      indigo1: "var(--kui-color-scale-indigo1)",
      indigo2: "var(--kui-color-scale-indigo2)",
      indigo3: "var(--kui-color-scale-indigo3)",
      indigo4: "var(--kui-color-scale-indigo4)",
      indigo5: "var(--kui-color-scale-indigo5)",
      indigo6: "var(--kui-color-scale-indigo6)",
      indigo7: "var(--kui-color-scale-indigo7)",
      indigo8: "var(--kui-color-scale-indigo8)",
      indigo9: "var(--kui-color-scale-indigo9)",
      indigo10: "var(--kui-color-scale-indigo10)",
      indigo11: "var(--kui-color-scale-indigo11)",
      pink1: "var(--kui-color-scale-pink1)",
      pink2: "var(--kui-color-scale-pink2)",
      pink3: "var(--kui-color-scale-pink3)",
      pink4: "var(--kui-color-scale-pink4)",
      pink5: "var(--kui-color-scale-pink5)",
      pink6: "var(--kui-color-scale-pink6)",
      pink7: "var(--kui-color-scale-pink7)",
      pink8: "var(--kui-color-scale-pink8)",
      pink9: "var(--kui-color-scale-pink9)",
      pink10: "var(--kui-color-scale-pink10)",
      pink11: "var(--kui-color-scale-pink11)",
      purple1: "var(--kui-color-scale-purple1)",
      purple2: "var(--kui-color-scale-purple2)",
      purple3: "var(--kui-color-scale-purple3)",
      purple4: "var(--kui-color-scale-purple4)",
      purple5: "var(--kui-color-scale-purple5)",
      purple6: "var(--kui-color-scale-purple6)",
      purple7: "var(--kui-color-scale-purple7)",
      purple8: "var(--kui-color-scale-purple8)",
      purple9: "var(--kui-color-scale-purple9)",
      purple10: "var(--kui-color-scale-purple10)",
      purple11: "var(--kui-color-scale-purple11)",
      red1: "var(--kui-color-scale-red1)",
      red2: "var(--kui-color-scale-red2)",
      red3: "var(--kui-color-scale-red3)",
      red4: "var(--kui-color-scale-red4)",
      red5: "var(--kui-color-scale-red5)",
      red6: "var(--kui-color-scale-red6)",
      red7: "var(--kui-color-scale-red7)",
      red8: "var(--kui-color-scale-red8)",
      red9: "var(--kui-color-scale-red9)",
      red10: "var(--kui-color-scale-red10)",
      red11: "var(--kui-color-scale-red11)",
      slate1: "var(--kui-color-scale-slate1)",
      slate2: "var(--kui-color-scale-slate2)",
      slate3: "var(--kui-color-scale-slate3)",
      slate4: "var(--kui-color-scale-slate4)",
      slate5: "var(--kui-color-scale-slate5)",
      slate6: "var(--kui-color-scale-slate6)",
      slate7: "var(--kui-color-scale-slate7)",
      slate8: "var(--kui-color-scale-slate8)",
      slate9: "var(--kui-color-scale-slate9)",
      slate10: "var(--kui-color-scale-slate10)",
      slate11: "var(--kui-color-scale-slate11)"
    }
  }
};
function transition(prop, options = {}) {
  let {
    delay = 0,
    duration = "short",
    easing = "easeInOut"
  } = options;
  let easingValue = easing === "linear" ? "linear" : tokenSchema.animation.easing[easing];
  let durationValue = resolveDuration(duration);
  if (Array.isArray(prop)) {
    return prop.map((p5) => transition(p5, options)).join(", ");
  }
  return `${prop} ${durationValue} ${easingValue}` + (delay ? ` ${resolveDuration(delay)}` : "");
}
function resolveDuration(duration) {
  return isNumber(duration) ? `${duration}ms` : tokenSchema.animation.duration[duration];
}
var classNamePrefix = TOKEN_PREFIX;
var resetClassName = voussoirClassName("reset");
function voussoirClassName(className) {
  return `${classNamePrefix}:${className}`;
}
function classNames(...inputs) {
  let resolved = cx(inputs);
  if (resolved.includes(resetClassName)) {
    return resolved;
  }
  return cx(resetClassName, resolved);
}
var _componentName, _root, _elements;
var ClassList = class {
  constructor(componentName, elements = []) {
    /** The component name for this class list. */
    __privateAdd(this, _componentName, void 0);
    /** The root class name. */
    __privateAdd(this, _root, void 0);
    /** The list of element class names. */
    __privateAdd(this, _elements, void 0);
    __privateSet(this, _componentName, componentName);
    __privateSet(this, _root, voussoirClassName(componentName));
    __privateSet(this, _elements, new Map(elements.map((element2) => [element2, `${__privateGet(this, _root)}-${element2}`])));
  }
  element(name2) {
    if (name2 === "root") {
      return __privateGet(this, _root);
    }
    let className = __privateGet(this, _elements).get(name2);
    assert(!!className, `Element "${name2}" not found in "${__privateGet(this, _componentName)}" class list. All elements must be defined when the ClassList is instantiated.`);
    return className;
  }
  selector(element2, combinator) {
    let className = this.element(element2);
    if (!combinator) {
      return safeClassName(className);
    }
    return combinators[combinator] + safeClassName(className);
  }
};
_componentName = new WeakMap();
_root = new WeakMap();
_elements = new WeakMap();
function safeClassName(className) {
  return `.${className.replace(/:/g, "\\:")}`;
}
var combinators = {
  descendant: "& ",
  child: "& > ",
  sibling: "& ~ ",
  "adjacent-sibling": "& + "
};
var breakpoints = {
  mobile: 0,
  tablet: 740,
  desktop: 992,
  wide: 1200
};
var mediaAbove = (bp) => `@media (min-width: ${bp}px)`;
var mediaBelow = (bp) => `@media (max-width: ${bp - 1}px)`;
var containerAbove = (bp) => `@container (min-width: ${bp}px)`;
var containerBelow = (bp) => `@container (max-width: ${bp - 1}px)`;
var breakpointQueries$1 = {
  above: {
    mobile: mediaAbove(breakpoints.tablet),
    tablet: mediaAbove(breakpoints.desktop),
    desktop: mediaAbove(breakpoints.wide)
  },
  below: {
    tablet: mediaBelow(breakpoints.tablet),
    desktop: mediaBelow(breakpoints.desktop),
    wide: mediaBelow(breakpoints.wide)
  }
};
var containerQueries = {
  above: {
    mobile: containerAbove(breakpoints.tablet),
    tablet: containerAbove(breakpoints.desktop),
    desktop: containerAbove(breakpoints.wide)
  },
  below: {
    tablet: containerBelow(breakpoints.tablet),
    desktop: containerBelow(breakpoints.desktop),
    wide: containerBelow(breakpoints.wide)
  }
};
var breakpointNames = typedKeys(breakpoints);
var {
  mobile: _mobile$1,
  ...breakpointsWithoutMobile$1
} = breakpoints;
var mediaQueries = Object.values(breakpointsWithoutMobile$1).map(mediaAbove);
var mapToMediaQueries = index_es_default(mediaQueries);
function mapResponsiveValue(propResolver, value2) {
  if (value2 == null) {
    return null;
  }
  if (typeof value2 === "object" && !Array.isArray(value2)) {
    return objectToArray(propResolver, value2);
  }
  return propResolver(value2);
}
function objectToArray(propResolver, value2) {
  const valueArray = [];
  for (let i6 = 0; i6 < breakpointNames.length; i6++) {
    const key = breakpointNames[i6];
    valueArray.push(value2[key] != null ? propResolver(value2[key]) : null);
  }
  return valueArray;
}
function getResponsiveProp(prop, matchedBreakpoints) {
  if (typeof prop === "object" && prop !== null) {
    for (let i6 = 0; i6 < matchedBreakpoints.length; i6++) {
      let value2 = prop[matchedBreakpoints[i6]];
      if (value2 != null) {
        return value2;
      }
    }
    return prop.mobile;
  }
  return prop;
}
function getResponsiveRange(range, matchedBreakpoints) {
  if (typeof range === "boolean") {
    return range;
  }
  if (!("above" in range) && !("below" in range)) {
    return getResponsiveProp(range, matchedBreakpoints);
  }
  const startIndex = "above" in range ? breakpointNames.indexOf(range.above) + 1 : 0;
  const endIndex = "below" in range ? breakpointNames.indexOf(range.below) - 1 : breakpointNames.length - 1;
  const prop = Object.fromEntries(breakpointNames.map((key, index2) => {
    return [key, index2 >= startIndex && index2 <= endIndex];
  }));
  return getResponsiveProp(prop, matchedBreakpoints);
}
var Context = import_react10.default.createContext(["mobile"]);
function BreakpointProvider(props) {
  const {
    children,
    value: value2
  } = props;
  return (0, import_jsx_runtime.jsx)(Context.Provider, {
    value: value2,
    children
  });
}
function useBreakpoint() {
  return (0, import_react10.useContext)(Context);
}
var {
  mobile: _mobile,
  ...breakpointsWithoutMobile
} = breakpoints;
var breakpointEntries = typedEntries(breakpointsWithoutMobile).sort(([, valueA], [, valueB]) => valueB - valueA);
var breakpointQueries = breakpointEntries.map(([, value2]) => `(min-width: ${value2}px)`);
var useLayoutEffectIgnoreOnServer = typeof window === "undefined" ? () => {
} : import_react10.useLayoutEffect;
var supportsMatchMedia = typeof window !== "undefined" && typeof window.matchMedia === "function";
function useMatchedBreakpoints() {
  const [breakpoint, setBreakpoint] = (0, import_react10.useState)(() => ["mobile"]);
  useLayoutEffectIgnoreOnServer(() => {
    if (!supportsMatchMedia) {
      return;
    }
    const onResize = () => {
      setBreakpoint((prevMatchedBreakpoints) => {
        const matched = [];
        for (let i6 in breakpointQueries) {
          let query = breakpointQueries[i6];
          if (window.matchMedia(query).matches) {
            matched.push(breakpointEntries[i6][0]);
          }
        }
        matched.push("mobile");
        if (prevMatchedBreakpoints.length !== matched.length || prevMatchedBreakpoints.some((breakpoint2, idx) => breakpoint2 !== matched[idx])) {
          return matched;
        }
        return prevMatchedBreakpoints;
      });
    };
    onResize();
    window.addEventListener("resize", onResize);
    return () => {
      window.removeEventListener("resize", onResize);
    };
  }, []);
  return breakpoint;
}
function useResponsiveRange() {
  let matchedBreakpoints = useBreakpoint();
  return function responsiveRange(range) {
    return getResponsiveRange(range, matchedBreakpoints);
  };
}
function get(val, path2) {
  for (const part of path2.split(".")) {
    if (typeof val !== "object" || val === null || !Object.prototype.hasOwnProperty.call(val, part)) {
      return;
    }
    val = val[part];
  }
  return val;
}
function maybeTokenByKey(path2, keyOrValue) {
  var _get;
  if (typeof keyOrValue !== "string") {
    return keyOrValue;
  }
  path2 = keyOrValue.includes(".") ? keyOrValue : `${path2}.${keyOrValue}`;
  return (_get = get(tokenSchema, path2)) !== null && _get !== void 0 ? _get : keyOrValue;
}
function resolvePropWithPath(prop, path2) {
  const resolver = (value2) => maybeTokenByKey(path2, value2);
  return [prop, resolver];
}
var identity = (value2) => value2;
function resolveProp(prop, fn2 = identity) {
  return [prop, fn2];
}
function border(prop) {
  const resolver = (value2) => {
    const color = maybeTokenByKey("color.border", value2);
    return `${tokenSchema.size.border.regular} solid ${color}`;
  };
  return [prop, resolver];
}
function isDimensionKey(value2) {
  let [prop, key] = value2.split(".");
  if (!prop || !key) {
    return false;
  }
  return !!tokenSchema.size[prop][key];
}
function sizeResolver(value2) {
  if (typeof value2 === "number") {
    if (value2 === 0) {
      return `${value2}px`;
    }
    assertNever(value2);
  }
  if (isDimensionKey(value2)) {
    let [prop, key] = value2.split(".");
    return tokenSchema.size[prop][key];
  }
  if (value2 === "auto" || value2 === "inherit" || value2 === "100%" || value2 === "100vh" || value2 === "100vw") {
    return value2;
  }
  assertNever(value2);
}
function size(cssProp) {
  return [cssProp, sizeResolver];
}
function space(prop) {
  return resolvePropWithPath(prop, "size.space");
}
function radius(prop) {
  return resolvePropWithPath(prop, "size.radius");
}
var defaultStyleProps = {
  // color
  backgroundColor: resolvePropWithPath("backgroundColor", "color.background"),
  boxShadow: ["boxShadow", boxShadowResolver],
  // dimension
  height: size("height"),
  maxHeight: size("maxHeight"),
  minHeight: size("minHeight"),
  maxWidth: size("maxWidth"),
  minWidth: size("minWidth"),
  width: size("width"),
  // space
  margin: space("margin"),
  marginStart: space("marginInlineStart"),
  marginEnd: space("marginInlineEnd"),
  marginTop: space("marginBlockStart"),
  marginBottom: space("marginBlockEnd"),
  marginX: space("marginInline"),
  marginY: space("marginBlock"),
  padding: space("padding"),
  paddingStart: space("paddingInlineStart"),
  paddingEnd: space("paddingInlineEnd"),
  paddingTop: space("paddingBlockStart"),
  paddingBottom: space("paddingBlockEnd"),
  paddingX: space("paddingInline"),
  paddingY: space("paddingBlock"),
  // border
  border: border("border"),
  borderStart: border("borderInlineStart"),
  borderEnd: border("borderInlineEnd"),
  borderTop: border("borderTop"),
  borderBottom: border("borderBottom"),
  borderColor: resolvePropWithPath("borderColor", "color.border"),
  borderStartColor: resolvePropWithPath("borderInlineStartColor", "color.border"),
  borderEndColor: resolvePropWithPath("borderInlineEndColor", "color.border"),
  borderTopColor: resolvePropWithPath("borderTopColor", "color.border"),
  borderBottomColor: resolvePropWithPath("borderBottomColor", "color.border"),
  borderStyle: resolveProp("borderStyle"),
  borderStartStyle: resolveProp("borderInlineStartStyle"),
  borderEndStyle: resolveProp("borderInlineEndStyle"),
  borderTopStyle: resolveProp("borderTopStyle"),
  borderBottomStyle: resolveProp("borderBottomStyle"),
  borderWidth: resolvePropWithPath("borderWidth", "size.border"),
  borderStartWidth: resolvePropWithPath("borderInlineStartWidth", "size.border"),
  borderEndWidth: resolvePropWithPath("borderInlineEndWidth", "size.border"),
  borderTopWidth: resolvePropWithPath("borderTopWidth", "size.border"),
  borderBottomWidth: resolvePropWithPath("borderBottomWidth", "size.border"),
  borderRadius: radius("borderRadius"),
  borderTopStartRadius: radius("borderStartStartRadius"),
  borderTopEndRadius: radius("borderStartEndRadius"),
  borderBottomStartRadius: radius("borderEndStartRadius"),
  borderBottomEndRadius: radius("borderEndEndRadius"),
  borderTopRadius: radius(["borderStartStartRadius", "borderStartEndRadius"]),
  borderBottomRadius: radius(["borderEndStartRadius", "borderEndEndRadius"]),
  borderStartRadius: radius(["borderStartStartRadius", "borderEndStartRadius"]),
  borderEndRadius: radius(["borderEndEndRadius", "borderStartEndRadius"]),
  // position
  inset: space("inset"),
  insetBottom: space("insetBlockEnd"),
  insetEnd: space("insetInlineEnd"),
  insetStart: space("insetInlineStart"),
  insetTop: space("insetBlockStart"),
  insetX: space("insetInline"),
  insetY: space("insetBlock"),
  position: resolveProp("position"),
  zIndex: resolveProp("zIndex"),
  // flex child
  order: resolveProp("order"),
  alignSelf: resolveProp("alignSelf"),
  flex: resolveProp("flex", flexResolver),
  flexBasis: size("flexBasis"),
  flexGrow: resolveProp("flexGrow", flexResolver),
  flexShrink: resolveProp("flexShrink", flexResolver),
  justifySelf: resolveProp("justifySelf"),
  // grid child
  gridArea: resolveProp("gridArea"),
  gridColumn: resolveProp("gridColumn"),
  gridColumnEnd: resolveProp("gridColumnEnd"),
  gridColumnStart: resolveProp("gridColumnStart"),
  gridRow: resolveProp("gridRow"),
  gridRowEnd: resolveProp("gridRowEnd"),
  gridRowStart: resolveProp("gridRowStart"),
  // misc. non-theme related
  cursor: resolveProp("cursor"),
  opacity: resolveProp("opacity"),
  pointerEvents: resolveProp("pointerEvents"),
  overflow: resolveProp("overflow"),
  userSelect: resolveProp("userSelect")
};
function flexResolver(value2) {
  if (typeof value2 === "boolean") {
    return value2 ? "1" : void 0;
  }
  return "" + value2;
}
function boxShadowResolver(value2) {
  const sizeToColorKey = {
    small: "muted",
    medium: "regular",
    large: "emphasis"
  };
  const [sizeKey, maybeColorKey] = value2.split(" ");
  const color = maybeTokenByKey("color.shadow", maybeColorKey !== null && maybeColorKey !== void 0 ? maybeColorKey : sizeToColorKey[sizeKey]);
  const size3 = maybeTokenByKey("size.shadow", sizeKey);
  return `${size3} ${color}`;
}
var defaultStyleKeys = Object.keys(defaultStyleProps);
function filterStyleProps(props, otherPropNames = []) {
  let filteredProps = {};
  let omit = /* @__PURE__ */ new Set(["isHidden", "UNSAFE_className", "UNSAFE_style", ...defaultStyleKeys, ...otherPropNames]);
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && !omit.has(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
}
function onlyStyleProps(props) {
  let filteredProps = {};
  let include = /* @__PURE__ */ new Set(["isHidden", "UNSAFE_className", "UNSAFE_style", ...defaultStyleKeys]);
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && include.has(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
}
function toDataAttributes(data, options = {}) {
  let dataAttributes = {};
  for (let key in data) {
    let prop = key;
    let value2 = data[key];
    if (value2 == null || options.omitFalsyValues && (value2 === false || value2 === "")) {
      continue;
    }
    if (options.trimBooleanKeys && key.startsWith("is")) {
      prop = prop.charAt(2).toLowerCase() + prop.slice(3);
    }
    prop = prop.replace(/[A-Z]/g, (char2) => `-${char2.toLowerCase()}`);
    dataAttributes[`data-${prop}`] = value2;
  }
  return dataAttributes;
}
function FocusRing(props) {
  let {
    children
  } = props;
  let {
    isFocused,
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f(props);
  let child = import_react10.Children.only(children);
  return (0, import_react10.cloneElement)(child, $3ef42575df84b30b$export$9d1611c77c2fe928(child.props, {
    ...focusProps,
    ...toDataAttributes({
      focus: isFocusVisible ? "visible" : props.within ? "within" : isFocused || void 0
    })
  }));
}
function useIsMobileDevice() {
  let isSSR = $b5e257d569688ac6$export$535bd6ca7f90a273();
  if (isSSR || typeof window === "undefined") {
    return false;
  }
  return window.screen.width <= breakpoints.tablet;
}
function useMediaQuery(query) {
  query = normalizeQuery(query);
  let supportsMatchMedia2 = typeof window !== "undefined" && typeof window.matchMedia === "function";
  let [matches, setMatches] = (0, import_react10.useState)(() => supportsMatchMedia2 ? window.matchMedia(query).matches : false);
  (0, import_react10.useEffect)(() => {
    if (!supportsMatchMedia2) {
      return;
    }
    let mediaQueryList = window.matchMedia(query);
    let supportsEventListener = typeof mediaQueryList.addEventListener === "function";
    let onChange = (evt) => {
      setMatches(evt.matches);
    };
    if (supportsEventListener) {
      mediaQueryList.addEventListener("change", onChange);
    } else {
      mediaQueryList.addListener(onChange);
    }
    return () => {
      if (supportsEventListener) {
        mediaQueryList.removeEventListener("change", onChange);
      } else {
        mediaQueryList.removeListener(onChange);
      }
    };
  }, [supportsMatchMedia2, query]);
  let isSSR = $b5e257d569688ac6$export$535bd6ca7f90a273();
  return isSSR ? false : matches;
}
function normalizeQuery(query) {
  return query.replace(/^@media( ?)/m, "");
}
function convertStyleProps(props, propResolvers) {
  let style = {};
  for (let key in props) {
    let styleProp = propResolvers[key];
    if (!styleProp || props[key] == null) {
      continue;
    }
    let [name2, convert] = styleProp;
    let value2 = mapResponsiveValue(convert, props[key]);
    if (Array.isArray(name2)) {
      for (let k2 of name2) {
        style[k2] = value2;
      }
    } else {
      style[name2] = value2;
    }
  }
  return style;
}
function useStyleProps(props, customResolvers = {}) {
  let propResolvers = {
    ...defaultStyleProps,
    ...customResolvers
  };
  let {
    isHidden: isHidden2,
    UNSAFE_className,
    UNSAFE_style,
    ...otherProps
  } = props;
  let convertedProps = convertStyleProps(props, propResolvers);
  let resolvedStyles = mapToMediaQueries(convertedProps);
  warning(
    // @ts-ignore
    !otherProps.className,
    "The className prop is unsafe and is unsupported. Please use style props, or UNSAFE_className if you absolutely must do something custom. Note that this may break in future versions due to DOM structure changes."
  );
  warning(
    // @ts-ignore
    !otherProps.style,
    "The style prop is unsafe and is unsupported. Please use style props, or UNSAFE_style if you absolutely must do something custom. Note that this may break in future versions due to DOM structure changes."
  );
  let hiddenStyles = [];
  if (isHidden2) {
    if (isHidden2 === true) {
      hiddenStyles.push({
        display: "none"
      });
    } else {
      const styles2 = {};
      if ("above" in isHidden2) {
        styles2[breakpointQueries$1.above[isHidden2.above]] = {
          display: "none"
        };
      }
      if ("below" in isHidden2) {
        styles2[breakpointQueries$1.below[isHidden2.below]] = {
          display: "none"
        };
      }
      hiddenStyles.push(styles2);
    }
  }
  return {
    className: classNames(
      css(resolvedStyles),
      UNSAFE_className,
      css(hiddenStyles)
      // must be last
    ),
    style: UNSAFE_style
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/core/dist/keystar-ui-core.esm.js
var import_react12 = __toESM(require_react());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/utils/ts/dist/keystar-ui-utils-ts.esm.js
var import_react11 = __toESM(require_react());
function forwardRefWithAs(render3) {
  return (0, import_react11.forwardRef)(render3);
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/core/dist/keystar-ui-core.esm.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var Context2 = (0, import_react12.createContext)(null);
Context2.displayName = "KeystarProviderContext";
function useProvider() {
  let context = (0, import_react12.useContext)(Context2);
  if (!context) {
    throw new Error("Attempt to access context outside of KeystarProvider.");
  }
  return context;
}
function useProviderProps(props) {
  let context = useProvider();
  if (!context) {
    return props;
  }
  return Object.assign({}, {
    // prominence: context.prominence,
    isDisabled: context.isDisabled,
    isRequired: context.isRequired,
    isReadOnly: context.isReadOnly
  }, props);
}
var cssCustomProperties = `
/**
 * Do not edit directly
 * Generated on Fri, 03 Nov 2023 05:52:12 GMT
 */

.kui-scheme--auto,
.kui-scheme--light {
  color-scheme: light;

  --kui-color-scale-slate11: #2c2c2c;
  --kui-color-scale-slate10: #4b4b4b;
  --kui-color-scale-slate9: #6e6e6e;
  --kui-color-scale-slate8: #8e8e8e;
  --kui-color-scale-slate7: #b3b3b3;
  --kui-color-scale-slate6: #cacaca;
  --kui-color-scale-slate5: #e1e1e1;
  --kui-color-scale-slate4: #eaeaea;
  --kui-color-scale-slate3: #f5f5f5;
  --kui-color-scale-slate2: #fafafa;
  --kui-color-scale-slate1: #ffffff;
  --kui-color-scale-red11: #cd2b31;
  --kui-color-scale-red10: #dc3d43;
  --kui-color-scale-red9: #e5484d;
  --kui-color-scale-red8: #eb9091;
  --kui-color-scale-red7: #f3aeaf;
  --kui-color-scale-red6: #f9c6c6;
  --kui-color-scale-red5: #fdd8d8;
  --kui-color-scale-red4: #ffe5e5;
  --kui-color-scale-red3: #ffefef;
  --kui-color-scale-red2: #fff8f8;
  --kui-color-scale-red1: #fffcfc;
  --kui-color-scale-purple11: #793aaf;
  --kui-color-scale-purple10: #8445bc;
  --kui-color-scale-purple9: #8e4ec6;
  --kui-color-scale-purple8: #be93e4;
  --kui-color-scale-purple7: #d3b4ed;
  --kui-color-scale-purple6: #e3ccf4;
  --kui-color-scale-purple5: #eddbf9;
  --kui-color-scale-purple4: #f3e7fc;
  --kui-color-scale-purple3: #f9f1fe;
  --kui-color-scale-purple2: #fdfaff;
  --kui-color-scale-purple1: #fefcfe;
  --kui-color-scale-pink11: #cd1d8d;
  --kui-color-scale-pink10: #d23197;
  --kui-color-scale-pink9: #d6409f;
  --kui-color-scale-pink8: #e38ec3;
  --kui-color-scale-pink7: #ecadd4;
  --kui-color-scale-pink6: #f3c6e2;
  --kui-color-scale-pink5: #f9d8ec;
  --kui-color-scale-pink4: #fce5f3;
  --kui-color-scale-pink3: #feeef8;
  --kui-color-scale-pink2: #fff7fc;
  --kui-color-scale-pink1: #fffcfe;
  --kui-color-scale-indigo11: #3451b2;
  --kui-color-scale-indigo10: #3a5ccc;
  --kui-color-scale-indigo9: #3e63dd;
  --kui-color-scale-indigo8: #8da4ef;
  --kui-color-scale-indigo7: #aec0f5;
  --kui-color-scale-indigo6: #c6d4f9;
  --kui-color-scale-indigo5: #d9e2fc;
  --kui-color-scale-indigo4: #e6edfe;
  --kui-color-scale-indigo3: #f0f4ff;
  --kui-color-scale-indigo2: #f8faff;
  --kui-color-scale-indigo1: #fdfdfe;
  --kui-color-scale-green11: #18794e;
  --kui-color-scale-green10: #299764;
  --kui-color-scale-green9: #30a46c;
  --kui-color-scale-green8: #5bb98c;
  --kui-color-scale-green7: #92ceac;
  --kui-color-scale-green6: #b4dfc4;
  --kui-color-scale-green5: #ccebd7;
  --kui-color-scale-green4: #ddf3e4;
  --kui-color-scale-green3: #e9f9ee;
  --kui-color-scale-green2: #f2fcf5;
  --kui-color-scale-green1: #fbfefc;
  --kui-color-scale-amber11: #ad5700;
  --kui-color-scale-amber10: #ffa01c;
  --kui-color-scale-amber9: #ffb224;
  --kui-color-scale-amber8: #ee9d2b;
  --kui-color-scale-amber7: #f3ba63;
  --kui-color-scale-amber6: #ffd386;
  --kui-color-scale-amber5: #ffe3a2;
  --kui-color-scale-amber4: #ffecbc;
  --kui-color-scale-amber3: #fff4d5;
  --kui-color-scale-amber2: #fff9ed;
  --kui-color-scale-amber1: #fefdfb;
  --kui-color-scale-white: #ffffff;
  --kui-color-scale-black: #000000;
  --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
  --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
  --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
  --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
  --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
  --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
  --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
  --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
  --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
  --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
  --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
  --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
  --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 3%);
  --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
  --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 15%);
  --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 5%);
  --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
  --kui-color-foreground-pending: var(--kui-color-scale-purple11);
  --kui-color-foreground-critical: var(--kui-color-scale-red11);
  --kui-color-foreground-caution: var(--kui-color-scale-amber11);
  --kui-color-foreground-positive: var(--kui-color-scale-green11);
  --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
  --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
  --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
  --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
  --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
  --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
  --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
  --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
  --kui-color-border-highlight: var(--kui-color-scale-pink6);
  --kui-color-border-pending: var(--kui-color-scale-purple6);
  --kui-color-border-critical: var(--kui-color-scale-red6);
  --kui-color-border-caution: var(--kui-color-scale-amber6);
  --kui-color-border-positive: var(--kui-color-scale-green6);
  --kui-color-border-accent: var(--kui-color-scale-indigo6);
  --kui-color-border-emphasis: var(--kui-color-scale-slate6);
  --kui-color-border-neutral: var(--kui-color-scale-slate5);
  --kui-color-border-muted: var(--kui-color-scale-slate4);
  --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
  --kui-color-background-highlight: var(--kui-color-scale-pink3);
  --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
  --kui-color-background-pending: var(--kui-color-scale-purple3);
  --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
  --kui-color-background-critical: var(--kui-color-scale-red3);
  --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
  --kui-color-background-caution: var(--kui-color-scale-amber3);
  --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
  --kui-color-background-positive: var(--kui-color-scale-green3);
  --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
  --kui-color-background-accent: var(--kui-color-scale-indigo3);
  --kui-color-background-inverse: var(--kui-color-scale-slate10);
  --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
  --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
  --kui-color-background-surface: var(--kui-color-scale-slate2);
  --kui-color-background-canvas: var(--kui-color-scale-slate1);
}
.kui-scheme--dark {
  color-scheme: dark;

  --kui-color-scale-slate11: #e3e3e3;
  --kui-color-scale-slate10: #b9b9b9;
  --kui-color-scale-slate9: #909090;
  --kui-color-scale-slate8: #6e6e6e;
  --kui-color-scale-slate7: #5a5a5a;
  --kui-color-scale-slate6: #4a4a4a;
  --kui-color-scale-slate5: #3e3e3e;
  --kui-color-scale-slate4: #323232;
  --kui-color-scale-slate3: #2f2f2f;
  --kui-color-scale-slate2: #252525;
  --kui-color-scale-slate1: #1f1f1f;
  --kui-color-scale-red11: #ff6369;
  --kui-color-scale-red10: #f2555a;
  --kui-color-scale-red9: #e5484d;
  --kui-color-scale-red8: #aa2429;
  --kui-color-scale-red7: #822025;
  --kui-color-scale-red6: #671e22;
  --kui-color-scale-red5: #541b1f;
  --kui-color-scale-red4: #481a1d;
  --kui-color-scale-red3: #3c181a;
  --kui-color-scale-red2: #291415;
  --kui-color-scale-red1: #1f1315;
  --kui-color-scale-purple11: #bf7af0;
  --kui-color-scale-purple10: #9d5bd2;
  --kui-color-scale-purple9: #8e4ec6;
  --kui-color-scale-purple8: #7938b2;
  --kui-color-scale-purple7: #5f2d84;
  --kui-color-scale-purple6: #4e2667;
  --kui-color-scale-purple5: #432155;
  --kui-color-scale-purple4: #3a1e48;
  --kui-color-scale-purple3: #301a3a;
  --kui-color-scale-purple2: #221527;
  --kui-color-scale-purple1: #1b141d;
  --kui-color-scale-pink11: #f65cb6;
  --kui-color-scale-pink10: #e34ba9;
  --kui-color-scale-pink9: #d6409f;
  --kui-color-scale-pink8: #a71873;
  --kui-color-scale-pink7: #7a1d5a;
  --kui-color-scale-pink6: #601d48;
  --kui-color-scale-pink5: #501b3f;
  --kui-color-scale-pink4: #451a37;
  --kui-color-scale-pink3: #3a182f;
  --kui-color-scale-pink2: #271421;
  --kui-color-scale-pink1: #1f121b;
  --kui-color-scale-indigo11: #849dff;
  --kui-color-scale-indigo10: #5373e7;
  --kui-color-scale-indigo9: #3e63dd;
  --kui-color-scale-indigo8: #2f4eb2;
  --kui-color-scale-indigo7: #273e89;
  --kui-color-scale-indigo6: #22346e;
  --kui-color-scale-indigo5: #1f2c5c;
  --kui-color-scale-indigo4: #1c274f;
  --kui-color-scale-indigo3: #192140;
  --kui-color-scale-indigo2: #15192d;
  --kui-color-scale-indigo1: #131620;
  --kui-color-scale-green11: #4cc38a;
  --kui-color-scale-green10: #3cb179;
  --kui-color-scale-green9: #30a46c;
  --kui-color-scale-green8: #236e4a;
  --kui-color-scale-green7: #1b543a;
  --kui-color-scale-green6: #164430;
  --kui-color-scale-green5: #133929;
  --kui-color-scale-green4: #113123;
  --kui-color-scale-green3: #0f291e;
  --kui-color-scale-green2: #0c1f17;
  --kui-color-scale-green1: #0d1912;
  --kui-color-scale-amber11: #f1a10d;
  --kui-color-scale-amber10: #ffcb47;
  --kui-color-scale-amber9: #ffb224;
  --kui-color-scale-amber8: #824e00;
  --kui-color-scale-amber7: #693f05;
  --kui-color-scale-amber6: #573300;
  --kui-color-scale-amber5: #4a2900;
  --kui-color-scale-amber4: #3f2200;
  --kui-color-scale-amber3: #341c00;
  --kui-color-scale-amber2: #271700;
  --kui-color-scale-amber1: #1f1300;
  --kui-color-scale-white: #ffffff;
  --kui-color-scale-black: #000000;
  --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
  --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
  --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
  --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
  --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
  --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
  --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
  --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
  --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
  --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
  --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
  --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
  --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 4%);
  --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 40%);
  --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
  --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
  --kui-color-foreground-pending: var(--kui-color-scale-purple11);
  --kui-color-foreground-critical: var(--kui-color-scale-red11);
  --kui-color-foreground-caution: var(--kui-color-scale-amber11);
  --kui-color-foreground-positive: var(--kui-color-scale-green11);
  --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
  --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
  --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
  --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
  --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
  --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
  --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
  --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
  --kui-color-border-highlight: var(--kui-color-scale-pink6);
  --kui-color-border-pending: var(--kui-color-scale-purple6);
  --kui-color-border-critical: var(--kui-color-scale-red6);
  --kui-color-border-caution: var(--kui-color-scale-amber6);
  --kui-color-border-positive: var(--kui-color-scale-green6);
  --kui-color-border-accent: var(--kui-color-scale-indigo6);
  --kui-color-border-emphasis: var(--kui-color-scale-slate6);
  --kui-color-border-neutral: var(--kui-color-scale-slate5);
  --kui-color-border-muted: var(--kui-color-scale-slate4);
  --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
  --kui-color-background-highlight: var(--kui-color-scale-pink3);
  --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
  --kui-color-background-pending: var(--kui-color-scale-purple3);
  --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
  --kui-color-background-critical: var(--kui-color-scale-red3);
  --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
  --kui-color-background-caution: var(--kui-color-scale-amber3);
  --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
  --kui-color-background-positive: var(--kui-color-scale-green3);
  --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
  --kui-color-background-accent: var(--kui-color-scale-indigo3);
  --kui-color-background-inverse: var(--kui-color-scale-slate10);
  --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
  --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
  --kui-color-background-surface: var(--kui-color-scale-slate2);
  --kui-color-background-canvas: var(--kui-color-scale-slate1);
}
@media (prefers-color-scheme: dark) {
  .kui-scheme--auto {
    color-scheme: dark;

    --kui-color-scale-slate11: #e3e3e3;
    --kui-color-scale-slate10: #b9b9b9;
    --kui-color-scale-slate9: #909090;
    --kui-color-scale-slate8: #6e6e6e;
    --kui-color-scale-slate7: #5a5a5a;
    --kui-color-scale-slate6: #4a4a4a;
    --kui-color-scale-slate5: #3e3e3e;
    --kui-color-scale-slate4: #323232;
    --kui-color-scale-slate3: #2f2f2f;
    --kui-color-scale-slate2: #252525;
    --kui-color-scale-slate1: #1f1f1f;
    --kui-color-scale-red11: #ff6369;
    --kui-color-scale-red10: #f2555a;
    --kui-color-scale-red9: #e5484d;
    --kui-color-scale-red8: #aa2429;
    --kui-color-scale-red7: #822025;
    --kui-color-scale-red6: #671e22;
    --kui-color-scale-red5: #541b1f;
    --kui-color-scale-red4: #481a1d;
    --kui-color-scale-red3: #3c181a;
    --kui-color-scale-red2: #291415;
    --kui-color-scale-red1: #1f1315;
    --kui-color-scale-purple11: #bf7af0;
    --kui-color-scale-purple10: #9d5bd2;
    --kui-color-scale-purple9: #8e4ec6;
    --kui-color-scale-purple8: #7938b2;
    --kui-color-scale-purple7: #5f2d84;
    --kui-color-scale-purple6: #4e2667;
    --kui-color-scale-purple5: #432155;
    --kui-color-scale-purple4: #3a1e48;
    --kui-color-scale-purple3: #301a3a;
    --kui-color-scale-purple2: #221527;
    --kui-color-scale-purple1: #1b141d;
    --kui-color-scale-pink11: #f65cb6;
    --kui-color-scale-pink10: #e34ba9;
    --kui-color-scale-pink9: #d6409f;
    --kui-color-scale-pink8: #a71873;
    --kui-color-scale-pink7: #7a1d5a;
    --kui-color-scale-pink6: #601d48;
    --kui-color-scale-pink5: #501b3f;
    --kui-color-scale-pink4: #451a37;
    --kui-color-scale-pink3: #3a182f;
    --kui-color-scale-pink2: #271421;
    --kui-color-scale-pink1: #1f121b;
    --kui-color-scale-indigo11: #849dff;
    --kui-color-scale-indigo10: #5373e7;
    --kui-color-scale-indigo9: #3e63dd;
    --kui-color-scale-indigo8: #2f4eb2;
    --kui-color-scale-indigo7: #273e89;
    --kui-color-scale-indigo6: #22346e;
    --kui-color-scale-indigo5: #1f2c5c;
    --kui-color-scale-indigo4: #1c274f;
    --kui-color-scale-indigo3: #192140;
    --kui-color-scale-indigo2: #15192d;
    --kui-color-scale-indigo1: #131620;
    --kui-color-scale-green11: #4cc38a;
    --kui-color-scale-green10: #3cb179;
    --kui-color-scale-green9: #30a46c;
    --kui-color-scale-green8: #236e4a;
    --kui-color-scale-green7: #1b543a;
    --kui-color-scale-green6: #164430;
    --kui-color-scale-green5: #133929;
    --kui-color-scale-green4: #113123;
    --kui-color-scale-green3: #0f291e;
    --kui-color-scale-green2: #0c1f17;
    --kui-color-scale-green1: #0d1912;
    --kui-color-scale-amber11: #f1a10d;
    --kui-color-scale-amber10: #ffcb47;
    --kui-color-scale-amber9: #ffb224;
    --kui-color-scale-amber8: #824e00;
    --kui-color-scale-amber7: #693f05;
    --kui-color-scale-amber6: #573300;
    --kui-color-scale-amber5: #4a2900;
    --kui-color-scale-amber4: #3f2200;
    --kui-color-scale-amber3: #341c00;
    --kui-color-scale-amber2: #271700;
    --kui-color-scale-amber1: #1f1300;
    --kui-color-scale-white: #ffffff;
    --kui-color-scale-black: #000000;
    --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
    --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
    --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
    --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
    --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
    --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
    --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
    --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
    --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
    --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
    --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
    --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
    --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
    --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
    --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
    --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
    --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
    --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
    --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
    --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
    --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 4%);
    --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
    --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
    --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 40%);
    --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
    --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
    --kui-color-foreground-pending: var(--kui-color-scale-purple11);
    --kui-color-foreground-critical: var(--kui-color-scale-red11);
    --kui-color-foreground-caution: var(--kui-color-scale-amber11);
    --kui-color-foreground-positive: var(--kui-color-scale-green11);
    --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
    --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
    --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
    --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
    --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
    --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
    --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
    --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
    --kui-color-border-highlight: var(--kui-color-scale-pink6);
    --kui-color-border-pending: var(--kui-color-scale-purple6);
    --kui-color-border-critical: var(--kui-color-scale-red6);
    --kui-color-border-caution: var(--kui-color-scale-amber6);
    --kui-color-border-positive: var(--kui-color-scale-green6);
    --kui-color-border-accent: var(--kui-color-scale-indigo6);
    --kui-color-border-emphasis: var(--kui-color-scale-slate6);
    --kui-color-border-neutral: var(--kui-color-scale-slate5);
    --kui-color-border-muted: var(--kui-color-scale-slate4);
    --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
    --kui-color-background-highlight: var(--kui-color-scale-pink3);
    --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
    --kui-color-background-pending: var(--kui-color-scale-purple3);
    --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
    --kui-color-background-critical: var(--kui-color-scale-red3);
    --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
    --kui-color-background-caution: var(--kui-color-scale-amber3);
    --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
    --kui-color-background-positive: var(--kui-color-scale-green3);
    --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
    --kui-color-background-accent: var(--kui-color-scale-indigo3);
    --kui-color-background-inverse: var(--kui-color-scale-slate10);
    --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
    --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
    --kui-color-background-surface: var(--kui-color-scale-slate2);
    --kui-color-background-canvas: var(--kui-color-scale-slate1);
  }
}
.kui-theme {
  --kui-animation-easing-ease-out: cubic-bezier(0, 0, 0.4, 1);
  --kui-animation-easing-ease-in: cubic-bezier(0.5, 0, 1, 1);
  --kui-animation-easing-ease-in-out: cubic-bezier(0.45, 0, 0.4, 1);
  --kui-animation-duration-xlong: 1920ms;
  --kui-animation-duration-long: 960ms;
  --kui-animation-duration-regular: 320ms;
  --kui-animation-duration-short: 160ms;
}
.kui-theme {
  --kui-size-dialog-large: 860px;
  --kui-size-dialog-medium: 640px;
  --kui-size-dialog-small: 420px;
  --kui-size-dialog-xsmall: 320px;
  --kui-size-container-xlarge: 1400px;
  --kui-size-container-large: 1280px;
  --kui-size-container-medium: 940px;
  --kui-size-container-small: 660px;
  --kui-size-container-xsmall: 400px;
  --kui-size-alias-focus-ring-gap: 2px;
  --kui-size-alias-focus-ring: 2px;
  --kui-size-icon-large: var(--kui-size-scale-400);
  --kui-size-icon-medium: var(--kui-size-scale-300);
  --kui-size-icon-regular: var(--kui-size-scale-200);
  --kui-size-icon-small: var(--kui-size-scale-150);
  --kui-size-element-xlarge: var(--kui-size-scale-800);
  --kui-size-element-large: var(--kui-size-scale-600);
  --kui-size-element-medium: var(--kui-size-scale-450);
  --kui-size-element-regular: var(--kui-size-scale-400);
  --kui-size-element-small: var(--kui-size-scale-300);
  --kui-size-element-xsmall: var(--kui-size-scale-200);
  --kui-size-alias-single-line-width: var(--kui-size-scale-2400);
  --kui-size-alias-single-line-height: var(--kui-size-scale-400);
}
.kui-theme {
  --kui-size-radius-xlarge: 16px;
  --kui-size-radius-large: 12px;
  --kui-size-radius-medium: 8px;
  --kui-size-radius-regular: 6px;
  --kui-size-radius-small: 4px;
  --kui-size-radius-xsmall: 2px;
  --kui-size-radius-full: 9999px;
  --kui-size-border-large: 4px;
  --kui-size-border-medium: 2px;
  --kui-size-border-regular: 1px;
  --kui-size-space-xxlarge: var(--kui-size-scale-400);
  --kui-size-space-xlarge: var(--kui-size-scale-300);
  --kui-size-space-large: var(--kui-size-scale-200);
  --kui-size-space-medium: var(--kui-size-scale-150);
  --kui-size-space-regular: var(--kui-size-scale-100);
  --kui-size-space-small: var(--kui-size-scale-50);
  --kui-size-space-xsmall: var(--kui-size-scale-25);
  --kui-size-shadow-large: 0px var(--kui-size-scale-100) var(--kui-size-scale-300) 0px;
  --kui-size-shadow-medium: 0px var(--kui-size-scale-40) var(--kui-size-scale-75) 0px;
  --kui-size-shadow-small: 0px var(--kui-size-scale-10) var(--kui-size-scale-25) 0px;
}
.kui-theme {
  --kui-size-scale-6000: 480px;
  --kui-size-scale-5000: 400px;
  --kui-size-scale-4600: 368px;
  --kui-size-scale-3600: 288px;
  --kui-size-scale-3400: 272px;
  --kui-size-scale-3000: 240px;
  --kui-size-scale-2400: 192px;
  --kui-size-scale-2000: 160px;
  --kui-size-scale-1700: 136px;
  --kui-size-scale-1600: 128px;
  --kui-size-scale-1250: 100px;
  --kui-size-scale-1200: 96px;
  --kui-size-scale-1000: 80px;
  --kui-size-scale-900: 72px;
  --kui-size-scale-800: 64px;
  --kui-size-scale-700: 56px;
  --kui-size-scale-675: 54px;
  --kui-size-scale-600: 48px;
  --kui-size-scale-550: 44px;
  --kui-size-scale-500: 40px;
  --kui-size-scale-450: 36px;
  --kui-size-scale-400: 32px;
  --kui-size-scale-350: 28px;
  --kui-size-scale-325: 26px;
  --kui-size-scale-300: 24px;
  --kui-size-scale-275: 22px;
  --kui-size-scale-250: 20px;
  --kui-size-scale-225: 18px;
  --kui-size-scale-200: 16px;
  --kui-size-scale-175: 14px;
  --kui-size-scale-160: 13px;
  --kui-size-scale-150: 12px;
  --kui-size-scale-130: 11px;
  --kui-size-scale-125: 10px;
  --kui-size-scale-115: 9px;
  --kui-size-scale-100: 8px;
  --kui-size-scale-85: 7px;
  --kui-size-scale-75: 6px;
  --kui-size-scale-65: 5px;
  --kui-size-scale-50: 4px;
  --kui-size-scale-40: 3px;
  --kui-size-scale-25: 2px;
  --kui-size-scale-10: 1px;
  --kui-size-scale-0: 0px;
}
.kui-theme {
  --kui-typography-heading-large-lineheight: 1.2;
  --kui-typography-heading-large-size: 32px;
  --kui-typography-heading-medium-lineheight: 1.2;
  --kui-typography-heading-medium-size: 24px;
  --kui-typography-heading-regular-lineheight: 1.2;
  --kui-typography-heading-regular-size: 20px;
  --kui-typography-heading-small-lineheight: 1.2;
  --kui-typography-heading-small-size: 16px;
  --kui-typography-text-large-lineheight: 1.2;
  --kui-typography-text-large-size: 18px;
  --kui-typography-text-medium-lineheight: 1.4;
  --kui-typography-text-medium-size: 16px;
  --kui-typography-text-regular-lineheight: 1.4;
  --kui-typography-text-regular-size: 14px;
  --kui-typography-text-small-lineheight: 1.4;
  --kui-typography-text-small-size: 12px;
  --kui-typography-lineheight-small: 1.2;
  --kui-typography-lineheight-medium: 1.4;
  --kui-typography-lineheight-large: 1.6;
  --kui-typography-font-weight-bold: 700;
  --kui-typography-font-weight-semibold: 600;
  --kui-typography-font-weight-medium: 500;
  --kui-typography-font-weight-regular: 400;
  --kui-typography-font-family-code: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  --kui-typography-font-family-base: var(--font-inter, Inter);
  --kui-typography-heading-large-capheight: 23.2727px;
  --kui-typography-heading-large-capheight-trim: -0.2364em;
  --kui-typography-heading-large-baseline-trim: -0.2364em;
  --kui-typography-heading-medium-capheight: 17.4545px;
  --kui-typography-heading-medium-capheight-trim: -0.2364em;
  --kui-typography-heading-medium-baseline-trim: -0.2364em;
  --kui-typography-heading-regular-capheight: 14.5455px;
  --kui-typography-heading-regular-capheight-trim: -0.2364em;
  --kui-typography-heading-regular-baseline-trim: -0.2364em;
  --kui-typography-heading-small-capheight: 11.6364px;
  --kui-typography-heading-small-capheight-trim: -0.2364em;
  --kui-typography-heading-small-baseline-trim: -0.2364em;
  --kui-typography-text-large-capheight: 13.0909px;
  --kui-typography-text-large-capheight-trim: -0.2364em;
  --kui-typography-text-large-baseline-trim: -0.2364em;
  --kui-typography-text-medium-capheight: 11.6364px;
  --kui-typography-text-medium-capheight-trim: -0.3364em;
  --kui-typography-text-medium-baseline-trim: -0.3364em;
  --kui-typography-text-regular-capheight: 10.1818px;
  --kui-typography-text-regular-capheight-trim: -0.3364em;
  --kui-typography-text-regular-baseline-trim: -0.3364em;
  --kui-typography-text-small-capheight: 8.7273px;
  --kui-typography-text-small-capheight-trim: -0.3364em;
  --kui-typography-text-small-baseline-trim: -0.3364em;
}`;
var schemes = {
  auto: SCHEME_AUTO,
  light: SCHEME_LIGHT,
  dark: SCHEME_DARK
};
var documentElementClasses = (args) => {
  const scheme = schemes[args.colorScheme || "auto"];
  return `${documentReset(args.bodyBackground)} ${THEME_DEFAULT} ${scheme}`;
};
var documentReset = (background = "canvas") => css`
  html& {
    scroll-behavior: smooth;
    text-size-adjust: none;
    -webkit-tap-highlight-color: #0000;
  }
  @media (prefers-reduced-motion: reduce) {
    html& {
      scroll-behavior: auto;
    }
  }

  html& body {
    background-color: ${tokenSchema.color.background[background]};
    margin: 0;
  }
`;
function flatString(str) {
  return str.replace(/\n|\s{2,}/g, "");
}
var reset = resetClassName.replace(":", "\\:");
var elementReset = flatString(`
  :where(.${reset}) {
    border: 0;
    box-sizing: border-box;
    font: inherit;
    font-size: 100%;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
  }
  :where(ol.${reset}, ul.${reset}) { list-style: none; }
  :where(canvas.${reset}, img.${reset}, picture.${reset}, svg.${reset}, video.${reset}) { display: block; }
  :where(input.${reset}, button.${reset}, textarea.${reset}, select.${reset}) { appearance: none; background-color: transparent; }
  :where(a.${reset}, abbr.${reset}) { color: inherit; text-decoration: none; }
  :where(table.${reset}) = { border-collapse: collapse; border-spacing: 0; }
`);
injectGlobal(cssCustomProperties);
injectGlobal(elementReset);
function useScale() {
  let matchesFine = useMediaQuery("(any-pointer: fine)");
  return !matchesFine ? "large" : "medium";
}
var KeystarProvider = forwardRefWithAs(function KeystarProvider2(props, forwardedRef) {
  let prevContext = (0, import_react12.useContext)(Context2);
  let prevColorScheme = prevContext && prevContext.colorScheme;
  let autoScale = useScale();
  let {
    locale: prevLocale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let matchedBreakpoints = useMatchedBreakpoints();
  let {
    children,
    colorScheme = prevColorScheme || "auto",
    isDisabled,
    isRequired,
    isReadOnly,
    locale = prevContext ? prevLocale : void 0,
    router,
    scale = prevContext ? prevContext.scale : autoScale,
    ...otherProps
  } = props;
  let currentProps = {
    colorScheme,
    isDisabled,
    isRequired,
    isReadOnly,
    scale
  };
  let filteredProps = Object.fromEntries(Object.entries(currentProps).filter(([_2, value2]) => value2 !== void 0));
  let context = Object.assign({}, prevContext, filteredProps);
  let contents = children;
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps);
  let styleProps = useStyleProps(otherProps);
  if (!prevContext || props.elementType || props.locale || colorScheme !== prevContext.colorScheme || scale !== prevContext.scale || Object.keys(domProps).length > 0 || otherProps.UNSAFE_className || styleProps.style && Object.keys(styleProps.style).length > 0) {
    var _props$elementType;
    contents = (0, import_jsx_runtime2.jsx)(ProviderWrapper, {
      ref: forwardedRef,
      ...props,
      style: {
        isolation: !prevContext ? "isolate" : void 0
      },
      elementType: (_props$elementType = props.elementType) !== null && _props$elementType !== void 0 ? _props$elementType : "div",
      children: contents
    });
  }
  if (router) {
    contents = (0, import_jsx_runtime2.jsx)($ea8dcbcb9ea1b556$export$323e4fc2fa4753fb, {
      ...router,
      children: contents
    });
  }
  return (0, import_jsx_runtime2.jsx)(Context2.Provider, {
    value: context,
    children: (0, import_jsx_runtime2.jsx)(BreakpointProvider, {
      value: matchedBreakpoints,
      children: (0, import_jsx_runtime2.jsx)($18f2051aff69b9bf$export$a54013f0d02a8f82, {
        locale,
        children: (0, import_jsx_runtime2.jsx)($f57aed4a881a3485$export$178405afcd8c5eb, {
          children: contents
        })
      })
    })
  });
});
var ProviderWrapper = forwardRefWithAs(function ProviderWrapper2(props, forwardedRef) {
  var _props$elementType2;
  let {
    children,
    style
  } = props;
  let {
    locale,
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let {
    modalProviderProps
  } = $f57aed4a881a3485$export$d9aaed4c3ece1bc0();
  let {
    colorScheme
  } = useProvider();
  const ElementType = (_props$elementType2 = props.elementType) !== null && _props$elementType2 !== void 0 ? _props$elementType2 : "div";
  return (0, import_jsx_runtime2.jsx)(ElementType, {
    ...modalProviderProps,
    className: `${props.UNSAFE_className ? `${props.UNSAFE_className} ` : ""}${documentElementClasses({
      bodyBackground: props.bodyBackground,
      colorScheme
    })}`,
    lang: locale,
    dir: direction,
    ref: forwardedRef,
    style: {
      ...style,
      ...props.UNSAFE_style
    },
    children
  });
});
function ClientSideOnlyDocumentElement(props) {
  const context = useProvider();
  const classes = documentElementClasses({
    bodyBackground: props.bodyBackground,
    colorScheme: context.colorScheme
  });
  (0, import_react12.useLayoutEffect)(() => {
    const split2 = classes.split(" ");
    const root = document.documentElement;
    root.classList.add(...split2);
    return () => {
      root.classList.remove(...split2);
    };
  }, [classes]);
  return null;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/slots/dist/keystar-ui-slots.esm.js
var import_react13 = __toESM(require_react());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var SlotContext = import_react13.default.createContext({});
function useSlotProps(props, defaultSlot) {
  let slot2 = props.slot || defaultSlot;
  let {
    [slot2]: slotProps = {}
  } = (0, import_react13.useContext)(SlotContext);
  return $3ef42575df84b30b$export$9d1611c77c2fe928(props, $3ef42575df84b30b$export$9d1611c77c2fe928(slotProps, {
    id: props.id
  }));
}
var SlotProvider = (props) => {
  let {
    children,
    slots
  } = props;
  let parentSlots = (0, import_react13.useContext)(SlotContext);
  let value2 = (0, import_react13.useMemo)(() => Object.keys(parentSlots).concat(Object.keys(slots)).reduce((obj, key) => ({
    ...obj,
    [key]: $3ef42575df84b30b$export$9d1611c77c2fe928(parentSlots[key], slots[key])
  }), {}), [parentSlots, slots]);
  return (0, import_jsx_runtime3.jsx)(SlotContext.Provider, {
    value: value2,
    children
  });
};
var ClearSlots = ({
  children
}) => {
  return (0, import_jsx_runtime3.jsx)(SlotContext.Provider, {
    value: {},
    children
  });
};
var Content = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "content");
  let {
    elementType: Element4 = "section",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children
  });
});
var Footer = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "footer");
  let {
    elementType: Element4 = "footer",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children
  });
});
var Header = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "header");
  let {
    elementType: Element4 = "header",
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime3.jsx)(Element4, {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    ref,
    children
  });
});

// node_modules/.pnpm/@react-aria+link@3.6.2_react@18.2.0/node_modules/@react-aria/link/dist/import.mjs
function $298d61e98472621b$export$dcf14c9974fe2767(props, ref) {
  let {
    elementType = "a",
    onPress,
    onPressStart,
    onPressEnd,
    // @ts-ignore
    onClick: deprecatedOnClick,
    isDisabled,
    ...otherProps
  } = props;
  let linkProps = {};
  if (elementType !== "a")
    linkProps = {
      role: "link",
      tabIndex: !isDisabled ? 0 : void 0
    };
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPress,
    onPressStart,
    onPressEnd,
    isDisabled,
    ref
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(otherProps, {
    labelable: true,
    isLink: elementType === "a"
  });
  let interactionHandlers = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, pressProps);
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  return {
    isPressed,
    linkProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...interactionHandlers,
      ...linkProps,
      "aria-disabled": isDisabled || void 0,
      "aria-current": props["aria-current"],
      onClick: (e6) => {
        var _pressProps_onClick;
        (_pressProps_onClick = pressProps.onClick) === null || _pressProps_onClick === void 0 ? void 0 : _pressProps_onClick.call(pressProps, e6);
        if (deprecatedOnClick) {
          deprecatedOnClick(e6);
          console.warn("onClick is deprecated, please use onPress");
        }
        if (!router.isNative && e6.currentTarget instanceof HTMLAnchorElement && e6.currentTarget.href && // If props are applied to a router Link component, it may have already prevented default.
        !e6.isDefaultPrevented() && (0, $ea8dcbcb9ea1b556$export$efa8c9099e530235)(e6.currentTarget, e6)) {
          e6.preventDefault();
          router.open(e6.currentTarget, e6);
        }
      }
    })
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/utils/dist/keystar-ui-utils.esm.js
var import_react14 = __toESM(require_react());
function useHasChild(query, ref) {
  let [hasChild, setHasChild] = (0, import_react14.useState)(true);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    setHasChild(!!(ref.current && ref.current.querySelector(query)));
  }, [setHasChild, query, ref]);
  return hasChild;
}
function cloneValidElement(child, props) {
  if (!(0, import_react14.isValidElement)(child)) {
    return null;
  }
  return (0, import_react14.cloneElement)(child, props);
}
function isReactText(value2) {
  if (Array.isArray(value2)) {
    return value2.every(isReactText);
  }
  return typeof value2 === "string" || typeof value2 === "number";
}
function useId(id) {
  let generatedId = import_react14.default.useId();
  return id || generatedId;
}
function useIsMounted() {
  const isMounted = (0, import_react14.useRef)(false);
  (0, import_react14.useEffect)(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return (0, import_react14.useCallback)(() => isMounted.current, []);
}
function usePrevious(value2) {
  const ref = (0, import_react14.useRef)();
  (0, import_react14.useEffect)(() => {
    ref.current = value2;
  });
  return ref.current;
}
function useRenderProps(props, values2) {
  if (typeof props.children === "function") {
    return props.children(values2);
  } else {
    return props.children;
  }
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/typography/dist/keystar-ui-typography.esm.js
var import_react15 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var HeadingContext = (0, import_react15.createContext)(void 0);
function useHeadingContext() {
  return (0, import_react15.useContext)(HeadingContext);
}
function getTrimStyles(fontDefinition) {
  const {
    capheightTrim: marginBottom,
    baselineTrim: marginTop
  } = fontDefinition;
  return {
    display: "block",
    lineHeight: fontDefinition.lineheight,
    "::before": {
      content: '" "',
      display: "table",
      marginBottom
    },
    "::after": {
      content: '" "',
      display: "table",
      marginTop
    }
  };
}
var TextContext = (0, import_react15.createContext)(void 0);
function useTextContext() {
  return (0, import_react15.useContext)(TextContext);
}
var textClassList = new ClassList("Text");
function useTextStyles(props) {
  const prevContext = useTextContext();
  const {
    align,
    casing,
    overflow = "breakword",
    size: size3,
    color,
    trim: trim2 = !prevContext,
    variant,
    weight,
    UNSAFE_className,
    ...otherProps
  } = props;
  const fontDefinition = tokenSchema.typography.text[size3];
  const trimStyles = trim2 ? getTrimStyles(fontDefinition) : null;
  const styles2 = [{
    color: maybeTokenByKey("color.foreground", color),
    fontFamily: tokenSchema.typography.fontFamily.base,
    fontSize: fontDefinition.size,
    fontVariantNumeric: variant,
    fontWeight: weight === "inherit" ? void 0 : tokenSchema.typography.fontWeight[weight],
    minWidth: 0,
    textAlign: align ? alignmentMap[align] : void 0,
    textTransform: casing
  }, textOptimizationStyles, overflow && overflowMap[overflow], trimStyles];
  return useStyleProps({
    ...otherProps,
    UNSAFE_className: [css(styles2), UNSAFE_className, textClassList.element("root")]
  });
}
var textOptimizationStyles = {
  MozOsxFontSmoothing: "auto",
  WebkitFontSmoothing: "auto"
};
var alignmentMap = {
  start: "start",
  center: "center",
  end: "end",
  FORCE_left: "left",
  FORCE_right: "right"
};
var overflowMap = {
  unset: {},
  nowrap: {
    whiteSpace: "nowrap"
  },
  breakword: {
    // hyphens: 'auto', // too eager
    overflowWrap: "break-word"
  }
};
var headingClassList = new ClassList("Heading");
function useHeadingStyles({
  align,
  size: size3,
  UNSAFE_className,
  ...otherProps
}) {
  const fontDefinition = tokenSchema.typography.heading[size3];
  const trimStyles = getTrimStyles(fontDefinition);
  const styles2 = [{
    color: tokenSchema.color.foreground.neutralEmphasis,
    fontSize: fontDefinition.size,
    fontFamily: tokenSchema.typography.fontFamily.base,
    fontWeight: sizeToWeight[size3],
    textAlign: align
  }, textOptimizationStyles, trimStyles];
  return useStyleProps({
    ...otherProps,
    UNSAFE_className: [css(styles2), UNSAFE_className, headingClassList.element("root")]
  });
}
var sizeToWeight = {
  small: tokenSchema.typography.fontWeight.semibold,
  regular: tokenSchema.typography.fontWeight.bold,
  medium: tokenSchema.typography.fontWeight.medium,
  large: tokenSchema.typography.fontWeight.bold
};
function Truncate({
  lines,
  title,
  ...props
}) {
  const className = useTruncateStyles(typeof lines === "boolean" ? 1 : lines);
  return (0, import_jsx_runtime4.jsx)("span", {
    className,
    title: title !== null && title !== void 0 ? title : isReactText(props.children) ? props.children.toString() : void 0,
    ...props
  });
}
function useTruncateStyles(lineClamp) {
  return css({
    display: "-webkit-box",
    WebkitLineClamp: lineClamp,
    textOverflow: "ellipsis",
    WebkitBoxOrient: "vertical",
    overflow: "hidden"
  });
}
function useVisuallyHiddenRange(range) {
  let matchedBreakpoints = useResponsiveRange();
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  if (range && matchedBreakpoints(range)) {
    return visuallyHiddenProps;
  }
}
var sizeToElement = {
  small: "h4",
  regular: "h3",
  medium: "h2",
  large: "h1"
};
var filterOptions$1 = {
  propNames: /* @__PURE__ */ new Set(["aria-hidden"])
};
var Heading = forwardRefWithAs((props, ref) => {
  props = useSlotProps(props, "heading");
  const {
    children,
    size: size3 = "regular",
    truncate,
    elementType: ElementType = sizeToElement[size3],
    ...otherProps
  } = props;
  const styleProps = useHeadingStyles({
    size: size3,
    ...otherProps
  });
  const headingContext = (0, import_react15.useMemo)(() => ({
    size: size3
  }), [size3]);
  const visuallyHiddenProps = useVisuallyHiddenRange(props.visuallyHidden);
  const content = truncate ? (0, import_jsx_runtime4.jsx)(Truncate, {
    lines: truncate,
    children
  }) : children;
  return (0, import_jsx_runtime4.jsx)(HeadingContext.Provider, {
    value: headingContext,
    children: (0, import_jsx_runtime4.jsx)(ElementType, {
      ref,
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions$1),
      ...styleProps,
      ...visuallyHiddenProps,
      children: content
    })
  });
});
var filterOptions = {
  propNames: /* @__PURE__ */ new Set(["aria-hidden", "role"])
};
var Text = forwardRefWithAs((props, forwardedRef) => {
  var _prevContext$color, _prevContext$size, _prevContext$weight;
  props = useSlotProps(props, "text");
  const headingContext = useHeadingContext();
  const prevContext = useTextContext();
  validateProps$1(props, prevContext);
  warning(!headingContext, "The `Text` component is not supported within `Heading` components.");
  if (headingContext) {
    return (0, import_jsx_runtime4.jsx)("span", {
      children: props.children
    });
  }
  const {
    children,
    color = (_prevContext$color = prevContext === null || prevContext === void 0 ? void 0 : prevContext.color) !== null && _prevContext$color !== void 0 ? _prevContext$color : "neutral",
    elementType: ElementType = "span",
    size: size3 = (_prevContext$size = prevContext === null || prevContext === void 0 ? void 0 : prevContext.size) !== null && _prevContext$size !== void 0 ? _prevContext$size : "regular",
    trim: trim2 = !prevContext,
    truncate,
    visuallyHidden,
    weight = (_prevContext$weight = prevContext === null || prevContext === void 0 ? void 0 : prevContext.weight) !== null && _prevContext$weight !== void 0 ? _prevContext$weight : "regular",
    ...otherProps
  } = props;
  const styleProps = useTextStyles({
    color,
    size: size3,
    trim: trim2,
    weight,
    ...otherProps
  });
  const visuallyHiddenProps = useVisuallyHiddenRange(visuallyHidden);
  const content = truncate ? (0, import_jsx_runtime4.jsx)(Truncate, {
    lines: truncate,
    children
  }) : children;
  const element2 = (0, import_jsx_runtime4.jsx)(ElementType, {
    ref: forwardedRef,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions),
    ...styleProps,
    ...visuallyHiddenProps,
    children: content
  });
  const nextContext = (0, import_react15.useMemo)(() => ({
    size: size3,
    color,
    weight
  }), [size3, color, weight]);
  if (prevContext || visuallyHidden) {
    return element2;
  }
  return (0, import_jsx_runtime4.jsx)(TextContext.Provider, {
    value: nextContext,
    children: element2
  });
});
function validateProps$1(props, context) {
  assert(!context || !props.align, 'The "align" prop is unsupported on nested Text.');
  assert(!context || !props.trim, 'The "trim" prop is unsupported on nested Text.');
}
var Emoji = (0, import_react15.forwardRef)(function Emoji2(props, forwardedRef) {
  const {
    label,
    symbol,
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime4.jsx)("span", {
    "aria-hidden": label ? void 0 : true,
    "aria-label": label,
    ref: forwardedRef,
    role: "img",
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    children: symbol
  });
});
function noopSubscribe() {
  return () => {
  };
}
function useIsMac() {
  return (0, import_react15.useSyncExternalStore)(noopSubscribe, $c87311424ea30a05$export$9ac100e40613ea10, () => false);
}
var Kbd = (0, import_react15.forwardRef)(function Kbd2(props, forwardedRef) {
  props = useSlotProps(props, "kbd");
  let {
    alt,
    meta,
    shift,
    children,
    ...otherProps
  } = props;
  const styleProps = useTextStyles({
    casing: "full-width",
    color: "neutral",
    size: "regular",
    weight: "regular",
    ...otherProps
  });
  const isMac = useIsMac();
  const modifiers = (0, import_react15.useMemo)(() => {
    const SYSTEM_KEYS = isMac ? {
      alt: "⌥",
      meta: "⌘",
      shift: "⇧"
    } : {
      alt: "Alt",
      meta: "Ctrl",
      shift: "Shift"
      // shift: '⇧', // maybe?
    };
    let keys = [alt && SYSTEM_KEYS.alt, shift && SYSTEM_KEYS.shift, meta && SYSTEM_KEYS.meta].filter(Boolean);
    return joinModifierKeys(keys, isMac);
  }, [alt, meta, shift, isMac]);
  return (0, import_jsx_runtime4.jsxs)("kbd", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...styleProps,
    dir: "ltr",
    ref: forwardedRef,
    children: [modifiers, (0, import_jsx_runtime4.jsx)(Char, {
      children
    })]
  });
});
function Char(props) {
  return (0, import_jsx_runtime4.jsx)("span", {
    className: css({
      display: "inline-block",
      minWidth: "1em",
      textAlign: "center"
    }),
    ...props
  });
}
function joinModifierKeys(modifiers, isMac) {
  if (modifiers.length === 0) {
    return "";
  }
  let delimiter2 = isMac ? "" : "+";
  return modifiers.join(delimiter2) + delimiter2;
}
var Numeral = (0, import_react15.forwardRef)(function Numeral2(props, forwardedRef) {
  props = useDerivedProps(props);
  validateProps(props);
  const formatter = $a916eb452884faea$export$b7a616150fdb9f44(optionsByFormat(props));
  const {
    abbreviate,
    format: format2,
    value: value2,
    ...textProps
  } = props;
  const headingContext = useHeadingContext();
  const formattedText = formatter.format(value2);
  if (headingContext) {
    return (0, import_jsx_runtime4.jsx)("span", {
      ref: forwardedRef,
      children: formattedText
    });
  }
  return (0, import_jsx_runtime4.jsx)(Text, {
    ref: forwardedRef,
    ...textProps,
    children: formattedText
  });
});
function getFormat(props) {
  const {
    format: format2,
    currency,
    unit
  } = props;
  if (format2) {
    return format2;
  }
  if (currency) {
    return "currency";
  }
  if (unit) {
    return "unit";
  }
  return "decimal";
}
function useDerivedProps(props) {
  return {
    ...props,
    format: getFormat(props)
  };
}
function toFractionDigits(precision) {
  return Array.isArray(precision) ? precision : [precision, precision];
}
function optionsByFormat(props) {
  const {
    abbreviate,
    format: format2,
    precision,
    currency,
    unit
  } = props;
  const notation = abbreviate ? "compact" : void 0;
  const [minimumFractionDigits, maximumFractionDigits] = toFractionDigits(precision);
  const common = {
    maximumFractionDigits,
    minimumFractionDigits,
    notation,
    compactDisplay: abbreviate === "long" ? "long" : "short"
  };
  switch (format2) {
    case "currency":
      return {
        ...common,
        style: "currency",
        currency,
        currencyDisplay: "narrowSymbol"
      };
    case "percent":
      return {
        ...common,
        style: "percent"
      };
    case "unit":
      return {
        ...common,
        style: "unit",
        unit,
        unitDisplay: "narrow"
      };
    default:
      return common;
  }
}
function validateProps(props) {
  const {
    format: format2,
    currency,
    precision,
    unit
  } = props;
  assert(currency ? format2 === "currency" : true, 'When format is "currency", the currency property must be provided.');
  assert(unit ? format2 === "unit" : true, 'When format is "unit", the unit property must be provided.');
  assert(!(currency && unit), 'Formatting of "currency" and "unit" cannot be combined.');
  if (precision) {
    assert(Array.isArray(precision) ? precision.every(isInteger) : isInteger(precision), "Precision must be an integer, or an integer tuple for min/max.");
  }
}
var Prose = forwardRefWithAs((props, ref) => {
  const {
    children,
    elementType: ElementType = "div",
    ...otherProps
  } = props;
  const styleProps = useProseStyles(otherProps);
  return (0, import_jsx_runtime4.jsx)(ElementType, {
    ref,
    ...filterStyleProps(otherProps),
    ...styleProps,
    children
  });
});
function useProseStyles(props) {
  const {
    size: size3 = "medium",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return {
    ...styleProps,
    ...toDataAttributes({
      size: size3
    }),
    className: classNames(css({
      color: tokenSchema.color.foreground.neutral,
      fontFamily: tokenSchema.typography.fontFamily.base,
      height: "100%",
      maxWidth: "100%",
      minHeight: 0,
      minWidth: 0,
      MozOsxFontSmoothing: "auto",
      WebkitFontSmoothing: "auto",
      '&[data-size="small"]': {
        fontSize: tokenSchema.typography.text.small.size,
        lineHeight: 1.6
      },
      '&[data-size="regular"]': {
        fontSize: tokenSchema.typography.text.regular.size,
        lineHeight: 1.5
      },
      '&[data-size="medium"]': {
        fontSize: tokenSchema.typography.text.medium.size,
        lineHeight: 1.5
      },
      '&[data-size="large"]': {
        fontSize: tokenSchema.typography.text.large.size,
        lineHeight: 1.4
      },
      // Elements
      // ---------------------------------------------------------------------
      "& :is(blockquote, p, pre, ol, ul)": {
        marginBlock: "0.75em",
        ":first-child": {
          marginTop: 0
        },
        ":last-child": {
          marginBottom: 0
        }
      },
      "ol, ul": {
        paddingInlineStart: "1em"
      },
      "ol ol, ul ul, ol ul, ul ol": {
        marginBlock: 0
      },
      blockquote: {
        borderInlineStart: `${tokenSchema.size.border.large} solid ${tokenSchema.color.foreground.neutral}`,
        marginInline: 0,
        paddingInlineStart: "1em"
      },
      hr: {
        marginBlock: "1.5em",
        backgroundColor: tokenSchema.color.alias.borderIdle,
        border: 0,
        height: tokenSchema.size.border.medium
      },
      // inline elements
      img: {
        height: "auto",
        maxWidth: "100%"
      },
      strong: {
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      a: {
        color: tokenSchema.color.foreground.accent
      },
      // code block
      pre: {
        backgroundColor: tokenSchema.color.background.surface,
        borderRadius: tokenSchema.size.radius.medium,
        color: tokenSchema.color.foreground.neutralEmphasis,
        fontFamily: tokenSchema.typography.fontFamily.code,
        fontSize: "0.85em",
        lineHeight: tokenSchema.typography.lineheight.medium,
        minWidth: 0,
        maxWidth: "100%",
        overflow: "auto",
        padding: tokenSchema.size.space.medium
      },
      "pre > code": {
        fontFamily: "inherit"
      },
      // inline code
      "& :not(pre) > code": {
        backgroundColor: tokenSchema.color.background.accent,
        borderRadius: tokenSchema.size.radius.small,
        color: tokenSchema.color.foreground.neutralEmphasis,
        display: "inline-block",
        fontSize: "0.85em",
        fontFamily: tokenSchema.typography.fontFamily.code,
        paddingInline: tokenSchema.size.space.small
      },
      // Headings
      // ---------------------------------------------------------------------
      "h1, h2, h3, h4, h5, h6": {
        color: tokenSchema.color.foreground.neutralEmphasis,
        lineHeight: 1.25,
        marginTop: "1.5em",
        marginBottom: "0.67em",
        ":first-child": {
          marginTop: 0
        },
        ":last-child": {
          marginBottom: 0
        }
      },
      h1: {
        fontSize: "2em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h2: {
        fontSize: "1.5em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h3: {
        fontSize: "1.25em",
        fontWeight: tokenSchema.typography.fontWeight.bold
      },
      h4: {
        fontSize: "1.1em",
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      h5: {
        fontSize: "1em",
        fontWeight: tokenSchema.typography.fontWeight.semibold
      },
      h6: {
        fontSize: "0.9em",
        fontWeight: tokenSchema.typography.fontWeight.semibold,
        letterSpacing: "0.0125em"
      },
      ...getListStyles()
    }), styleProps.className)
  };
}
function getListStyles() {
  let styles2 = {};
  let listDepth = 10;
  const orderedListStyles = ["lower-roman", "decimal", "lower-alpha"];
  const unorderedListStyles = ["square", "disc", "circle"];
  while (listDepth--) {
    let arr = Array.from({
      length: listDepth
    });
    if (arr.length) {
      styles2[arr.map(() => `ol`).join(" ")] = {
        listStyle: orderedListStyles[listDepth % 3]
      };
      styles2[arr.map(() => `ul`).join(" ")] = {
        listStyle: unorderedListStyles[listDepth % 3]
      };
    }
  }
  return styles2;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/dist/keystar-ui-icon.esm.js
var import_react16 = __toESM(require_react());
var STROKE_VAR = `--${TOKEN_PREFIX}-icon-stroke`;
var Icon = (props) => {
  var _maybeTokenByKey;
  props = useSlotProps(props, "icon");
  const {
    strokeScaling,
    size: size3,
    color,
    ...otherProps
  } = props;
  const stroke = (_maybeTokenByKey = maybeTokenByKey("color.foreground", color)) !== null && _maybeTokenByKey !== void 0 ? _maybeTokenByKey : "currentColor";
  const iconClassName2 = css({
    fill: "none",
    stroke: `var(${STROKE_VAR})`,
    flexShrink: 0,
    height: tokenSchema.size.icon.regular,
    width: tokenSchema.size.icon.regular,
    "&[data-size=small]": {
      height: tokenSchema.size.icon.small,
      width: tokenSchema.size.icon.small
    },
    "&[data-size=medium]": {
      height: tokenSchema.size.icon.medium,
      width: tokenSchema.size.icon.medium
    },
    "&[data-size=large]": {
      height: tokenSchema.size.icon.large,
      width: tokenSchema.size.icon.large
    },
    // Maintain stroke width, no matter the size.
    // @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/vector-effect#non-scaling-stroke
    "&[data-stroke-scaling=false] > *": {
      vectorEffect: "non-scaling-stroke"
    }
  });
  const styleProps = useStyleProps(otherProps);
  const hasAriaLabel = "aria-label" in props && !!props["aria-label"];
  return import_react16.default.cloneElement(props.src, {
    ...toDataAttributes({
      strokeScaling,
      size: size3
    }),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    "aria-hidden": !hasAriaLabel,
    focusable: "false",
    role: "img",
    className: classNames(iconClassName2, styleProps.className),
    style: {
      [STROKE_VAR]: stroke,
      ...styleProps.style
    }
  });
};

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/button/dist/keystar-ui-button.esm.js
var import_react17 = __toESM(require_react());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-aria+button@3.9.0_react@18.2.0/node_modules/@react-aria/button/dist/import.mjs
function $701a24aa0da5b062$export$ea18c227d4417cc3(props, ref) {
  let {
    elementType = "button",
    isDisabled,
    onPress,
    onPressStart,
    onPressEnd,
    onPressUp,
    onPressChange,
    preventFocusOnPress,
    allowFocusWhenDisabled,
    // @ts-ignore
    onClick: deprecatedOnClick,
    href,
    target,
    rel,
    type: type2 = "button"
  } = props;
  let additionalProps;
  if (elementType === "button")
    additionalProps = {
      type: type2,
      disabled: isDisabled
    };
  else
    additionalProps = {
      role: "button",
      tabIndex: isDisabled ? void 0 : 0,
      href: elementType === "a" && isDisabled ? void 0 : href,
      target: elementType === "a" ? target : void 0,
      type: elementType === "input" ? type2 : void 0,
      disabled: elementType === "input" ? isDisabled : void 0,
      "aria-disabled": !isDisabled || elementType === "input" ? void 0 : isDisabled,
      rel: elementType === "a" ? rel : void 0
    };
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPressStart,
    onPressEnd,
    onPressChange,
    onPress,
    onPressUp,
    isDisabled,
    preventFocusOnPress,
    ref
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  if (allowFocusWhenDisabled)
    focusableProps.tabIndex = isDisabled ? -1 : focusableProps.tabIndex;
  let buttonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, pressProps, (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  }));
  return {
    isPressed,
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(additionalProps, buttonProps, {
      "aria-haspopup": props["aria-haspopup"],
      "aria-expanded": props["aria-expanded"],
      "aria-controls": props["aria-controls"],
      "aria-pressed": props["aria-pressed"],
      onClick: (e6) => {
        if (deprecatedOnClick) {
          deprecatedOnClick(e6);
          console.warn("onClick is deprecated, please use onPress");
        }
      }
    })
  };
}
function $55f54f7887471b58$export$51e84d46ca0bc451(props, state, ref) {
  const { isSelected } = state;
  const { isPressed, buttonProps } = (0, $701a24aa0da5b062$export$ea18c227d4417cc3)({
    ...props,
    onPress: (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(state.toggle, props.onPress)
  }, ref);
  return {
    isPressed,
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(buttonProps, {
      "aria-pressed": isSelected
    })
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/xIcon/dist/keystar-ui-icon-icons-xIcon.esm.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var xIcon = (0, import_jsx_runtime5.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime5.jsx)("path", {
    d: "M18 6 6 18M6 6l12 12"
  })
});

// node_modules/.pnpm/@react-stately+toggle@3.7.0_react@18.2.0/node_modules/@react-stately/toggle/dist/import.mjs
function $3017fa7ffdddec74$export$8042c6c013fd5226(props = {}) {
  let { isReadOnly } = props;
  let [isSelected, setSelected] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.isSelected, props.defaultSelected || false, props.onChange);
  function updateSelected(value2) {
    if (!isReadOnly)
      setSelected(value2);
  }
  function toggleState() {
    if (!isReadOnly)
      setSelected(!isSelected);
  }
  return {
    isSelected,
    setSelected: updateSelected,
    toggle: toggleState
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/button/dist/keystar-ui-button.esm.js
var ButtonGroup = (0, import_react17.forwardRef)(function ButtonGroup2(props, forwardedRef) {
  let {
    scale
  } = useProvider();
  props = useProviderProps(props);
  props = useSlotProps(props, "buttonGroup");
  let {
    align = "start",
    children,
    isDisabled,
    orientation = "horizontal",
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let [hasOverflow, setHasOverflow] = $1dbecbe27a04f9af$export$14d238f342723f25(false);
  let checkForOverflow = (0, import_react17.useCallback)(() => {
    let computeHasOverflow = () => {
      if (domRef.current && orientation === "horizontal") {
        let buttonGroupChildren = Array.from(domRef.current.children);
        let maxX = domRef.current.offsetWidth + 1;
        if (buttonGroupChildren.some((child) => child.offsetLeft < 0 || child.offsetLeft + child.offsetWidth > maxX)) {
          return true;
        }
        return false;
      }
    };
    if (orientation === "horizontal") {
      setHasOverflow(function* () {
        yield false;
        yield computeHasOverflow();
      });
    }
  }, [domRef, orientation, scale, setHasOverflow, children]);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    checkForOverflow();
  }, [checkForOverflow]);
  let parent = (0, import_react17.useRef)();
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (domRef.current) {
      parent.current = domRef.current.parentElement;
    }
  });
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: parent,
    onResize: checkForOverflow
  });
  return (0, import_jsx_runtime6.jsx)("div", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...toDataAttributes({
      align,
      orientation: hasOverflow ? "vertical" : orientation
    }),
    ...styleProps,
    ref: domRef,
    className: classNames(styleProps.className, css({
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      position: "relative",
      '&[data-orientation="horizontal"]': {
        '&[data-align="center"]': {
          justifyContent: "center"
        },
        '&[data-align="end"]': {
          justifyContent: "flex-end"
        }
      },
      '&[data-orientation="vertical"]': {
        flexDirection: "column",
        '&[data-align="center"]': {
          alignItems: "center"
        },
        '&[data-align="end"]': {
          alignItems: "flex-end"
        }
      }
    })),
    children: (0, import_jsx_runtime6.jsx)(KeystarProvider, {
      isDisabled,
      children
    })
  });
});
var buttonClassList = new ClassList("Button", ["icon", "text"]);
function useButtonStyles(props, state) {
  const {
    prominence = "default",
    tone = prominence === "high" ? "accent" : "neutral"
  } = props;
  const {
    isHovered,
    isPressed
  } = state;
  const styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      hovered: isHovered || void 0,
      pressed: isPressed || void 0,
      prominence: prominence === "default" ? void 0 : prominence,
      tone: tone === "neutral" ? void 0 : tone,
      static: props.static
    }),
    style: styleProps.style,
    className: classNames(buttonClassList.element("root"), css({
      alignItems: "center",
      borderRadius: tokenSchema.size.radius.regular,
      cursor: "default",
      display: "inline-flex",
      flexShrink: 0,
      fontSize: tokenSchema.typography.text.regular.size,
      fontWeight: tokenSchema.typography.fontWeight.semibold,
      height: tokenSchema.size.element.regular,
      justifyContent: "center",
      minWidth: tokenSchema.size.element.regular,
      outline: 0,
      gap: tokenSchema.size.space.regular,
      paddingInline: tokenSchema.size.space.large,
      position: "relative",
      transitionDuration: "130ms",
      transitionProperty: "background, border-color, box-shadow, color, ",
      transitionTimingFunction: "ease-out",
      userSelect: "none",
      // indicate when external link? e.g. `&[href^=http]`
      "a&": {
        cursor: "pointer"
      },
      "&:disabled, &[aria-disabled]": {
        cursor: "default"
      },
      // inherit text styles from parent
      [buttonClassList.selector("text", "descendant")]: {
        fontSize: "inherit",
        fontWeight: "inherit"
      },
      // special size for button icons. otherwise they appear too "thin"
      // beside the bold text
      [buttonClassList.selector("icon", "descendant")]: {
        height: tokenSchema.size.scale[225],
        width: tokenSchema.size.scale[225]
      },
      // focus ring
      "--focus-ring-color": tokenSchema.color.alias.focusRing,
      "&[data-static=light]": {
        "--focus-ring-color": "#fff"
      },
      "&[data-static=dark]": {
        "--focus-ring-color": "#000"
      },
      "&::after": {
        borderRadius: `calc(${tokenSchema.size.radius.regular} + ${tokenSchema.size.alias.focusRingGap})`,
        content: '""',
        inset: 0,
        pointerEvents: "none",
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      "&[data-focus=visible]::after": {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`,
        margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`
      },
      // PROMINENCE: default
      "&:not([data-prominence])": {
        backgroundColor: tokenSchema.color.scale.slate4,
        color: tokenSchema.color.foreground.neutralEmphasis,
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.scale.slate5
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.scale.slate6
        },
        // tones
        "&[data-tone=accent]": {
          color: tokenSchema.color.foreground.accent
        },
        "&[data-tone=critical]": {
          color: tokenSchema.color.foreground.critical
        },
        // states
        "&:disabled, &[aria-disabled]": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          backgroundColor: "#ffffff12",
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-pressed]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#ffffff1a",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          backgroundColor: "#00000012",
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-pressed]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#0000001a",
            color: "#0000008c"
          }
        }
      },
      // PROMINENCE: high
      "&[data-prominence=high]": {
        backgroundColor: tokenSchema.color.scale.slate10,
        color: tokenSchema.color.foreground.inverse,
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.scale.slate11
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.scale.slate11
        },
        // NOTE: "neutral" tone invalid for "high" prominence
        "&[data-tone=accent]": {
          backgroundColor: tokenSchema.color.scale.indigo9,
          color: tokenSchema.color.foreground.onEmphasis,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.indigo10
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.indigo11
          }
        },
        "&[data-tone=critical]": {
          backgroundColor: tokenSchema.color.scale.red9,
          color: tokenSchema.color.foreground.onEmphasis,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.red10
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.red11
          }
        },
        "&:disabled, &[aria-disabled]": {
          backgroundColor: tokenSchema.color.background.surfaceTertiary,
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          backgroundColor: "#ffffffe6",
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#fff"
          },
          "&[data-pressed]": {
            backgroundColor: "#fff"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#ffffff1a",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          backgroundColor: "#000000e6",
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#000"
          },
          "&[data-pressed]": {
            backgroundColor: "#000"
          },
          "&:disabled, &[aria-disabled]": {
            backgroundColor: "#0000001a",
            color: "#0000008c"
          }
        }
      },
      // PROMINENCE: low
      "&[data-prominence=low]": {
        color: tokenSchema.color.foreground.neutral,
        // neutral interactions
        '&[data-hovered], &[data-focus="visible"]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.foreground.neutralEmphasis
        },
        "&[data-pressed]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // tones
        "&[data-tone=accent]": {
          color: tokenSchema.color.foreground.accent,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.indigo3
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.indigo4
          }
        },
        "&[data-tone=critical]": {
          color: tokenSchema.color.foreground.critical,
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.scale.red3
          },
          "&[data-pressed]": {
            backgroundColor: tokenSchema.color.scale.red4
          }
        },
        "&:disabled, &[aria-disabled]": {
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          color: "#fff",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-pressed]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          color: "#000",
          '&[data-hovered], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-pressed]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#0000008c"
          }
        }
      }
    }), styleProps.className)
  };
}
var Button = (0, import_react17.forwardRef)(function Button2(props, forwardedRef) {
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const children = useButtonChildren(props);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  if ("href" in props && props.href) {
    return (0, import_jsx_runtime6.jsx)(FocusRing, {
      autoFocus: props.autoFocus,
      children: (0, import_jsx_runtime6.jsx)(LinkButton$1, {
        ref: domRef,
        ...props,
        children
      })
    });
  }
  return (0, import_jsx_runtime6.jsx)(FocusRing, {
    autoFocus: props.autoFocus,
    children: (0, import_jsx_runtime6.jsx)(BaseButton$1, {
      ref: domRef,
      ...props,
      children
    })
  });
});
var LinkButton$1 = (0, import_react17.forwardRef)(function Button3(props, forwardedRef) {
  const {
    children,
    isDisabled,
    // link specific
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    elementType: "a",
    ...props
  }, domRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(otherProps, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useButtonStyles(props, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime6.jsx)("a", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, linkProps, hoverProps, styleProps),
    ref: domRef,
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    children
  });
});
var BaseButton$1 = (0, import_react17.forwardRef)(function Button4(props, forwardedRef) {
  const {
    children,
    isDisabled,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useButtonStyles(props, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime6.jsx)("button", {
    ref: domRef,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      propNames: /* @__PURE__ */ new Set(["form"])
    }),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
    children
  });
});
var useButtonChildren = (props) => {
  const {
    children
  } = props;
  const slots = (0, import_react17.useMemo)(() => {
    return {
      icon: {
        UNSAFE_className: buttonClassList.element("icon")
      },
      text: {
        color: "inherit",
        overflow: "unset",
        trim: false,
        UNSAFE_className: buttonClassList.element("text")
      }
    };
  }, []);
  return (0, import_jsx_runtime6.jsx)(SlotProvider, {
    slots,
    children: isReactText(children) ? (0, import_jsx_runtime6.jsx)(Text, {
      children
    }) : children
  });
};
var actionButtonClassList = new ClassList("ActionButton", ["icon", "text"]);
function useActionButtonStyles(props, state) {
  const {
    prominence = "default"
  } = props;
  const {
    isHovered,
    isPressed
  } = state;
  const isSelected = "isSelected" in props && props.isSelected || state.isSelected;
  const styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      interaction: isPressed ? "press" : isHovered ? "hover" : void 0,
      prominence: prominence === "default" ? void 0 : prominence,
      selected: isSelected || void 0,
      static: props.static
    }),
    style: styleProps.style,
    className: classNames(actionButtonClassList.element("root"), css({
      alignItems: "center",
      borderColor: "transparent",
      borderRadius: tokenSchema.size.radius.regular,
      borderStyle: "solid",
      borderWidth: tokenSchema.size.border.regular,
      cursor: "default",
      display: "inline-flex",
      flexShrink: 0,
      fontWeight: tokenSchema.typography.fontWeight.medium,
      height: tokenSchema.size.element.regular,
      justifyContent: "center",
      minWidth: tokenSchema.size.element.regular,
      outline: 0,
      paddingInline: tokenSchema.size.space.regular,
      position: "relative",
      transitionDuration: "130ms",
      transitionProperty: "background, border-color, box-shadow, color, ",
      transitionTimingFunction: "ease-out",
      userSelect: "none",
      // indicate when external link? e.g. `&[href^=http]`
      "a&": {
        cursor: "pointer"
      },
      // CONTENTS
      [actionButtonClassList.selector("text", "descendant")]: {
        fontWeight: "inherit",
        marginInline: tokenSchema.size.space.small,
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      },
      // FOCUS RING
      "--focus-ring-color": tokenSchema.color.alias.focusRing,
      "&[data-static]": {
        "--focus-ring-color": "currentColor"
      },
      "&::after": {
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        pointerEvents: "none",
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      "&[data-focus=visible]::after": {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`
      },
      // PROMINENCE
      // prominence: default
      "&:not([data-prominence])": {
        backgroundColor: tokenSchema.color.alias.backgroundIdle,
        borderColor: tokenSchema.color.alias.borderIdle,
        color: tokenSchema.color.alias.foregroundIdle,
        // interactions
        "&[data-interaction=hover]": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          borderColor: tokenSchema.color.alias.borderHovered,
          color: tokenSchema.color.alias.foregroundHovered
        },
        "&[data-interaction=press]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed,
          borderColor: tokenSchema.color.alias.borderPressed,
          color: tokenSchema.color.alias.foregroundPressed
        },
        // states
        "&[data-selected]": {
          backgroundColor: tokenSchema.color.alias.backgroundSelected,
          color: tokenSchema.color.foreground.neutralEmphasis,
          "&[data-interaction=hover]": {
            backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
          }
        },
        "&:disabled, &[aria-disabled=true], &[data-disabled=true]": {
          backgroundColor: tokenSchema.color.alias.backgroundDisabled,
          borderColor: "transparent",
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static]": {
          backgroundColor: "transparent"
        },
        "&[data-static=light]": {
          borderColor: "#fff6",
          color: "#fff",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a",
            borderColor: "#ffffff8c"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#ffffff26",
            borderColor: "#ffffffb3"
          },
          "&:disabled, &[aria-disabled]": {
            borderColor: "#ffffff40",
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          borderColor: "#0006",
          color: "#000",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#0000001a",
            borderColor: "#0000008c"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#00000026",
            borderColor: "#000000b3"
          },
          "&:disabled, &[aria-disabled]": {
            borderColor: "#00000040",
            color: "#0000008c"
          }
        }
      },
      // prominence: low
      "&[data-prominence=low]": {
        color: tokenSchema.color.foreground.neutral,
        // interactions
        "&[data-interaction=hover]": {
          backgroundColor: tokenSchema.color.alias.backgroundHovered,
          color: tokenSchema.color.foreground.neutralEmphasis
        },
        "&[data-interaction=press]": {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // states
        "&[data-selected]": {
          backgroundColor: tokenSchema.color.alias.backgroundSelected,
          color: tokenSchema.color.alias.foregroundSelected,
          "&[data-interaction=hover]": {
            backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
          }
        },
        "&:disabled, &[aria-disabled=true], &[data-disabled=true]": {
          borderColor: "transparent",
          color: tokenSchema.color.alias.foregroundDisabled
        },
        // static
        "&[data-static=light]": {
          color: "#fff",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#ffffff1a"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#ffffff26"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#ffffff8c"
          }
        },
        "&[data-static=dark]": {
          color: "#000",
          '&[data-interaction=hover], &[data-focus="visible"]': {
            backgroundColor: "#0000001a"
          },
          "&[data-interaction=press]": {
            backgroundColor: "#00000026"
          },
          "&:disabled, &[aria-disabled]": {
            color: "#0000008c"
          }
        }
      }
    }), styleProps.className)
  };
}
var ActionButton = (0, import_react17.forwardRef)(function ActionButton2(props, forwardedRef) {
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const children = useActionButtonChildren(props);
  if ("href" in props && props.href) {
    return (0, import_jsx_runtime6.jsx)(FocusRing, {
      autoFocus: props.autoFocus,
      children: (0, import_jsx_runtime6.jsx)(LinkButton, {
        ref: domRef,
        ...props,
        children
      })
    });
  }
  return (0, import_jsx_runtime6.jsx)(FocusRing, {
    autoFocus: props.autoFocus,
    children: (0, import_jsx_runtime6.jsx)(BaseButton, {
      ref: domRef,
      ...props,
      children
    })
  });
});
var LinkButton = (0, import_react17.forwardRef)(function LinkActionButton(props, forwardedRef) {
  const {
    children,
    isDisabled,
    // link specific
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    elementType: "a",
    ...props
  }, domRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(otherProps, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useActionButtonStyles(props, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime6.jsx)("a", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, linkProps, hoverProps, styleProps),
    ref: domRef,
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    children
  });
});
var BaseButton = (0, import_react17.forwardRef)(function BaseActionButton(props, forwardedRef) {
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const {
    children,
    isDisabled,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useActionButtonStyles(props, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime6.jsx)("button", {
    ref: domRef,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      propNames: /* @__PURE__ */ new Set(["form"])
    }),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
    children
  });
});
var iconClassName = actionButtonClassList.element("icon");
var textClassName = actionButtonClassList.element("text");
var useActionButtonChildren = (props, alternateSlots) => {
  const {
    children
  } = props;
  const slots = (0, import_react17.useMemo)(() => {
    return {
      ...alternateSlots,
      icon: {
        UNSAFE_className: iconClassName,
        ...alternateSlots === null || alternateSlots === void 0 ? void 0 : alternateSlots.icon
      },
      text: {
        color: "inherit",
        overflow: "unset",
        trim: false,
        UNSAFE_className: textClassName,
        ...alternateSlots === null || alternateSlots === void 0 ? void 0 : alternateSlots.text
      }
    };
  }, [alternateSlots]);
  return (0, import_jsx_runtime6.jsx)(SlotProvider, {
    slots,
    children: isReactText(children) ? (0, import_jsx_runtime6.jsx)(Text, {
      children
    }) : children
  });
};
var ClearButton = (0, import_react17.forwardRef)(function ClearButton2(props, forwardedRef) {
  let {
    autoFocus,
    isDisabled,
    preventFocus,
    elementType = preventFocus ? "div" : "button",
    ...otherProps
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    ...props,
    elementType
  }, domRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let styleProps = useClearButtonStyles(otherProps, {
    isHovered,
    isPressed
  });
  if (preventFocus) {
    delete buttonProps.tabIndex;
  }
  let ElementType = elementType;
  return (0, import_jsx_runtime6.jsx)(FocusRing, {
    autoFocus,
    children: (0, import_jsx_runtime6.jsx)(ElementType, {
      ...styleProps,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
      ref: domRef,
      children: (0, import_jsx_runtime6.jsx)(Icon, {
        src: xIcon
      })
    })
  });
});
function useClearButtonStyles(props, state) {
  let {
    isPressed,
    isHovered
  } = state;
  let styleProps = useStyleProps(props);
  const clearButtonStyles = css({
    alignItems: "center",
    borderRadius: "100%",
    color: tokenSchema.color.foreground.neutralSecondary,
    display: "flex",
    height: tokenSchema.size.element.regular,
    justifyContent: "center",
    outline: 0,
    position: "relative",
    transition: transition(["box-shadow", "margin"], {
      easing: "easeOut"
    }),
    width: tokenSchema.size.element.regular,
    "--focus-ring-color": tokenSchema.color.alias.focusRing,
    "&[data-static]": {
      "--focus-ring-color": "currentColor"
    },
    "&::after": {
      borderRadius: `inherit`,
      content: '""',
      inset: 0,
      pointerEvents: "none",
      position: "absolute",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      })
    },
    "&[data-focus=visible]::after": {
      boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} var(--focus-ring-color)`,
      margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`
    },
    "&[data-interaction=hover]": {
      color: tokenSchema.color.foreground.neutral
    },
    "&[data-interaction=press]": {
      color: tokenSchema.color.foreground.neutralEmphasis
    },
    "&:disabled, &[aria-disabled]": {
      color: tokenSchema.color.alias.foregroundDisabled
    },
    // static
    "&[data-static=light]": {
      color: "#fff",
      '&[data-interaction=hover], &[data-focus="visible"]': {
        backgroundColor: "#ffffff1a"
      },
      "&[data-interaction=press]": {
        backgroundColor: "#ffffff26"
      },
      "&:disabled, &[aria-disabled]": {
        backgroundColor: "#ffffff1a",
        color: "#ffffff8c"
      }
    },
    "&[data-static=dark]": {
      color: "#000",
      '&[data-interaction=hover], &[data-focus="visible"]': {
        backgroundColor: "#0000001a"
      },
      "&[data-interaction=press]": {
        backgroundColor: "#00000026"
      },
      "&:disabled, &[aria-disabled]": {
        backgroundColor: "#0000001a",
        color: "#0000008c"
      }
    }
  });
  return {
    ...styleProps,
    ...toDataAttributes({
      static: props.static,
      interaction: isPressed ? "press" : isHovered ? "hover" : void 0
    }),
    className: classNames(clearButtonStyles, styleProps.className)
  };
}
var FieldButton = (0, import_react17.forwardRef)(function FieldButton2(props, forwardedRef) {
  props = useSlotProps(props, "button");
  let {
    elementType: ElementType = "button",
    isDisabled,
    autoFocus,
    isActive
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3(props, domRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let {
    children,
    styleProps
  } = useFieldButton(props, {
    isHovered,
    isPressed: isActive !== null && isActive !== void 0 ? isActive : isPressed
  });
  return (0, import_jsx_runtime6.jsx)(FocusRing, {
    autoFocus,
    children: (0, import_jsx_runtime6.jsx)(ElementType, {
      ...styleProps,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
      ref: domRef,
      className: classNames(css({
        justifyContent: "space-between",
        textAlign: "start"
      }), styleProps.className),
      style: {
        ...styleProps.style,
        boxShadow: "none"
      },
      children
    })
  });
});
function useFieldButton(props, state) {
  let {
    isHovered,
    isPressed
  } = state;
  const styleProps = useActionButtonStyles(props, {
    isHovered,
    isPressed
  });
  let slots = (0, import_react17.useMemo)(() => ({
    text: {
      flex: true,
      truncate: true
    }
  }), []);
  let children = useActionButtonChildren(props, slots);
  return {
    children,
    styleProps
  };
}
var ToggleButton = (0, import_react17.forwardRef)(function ToggleButton2(props, forwardedRef) {
  const {
    isDisabled,
    ...otherProps
  } = props;
  props = useProviderProps(props);
  props = useSlotProps(props, "button");
  const children = useActionButtonChildren(props);
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const state = $3017fa7ffdddec74$export$8042c6c013fd5226(props);
  const {
    buttonProps,
    isPressed
  } = $55f54f7887471b58$export$51e84d46ca0bc451(props, state, domRef);
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  const styleProps = useActionButtonStyles(props, {
    isHovered,
    isPressed,
    isSelected: state.isSelected
  });
  return (0, import_jsx_runtime6.jsx)(FocusRing, {
    autoFocus: props.autoFocus,
    children: (0, import_jsx_runtime6.jsx)("button", {
      ref: domRef,
      ...styleProps,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, hoverProps),
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
      children
    })
  });
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/layout/dist/keystar-ui-layout.esm.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-aria+separator@3.3.8_react@18.2.0/node_modules/@react-aria/separator/dist/import.mjs
function $f4b273590fab9f93$export$52210f68a14655d0(props) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let ariaOrientation;
  if (props.orientation === "vertical")
    ariaOrientation = "vertical";
  if (props.elementType !== "hr")
    return {
      separatorProps: {
        ...domProps,
        role: "separator",
        "aria-orientation": ariaOrientation
      }
    };
  return {
    separatorProps: domProps
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/layout/dist/keystar-ui-layout.esm.js
var import_react18 = __toESM(require_react());
var Box = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime7.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps),
    ...styleProps,
    children
  });
});
var dividerClassList = new ClassList("Divider");
var filterOptions2 = {
  propNames: /* @__PURE__ */ new Set(["role"])
};
var Divider = forwardRefWithAs((props, forwardedRef) => {
  props = useSlotProps(props, "divider");
  const {
    orientation = "horizontal",
    elementType: Element4 = orientation === "vertical" ? "div" : "hr",
    size: size3 = "regular",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  let {
    separatorProps
  } = $f4b273590fab9f93$export$52210f68a14655d0({
    ...props,
    // FIXME: `forwardRefWithAs` yields `React.ElementType<any>` which is
    // incompatible with react-aria's expectations for `elementType`.
    elementType: Element4
  });
  return (0, import_jsx_runtime7.jsx)(Element4, {
    ...styleProps,
    ...separatorProps,
    ...toDataAttributes({
      orientation,
      size: size3
    }),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, filterOptions2),
    ref: forwardedRef,
    className: classNames(dividerClassList.element("root"), css({
      alignSelf: "stretch",
      backgroundColor: tokenSchema.color.border.neutral,
      borderRadius: "var(--size)",
      "&[data-size=regular]": {
        "--size": tokenSchema.size.border.regular
      },
      "&[data-size=medium]": {
        "--size": tokenSchema.size.border.medium
      },
      "&[data-size=large]": {
        "--size": tokenSchema.size.border.large
      },
      "&[data-orientation=horizontal]": {
        height: "var(--size)"
      },
      "&[data-orientation=vertical]": {
        width: "var(--size)"
      }
    }), styleProps.className)
  });
});
var sharedStyleProps = {
  gap: resolvePropWithPath("gap", "size.space"),
  columnGap: resolvePropWithPath("columnGap", "size.space"),
  rowGap: resolvePropWithPath("rowGap", "size.space"),
  alignContent: resolveProp("alignContent", flexAlignValue),
  alignItems: resolveProp("alignItems", flexAlignValue),
  direction: resolveProp("flexDirection"),
  justifyContent: resolveProp("justifyContent", flexAlignValue)
};
function displayInline(block5) {
  const resolver = (inline4) => inline4 ? `inline-${block5}` : block5;
  return resolver;
}
function useFlexStyleProps(props) {
  return useStyleProps({
    inline: false,
    ...props
  }, flexStyleProps);
}
var flexStyleProps = {
  ...sharedStyleProps,
  direction: resolveProp("flexDirection"),
  inline: resolveProp("display", displayInline("flex")),
  wrap: resolveProp("flexWrap", flexWrapValue)
};
function flexAlignValue(value2) {
  if (value2 === "start") {
    return "flex-start";
  }
  if (value2 === "end") {
    return "flex-end";
  }
  return value2;
}
function flexWrapValue(value2) {
  if (typeof value2 === "boolean") {
    return value2 ? "wrap" : "nowrap";
  }
  return value2;
}
function isFractionUnit(value2) {
  return value2.endsWith("fr");
}
function gridSizeResolver(value2) {
  if (typeof value2 === "number") {
    return value2;
  }
  if (isFractionUnit(value2)) {
    return value2;
  }
  return sizeResolver(value2);
}
function useGridStyleProps(props) {
  return useStyleProps({
    inline: false,
    ...props
  }, gridStyleProps);
}
var gridStyleProps = {
  ...sharedStyleProps,
  inline: resolveProp("display", displayInline("grid")),
  autoFlow: resolveProp("gridAutoFlow"),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  autoColumns: resolveProp("gridAutoColumns", sizeResolver),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  autoRows: resolveProp("gridAutoRows", sizeResolver),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  areas: resolveProp("gridTemplateAreas", gridTemplateAreasValue),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  columns: resolveProp("gridTemplateColumns", gridTemplateValue),
  // @ts-ignore FIXME: The `StyleResolver` type is not generic enough to support this.
  rows: resolveProp("gridTemplateRows", gridTemplateValue),
  justifyItems: resolveProp("justifyItems"),
  justifyContent: resolveProp("justifyContent"),
  alignItems: resolveProp("alignItems"),
  alignContent: resolveProp("alignContent")
};
function gridTemplateAreasValue(values2) {
  return values2.map((value2) => `"${value2}"`).join("\n");
}
function gridTemplateValue(value2) {
  if (Array.isArray(value2)) {
    return value2.map(gridSizeResolver).join(" ");
  }
  return value2;
}
function minmax(min, max2) {
  return `minmax(${gridSizeResolver(min)}, ${gridSizeResolver(max2)})`;
}
var Flex = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps(otherProps);
  return (0, import_jsx_runtime7.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var Grid = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useGridStyleProps(otherProps);
  return (0, import_jsx_runtime7.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(gridStyleProps)),
    ...styleProps,
    children
  });
});
var VStack = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps({
    direction: "column",
    ...otherProps
  });
  return (0, import_jsx_runtime7.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var HStack = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    ...otherProps
  } = props;
  const styleProps = useFlexStyleProps({
    direction: "row",
    ...otherProps
  });
  return (0, import_jsx_runtime7.jsx)(ElementType, {
    ref: forwardedRef,
    ...filterStyleProps(otherProps, Object.keys(flexStyleProps)),
    ...styleProps,
    children
  });
});
var levels = ["one", "two", "three"];
var MAX_LEVEL = levels.length - 1;
var SurfaceContext = (0, import_react18.createContext)(1);
var Surface = forwardRefWithAs((props, forwardedRef) => {
  const {
    elementType: ElementType = "div",
    children,
    level: overrideLevel,
    ...otherProps
  } = props;
  const contextLevel = (0, import_react18.useContext)(SurfaceContext);
  const level = overrideLevel !== null && overrideLevel !== void 0 ? overrideLevel : contextLevel;
  const levelClassName = `${TOKEN_PREFIX}--surface-${levels[level]}`;
  const value2 = Math.max(0, Math.min(level + 1, MAX_LEVEL));
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime7.jsx)(SurfaceContext.Provider, {
    value: value2,
    children: (0, import_jsx_runtime7.jsx)(ElementType, {
      ref: forwardedRef,
      ...filterStyleProps(otherProps),
      ...styleProps,
      className: classNames(levelClassName, styleProps.className),
      children
    })
  });
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/link/dist/keystar-ui-link.esm.js
var import_react19 = __toESM(require_react());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
function useTextLink({
  autoFocus,
  prominence = "default"
}) {
  const headingContext = useHeadingContext();
  const textContext = useTextContext();
  const {
    focusProps,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    autoFocus
  });
  const {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({});
  const fontWeight = headingContext ? void 0 : tokenSchema.typography.fontWeight.medium;
  const dataOptions = {
    prominence,
    hover: isHovered ? "true" : void 0,
    focus: isFocusVisible ? "visible" : void 0
  };
  return {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, focusProps),
    ...toDataAttributes(dataOptions),
    Wrapper: !textContext && !headingContext ? Text : import_react19.Fragment,
    className: classNames(css({
      color: tokenSchema.color.foreground.neutral,
      cursor: "pointer",
      fontWeight,
      outline: 0,
      textDecoration: "underline",
      textDecorationColor: tokenSchema.color.border.emphasis,
      textDecorationThickness: tokenSchema.size.border.regular,
      textUnderlineOffset: tokenSchema.size.border.medium,
      '&[data-hover="true"], &[data-focus="visible"]': {
        color: tokenSchema.color.foreground.neutralEmphasis,
        textDecorationColor: tokenSchema.color.foreground.neutral
      },
      '&[data-focus="visible"]': {
        textDecorationStyle: "double"
      },
      '&[data-prominence="high"]': {
        color: tokenSchema.color.foreground.accent,
        textDecorationColor: tokenSchema.color.border.accent,
        '&[data-hover="true"], &[data-focus="visible"]': {
          textDecorationColor: tokenSchema.color.foreground.accent
        }
      }
    }))
  };
}
var TextLinkAnchor = (0, import_react19.forwardRef)(function TextLink(props, forwardedRef) {
  const {
    children,
    download,
    href,
    hrefLang,
    ping,
    referrerPolicy,
    rel,
    target,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    Wrapper,
    ...styleProps
  } = useTextLink(props);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(otherProps, domRef);
  return (0, import_jsx_runtime8.jsx)(Wrapper, {
    children: (0, import_jsx_runtime8.jsx)("a", {
      ref: domRef,
      download,
      href,
      hrefLang,
      ping,
      referrerPolicy,
      rel,
      target,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(linkProps, styleProps),
      children
    })
  });
});
var TextLinkButton = (0, import_react19.forwardRef)(function TextLink2(props, forwardedRef) {
  const {
    children,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    Wrapper,
    ...styleProps
  } = useTextLink(otherProps);
  const {
    buttonProps
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    elementType: "span",
    ...otherProps
  }, domRef);
  return (0, import_jsx_runtime8.jsx)(Wrapper, {
    children: (0, import_jsx_runtime8.jsx)("span", {
      ref: domRef,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, styleProps),
      children
    })
  });
});
var TextLink3 = (0, import_react19.forwardRef)(function TextLink4(props, forwardedRef) {
  if ("href" in props) {
    return (0, import_jsx_runtime8.jsx)(TextLinkAnchor, {
      ...props,
      ref: forwardedRef
    });
  }
  return (0, import_jsx_runtime8.jsx)(TextLinkButton, {
    ...props,
    ref: forwardedRef
  });
});

// node_modules/.pnpm/@react-aria+label@3.7.3_react@18.2.0/node_modules/@react-aria/label/dist/import.mjs
function $d191a55c9702f145$export$8467354a121f1b9f(props) {
  let { id, label, "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel, labelElementType = "label" } = props;
  id = (0, $bdb11010cef70236$export$f680877a34711e37)(id);
  let labelId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let labelProps = {};
  if (label) {
    ariaLabelledby = ariaLabelledby ? `${labelId} ${ariaLabelledby}` : labelId;
    labelProps = {
      id: labelId,
      htmlFor: labelElementType === "label" ? id : void 0
    };
  } else if (!ariaLabelledby && !ariaLabel)
    console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
  let fieldProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby
  });
  return {
    labelProps,
    fieldProps
  };
}
function $2baaea4c71418dea$export$294aa081a6c6f55d(props) {
  let { description, errorMessage, isInvalid, validationState } = props;
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)(props);
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)([
    Boolean(description),
    Boolean(errorMessage),
    isInvalid,
    validationState
  ]);
  let errorMessageId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)([
    Boolean(description),
    Boolean(errorMessage),
    isInvalid,
    validationState
  ]);
  fieldProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(fieldProps, {
    "aria-describedby": [
      descriptionId,
      // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA. See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
      errorMessageId,
      props["aria-describedby"]
    ].filter(Boolean).join(" ") || void 0
  });
  return {
    labelProps,
    fieldProps,
    descriptionProps: {
      id: descriptionId
    },
    errorMessageProps: {
      id: errorMessageId
    }
  };
}

// node_modules/.pnpm/@react-aria+progress@3.4.8_react@18.2.0/node_modules/@react-aria/progress/dist/import.mjs
function $204d9ebcedfb8806$export$ed5abd763a836edc(props) {
  let { value: value2 = 0, minValue = 0, maxValue = 100, valueLabel, isIndeterminate, formatOptions = {
    style: "percent"
  } } = props;
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)({
    ...props,
    // Progress bar is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span"
  });
  value2 = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(value2, minValue, maxValue);
  let percentage = (value2 - minValue) / (maxValue - minValue);
  let formatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)(formatOptions);
  if (!isIndeterminate && !valueLabel) {
    let valueToFormat = formatOptions.style === "percent" ? percentage : value2;
    valueLabel = formatter.format(valueToFormat);
  }
  return {
    progressBarProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...fieldProps,
      "aria-valuenow": isIndeterminate ? void 0 : value2,
      "aria-valuemin": minValue,
      "aria-valuemax": maxValue,
      "aria-valuetext": isIndeterminate ? void 0 : valueLabel,
      role: "progressbar"
    }),
    labelProps
  };
}

// node_modules/.pnpm/@react-aria+meter@3.4.8_react@18.2.0/node_modules/@react-aria/meter/dist/import.mjs
function $0002d7e1d16de204$export$e969dbfa146870ff(props) {
  let { progressBarProps, labelProps } = (0, $204d9ebcedfb8806$export$ed5abd763a836edc)(props);
  return {
    meterProps: {
      ...progressBarProps,
      // Use the meter role if available, but fall back to progressbar if not
      // Chrome currently falls back from meter automatically, and Firefox
      // does not support meter at all. Safari 13+ seems to support meter properly.
      // https://bugs.chromium.org/p/chromium/issues/detail?id=944542
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1460378
      role: "meter progressbar"
    },
    labelProps
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/progress/dist/keystar-ui-progress.esm.js
var import_react20 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var BarBase = (0, import_react20.forwardRef)(function BarBase2(props, forwardedRef) {
  let {
    value: value2 = 0,
    minValue = 0,
    maxValue = 100,
    label,
    barClassName,
    showValueLabel = !!label,
    isIndeterminate,
    barProps,
    labelProps,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  value2 = $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, minValue, maxValue);
  let barStyle = {};
  if (!isIndeterminate) {
    let percentage = (value2 - minValue) / (maxValue - minValue);
    barStyle.width = `${Math.round(percentage * 100)}%`;
  }
  warning(!!(label || ariaLabel || ariaLabelledby), "If you do not provide a visible label via children, you must specify an aria-label or aria-labelledby attribute for accessibility.");
  return (0, import_jsx_runtime9.jsxs)("div", {
    ...barProps,
    ...styleProps,
    ref: forwardedRef,
    className: classNames(css({
      "--bar-fill": tokenSchema.color.background.accentEmphasis,
      alignItems: "flex-start",
      display: "inline-flex",
      gap: tokenSchema.size.space.regular,
      flexFlow: "wrap",
      isolation: "isolate",
      justifyContent: "space-between",
      minWidth: 0,
      position: "relative",
      verticalAlign: "top",
      width: tokenSchema.size.alias.singleLineWidth
    }), barClassName, styleProps.className),
    children: [label && (0, import_jsx_runtime9.jsx)(Text, {
      ...labelProps,
      flex: true,
      children: label
    }), showValueLabel && barProps && (0, import_jsx_runtime9.jsx)(Text, {
      flexShrink: 0,
      children: barProps["aria-valuetext"]
    }), (0, import_jsx_runtime9.jsx)("div", {
      className: css({
        backgroundColor: tokenSchema.color.border.muted,
        borderRadius: tokenSchema.size.radius.full,
        height: tokenSchema.size.space.regular,
        minWidth: 0,
        overflow: "hidden",
        width: "100%",
        zIndex: "1"
      }),
      children: (0, import_jsx_runtime9.jsx)("div", {
        ...toDataAttributes({
          indeterminate: isIndeterminate !== null && isIndeterminate !== void 0 ? isIndeterminate : void 0
        }),
        className: css({
          backgroundColor: "var(--bar-fill)",
          height: tokenSchema.size.space.regular,
          transition: transition("width", {
            duration: "regular"
          }),
          "&[data-indeterminate]": {
            animation: `${indeterminateLoopLtr} ${tokenSchema.animation.duration.long} ${tokenSchema.animation.easing.easeInOut} infinite`,
            willChange: "transform",
            "[dir=rtl] &": {
              animationName: indeterminateLoopRtl
            }
          }
        }),
        style: barStyle
      })
    })]
  });
});
var indeterminateLoopLtr = keyframes({
  from: {
    transform: "translate(-100%)"
  },
  to: {
    transform: "translate(100%)"
  }
});
var indeterminateLoopRtl = keyframes({
  from: {
    transform: "translate(100%)"
  },
  to: {
    transform: "translate(-100%)"
  }
});
var Meter = (0, import_react20.forwardRef)(function Meter2(props, forwardedRef) {
  let {
    tone,
    ...otherProps
  } = props;
  const {
    meterProps,
    labelProps
  } = $0002d7e1d16de204$export$e969dbfa146870ff(props);
  return (0, import_jsx_runtime9.jsx)(BarBase, {
    ...otherProps,
    ref: forwardedRef,
    barClassName: css({
      '&[data-tone="positive"]': {
        "--bar-fill": tokenSchema.color.background.positiveEmphasis
      },
      '&[data-tone="caution"]': {
        "--bar-fill": tokenSchema.color.background.cautionEmphasis
      },
      '&[data-tone="critical"]': {
        "--bar-fill": tokenSchema.color.background.criticalEmphasis
      }
    }),
    barProps: {
      ...meterProps,
      ...toDataAttributes({
        tone
      })
    },
    labelProps
  });
});
var ProgressBar = (0, import_react20.forwardRef)(function ProgressBar2(props, forwardedRef) {
  const {
    progressBarProps,
    labelProps
  } = $204d9ebcedfb8806$export$ed5abd763a836edc(props);
  return (0, import_jsx_runtime9.jsx)(BarBase, {
    ...props,
    ref: forwardedRef,
    barProps: progressBarProps,
    labelProps
  });
});
var ProgressCircle = (0, import_react20.forwardRef)(function ProgressCircle2(props, forwardRef24) {
  let {
    value: value2 = 0,
    minValue = 0,
    maxValue = 100,
    size: size3 = "medium",
    isIndeterminate,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledby,
    ...otherProps
  } = props;
  value2 = $9446cca9a3875146$export$7d15b64cf5a3a4c4(value2, minValue, maxValue);
  let {
    progressBarProps
  } = $204d9ebcedfb8806$export$ed5abd763a836edc({
    ...props,
    value: value2
  });
  let styleProps = useStyleProps(otherProps);
  warning(!!(ariaLabel || ariaLabelledby), "ProgressCircle requires an aria-label or aria-labelledby attribute for accessibility.");
  return (0, import_jsx_runtime9.jsx)("div", {
    ...styleProps,
    ...progressBarProps,
    ref: forwardRef24,
    ...toDataAttributes({
      indeterminate: isIndeterminate !== null && isIndeterminate !== void 0 ? isIndeterminate : void 0,
      size: size3 === "medium" ? void 0 : size3
    }),
    className: classNames(css({
      height: "var(--diameter)",
      width: "var(--diameter)",
      "--PI": 3.14159,
      "--diameter": tokenSchema.size.element.regular,
      "--radius": "calc(var(--diameter) / 2)",
      "--stroke-width": tokenSchema.size.scale[40],
      // TODO: component tokent
      "--offset-radius": "calc(var(--radius) - var(--stroke-width) / 2)",
      "--circumference": `calc(var(--offset-radius) * var(--PI) * 2)`,
      ["&[data-size=small]"]: {
        "--diameter": tokenSchema.size.element.xsmall,
        "--stroke-width": tokenSchema.size.border.medium
      },
      ["&[data-size=large]"]: {
        "--diameter": tokenSchema.size.element.xlarge,
        "--stroke-width": tokenSchema.size.border.large
      }
    }), styleProps.className),
    style: {
      // @ts-ignore
      "--percent": (value2 - minValue) / (maxValue - minValue),
      ...styleProps.style
    },
    children: (0, import_jsx_runtime9.jsxs)("svg", {
      role: "presentation",
      tabIndex: -1,
      className: css({
        height: "var(--diameter)",
        width: "var(--diameter)"
      }),
      children: [(0, import_jsx_runtime9.jsx)("circle", {
        className: circle({
          stroke: tokenSchema.color.border.muted
        })
      }), (0, import_jsx_runtime9.jsx)("circle", {
        ...toDataAttributes({
          indeterminate: isIndeterminate !== null && isIndeterminate !== void 0 ? isIndeterminate : void 0
        }),
        className: circle({
          stroke: tokenSchema.color.background.accentEmphasis,
          strokeDasharray: "var(--circumference)",
          strokeLinecap: "round",
          transition: transition("stroke-dashoffset", {
            duration: "regular"
          }),
          transform: "rotate(-90deg)",
          transformOrigin: "50% 50%",
          "&[data-indeterminate]": {
            animation: `${indeterminateAnimation} ${tokenSchema.animation.duration.xlong} ${tokenSchema.animation.easing.easeInOut} infinite`
          }
        }),
        style: {
          strokeDashoffset: `calc(var(--circumference) - var(--percent) * var(--circumference))`
        }
      })]
    })
  });
});
function circle(styles2) {
  return css([{
    cx: "var(--radius)",
    cy: "var(--radius)",
    r: "var(--offset-radius)",
    fill: "transparent",
    strokeWidth: "var(--stroke-width)"
  }, styles2]);
}
var indeterminateAnimation = keyframes({
  from: {
    transform: "rotate(0deg)",
    strokeDashoffset: "var(--circumference)"
  },
  to: {
    transform: "rotate(360deg)",
    strokeDashoffset: "calc(var(--circumference) * -1)"
  }
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/field/dist/keystar-ui-field.esm.js
var import_react21 = __toESM(require_react());
var import_jsx_runtime11 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/alertTriangleIcon/dist/keystar-ui-icon-icons-alertTriangleIcon.esm.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var alertTriangleIcon = (0, import_jsx_runtime10.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime10.jsx)("path", {
    d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3ZM12 9v4M12 17h.01"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/field/dist/keystar-ui-field.esm.js
var localizedMessages = {
  "ar-AE": {
    "(optional)": "(اختياري)",
    "(required)": "(مطلوب)"
  },
  "bg-BG": {
    "(optional)": "(незадължително)",
    "(required)": "(задължително)"
  },
  "cs-CZ": {
    "(optional)": "(volitelně)",
    "(required)": "(požadováno)"
  },
  "da-DK": {
    "(optional)": "(valgfrit)",
    "(required)": "(obligatorisk)"
  },
  "de-DE": {
    "(optional)": "(optional)",
    "(required)": "(erforderlich)"
  },
  "el-GR": {
    "(optional)": "(προαιρετικό)",
    "(required)": "(απαιτείται)"
  },
  "en-US": {
    "(optional)": "(optional)",
    "(required)": "(required)"
  },
  "es-ES": {
    "(optional)": "(opcional)",
    "(required)": "(necesario)"
  },
  "et-EE": {
    "(optional)": "(valikuline)",
    "(required)": "(nõutav)"
  },
  "fi-FI": {
    "(optional)": "(valinnainen)",
    "(required)": "(pakollinen)"
  },
  "fr-FR": {
    "(optional)": "(facultatif)",
    "(required)": "(requis)"
  },
  "he-IL": {
    "(optional)": "(אופציונלי)",
    "(required)": "(נדרש)"
  },
  "hr-HR": {
    "(optional)": "(opcionalno)",
    "(required)": "(obvezno)"
  },
  "hu-HU": {
    "(optional)": "(opcionális)",
    "(required)": "(kötelező)"
  },
  "it-IT": {
    "(optional)": "(facoltativo)",
    "(required)": "(obbligatorio)"
  },
  "ja-JP": {
    "(optional)": "（オプション）",
    "(required)": "（必須）"
  },
  "ko-KR": {
    "(optional)": "(선택 사항)",
    "(required)": "(필수 사항)"
  },
  "lt-LT": {
    "(optional)": "(pasirenkama)",
    "(required)": "(privaloma)"
  },
  "lv-LV": {
    "(optional)": "(neobligāti)",
    "(required)": "(obligāti)"
  },
  "nb-NO": {
    "(optional)": "(valgfritt)",
    "(required)": "(obligatorisk)"
  },
  "nl-NL": {
    "(optional)": "(optioneel)",
    "(required)": "(vereist)"
  },
  "pl-PL": {
    "(optional)": "(opcjonalne)",
    "(required)": "(wymagane)"
  },
  "pt-BR": {
    "(optional)": "(opcional)",
    "(required)": "(obrigatório)"
  },
  "pt-PT": {
    "(optional)": "(opcional)",
    "(required)": "(obrigatório)"
  },
  "ro-RO": {
    "(optional)": "(opţional)",
    "(required)": "(obligatoriu)"
  },
  "ru-RU": {
    "(optional)": "(дополнительно)",
    "(required)": "(обязательно)"
  },
  "sk-SK": {
    "(optional)": "(nepovinné)",
    "(required)": "(povinné)"
  },
  "sl-SI": {
    "(optional)": "(opcijsko)",
    "(required)": "(obvezno)"
  },
  "sr-SP": {
    "(optional)": "(opciono)",
    "(required)": "(obavezno)"
  },
  "sv-SE": {
    "(optional)": "(valfritt)",
    "(required)": "(krävs)"
  },
  "tr-TR": {
    "(optional)": "(isteğe bağlı)",
    "(required)": "(gerekli)"
  },
  "uk-UA": {
    "(optional)": "(необов’язково)",
    "(required)": "(обов’язково)"
  },
  "zh-CN": {
    "(optional)": "（可选）",
    "(required)": "（必填）"
  },
  "zh-TW": {
    "(optional)": "(選填)",
    "(required)": "(必填)"
  }
};
var FieldLabel = forwardRefWithAs(function FieldLabel2({
  children,
  elementType: ElementType = "label",
  isRequired,
  supplementRequiredState,
  ...labelProps
}, forwardedRef) {
  const styleProps = useTextStyles({
    color: "neutral",
    size: "regular",
    trim: true,
    weight: "medium",
    UNSAFE_className: css({
      cursor: "default"
    })
  });
  return (0, import_jsx_runtime11.jsxs)(ElementType, {
    ref: forwardedRef,
    ...labelProps,
    ...styleProps,
    children: [children, isRequired && (0, import_jsx_runtime11.jsx)(Asterisk, {
      supplementRequiredState
    })]
  });
});
function Asterisk({
  supplementRequiredState
}) {
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  return (0, import_jsx_runtime11.jsx)("span", {
    "aria-label": supplementRequiredState ? stringFormatter.format("(required)") : void 0,
    children: (0, import_jsx_runtime11.jsx)("span", {
      "aria-hidden": true,
      className: css({
        color: tokenSchema.color.foreground.critical,
        fontSize: tokenSchema.typography.text.large.size,
        lineHeight: 1,
        paddingInlineStart: "0.125em"
      }),
      children: "*"
    })
  });
}
var FieldMessage = (props) => {
  return (0, import_jsx_runtime11.jsxs)(Flex, {
    gap: "regular",
    UNSAFE_className: css({
      marginTop: "calc(var(--icon-offset) * -1)"
    }),
    UNSAFE_style: {
      // @ts-ignore
      "--icon-offset": `calc(${tokenSchema.size.icon.regular} - ${tokenSchema.typography.text.small.size})`
    },
    children: [(0, import_jsx_runtime11.jsx)(Icon, {
      src: alertTriangleIcon,
      color: "critical"
    }), (0, import_jsx_runtime11.jsx)(Text, {
      color: "critical",
      size: "small",
      UNSAFE_className: css({
        paddingTop: "var(--icon-offset)"
      }),
      ...props
    })]
  });
};
var FieldPrimitive = (0, import_react21.forwardRef)(function FieldPrimitive2(props, forwardedRef) {
  const {
    children,
    contextualHelp,
    isRequired,
    label,
    labelElementType,
    labelProps,
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    supplementRequiredState
  } = props;
  const styleProps = useStyleProps(props);
  const contextualHelpId = (0, import_react21.useId)();
  const contextualHelpSlots = (0, import_react21.useMemo)(() => {
    return {
      // match capsize styles from the label text. stops the contextual help button
      // from pushing elements above/below it
      button: {
        UNSAFE_className: css({
          marginBottom: tokenSchema.typography.text.regular.capheightTrim,
          marginTop: tokenSchema.typography.text.regular.baselineTrim
        }),
        id: contextualHelpId,
        "aria-labelledby": labelProps !== null && labelProps !== void 0 && labelProps.id ? `${labelProps.id} ${contextualHelpId}` : void 0
      }
    };
  }, [contextualHelpId, labelProps === null || labelProps === void 0 ? void 0 : labelProps.id]);
  return (0, import_jsx_runtime11.jsxs)(Flex, {
    ref: forwardedRef,
    direction: "column",
    gap: "medium",
    minWidth: 0,
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    children: [(() => {
      if (!label) {
        return null;
      }
      const labelUI = (0, import_jsx_runtime11.jsx)(FieldLabel, {
        elementType: labelElementType,
        isRequired,
        supplementRequiredState,
        ...labelProps,
        children: label
      });
      if (contextualHelp) {
        return (0, import_jsx_runtime11.jsxs)(Flex, {
          gap: "small",
          alignItems: "center",
          children: [labelUI, (0, import_jsx_runtime11.jsx)(SlotProvider, {
            slots: contextualHelpSlots,
            children: contextualHelp
          })]
        });
      }
      return labelUI;
    })(), description && (0, import_jsx_runtime11.jsx)(Text, {
      ...descriptionProps,
      size: "small",
      color: "neutralSecondary",
      children: description
    }), children, errorMessage && (0, import_jsx_runtime11.jsx)(FieldMessage, {
      ...errorMessageProps,
      children: errorMessage
    })]
  });
});
var Field = (props) => {
  const {
    children,
    description,
    errorMessage,
    isDisabled,
    isReadOnly,
    isRequired,
    label,
    ...otherProps
  } = props;
  let {
    labelProps,
    fieldProps,
    descriptionProps,
    errorMessageProps
  } = $2baaea4c71418dea$export$294aa081a6c6f55d(props);
  const renderProps = {
    ...fieldProps,
    disabled: isDisabled,
    readOnly: isReadOnly,
    "aria-required": isRequired || void 0,
    "aria-invalid": errorMessage ? true : void 0
  };
  return (0, import_jsx_runtime11.jsx)(FieldPrimitive, {
    isRequired,
    label,
    labelProps,
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    ...otherProps,
    children: children(renderProps)
  });
};
function validateFieldProps(props) {
  if (props.errorMessage) {
    return Object.assign({}, {
      validationState: "invalid"
    }, props);
  }
  return props;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/text-field/dist/keystar-ui-text-field.esm.js
var import_react25 = __toESM(require_react());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-aria+textfield@3.13.0_react@18.2.0/node_modules/@react-aria/textfield/dist/import.mjs
var import_react24 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+form@3.0.0_react@18.2.0/node_modules/@react-aria/form/dist/import.mjs
var import_react22 = __toESM(require_react(), 1);
function $e93e671b31057976$export$b8473d3665f3a75a(props, state, ref) {
  let { validationBehavior, focus } = props;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (validationBehavior === "native" && (ref === null || ref === void 0 ? void 0 : ref.current)) {
      let errorMessage = state.realtimeValidation.isInvalid ? state.realtimeValidation.validationErrors.join(" ") || "Invalid value." : "";
      ref.current.setCustomValidity(errorMessage);
      if (!ref.current.hasAttribute("title"))
        ref.current.title = "";
      if (!state.realtimeValidation.isInvalid)
        state.updateValidation($e93e671b31057976$var$getNativeValidity(ref.current));
    }
  });
  let onReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    state.resetValidation();
  });
  let onInvalid = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    var _ref_current;
    if (!state.displayValidation.isInvalid)
      state.commitValidation();
    let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;
    if (!e6.defaultPrevented && ref && form && $e93e671b31057976$var$getFirstInvalidInput(form) === ref.current) {
      var _ref_current1;
      if (focus)
        focus();
      else
        (_ref_current1 = ref.current) === null || _ref_current1 === void 0 ? void 0 : _ref_current1.focus();
      (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
    }
    e6.preventDefault();
  });
  let onChange = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    state.commitValidation();
  });
  (0, import_react22.useEffect)(() => {
    let input = ref === null || ref === void 0 ? void 0 : ref.current;
    if (!input)
      return;
    let form = input.form;
    input.addEventListener("invalid", onInvalid);
    input.addEventListener("change", onChange);
    form === null || form === void 0 ? void 0 : form.addEventListener("reset", onReset);
    return () => {
      input.removeEventListener("invalid", onInvalid);
      input.removeEventListener("change", onChange);
      form === null || form === void 0 ? void 0 : form.removeEventListener("reset", onReset);
    };
  }, [
    ref,
    onInvalid,
    onChange,
    onReset,
    validationBehavior
  ]);
}
function $e93e671b31057976$var$getValidity(input) {
  let validity = input.validity;
  return {
    badInput: validity.badInput,
    customError: validity.customError,
    patternMismatch: validity.patternMismatch,
    rangeOverflow: validity.rangeOverflow,
    rangeUnderflow: validity.rangeUnderflow,
    stepMismatch: validity.stepMismatch,
    tooLong: validity.tooLong,
    tooShort: validity.tooShort,
    typeMismatch: validity.typeMismatch,
    valueMissing: validity.valueMissing,
    valid: validity.valid
  };
}
function $e93e671b31057976$var$getNativeValidity(input) {
  return {
    isInvalid: !input.validity.valid,
    validationDetails: $e93e671b31057976$var$getValidity(input),
    validationErrors: input.validationMessage ? [
      input.validationMessage
    ] : []
  };
}
function $e93e671b31057976$var$getFirstInvalidInput(form) {
  for (let i6 = 0; i6 < form.elements.length; i6++) {
    let element2 = form.elements[i6];
    if (!element2.validity.valid)
      return element2;
  }
  return null;
}

// node_modules/.pnpm/@react-stately+form@3.0.0_react@18.2.0/node_modules/@react-stately/form/dist/import.mjs
var import_react23 = __toESM(require_react(), 1);
var $e5be200c675c3b3a$export$aca958c65c314e6c = {
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valueMissing: false,
  valid: true
};
var $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE = {
  ...$e5be200c675c3b3a$export$aca958c65c314e6c,
  customError: true,
  valid: false
};
var $e5be200c675c3b3a$export$dad6ae84456c676a = {
  isInvalid: false,
  validationDetails: $e5be200c675c3b3a$export$aca958c65c314e6c,
  validationErrors: []
};
var $e5be200c675c3b3a$export$571b5131b7e65c11 = (0, import_react23.createContext)({});
var $e5be200c675c3b3a$export$a763b9476acd3eb = "__formValidationState" + Date.now();
function $e5be200c675c3b3a$export$fc1a364ae1f3ff10(props) {
  if (props[$e5be200c675c3b3a$export$a763b9476acd3eb]) {
    let { realtimeValidation, displayValidation, updateValidation, resetValidation, commitValidation } = props[$e5be200c675c3b3a$export$a763b9476acd3eb];
    return {
      realtimeValidation,
      displayValidation,
      updateValidation,
      resetValidation,
      commitValidation
    };
  }
  return $e5be200c675c3b3a$var$useFormValidationStateImpl(props);
}
function $e5be200c675c3b3a$var$useFormValidationStateImpl(props) {
  let { isInvalid, validationState, name: name2, value: value2, builtinValidation, validate: validate3, validationBehavior = "aria" } = props;
  if (validationState)
    isInvalid || (isInvalid = validationState === "invalid");
  let controlledError = isInvalid ? {
    isInvalid: true,
    validationErrors: [],
    validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE
  } : null;
  let clientError = (0, import_react23.useMemo)(() => $e5be200c675c3b3a$var$getValidationResult($e5be200c675c3b3a$var$runValidate(validate3, value2)), [
    validate3,
    value2
  ]);
  if (builtinValidation === null || builtinValidation === void 0 ? void 0 : builtinValidation.validationDetails.valid)
    builtinValidation = null;
  let serverErrors = (0, import_react23.useContext)($e5be200c675c3b3a$export$571b5131b7e65c11);
  let serverErrorMessages = (0, import_react23.useMemo)(() => {
    if (name2)
      return Array.isArray(name2) ? name2.flatMap((name3) => $e5be200c675c3b3a$var$asArray(serverErrors[name3])) : $e5be200c675c3b3a$var$asArray(serverErrors[name2]);
    return [];
  }, [
    serverErrors,
    name2
  ]);
  let [lastServerErrors, setLastServerErrors] = (0, import_react23.useState)(serverErrors);
  let [isServerErrorCleared, setServerErrorCleared] = (0, import_react23.useState)(false);
  if (serverErrors !== lastServerErrors) {
    setLastServerErrors(serverErrors);
    setServerErrorCleared(false);
  }
  let serverError = (0, import_react23.useMemo)(() => $e5be200c675c3b3a$var$getValidationResult(isServerErrorCleared ? [] : serverErrorMessages), [
    isServerErrorCleared,
    serverErrorMessages
  ]);
  let nextValidation = (0, import_react23.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let [currentValidity, setCurrentValidity] = (0, import_react23.useState)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let lastError = (0, import_react23.useRef)($e5be200c675c3b3a$export$dad6ae84456c676a);
  let commitValidation = () => {
    if (!commitQueued)
      return;
    setCommitQueued(false);
    let error3 = clientError || builtinValidation || nextValidation.current;
    if (!$e5be200c675c3b3a$var$isEqualValidation(error3, lastError.current)) {
      lastError.current = error3;
      setCurrentValidity(error3);
    }
  };
  let [commitQueued, setCommitQueued] = (0, import_react23.useState)(false);
  (0, import_react23.useEffect)(commitValidation);
  let realtimeValidation = controlledError || serverError || clientError || builtinValidation || $e5be200c675c3b3a$export$dad6ae84456c676a;
  let displayValidation = validationBehavior === "native" ? controlledError || serverError || currentValidity : controlledError || serverError || clientError || builtinValidation || currentValidity;
  return {
    realtimeValidation,
    displayValidation,
    updateValidation(value3) {
      if (validationBehavior === "aria" && !$e5be200c675c3b3a$var$isEqualValidation(currentValidity, value3))
        setCurrentValidity(value3);
      else
        nextValidation.current = value3;
    },
    resetValidation() {
      let error3 = $e5be200c675c3b3a$export$dad6ae84456c676a;
      if (!$e5be200c675c3b3a$var$isEqualValidation(error3, lastError.current)) {
        lastError.current = error3;
        setCurrentValidity(error3);
      }
      if (validationBehavior === "native")
        setCommitQueued(false);
      setServerErrorCleared(true);
    },
    commitValidation() {
      if (validationBehavior === "native")
        setCommitQueued(true);
      setServerErrorCleared(true);
    }
  };
}
function $e5be200c675c3b3a$var$asArray(v5) {
  if (!v5)
    return [];
  return Array.isArray(v5) ? v5 : [
    v5
  ];
}
function $e5be200c675c3b3a$var$runValidate(validate3, value2) {
  if (typeof validate3 === "function") {
    let e6 = validate3(value2);
    if (e6 && typeof e6 !== "boolean")
      return $e5be200c675c3b3a$var$asArray(e6);
  }
  return [];
}
function $e5be200c675c3b3a$var$getValidationResult(errors) {
  return errors.length ? {
    isInvalid: true,
    validationErrors: errors,
    validationDetails: $e5be200c675c3b3a$var$CUSTOM_VALIDITY_STATE
  } : null;
}
function $e5be200c675c3b3a$var$isEqualValidation(a3, b2) {
  if (a3 === b2)
    return true;
  return a3 && b2 && a3.isInvalid === b2.isInvalid && a3.validationErrors.length === b2.validationErrors.length && a3.validationErrors.every((a4, i6) => a4 === b2.validationErrors[i6]) && Object.entries(a3.validationDetails).every(([k2, v5]) => b2.validationDetails[k2] === v5);
}
function $e5be200c675c3b3a$export$75ee7c75d68f5b0e(...results) {
  let errors = /* @__PURE__ */ new Set();
  let isInvalid = false;
  let validationDetails = {
    ...$e5be200c675c3b3a$export$aca958c65c314e6c
  };
  for (let v5 of results) {
    var _validationDetails, _key;
    for (let e6 of v5.validationErrors)
      errors.add(e6);
    isInvalid || (isInvalid = v5.isInvalid);
    for (let key in validationDetails)
      (_validationDetails = validationDetails)[_key = key] || (_validationDetails[_key] = v5.validationDetails[key]);
  }
  validationDetails.valid = !isInvalid;
  return {
    isInvalid,
    validationErrors: [
      ...errors
    ],
    validationDetails
  };
}

// node_modules/.pnpm/@react-aria+textfield@3.13.0_react@18.2.0/node_modules/@react-aria/textfield/dist/import.mjs
function $2d73ec29415bd339$export$712718f7aec83d5(props, ref) {
  let { inputElementType = "input", isDisabled = false, isRequired = false, isReadOnly = false, type: type2 = "text", validationBehavior = "aria" } = props;
  let [value2, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, props.defaultValue || "", props.onChange);
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: value2
  });
  let { isInvalid, validationErrors, validationDetails } = validationState.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  const inputOnlyProps = {
    type: type2,
    pattern: props.pattern
  };
  (0, $99facab73266f662$export$5add1d006293d136)(ref, value2, setValue);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)(props, validationState, ref);
  (0, import_react24.useEffect)(() => {
    if (ref.current instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(ref.current).HTMLTextAreaElement) {
      let input = ref.current;
      Object.defineProperty(input, "defaultValue", {
        get: () => input.value,
        set: () => {
        },
        configurable: true
      });
    }
  }, [
    ref
  ]);
  return {
    labelProps,
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, inputElementType === "input" && inputOnlyProps, {
      disabled: isDisabled,
      readOnly: isReadOnly,
      required: isRequired && validationBehavior === "native",
      "aria-required": isRequired && validationBehavior === "aria" || void 0,
      "aria-invalid": isInvalid || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-activedescendant": props["aria-activedescendant"],
      "aria-autocomplete": props["aria-autocomplete"],
      "aria-haspopup": props["aria-haspopup"],
      value: value2,
      onChange: (e6) => setValue(e6.target.value),
      autoComplete: props.autoComplete,
      maxLength: props.maxLength,
      minLength: props.minLength,
      name: props.name,
      placeholder: props.placeholder,
      inputMode: props.inputMode,
      // Clipboard events
      onCopy: props.onCopy,
      onCut: props.onCut,
      onPaste: props.onPaste,
      // Composition events
      onCompositionEnd: props.onCompositionEnd,
      onCompositionStart: props.onCompositionStart,
      onCompositionUpdate: props.onCompositionUpdate,
      // Selection events
      onSelect: props.onSelect,
      // Input events
      onBeforeInput: props.onBeforeInput,
      onInput: props.onInput,
      ...focusableProps,
      ...fieldProps
    }),
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}
function $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {
  return typeof window !== "undefined" && window.InputEvent && // @ts-ignore
  typeof InputEvent.prototype.getTargetRanges === "function";
}
function $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {
  let onBeforeInputFallback = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    let input = inputRef.current;
    let nextValue;
    switch (e6.inputType) {
      case "historyUndo":
      case "historyRedo":
        return;
      case "deleteContent":
      case "deleteByCut":
      case "deleteByDrag":
        nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteContentForward":
        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteContentBackward":
        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
        break;
      case "deleteSoftLineBackward":
      case "deleteHardLineBackward":
        nextValue = input.value.slice(input.selectionStart);
        break;
      default:
        if (e6.data != null)
          nextValue = input.value.slice(0, input.selectionStart) + e6.data + input.value.slice(input.selectionEnd);
        break;
    }
    if (nextValue == null || !state.validate(nextValue))
      e6.preventDefault();
  });
  (0, import_react24.useEffect)(() => {
    if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent())
      return;
    let input = inputRef.current;
    input.addEventListener("beforeinput", onBeforeInputFallback, false);
    return () => {
      input.removeEventListener("beforeinput", onBeforeInputFallback, false);
    };
  }, [
    inputRef,
    onBeforeInputFallback
  ]);
  let onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? (e6) => {
    let nextValue = e6.target.value.slice(0, e6.target.selectionStart) + e6.data + e6.target.value.slice(e6.target.selectionEnd);
    if (!state.validate(nextValue))
      e6.preventDefault();
  } : null;
  let { labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps, ...validation } = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef);
  let compositionStartState = (0, import_react24.useRef)(null);
  return {
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(textFieldProps, {
      onBeforeInput,
      onCompositionStart() {
        let { value: value2, selectionStart, selectionEnd } = inputRef.current;
        compositionStartState.current = {
          value: value2,
          selectionStart,
          selectionEnd
        };
      },
      onCompositionEnd() {
        if (!state.validate(inputRef.current.value)) {
          let { value: value2, selectionStart, selectionEnd } = compositionStartState.current;
          inputRef.current.value = value2;
          inputRef.current.setSelectionRange(selectionStart, selectionEnd);
          state.setInputValue(value2);
        }
      }
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    ...validation
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/text-field/dist/keystar-ui-text-field.esm.js
var TextFieldPrimitive = (0, import_react25.forwardRef)(function TextFieldPrimitive2(props, forwardedRef) {
  const {
    autoFocus,
    description,
    descriptionProps,
    endElement,
    errorMessage,
    errorMessageProps,
    id,
    inputProps,
    inputWrapperProps,
    isDisabled,
    isMultiline = false,
    isRequired,
    label,
    labelProps,
    startElement,
    ...otherProps
  } = props;
  const InputElement = isMultiline ? "textarea" : "input";
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let inputClassName = useTextFieldStyles();
  let inputRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let onIndicatorPressStart = () => {
    if (document.activeElement === inputRef.current) {
      return;
    }
    inputRef.current.focus();
  };
  let {
    pressProps
  } = $f6c31cce2adf654f$export$45712eceda6fad21({
    isDisabled,
    onPressStart: onIndicatorPressStart,
    preventFocusOnPress: true
  });
  return (0, import_jsx_runtime12.jsx)(FieldPrimitive, {
    isRequired,
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    label,
    labelProps,
    ...otherProps,
    children: (0, import_jsx_runtime12.jsxs)("div", {
      ...inputWrapperProps,
      ...hoverProps,
      className: classNames(css({
        display: "flex",
        flex: "1 1 auto",
        position: "relative",
        zIndex: 0
      }), inputWrapperProps === null || inputWrapperProps === void 0 ? void 0 : inputWrapperProps.className),
      children: [startElement, (0, import_jsx_runtime12.jsx)(FocusRing, {
        autoFocus,
        isTextInput: true,
        children: (0, import_jsx_runtime12.jsx)(InputElement, {
          ...inputProps,
          ...toDataAttributes({
            adornment: getAdornmentType(props),
            hovered: isHovered || void 0,
            multiline: isMultiline || void 0
          }),
          className: classNames(inputClassName, inputProps === null || inputProps === void 0 ? void 0 : inputProps.className),
          "data-adornment": getAdornmentType(props),
          ref: inputRef,
          rows: isMultiline ? 1 : void 0
        })
      }), (0, import_jsx_runtime12.jsx)(InputStateIndicator, {
        inputClassName,
        ...pressProps
      }), endElement]
    })
  });
});
function makeSiblingSelector(base) {
  return function siblingSelector(...selectors) {
    return selectors.map((s4) => `.${base}${s4} + &`).join(", ");
  };
}
var InputStateIndicator = ({
  inputClassName,
  ...props
}) => {
  const s4 = makeSiblingSelector(inputClassName);
  return (0, import_jsx_runtime12.jsx)("div", {
    role: "presentation",
    ...props,
    className: css({
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
      borderRadius: tokenSchema.size.radius.regular,
      cursor: "text",
      inset: 0,
      position: "absolute",
      transition: transition(["border-color", "box-shadow"]),
      zIndex: -1,
      [s4("[data-hovered]")]: {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      [s4(":invalid", "[aria-invalid]")]: {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [s4(":focus")]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [s4(":focus:not([readonly])")]: {
        boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
      },
      [s4(":disabled", "[aria-disabled]")]: {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        borderColor: "transparent",
        cursor: "auto"
      }
    })
  });
};
function useTextFieldStyles() {
  return css({
    color: tokenSchema.color.foreground.neutral,
    flex: 1,
    fontFamily: tokenSchema.typography.fontFamily.base,
    fontSize: tokenSchema.typography.text.regular.size,
    fontWeight: tokenSchema.typography.fontWeight.regular,
    height: tokenSchema.size.element.regular,
    lineHeight: tokenSchema.typography.lineheight.small,
    outline: 0,
    overflow: "visible",
    paddingBlock: tokenSchema.size.space.small,
    paddingInline: tokenSchema.size.space.medium,
    position: "relative",
    textIndent: 0,
    textOverflow: "ellipsis",
    verticalAlign: "top",
    width: "100%",
    MozOsxFontSmoothing: "auto",
    WebkitFontSmoothing: "auto",
    "::placeholder": {
      color: tokenSchema.color.foreground.neutralTertiary
    },
    "&:disabled, &[aria-disabled]": {
      color: tokenSchema.color.alias.foregroundDisabled,
      "::placeholder": {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    },
    /* Remove the inner padding and cancel buttons for input[type="search"] in Chrome and Safari on macOS. */
    "&::-webkit-search-cancel-button, &::-webkit-search-decoration": {
      WebkitAppearance: "none"
    },
    // TEXTAREA
    // ------------------------------
    "&[data-multiline]": {
      height: "auto",
      lineHeight: tokenSchema.typography.lineheight.medium,
      minHeight: tokenSchema.size.scale["700"],
      overflow: "auto",
      paddingBlock: tokenSchema.size.space.regular,
      resize: "none"
    }
  });
}
function getAdornmentType(props) {
  if (props.startElement && props.endElement) {
    return "both";
  } else if (props.startElement) {
    return "start";
  } else if (props.endElement) {
    return "end";
  }
  return "none";
}
function validateTextFieldProps(props) {
  warning(!props.placeholder || !!props.description, "Placeholder text is not accessible. Use the `description` prop to provide information that will aid user input.");
  return validateFieldProps(props);
}
var TextField = (0, import_react25.forwardRef)(function TextField2(props, forwardedRef) {
  props = validateTextFieldProps(props);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  } = $2d73ec29415bd339$export$712718f7aec83d5(props, domRef);
  return (0, import_jsx_runtime12.jsx)(TextFieldPrimitive, {
    ref: domRef,
    ...props,
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  });
});
var TextArea = (0, import_react25.forwardRef)(function TextArea2({
  onChange,
  ...props
}, forwardedRef) {
  props = validateTextFieldProps(props);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let [inputValue, setInputValue] = $458b0a5536c1a7cf$export$40bfa8c7b0832715(props.value, props.defaultValue, () => {
  });
  let onHeightChange = (0, import_react25.useCallback)(() => {
    let input = domRef.current;
    if (!props.height && input) {
      let prevOverflow = input.style.overflow;
      let isFirefox = "MozAppearance" in input.style;
      if (!isFirefox) {
        input.style.overflow = "hidden";
      }
      input.style.height = "auto";
      input.style.height = `${input.scrollHeight + (input.offsetHeight - input.clientHeight)}px`;
      input.style.overflow = prevOverflow;
    }
  }, [domRef, props.height]);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (domRef.current) {
      onHeightChange();
    }
  }, [onHeightChange, inputValue, domRef]);
  let {
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps
  } = $2d73ec29415bd339$export$712718f7aec83d5({
    ...props,
    onChange: $ff5963eb1fccf552$export$e08e3b67e392101e(onChange, setInputValue),
    inputElementType: "textarea"
  }, domRef);
  return (0, import_jsx_runtime12.jsx)(TextFieldPrimitive, {
    ...props,
    ref: domRef,
    labelProps,
    inputProps,
    descriptionProps,
    errorMessageProps,
    isMultiline: true
  });
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/status-light/dist/keystar-ui-status-light.esm.js
var import_react26 = __toESM(require_react());
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var StatusLight = (0, import_react26.forwardRef)(function StatusLight2(props, forwardedRef) {
  let {
    children,
    role,
    tone = "neutral"
  } = props;
  const styleProps = useStyleProps(props);
  if (!children && !props["aria-label"]) {
    console.warn("If no children are provided, an aria-label must be specified");
  }
  if (!role && (props["aria-label"] || props["aria-labelledby"])) {
    console.warn("A labelled StatusLight must have a role.");
  }
  return (0, import_jsx_runtime13.jsx)("div", {
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    }),
    ...styleProps,
    ref: forwardedRef,
    "data-tone": tone,
    className: classNames(css({
      alignItems: "center",
      color: tokenSchema.color.foreground.neutral,
      display: "flex",
      gap: tokenSchema.size.space.regular,
      height: tokenSchema.size.element.small,
      // indicator
      "&::before": {
        content: '""',
        backgroundColor: tokenSchema.color.foreground.neutralTertiary,
        borderRadius: tokenSchema.size.radius.full,
        height: tokenSchema.size.scale[100],
        width: tokenSchema.size.scale[100]
      },
      // special case for neutral
      "&[data-tone=neutral]": {
        color: tokenSchema.color.foreground.neutralSecondary
      },
      "&[data-tone=accent]::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis
      },
      "&[data-tone=caution]::before": {
        backgroundColor: tokenSchema.color.background.cautionEmphasis
      },
      "&[data-tone=critical]::before": {
        backgroundColor: tokenSchema.color.background.criticalEmphasis
      },
      "&[data-tone=pending]::before": {
        backgroundColor: tokenSchema.color.background.pendingEmphasis
      },
      "&[data-tone=positive]::before": {
        backgroundColor: tokenSchema.color.background.positiveEmphasis
      }
    }), styleProps.className),
    children: isReactText(children) ? (0, import_jsx_runtime13.jsx)(Text, {
      color: "inherit",
      children
    }) : children
  });
});

// node_modules/.pnpm/@react-stately+collections@3.10.3_react@18.2.0/node_modules/@react-stately/collections/dist/import.mjs
var import_react27 = __toESM(require_react(), 1);
function $c1d7fb2ec91bae71$var$Item(props) {
  return null;
}
$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
  let { childItems, title, children } = props;
  let rendered = props.title || props.children;
  let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"] || "";
  if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning))
    console.warn("<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.");
  yield {
    type: "item",
    props,
    rendered,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),
    *childNodes() {
      if (childItems)
        for (let child of childItems)
          yield {
            type: "item",
            value: child
          };
      else if (title) {
        let items = [];
        (0, import_react27.default).Children.forEach(children, (child) => {
          items.push({
            type: "item",
            element: child
          });
        });
        yield* items;
      }
    }
  };
};
function $c1d7fb2ec91bae71$var$hasChildItems(props) {
  if (props.hasChildItems != null)
    return props.hasChildItems;
  if (props.childItems)
    return true;
  if (props.title && (0, import_react27.default).Children.count(props.children) > 0)
    return true;
  return false;
}
var $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;
function $9fc4852771d079eb$var$Section(props) {
  return null;
}
$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode2(props) {
  let { children, title, items } = props;
  yield {
    type: "section",
    props,
    hasChildNodes: true,
    rendered: title,
    "aria-label": props["aria-label"],
    *childNodes() {
      if (typeof children === "function") {
        if (!items)
          throw new Error("props.children was a function but props.items is missing");
        for (let item2 of items)
          yield {
            type: "item",
            value: item2,
            renderer: children
          };
      } else {
        let items2 = [];
        (0, import_react27.default).Children.forEach(children, (child) => {
          items2.push({
            type: "item",
            element: child
          });
        });
        yield* items2;
      }
    }
  };
};
var $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;
var $eb2240fc39a57fa5$export$bf788dd355e3a401 = class {
  build(props, context) {
    this.context = context;
    return $eb2240fc39a57fa5$var$iterable(() => this.iterateCollection(props));
  }
  *iterateCollection(props) {
    let { children, items } = props;
    if (typeof children === "function") {
      if (!items)
        throw new Error("props.children was a function but props.items is missing");
      for (let item2 of props.items)
        yield* this.getFullNode({
          value: item2
        }, {
          renderer: children
        });
    } else {
      let items2 = [];
      (0, import_react27.default).Children.forEach(children, (child) => {
        items2.push(child);
      });
      let index2 = 0;
      for (let item2 of items2) {
        let nodes = this.getFullNode({
          element: item2,
          index: index2
        }, {});
        for (let node3 of nodes) {
          index2++;
          yield node3;
        }
      }
    }
  }
  getKey(item2, partialNode, state, parentKey) {
    if (item2.key != null)
      return item2.key;
    if (partialNode.type === "cell" && partialNode.key != null)
      return `${parentKey}${partialNode.key}`;
    let v5 = partialNode.value;
    if (v5 != null) {
      var _v_key;
      let key = (_v_key = v5.key) !== null && _v_key !== void 0 ? _v_key : v5.id;
      if (key == null)
        throw new Error("No key found for item");
      return key;
    }
    return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;
  }
  getChildState(state, partialNode) {
    return {
      renderer: partialNode.renderer || state.renderer
    };
  }
  *getFullNode(partialNode, state, parentKey, parentNode) {
    let element2 = partialNode.element;
    if (!element2 && partialNode.value && state && state.renderer) {
      let cached = this.cache.get(partialNode.value);
      if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
        cached.index = partialNode.index;
        cached.parentKey = parentNode ? parentNode.key : null;
        yield cached;
        return;
      }
      element2 = state.renderer(partialNode.value);
    }
    if ((0, import_react27.default).isValidElement(element2)) {
      let type2 = element2.type;
      if (typeof type2 !== "function" && typeof type2.getCollectionNode !== "function") {
        let name2 = typeof element2.type === "function" ? element2.type.name : element2.type;
        throw new Error(`Unknown element <${name2}> in collection.`);
      }
      let childNodes = type2.getCollectionNode(element2.props, this.context);
      let index2 = partialNode.index;
      let result = childNodes.next();
      while (!result.done && result.value) {
        let childNode = result.value;
        partialNode.index = index2;
        let nodeKey = childNode.key;
        if (!nodeKey)
          nodeKey = childNode.element ? null : this.getKey(element2, partialNode, state, parentKey);
        let nodes = this.getFullNode({
          ...childNode,
          key: nodeKey,
          index: index2,
          wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)
        }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element2.key}` : element2.key, parentNode);
        let children = [
          ...nodes
        ];
        for (let node4 of children) {
          node4.value = childNode.value || partialNode.value;
          if (node4.value)
            this.cache.set(node4.value, node4);
          if (partialNode.type && node4.type !== partialNode.type)
            throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node4.type)}> in <${$eb2240fc39a57fa5$var$capitalize(parentNode.type)}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);
          index2++;
          yield node4;
        }
        result = childNodes.next(children);
      }
      return;
    }
    if (partialNode.key == null)
      return;
    let builder = this;
    let node3 = {
      type: partialNode.type,
      props: partialNode.props,
      key: partialNode.key,
      parentKey: parentNode ? parentNode.key : null,
      value: partialNode.value,
      level: parentNode ? parentNode.level + 1 : 0,
      index: partialNode.index,
      rendered: partialNode.rendered,
      textValue: partialNode.textValue,
      "aria-label": partialNode["aria-label"],
      wrapper: partialNode.wrapper,
      shouldInvalidate: partialNode.shouldInvalidate,
      hasChildNodes: partialNode.hasChildNodes,
      childNodes: $eb2240fc39a57fa5$var$iterable(function* () {
        if (!partialNode.hasChildNodes)
          return;
        let index2 = 0;
        for (let child of partialNode.childNodes()) {
          if (child.key != null)
            child.key = `${node3.key}${child.key}`;
          child.index = index2;
          let nodes = builder.getFullNode(child, builder.getChildState(state, child), node3.key, node3);
          for (let node4 of nodes) {
            index2++;
            yield node4;
          }
        }
      })
    };
    yield node3;
  }
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};
function $eb2240fc39a57fa5$var$iterable(iterator) {
  let cache3 = [];
  let iterable = null;
  return {
    *[Symbol.iterator]() {
      for (let item2 of cache3)
        yield item2;
      if (!iterable)
        iterable = iterator();
      for (let item2 of iterable) {
        cache3.push(item2);
        yield item2;
      }
    }
  };
}
function $eb2240fc39a57fa5$var$compose(outer, inner) {
  if (outer && inner)
    return (element2) => outer(inner(element2));
  if (outer)
    return outer;
  if (inner)
    return inner;
}
function $eb2240fc39a57fa5$var$capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
function $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {
  let builder = (0, import_react27.useMemo)(() => new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);
  let { children, items, collection: collection2 } = props;
  let result = (0, import_react27.useMemo)(() => {
    if (collection2)
      return collection2;
    let nodes = builder.build({
      children,
      items
    }, context);
    return factory(nodes);
  }, [
    builder,
    children,
    items,
    collection2,
    context,
    factory
  ]);
  return result;
}
function $c5a24bc478652b5f$export$1005530eda016c13(node3, collection2) {
  if (typeof collection2.getChildren === "function")
    return collection2.getChildren(node3.key);
  return node3.childNodes;
}
function $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {
  return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);
}
function $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index2) {
  if (index2 < 0)
    return void 0;
  let i6 = 0;
  for (let item2 of iterable) {
    if (i6 === index2)
      return item2;
    i6++;
  }
}
function $c5a24bc478652b5f$export$7475b2c64539e4cf(iterable) {
  let lastItem = void 0;
  for (let value2 of iterable)
    lastItem = value2;
  return lastItem;
}
function $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection2, a3, b2) {
  if (a3.parentKey === b2.parentKey)
    return a3.index - b2.index;
  let aAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection2, a3),
    a3
  ];
  let bAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection2, b2),
    b2
  ];
  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a4, i6) => a4 !== bAncestors[i6]);
  if (firstNonMatchingAncestor !== -1) {
    a3 = aAncestors[firstNonMatchingAncestor];
    b2 = bAncestors[firstNonMatchingAncestor];
    return a3.index - b2.index;
  }
  if (aAncestors.findIndex((node3) => node3 === b2) >= 0)
    return 1;
  else if (bAncestors.findIndex((node3) => node3 === a3) >= 0)
    return -1;
  return -1;
}
function $c5a24bc478652b5f$var$getAncestors(collection2, node3) {
  let parents = [];
  while ((node3 === null || node3 === void 0 ? void 0 : node3.parentKey) != null) {
    node3 = collection2.getItem(node3.parentKey);
    parents.unshift(node3);
  }
  return parents;
}
var $453cc9f0df89c0a5$var$cache = /* @__PURE__ */ new WeakMap();
function $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection2) {
  let count = $453cc9f0df89c0a5$var$cache.get(collection2);
  if (count != null)
    return count;
  count = 0;
  let countItems = (items) => {
    for (let item2 of items)
      if (item2.type === "section")
        countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, collection2));
      else
        count++;
  };
  countItems(collection2);
  $453cc9f0df89c0a5$var$cache.set(collection2, count);
  return count;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/minusIcon/dist/keystar-ui-icon-icons-minusIcon.esm.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var minusIcon = (0, import_jsx_runtime14.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime14.jsx)("path", {
    d: "M5 12h14"
  })
});

// node_modules/.pnpm/@react-aria+checkbox@3.12.0_react@18.2.0/node_modules/@react-aria/checkbox/dist/import.mjs
var import_react28 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+toggle@3.9.0_react@18.2.0/node_modules/@react-aria/toggle/dist/import.mjs
function $d2c8e2b0480f3f34$export$cbe85ee05b554577(props, state, ref) {
  let { isDisabled = false, isReadOnly = false, value: value2, name: name2, children, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, validationState = "valid", isInvalid } = props;
  let onChange = (e6) => {
    e6.stopPropagation();
    state.setSelected(e6.target.checked);
  };
  let hasChildren = children != null;
  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;
  if (!hasChildren && !hasAriaLabel)
    console.warn("If you do not provide children, you must specify an aria-label for accessibility");
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, focusableProps);
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  (0, $99facab73266f662$export$5add1d006293d136)(ref, state.isSelected, state.setSelected);
  return {
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      "aria-invalid": isInvalid || validationState === "invalid" || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-controls": props["aria-controls"],
      "aria-readonly": isReadOnly || void 0,
      onChange,
      disabled: isDisabled,
      ...value2 == null ? {} : {
        value: value2
      },
      name: name2,
      type: "checkbox",
      ...interactions
    }),
    isSelected: state.isSelected,
    isPressed,
    isDisabled,
    isReadOnly,
    isInvalid: isInvalid || validationState === "invalid"
  };
}

// node_modules/.pnpm/@react-aria+checkbox@3.12.0_react@18.2.0/node_modules/@react-aria/checkbox/dist/import.mjs
function $406796ff087fe49b$export$e375f10ce42261c5(props, state, inputRef) {
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: state.isSelected
  });
  let { isInvalid, validationErrors, validationDetails } = validationState.displayValidation;
  let { inputProps, isSelected, isPressed, isDisabled, isReadOnly } = (0, $d2c8e2b0480f3f34$export$cbe85ee05b554577)({
    ...props,
    isInvalid
  }, state, inputRef);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)(props, validationState, inputRef);
  let { isIndeterminate, isRequired, validationBehavior = "aria" } = props;
  (0, import_react28.useEffect)(() => {
    if (inputRef.current)
      inputRef.current.indeterminate = isIndeterminate;
  });
  return {
    inputProps: {
      ...inputProps,
      checked: isSelected,
      "aria-required": isRequired && validationBehavior === "aria" || void 0,
      required: isRequired && validationBehavior === "native"
    },
    isSelected,
    isPressed,
    isDisabled,
    isReadOnly,
    isInvalid,
    validationErrors,
    validationDetails
  };
}
var $1ae600c947479353$export$ec98120685d4f57d = /* @__PURE__ */ new WeakMap();
function $1e9fce0cfacc738b$export$49ff6f28c54f1cbe(props, state) {
  let { isDisabled, name: name2, validationBehavior = "aria" } = props;
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    // Checkbox group is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span",
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  (0, $1ae600c947479353$export$ec98120685d4f57d).set(state, {
    name: name2,
    descriptionId: descriptionProps.id,
    errorMessageId: errorMessageProps.id,
    validationBehavior
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  return {
    groupProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      role: "group",
      "aria-disabled": isDisabled || void 0,
      ...fieldProps
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}
function $fba3e38d5ca8983f$export$353b32fc6898d37d(props, state, inputRef) {
  const toggleState = (0, $3017fa7ffdddec74$export$8042c6c013fd5226)({
    isReadOnly: props.isReadOnly || state.isReadOnly,
    isSelected: state.isSelected(props.value),
    onChange(isSelected) {
      if (isSelected)
        state.addValue(props.value);
      else
        state.removeValue(props.value);
      if (props.onChange)
        props.onChange(isSelected);
    }
  });
  let { name: name2, descriptionId, errorMessageId, validationBehavior } = (0, $1ae600c947479353$export$ec98120685d4f57d).get(state);
  var _props_validationBehavior;
  validationBehavior = (_props_validationBehavior = props.validationBehavior) !== null && _props_validationBehavior !== void 0 ? _props_validationBehavior : validationBehavior;
  let { realtimeValidation } = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: toggleState.isSelected,
    // Server validation is handled at the group level.
    name: void 0,
    validationBehavior: "aria"
  });
  let nativeValidation = (0, import_react28.useRef)((0, $e5be200c675c3b3a$export$dad6ae84456c676a));
  let updateValidation = () => {
    state.setInvalid(props.value, realtimeValidation.isInvalid ? realtimeValidation : nativeValidation.current);
  };
  (0, import_react28.useEffect)(updateValidation);
  let combinedRealtimeValidation = state.realtimeValidation.isInvalid ? state.realtimeValidation : realtimeValidation;
  let displayValidation = validationBehavior === "native" ? state.displayValidation : combinedRealtimeValidation;
  var _props_isRequired;
  let res = (0, $406796ff087fe49b$export$e375f10ce42261c5)({
    ...props,
    isReadOnly: props.isReadOnly || state.isReadOnly,
    isDisabled: props.isDisabled || state.isDisabled,
    name: props.name || name2,
    isRequired: (_props_isRequired = props.isRequired) !== null && _props_isRequired !== void 0 ? _props_isRequired : state.isRequired,
    validationBehavior,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: {
      realtimeValidation: combinedRealtimeValidation,
      displayValidation,
      resetValidation: state.resetValidation,
      commitValidation: state.commitValidation,
      updateValidation(v5) {
        nativeValidation.current = v5;
        updateValidation();
      }
    }
  }, toggleState, inputRef);
  return {
    ...res,
    inputProps: {
      ...res.inputProps,
      "aria-describedby": [
        props["aria-describedby"],
        state.isInvalid ? errorMessageId : null,
        descriptionId
      ].filter(Boolean).join(" ") || void 0
    }
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/checkbox/dist/keystar-ui-checkbox.esm.js
var import_react30 = __toESM(require_react());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/checkIcon/dist/keystar-ui-icon-icons-checkIcon.esm.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var checkIcon = (0, import_jsx_runtime15.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime15.jsx)("path", {
    d: "M20 6 9 17l-5-5"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/checkbox/dist/keystar-ui-checkbox.esm.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-stately+checkbox@3.6.0_react@18.2.0/node_modules/@react-stately/checkbox/dist/import.mjs
var import_react29 = __toESM(require_react(), 1);
function $587d3ad58be6d31f$export$daff6da51032a415(props = {}) {
  let [selectedValues, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, props.defaultValue || [], props.onChange);
  let isRequired = props.isRequired && selectedValues.length === 0;
  let invalidValues = (0, import_react29.useRef)(/* @__PURE__ */ new Map());
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: selectedValues
  });
  let isInvalid = validation.displayValidation.isInvalid;
  var _props_validationState;
  const state = {
    ...validation,
    value: selectedValues,
    setValue(value2) {
      if (props.isReadOnly || props.isDisabled)
        return;
      setValue(value2);
    },
    isDisabled: props.isDisabled || false,
    isReadOnly: props.isReadOnly || false,
    isSelected(value2) {
      return selectedValues.includes(value2);
    },
    addValue(value2) {
      if (props.isReadOnly || props.isDisabled)
        return;
      if (!selectedValues.includes(value2))
        setValue(selectedValues.concat(value2));
    },
    removeValue(value2) {
      if (props.isReadOnly || props.isDisabled)
        return;
      if (selectedValues.includes(value2))
        setValue(selectedValues.filter((existingValue) => existingValue !== value2));
    },
    toggleValue(value2) {
      if (props.isReadOnly || props.isDisabled)
        return;
      if (selectedValues.includes(value2))
        setValue(selectedValues.filter((existingValue) => existingValue !== value2));
      else
        setValue(selectedValues.concat(value2));
    },
    setInvalid(value2, v5) {
      let s4 = new Map(invalidValues.current);
      if (v5.isInvalid)
        s4.set(value2, v5);
      else
        s4.delete(value2);
      invalidValues.current = s4;
      validation.updateValidation((0, $e5be200c675c3b3a$export$75ee7c75d68f5b0e)(...s4.values()));
    },
    validationState: (_props_validationState = props.validationState) !== null && _props_validationState !== void 0 ? _props_validationState : isInvalid ? "invalid" : null,
    isInvalid,
    isRequired
  };
  return state;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/checkbox/dist/keystar-ui-checkbox.esm.js
var CheckboxGroupContext = import_react30.default.createContext(null);
var checkboxClassList = new ClassList("Checkbox", ["indicator"]);
function Checkbox(props) {
  let {
    isIndeterminate = false,
    isDisabled = false,
    autoFocus,
    children,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let inputRef = (0, import_react30.useRef)(null);
  let groupState = (0, import_react30.useContext)(CheckboxGroupContext);
  let {
    inputProps
  } = groupState ? (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    $fba3e38d5ca8983f$export$353b32fc6898d37d({
      ...props,
      // Value is optional for standalone checkboxes, but required for
      // CheckboxGroup items; it's passed explicitly here to avoid
      // typescript error (requires ignore).
      // @ts-ignore
      value: props.value
    }, groupState.state, inputRef)
  ) : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    $406796ff087fe49b$export$e375f10ce42261c5(props, $3017fa7ffdddec74$export$8042c6c013fd5226(props), inputRef)
  );
  const labelClassName = css({
    alignItems: "flex-start",
    display: "inline-flex",
    gap: tokenSchema.size.space.regular,
    position: "relative",
    userSelect: "none"
  });
  const slots = (0, import_react30.useMemo)(() => ({
    text: {
      color: "inherit"
    },
    description: {
      color: "neutralTertiary"
    }
  }), []);
  return (0, import_jsx_runtime16.jsxs)("label", {
    "data-disabled": isDisabled,
    className: classNames(styleProps.className, labelClassName),
    style: styleProps.style,
    children: [(0, import_jsx_runtime16.jsx)(FocusRing, {
      autoFocus,
      children: (0, import_jsx_runtime16.jsx)("input", {
        ...inputProps,
        ref: inputRef,
        className: classNames(css({
          position: "absolute",
          zIndex: 1,
          inset: 0,
          opacity: 1e-4
        }))
      })
    }), (0, import_jsx_runtime16.jsx)(Indicator, {
      isIndeterminate
    }), (0, import_jsx_runtime16.jsx)(SlotProvider, {
      slots,
      children: children && (0, import_jsx_runtime16.jsx)(Content2, {
        children: isReactText(children) ? (0, import_jsx_runtime16.jsx)(Text, {
          children
        }) : children
      })
    })]
  });
}
var sizeToken = tokenSchema.size.element.xsmall;
var Indicator = (props) => {
  let {
    isIndeterminate
  } = props;
  return (0, import_jsx_runtime16.jsx)("span", {
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      borderRadius: tokenSchema.size.radius.small,
      color: tokenSchema.color.foreground.onEmphasis,
      display: "flex",
      flexShrink: 0,
      justifyContent: "center",
      alignItems: "center",
      position: "relative",
      height: sizeToken,
      width: sizeToken,
      // indicator icons
      [checkboxClassList.selector("indicator")]: {
        opacity: 0,
        transform: `scale(0) translate3d(0, 0, 0)`,
        transition: transition(["opacity", "transform"]),
        willChange: "opacity, transform"
      },
      // focus ring
      "::after": {
        borderRadius: `calc(${tokenSchema.size.alias.focusRingGap} + ${tokenSchema.size.radius.small})`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      'input[type="checkbox"][data-focus=visible] + &::after': {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // border / background
      "&::before": {
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.alias.borderIdle}`,
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["border-color", "border-width"])
      },
      'input[type="checkbox"]:disabled + &': {
        color: tokenSchema.color.alias.foregroundDisabled,
        "&::before": {
          borderColor: tokenSchema.color.alias.borderDisabled
        }
      },
      'input[type="checkbox"]:enabled:hover + &::before': {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      'input[type="checkbox"]:enabled:active + &::before': {
        borderColor: tokenSchema.color.alias.borderPressed
      },
      // checked states
      'input[type="checkbox"]:checked + &, input[type="checkbox"]:indeterminate + &': {
        "&::before": {
          borderWidth: `calc(${sizeToken} / 2)`
        },
        [checkboxClassList.selector("indicator")]: {
          opacity: 1,
          transform: `scale(1)`
        }
      },
      'input[type="checkbox"]:enabled:checked + &::before, input[type="checkbox"]:enabled:indeterminate + &::before': {
        borderColor: tokenSchema.color.scale.indigo9
      },
      'input[type="checkbox"]:enabled:checked:hover + &::before, input[type="checkbox"]:enabled:indeterminate:hover + &::before': {
        borderColor: tokenSchema.color.scale.indigo10
      },
      'input[type="checkbox"]:enabled:checked:active + &::before, input[type="checkbox"]:enabled:indeterminate:active + &::before': {
        borderColor: tokenSchema.color.scale.indigo11
      }
    })),
    children: (0, import_jsx_runtime16.jsx)("span", {
      className: checkboxClassList.element("indicator"),
      children: (0, import_jsx_runtime16.jsx)(Icon, {
        size: "small",
        src: isIndeterminate ? minusIcon : checkIcon,
        strokeScaling: false
      })
    })
  });
};
var Content2 = (props) => {
  return (0, import_jsx_runtime16.jsx)("div", {
    className: classNames(css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: "grid",
      paddingTop: `calc((${sizeToken} - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      gap: tokenSchema.size.space.large,
      'input[type="checkbox"]:hover ~ &': {
        color: tokenSchema.color.alias.foregroundHovered
      },
      'input[type="checkbox"]:disabled ~ &': {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    })),
    ...props
  });
};
var CheckboxGroup = (0, import_react30.forwardRef)(function CheckboxGroup2(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateFieldProps(props);
  let {
    children,
    orientation = "vertical",
    validationState
  } = props;
  let state = $587d3ad58be6d31f$export$daff6da51032a415(props);
  let {
    labelProps,
    groupProps,
    descriptionProps,
    errorMessageProps
  } = $1e9fce0cfacc738b$export$49ff6f28c54f1cbe(props, state);
  return (0, import_jsx_runtime16.jsx)(FieldPrimitive, {
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    supplementRequiredState: true,
    children: (0, import_jsx_runtime16.jsx)("div", {
      ...groupProps,
      ...toDataAttributes({
        orientation
      }),
      className: classNames(css({
        display: "flex",
        gap: tokenSchema.size.space.large,
        '&[data-orientation="vertical"]': {
          flexDirection: "column"
        }
      })),
      children: (0, import_jsx_runtime16.jsx)(CheckboxGroupContext.Provider, {
        value: {
          validationState,
          state
        },
        children
      })
    })
  });
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/overlays/dist/keystar-ui-overlays.esm.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var import_react33 = __toESM(require_react());

// node_modules/.pnpm/@babel+runtime@7.23.5/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i6;
  for (i6 = 0; i6 < sourceKeys.length; i6++) {
    key = sourceKeys[i6];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/.pnpm/@babel+runtime@7.23.5/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o5, p5) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o6, p6) {
    o6.__proto__ = p6;
    return o6;
  };
  return _setPrototypeOf(o5, p5);
}

// node_modules/.pnpm/@babel+runtime@7.23.5/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// node_modules/.pnpm/react-transition-group@4.4.5_react-dom@18.2.0_react@18.2.0/node_modules/react-transition-group/esm/Transition.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react32 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/.pnpm/react-transition-group@4.4.5_react-dom@18.2.0_react@18.2.0/node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: false
};

// node_modules/.pnpm/react-transition-group@4.4.5_react-dom@18.2.0_react@18.2.0/node_modules/react-transition-group/esm/utils/PropTypes.js
var import_prop_types = __toESM(require_prop_types());
var timeoutsShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
  enter: import_prop_types.default.number,
  exit: import_prop_types.default.number,
  appear: import_prop_types.default.number
}).isRequired]) : null;
var classNamesShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  active: import_prop_types.default.string
}), import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  enterDone: import_prop_types.default.string,
  enterActive: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  exitDone: import_prop_types.default.string,
  exitActive: import_prop_types.default.string
})]) : null;

// node_modules/.pnpm/react-transition-group@4.4.5_react-dom@18.2.0_react@18.2.0/node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react31 = __toESM(require_react());
var TransitionGroupContext_default = import_react31.default.createContext(null);

// node_modules/.pnpm/react-transition-group@4.4.5_react-dom@18.2.0_react@18.2.0/node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function forceReflow2(node3) {
  return node3.scrollTop;
};

// node_modules/.pnpm/react-transition-group@4.4.5_react-dom@18.2.0_react@18.2.0/node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node3 = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom2.default.findDOMNode(this);
          if (node3)
            forceReflow(node3);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom2.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node3 = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom2.default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node3 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node3, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render3() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      import_react32.default.createElement(TransitionGroupContext_default.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : import_react32.default.cloneElement(import_react32.default.Children.only(children), childProps))
    );
  };
  return Transition2;
}(import_react32.default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = true ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: import_prop_types2.default.shape({
    current: typeof Element === "undefined" ? import_prop_types2.default.any : function(propValue, key, componentName, location2, propFullName, secret) {
      var value2 = propValue[key];
      return import_prop_types2.default.instanceOf(value2 && "ownerDocument" in value2 ? value2.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location2, propFullName, secret);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: import_prop_types2.default.oneOfType([import_prop_types2.default.func.isRequired, import_prop_types2.default.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: import_prop_types2.default.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: import_prop_types2.default.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: import_prop_types2.default.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: import_prop_types2.default.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: import_prop_types2.default.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: import_prop_types2.default.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener)
      pt = pt.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt.apply(void 0, [props].concat(args));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: import_prop_types2.default.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: import_prop_types2.default.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types2.default.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: import_prop_types2.default.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: import_prop_types2.default.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: import_prop_types2.default.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: import_prop_types2.default.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/overlays/dist/keystar-ui-overlays.esm.js
function Blanket(props) {
  const {
    isOpen,
    isTransparent,
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime17.jsx)("div", {
    ...filterStyleProps(otherProps),
    ...toDataAttributes({
      fill: isTransparent ? "transparent" : "translucent",
      open: isOpen || void 0
    }),
    ...styleProps,
    className: classNames(css({
      inset: 0,
      opacity: 0,
      overflow: "hidden",
      pointerEvents: "none",
      position: "fixed",
      visibility: "hidden",
      zIndex: 1,
      // exit animation
      '&[data-fill="translucent"]': {
        backgroundColor: "#0006",
        // TODO: add token
        transition: [transition("opacity", {
          easing: "easeOut",
          duration: "regular",
          delay: "short"
        }), transition("visibility", {
          delay: "regular",
          duration: 0,
          easing: "linear"
        })].join(", ")
      },
      '&[data-open="true"]': {
        opacity: 1,
        pointerEvents: "auto",
        visibility: "visible",
        // enter animation
        transition: transition("opacity", {
          easing: "easeIn"
        })
      }
    }), styleProps.className)
  });
}
function DirectionIndicator({
  fill,
  placement,
  size: size3,
  stroke,
  ...props
}) {
  return (0, import_jsx_runtime17.jsx)("span", {
    ...props,
    ...toDataAttributes({
      fill,
      placement,
      size: size3
    }),
    "data-placement": placement,
    className: classNames(css({
      height: "var(--size)",
      position: "absolute",
      width: "var(--size)",
      // fill
      '&[data-fill="surface"]': {
        fill: tokenSchema.color.background.surface
      },
      '&[data-fill="inverse"]': {
        fill: tokenSchema.color.background.inverse
      },
      '&[data-fill="accent"]': {
        fill: tokenSchema.color.background.accentEmphasis
      },
      '&[data-fill="critical"]': {
        fill: tokenSchema.color.background.criticalEmphasis
      },
      '&[data-fill="positive"]': {
        fill: tokenSchema.color.background.positiveEmphasis
      },
      // size
      '&[data-size="xsmall"]': {
        "--size": tokenSchema.size.element.xsmall
      },
      '&[data-size="small"]': {
        "--size": tokenSchema.size.element.small
      },
      '&[data-size="regular"]': {
        "--size": tokenSchema.size.element.regular
      },
      // align block
      '&[data-placement="top"], &[data-placement="bottom"]': {
        left: "50%",
        transform: "translateX(-50%)"
      },
      '&[data-placement="top"]': {
        top: "100%"
      },
      '&[data-placement="bottom"]': {
        bottom: "100%"
      },
      // align inline
      '&[data-placement="left"], &[data-placement="right"], &[data-placement="start"], &[data-placement="end"]': {
        top: "50%",
        transform: "translateY(-50%)"
      },
      '&[data-placement="left"]': {
        left: "100%"
      },
      '&[data-placement="right"]': {
        right: "100%"
      },
      '&[data-placement="start"]': {
        insetInlineStart: "100%"
      },
      '&[data-placement="end"]': {
        insetInlineEnd: "100%"
      }
    }), props.className),
    children: (0, import_jsx_runtime17.jsxs)("svg", {
      "data-placement": placement,
      viewBox: "0 0 30 30",
      className: css({
        // bottom is default; no rotation
        '&[data-placement="top"]': {
          transform: "rotate(180deg)"
        },
        '&[data-placement="left"], [dir=ltr] &[data-placement="start"], [dir=rtl] &[data-placement="end"]': {
          transform: "rotate(90deg)"
        },
        '&[data-placement="right"], [dir=ltr] &[data-placement="end"], [dir=rtl] &[data-placement="start"]': {
          transform: "rotate(270deg)"
        }
      }),
      children: [stroke && (0, import_jsx_runtime17.jsx)("path", {
        fill: stroke,
        d: "M23.7,27.1L17,19.9C16.5,19.3,15.8,19,15,19s-1.6,0.3-2.1,0.9l-6.6,7.2C5.3,28.1,3.4,29,2,29h26 C26.7,29,24.6,28.1,23.7,27.1z"
      }), (0, import_jsx_runtime17.jsx)("path", {
        d: "M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"
      })]
    })
  });
}
function OpenTransition(props) {
  const {
    children
  } = props;
  return (0, import_jsx_runtime17.jsx)(Transition_default, {
    timeout: {
      enter: 0,
      exit: 320
    },
    ...props,
    children: (state) => import_react33.Children.map(children, (child) => {
      var _cloneValidElement;
      return (_cloneValidElement = cloneValidElement(child, {
        isOpen: state === "entered"
      })) !== null && _cloneValidElement !== void 0 ? _cloneValidElement : child;
    })
  });
}
var Overlay = (0, import_react33.forwardRef)(function Overlay2(props, forwardedRef) {
  let {
    children,
    isOpen,
    container,
    nodeRef,
    onEnter,
    onEntering,
    onEntered,
    onExit,
    onExiting,
    onExited
  } = props;
  let [exited, setExited] = (0, import_react33.useState)(!isOpen);
  let handleEntered = (0, import_react33.useCallback)(() => {
    setExited(false);
    if (onEntered) {
      onEntered();
    }
  }, [onEntered]);
  let handleExited = (0, import_react33.useCallback)(() => {
    setExited(true);
    if (onExited) {
      onExited();
    }
  }, [onExited]);
  if (!(isOpen || !exited)) {
    return null;
  }
  return (0, import_jsx_runtime17.jsx)($337b884510726a0d$export$c6fdb837b070b4ff, {
    portalContainer: container,
    children: (0, import_jsx_runtime17.jsx)(KeystarProvider, {
      ref: forwardedRef,
      UNSAFE_style: {
        background: "transparent",
        isolation: "isolate"
      },
      isDisabled: false,
      children: (0, import_jsx_runtime17.jsx)(OpenTransition, {
        appear: true,
        in: isOpen,
        nodeRef,
        onEnter,
        onEntered: handleEntered,
        onEntering,
        onExit,
        onExited: handleExited,
        onExiting,
        children
      })
    })
  });
});
var Modal = (0, import_react33.forwardRef)(function Modal2(props, forwardedRef) {
  let {
    children,
    state,
    ...otherProps
  } = props;
  let wrapperRef = (0, import_react33.useRef)(null);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime17.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: (0, import_jsx_runtime17.jsx)(ModalWrapper, {
        ref: forwardedRef,
        ...props,
        wrapperRef,
        children
      })
    })
  );
});
var MAX_HEIGHT_VAR = `--${TOKEN_PREFIX}-visual-viewport-height`;
var ModalWrapper = (0, import_react33.forwardRef)(function ModalWrapper2(props, forwardedRef) {
  let {
    type: type2,
    children,
    state,
    isOpen,
    wrapperRef
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, domRef);
  let styleProps = useStyleProps(props);
  let viewport = $5df64b3807dc15ee$export$d699905dd57c73ca();
  return (0, import_jsx_runtime17.jsxs)("div", {
    ref: wrapperRef,
    children: [(0, import_jsx_runtime17.jsx)(Blanket, {
      ...underlayProps,
      isOpen
    }), (0, import_jsx_runtime17.jsx)("div", {
      className: css({
        alignItems: "center",
        boxSizing: "border-box",
        display: "flex",
        insetBlockStart: 0,
        insetInlineStart: 0,
        justifyContent: "center",
        pointerEvents: "none",
        position: "fixed",
        width: "100vw",
        zIndex: 2
        // above blanket
      }),
      style: {
        // @ts-ignore
        [MAX_HEIGHT_VAR]: `${viewport.height}px`,
        height: `var(${MAX_HEIGHT_VAR})`
      },
      children: (0, import_jsx_runtime17.jsx)("div", {
        ...modalProps,
        ...toDataAttributes({
          open: isOpen,
          type: type2
        }),
        ...styleProps,
        ref: domRef,
        className: classNames(styleProps.className, css({
          backgroundColor: tokenSchema.color.background.surface,
          // TODO: component token?
          borderRadius: tokenSchema.size.radius.large,
          // TODO: component token?
          boxShadow: `${tokenSchema.size.shadow.large} ${tokenSchema.color.shadow.emphasis}`,
          maxHeight: `calc(var(${MAX_HEIGHT_VAR}) * 0.9)`,
          maxWidth: "90vw",
          opacity: 0,
          outline: 0,
          pointerEvents: "auto",
          transform: `translateY(${tokenSchema.size.space.large})`,
          // initialise with offset
          zIndex: 2,
          // above blanket
          // exit animation
          transition: [transition("opacity", {
            easing: "easeIn"
          }), transition("transform", {
            delay: "short",
            duration: 0,
            easing: "linear"
          })].join(", "),
          '&[data-type="fullscreen"]': {
            position: "fixed",
            inset: tokenSchema.size.space.xxlarge,
            maxWidth: "none",
            maxHeight: "none",
            width: `calc(100% - calc(2 * ${tokenSchema.size.space.xxlarge}))`,
            height: `calc(100% - calc(2 * ${tokenSchema.size.space.xxlarge}))`
          },
          '&[data-open="true"]': {
            opacity: 1,
            transform: `translateY(0)`,
            // enter animation
            transition: transition(["opacity", "transform"], {
              easing: "easeOut"
            })
          }
        })),
        children
      })
    })]
  });
});
var Popover = (0, import_react33.forwardRef)(function Popover2(props, forwardedRef) {
  let {
    children,
    state,
    ...otherProps
  } = props;
  let wrapperRef = (0, import_react33.useRef)(null);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime17.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: (0, import_jsx_runtime17.jsx)(PopoverWrapper, {
        ref: forwardedRef,
        ...props,
        wrapperRef,
        children
      })
    })
  );
});
var PopoverWrapper = (0, import_react33.forwardRef)(function PopoverWrapper2(props, forwardedRef) {
  let {
    children,
    isOpen,
    hideArrow,
    isNonModal,
    state,
    wrapperRef
  } = props;
  let popoverRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    popoverProps,
    arrowProps,
    underlayProps,
    placement
  } = $f2f8a6077418541e$export$542a6fd13ac93354({
    ...props,
    containerPadding: 8,
    popoverRef,
    // @ts-expect-error we need to override the default value, but `undefined` doesn't work.
    maxHeight: null
  }, state);
  let styleProps = usePopoverStyles({
    ...props,
    placement
  });
  return (0, import_jsx_runtime17.jsxs)("div", {
    ref: wrapperRef,
    children: [!isNonModal && (0, import_jsx_runtime17.jsx)(Blanket, {
      isTransparent: true,
      ...underlayProps,
      isOpen
    }), (0, import_jsx_runtime17.jsxs)("div", {
      ...styleProps,
      ...popoverProps,
      style: {
        ...styleProps.style,
        ...popoverProps.style
      },
      ref: popoverRef,
      role: "presentation",
      children: [!isNonModal && (0, import_jsx_runtime17.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: state.close
      }), hideArrow ? null : (0, import_jsx_runtime17.jsx)(DirectionIndicator, {
        ...arrowProps,
        fill: "surface",
        stroke: tokenSchema.color.border.emphasis,
        placement,
        size: "regular"
      }), children, (0, import_jsx_runtime17.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: state.close
      })]
    })]
  });
});
function usePopoverStyles(props) {
  let {
    hideArrow,
    isOpen,
    placement
  } = props;
  let consumerStyleProps = useStyleProps(props);
  let offset = "var(--popover-offset)";
  let popoverStyles = css({
    backgroundColor: tokenSchema.color.background.surface,
    // TODO: component token?
    borderRadius: tokenSchema.size.radius.medium,
    // TODO: component token?
    border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
    boxSizing: "content-box",
    // resolves measurement/scroll issues related to border
    opacity: 0,
    outline: 0,
    pointerEvents: "auto",
    position: "absolute",
    // drop shadow
    filter: `drop-shadow(0 1px 4px ${tokenSchema.color.shadow.regular})`,
    // use filter:drop-shadow instead of box-shadow so the arrow is included
    willChange: "filter, transform",
    // filter bug in safari: https://stackoverflow.com/questions/56478925/safari-drop-shadow-filter-remains-visible-even-with-hidden-element
    // exit animation
    transition: [transition("opacity", {
      easing: "easeIn"
    }), transition("transform", {
      delay: "short",
      duration: 0,
      easing: "linear"
    })].join(", "),
    // gutter between popover and viewport
    "&[data-placement=top]": {
      marginTop: tokenSchema.size.space.regular
    },
    "&[data-placement=bottom]": {
      marginBottom: tokenSchema.size.space.regular
    },
    "&[data-placement=left]": {
      marginLeft: tokenSchema.size.space.regular
    },
    "&[data-placement=right]": {
      marginRight: tokenSchema.size.space.regular
    },
    "&[data-open]": {
      opacity: 1,
      // enter animation
      transition: transition(["opacity", "transform"], {
        easing: "easeOut"
      })
    },
    // animate towards placement; re-enforce the illusion that the popover
    // originates from, and is bound to, the trigger.
    "&[data-placement=top][data-open]": {
      transform: `translateY(calc(${offset} * -1))`
    },
    "&[data-placement=bottom][data-open]": {
      transform: `translateY(${offset})`
    },
    "&[data-placement=left][data-open]": {
      transform: `translateX(calc(${offset} * -1))`
    },
    "&[data-placement=right][data-open]": {
      transform: `translateX(${offset})`
    }
  });
  return {
    ...toDataAttributes({
      arrow: !hideArrow || void 0,
      placement,
      open: isOpen || void 0
    }),
    className: classNames(popoverStyles, consumerStyleProps.className),
    style: {
      "--popover-offset": hideArrow ? tokenSchema.size.space.regular : tokenSchema.size.space.large,
      ...consumerStyleProps.style
    }
  };
}
var Tray = (0, import_react33.forwardRef)(function Tray2(props, forwardedRef) {
  let {
    children,
    state,
    ...otherProps
  } = props;
  let wrapperRef = (0, import_react33.useRef)(null);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime17.jsx)(Overlay, {
      ...otherProps,
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: (0, import_jsx_runtime17.jsx)(TrayWrapper, {
        ref: forwardedRef,
        ...props,
        wrapperRef,
        children
      })
    })
  );
});
var TrayWrapper = (0, import_react33.forwardRef)(function TrayWrapper2(props, forwardedRef) {
  let {
    children,
    state,
    isFixedHeight,
    isOpen,
    wrapperRef
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb({
    ...props,
    isDismissable: true
  }, state, domRef);
  let styleProps = useStyleProps(props);
  let viewport = $5df64b3807dc15ee$export$d699905dd57c73ca();
  return (0, import_jsx_runtime17.jsxs)("div", {
    ref: wrapperRef,
    children: [(0, import_jsx_runtime17.jsx)(Blanket, {
      ...underlayProps,
      isOpen
    }), (0, import_jsx_runtime17.jsx)("div", {
      className: css({
        boxSizing: "border-box",
        display: "flex",
        insetBlockStart: 0,
        insetInlineStart: 0,
        justifyContent: "center",
        pointerEvents: "none",
        position: "fixed",
        height: "100vh",
        width: "100%",
        zIndex: 2
        // above blanket
      }),
      style: {
        height: viewport.height
      },
      children: (0, import_jsx_runtime17.jsx)("div", {
        ...modalProps,
        ...toDataAttributes({
          open: isOpen,
          fillScreen: isFixedHeight || void 0
        }),
        ref: domRef,
        style: Object.assign({}, isFixedHeight ? {
          height: `calc(${viewport.height}px - ${tokenSchema.size.space.xxlarge})`,
          top: tokenSchema.size.space.xxlarge
        } : {}, {
          maxHeight: `calc(${viewport.height}px - ${tokenSchema.size.space.xxlarge})`,
          paddingBottom: `max(calc(100vh - ${viewport.height}px), env(safe-area-inset-bottom))`
        }, styleProps.style),
        className: classNames(styleProps.className, css({
          backgroundColor: tokenSchema.color.background.surface,
          // TODO: component token?
          bottom: 0,
          maxWidth: "100vw",
          opacity: 0,
          outline: 0,
          pointerEvents: "auto",
          position: "absolute",
          transform: "translateY(100%)",
          // initialise with offset
          width: "100%",
          zIndex: 2,
          // above blanket
          // NOTE: trays shouldn't be used for larger screens, but in case
          // they are we need to tweak the appearance.
          [breakpointQueries$1.above.mobile]: {
            borderStartStartRadius: tokenSchema.size.radius.medium,
            // TODO: component token?
            borderStartEndRadius: tokenSchema.size.radius.medium,
            // TODO: component token?
            maxWidth: breakpoints.tablet
          },
          // exit animation
          transition: transition(["opacity", "transform"], {
            easing: "easeIn"
          }),
          '&[data-open="true"]': {
            opacity: 1,
            transform: `translateY(0)`,
            // enter animation
            transition: transition(["opacity", "transform"], {
              easing: "easeOut",
              delay: "short"
            })
          }
        })),
        children
      })
    })]
  });
});

// node_modules/.pnpm/@react-stately+overlays@3.6.4_react@18.2.0/node_modules/@react-stately/overlays/dist/import.mjs
var import_react34 = __toESM(require_react(), 1);
function $fc909762b330b746$export$61c6a8c84e605fb6(props) {
  let [isOpen, setOpen] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.isOpen, props.defaultOpen || false, props.onOpenChange);
  const open = (0, import_react34.useCallback)(() => {
    setOpen(true);
  }, [
    setOpen
  ]);
  const close = (0, import_react34.useCallback)(() => {
    setOpen(false);
  }, [
    setOpen
  ]);
  const toggle = (0, import_react34.useCallback)(() => {
    setOpen(!isOpen);
  }, [
    setOpen,
    isOpen
  ]);
  return {
    isOpen,
    setOpen,
    open,
    close,
    toggle
  };
}

// node_modules/.pnpm/@react-aria+tooltip@3.6.5_react@18.2.0/node_modules/@react-aria/tooltip/dist/import.mjs
var import_react35 = __toESM(require_react(), 1);
function $326e436e94273fe1$export$1c4b08e0eca38426(props, state) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    onHoverStart: () => state === null || state === void 0 ? void 0 : state.open(true),
    onHoverEnd: () => state === null || state === void 0 ? void 0 : state.close()
  });
  return {
    tooltipProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, hoverProps, {
      role: "tooltip"
    })
  };
}
function $4e1b34546679e357$export$a6da6c504e4bba8b(props, state, ref) {
  let { isDisabled, trigger: trigger2 } = props;
  let tooltipId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let isHovered = (0, import_react35.useRef)(false);
  let isFocused = (0, import_react35.useRef)(false);
  let handleShow = () => {
    if (isHovered.current || isFocused.current)
      state.open(isFocused.current);
  };
  let handleHide = (immediate) => {
    if (!isHovered.current && !isFocused.current)
      state.close(immediate);
  };
  (0, import_react35.useEffect)(() => {
    let onKeyDown = (e6) => {
      if (ref && ref.current) {
        if (e6.key === "Escape") {
          e6.stopPropagation();
          state.close(true);
        }
      }
    };
    if (state.isOpen) {
      document.addEventListener("keydown", onKeyDown, true);
      return () => {
        document.removeEventListener("keydown", onKeyDown, true);
      };
    }
  }, [
    ref,
    state
  ]);
  let onHoverStart = () => {
    if (trigger2 === "focus")
      return;
    if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "pointer")
      isHovered.current = true;
    else
      isHovered.current = false;
    handleShow();
  };
  let onHoverEnd = () => {
    if (trigger2 === "focus")
      return;
    isFocused.current = false;
    isHovered.current = false;
    handleHide();
  };
  let onPressStart = () => {
    isFocused.current = false;
    isHovered.current = false;
    handleHide(true);
  };
  let onFocus = () => {
    let isVisible = (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)();
    if (isVisible) {
      isFocused.current = true;
      handleShow();
    }
  };
  let onBlur = () => {
    isFocused.current = false;
    isHovered.current = false;
    handleHide(true);
  };
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled,
    onHoverStart,
    onHoverEnd
  });
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPressStart
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)({
    isDisabled,
    onFocus,
    onBlur
  }, ref);
  return {
    triggerProps: {
      "aria-describedby": state.isOpen ? tooltipId : void 0,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(focusableProps, hoverProps, pressProps)
    },
    tooltipProps: {
      id: tooltipId
    }
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/tooltip/dist/keystar-ui-tooltip.esm.js
var import_react37 = __toESM(require_react());
var import_jsx_runtime18 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-stately+tooltip@3.4.6_react@18.2.0/node_modules/@react-stately/tooltip/dist/import.mjs
var import_react36 = __toESM(require_react(), 1);
var $8796f90736e175cb$var$TOOLTIP_DELAY = 1500;
var $8796f90736e175cb$var$TOOLTIP_COOLDOWN = 500;
var $8796f90736e175cb$var$tooltips = {};
var $8796f90736e175cb$var$tooltipId = 0;
var $8796f90736e175cb$var$globalWarmedUp = false;
var $8796f90736e175cb$var$globalWarmUpTimeout = null;
var $8796f90736e175cb$var$globalCooldownTimeout = null;
function $8796f90736e175cb$export$4d40659c25ecb50b(props = {}) {
  let { delay = $8796f90736e175cb$var$TOOLTIP_DELAY, closeDelay = $8796f90736e175cb$var$TOOLTIP_COOLDOWN } = props;
  let { isOpen, open, close } = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let id = (0, import_react36.useMemo)(() => `${++$8796f90736e175cb$var$tooltipId}`, []);
  let closeTimeout = (0, import_react36.useRef)();
  let ensureTooltipEntry = () => {
    $8796f90736e175cb$var$tooltips[id] = hideTooltip;
  };
  let closeOpenTooltips = () => {
    for (let hideTooltipId in $8796f90736e175cb$var$tooltips)
      if (hideTooltipId !== id) {
        $8796f90736e175cb$var$tooltips[hideTooltipId](true);
        delete $8796f90736e175cb$var$tooltips[hideTooltipId];
      }
  };
  let showTooltip = () => {
    clearTimeout(closeTimeout.current);
    closeTimeout.current = null;
    closeOpenTooltips();
    ensureTooltipEntry();
    $8796f90736e175cb$var$globalWarmedUp = true;
    open();
    if ($8796f90736e175cb$var$globalWarmUpTimeout) {
      clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);
      $8796f90736e175cb$var$globalWarmUpTimeout = null;
    }
    if ($8796f90736e175cb$var$globalCooldownTimeout) {
      clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);
      $8796f90736e175cb$var$globalCooldownTimeout = null;
    }
  };
  let hideTooltip = (immediate) => {
    if (immediate || closeDelay <= 0) {
      clearTimeout(closeTimeout.current);
      closeTimeout.current = null;
      close();
    } else if (!closeTimeout.current)
      closeTimeout.current = setTimeout(() => {
        closeTimeout.current = null;
        close();
      }, closeDelay);
    if ($8796f90736e175cb$var$globalWarmUpTimeout) {
      clearTimeout($8796f90736e175cb$var$globalWarmUpTimeout);
      $8796f90736e175cb$var$globalWarmUpTimeout = null;
    }
    if ($8796f90736e175cb$var$globalWarmedUp) {
      if ($8796f90736e175cb$var$globalCooldownTimeout)
        clearTimeout($8796f90736e175cb$var$globalCooldownTimeout);
      $8796f90736e175cb$var$globalCooldownTimeout = setTimeout(() => {
        delete $8796f90736e175cb$var$tooltips[id];
        $8796f90736e175cb$var$globalCooldownTimeout = null;
        $8796f90736e175cb$var$globalWarmedUp = false;
      }, Math.max($8796f90736e175cb$var$TOOLTIP_COOLDOWN, closeDelay));
    }
  };
  let warmupTooltip = () => {
    closeOpenTooltips();
    ensureTooltipEntry();
    if (!isOpen && !$8796f90736e175cb$var$globalWarmUpTimeout && !$8796f90736e175cb$var$globalWarmedUp)
      $8796f90736e175cb$var$globalWarmUpTimeout = setTimeout(() => {
        $8796f90736e175cb$var$globalWarmUpTimeout = null;
        $8796f90736e175cb$var$globalWarmedUp = true;
        showTooltip();
      }, delay);
    else if (!isOpen)
      showTooltip();
  };
  (0, import_react36.useEffect)(() => {
    return () => {
      clearTimeout(closeTimeout.current);
      let tooltip = $8796f90736e175cb$var$tooltips[id];
      if (tooltip)
        delete $8796f90736e175cb$var$tooltips[id];
    };
  }, [
    id
  ]);
  return {
    isOpen,
    open: (immediate) => {
      if (!immediate && delay > 0 && !closeTimeout.current)
        warmupTooltip();
      else
        showTooltip();
    },
    close: hideTooltip
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/tooltip/dist/keystar-ui-tooltip.esm.js
var TooltipContext = import_react37.default.createContext({});
var Tooltip = (0, import_react37.forwardRef)(function Tooltip2(props, forwardedRef) {
  let {
    state,
    targetRef: triggerRef,
    overlayRef: tooltipRef,
    crossOffset,
    offset,
    ...contextualProps
  } = (0, import_react37.useContext)(TooltipContext);
  props = $3ef42575df84b30b$export$9d1611c77c2fe928(props, contextualProps);
  let {
    isOpen,
    tone,
    ...otherProps
  } = props;
  let targetGapToken = tokenSchema.size.space.regular;
  let {
    tooltipProps
  } = $326e436e94273fe1$export$1c4b08e0eca38426(contextualProps, state);
  let styleProps = useStyleProps(otherProps);
  let ref = (0, import_react37.useRef)(null);
  let overlayRef = $df56164dff5785e2$export$4338b53315abf666(tooltipRef ? $5dc95899b306f630$export$c9058316764c140e(tooltipRef, forwardedRef) : forwardedRef);
  let targetRef = triggerRef !== null && triggerRef !== void 0 ? triggerRef : ref;
  let slots = (0, import_react37.useMemo)(() => ({
    icon: {
      size: "small",
      color: "inherit"
    },
    text: {
      size: "small",
      color: "inherit"
    },
    kbd: {
      size: "small",
      color: "inherit"
    }
  }), []);
  let preferredPlacement = contextualProps.placement || "top";
  let {
    overlayProps,
    arrowProps,
    placement: resolvedPlacement
  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1({
    ...contextualProps,
    placement: preferredPlacement,
    isOpen: state === null || state === void 0 ? void 0 : state.isOpen,
    overlayRef,
    targetRef
  });
  let placement = (resolvedPlacement || preferredPlacement).split(" ")[0];
  return (0, import_jsx_runtime18.jsxs)("div", {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, tooltipProps),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    ...toDataAttributes({
      placement,
      tone,
      open: isOpen || void 0
    }),
    ref: overlayRef,
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.inverse,
      color: tokenSchema.color.foreground.inverse,
      borderRadius: tokenSchema.size.radius.small,
      maxWidth: tokenSchema.size.alias.singleLineWidth,
      minHeight: tokenSchema.size.element.small,
      paddingBlock: tokenSchema.size.space.regular,
      paddingInline: tokenSchema.size.space.regular,
      opacity: 0,
      pointerEvents: "none",
      transition: transition(["opacity", "transform"]),
      userSelect: "none",
      '&[data-tone="accent"]': {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      '&[data-tone="critical"]': {
        backgroundColor: tokenSchema.color.background.criticalEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      '&[data-tone="positive"]': {
        backgroundColor: tokenSchema.color.background.positiveEmphasis,
        color: tokenSchema.color.foreground.onEmphasis
      },
      // animate towards placement, away from the trigger
      '&[data-placement="top"]': {
        marginBottom: targetGapToken,
        transform: `translateY(calc(${targetGapToken} * 0.5))`
      },
      '&[data-placement="bottom"]': {
        marginTop: targetGapToken,
        transform: `translateY(calc(${targetGapToken} * -0.5))`
      },
      '&[data-placement="left"], [dir=ltr] &[data-placement="start"], [dir=rtl] &[data-placement="end"]': {
        marginRight: targetGapToken,
        transform: `translateX(calc(${targetGapToken} * 0.5))`
      },
      '&[data-placement="right"], [dir=ltr] &[data-placement="end"], [dir=rtl] &[data-placement="start"]': {
        marginLeft: targetGapToken,
        transform: `translateX(calc(${targetGapToken} * -0.5))`
      },
      '&[data-open="true"]': {
        opacity: 1,
        transform: `translate(0)`
      }
    }), styleProps.className),
    style: {
      ...overlayProps.style,
      ...tooltipProps.style,
      ...styleProps.style
    },
    children: [(0, import_jsx_runtime18.jsx)("div", {
      className: css({
        alignItems: "center",
        boxSizing: "border-box",
        display: "flex",
        gap: tokenSchema.size.space.small
      }),
      children: (0, import_jsx_runtime18.jsx)(SlotProvider, {
        slots,
        children: props.children && (isReactText(props.children) ? (0, import_jsx_runtime18.jsx)(Text, {
          children: props.children
        }) : props.children)
      })
    }), (0, import_jsx_runtime18.jsx)(DirectionIndicator, {
      ...arrowProps,
      fill: toneToFill[tone !== null && tone !== void 0 ? tone : "neutral"],
      placement,
      size: "xsmall"
    })]
  });
});
var toneToFill = {
  accent: "accent",
  critical: "critical",
  neutral: "inverse",
  positive: "positive"
};
var MOUSE_REST_TIMEOUT = 600;
function TooltipTrigger(props) {
  let {
    children,
    isDisabled,
    trigger: triggerMode,
    ...otherProps
  } = props;
  let targetRef = (0, import_react37.useRef)(null);
  let overlayRef = (0, import_react37.useRef)(null);
  let state = $8796f90736e175cb$export$4d40659c25ecb50b({
    isDisabled,
    delay: MOUSE_REST_TIMEOUT,
    trigger: triggerMode,
    ...props
  });
  let {
    triggerProps,
    tooltipProps
  } = $4e1b34546679e357$export$a6da6c504e4bba8b({
    isDisabled,
    trigger: triggerMode
  }, state, targetRef);
  let [triggerElement, tooltipElement] = import_react37.default.Children.toArray(children);
  return (0, import_jsx_runtime18.jsxs)($e6afbd83fe6ebbd2$export$13f3202a3e5ddd5, {
    ...triggerProps,
    ref: targetRef,
    children: [triggerElement, (0, import_jsx_runtime18.jsx)(TooltipContext.Provider, {
      value: {
        overlayRef,
        targetRef,
        state,
        ...otherProps,
        ...tooltipProps
      },
      children: (0, import_jsx_runtime18.jsx)(Overlay, {
        isOpen: state.isOpen,
        nodeRef: overlayRef,
        children: tooltipElement
      })
    })]
  });
}
TooltipTrigger.getCollectionNode = function* (props) {
  let childArray = [];
  import_react37.default.Children.forEach(props.children, (child) => {
    if (import_react37.default.isValidElement(child)) {
      childArray.push(child);
    }
  });
  let [trigger2, tooltip] = childArray;
  yield {
    element: trigger2,
    wrapper: (element2) => (0, import_jsx_runtime18.jsxs)(TooltipTrigger, {
      ...props,
      children: [element2, tooltip]
    }, element2.key)
  };
};
var _TooltipTrigger = TooltipTrigger;

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/languages-97fa34d5.esm.js
var import_sanitize_url = __toESM(require_dist());
var localizedMessages2 = {
  "cs-CZ": {
    add: "Přidat",
    basedOn: "Na základě",
    branchName: "Jméno pobočky",
    branches: "Větve",
    cancel: "zrušení",
    clear: "Vymazat",
    collection: "Sbírka",
    collections: "Sbírky",
    create: "Vytvořit",
    createPullRequest: "Vytvořit požadavek na stažení",
    currentBranch: "Současná pobočka",
    defaultBranch: "Výchozí větev",
    dashboard: "Přístrojová deska",
    "delete": "Vymazat",
    deleteBranch: "Smazat větev",
    loading: "Načítání",
    edit: "Upravit",
    newBranch: "Nová pobočka",
    otherBranches: "Ostatní pobočky",
    pullRequests: "Vytáhněte požadavky",
    search: "Hledat",
    save: "Uložit",
    singleton: "Jedináček",
    singletons: "Singletons",
    theDefaultBranchInYourRepository: "Výchozí větev ve vašem úložišti. Zvolte tuto možnost, chcete-li začít s něčím novým, co není závislé na vaší aktuální větvi.",
    theCurrentlyCheckedOutBranch: "Aktuálně odhlášená pobočka. Tuto možnost vyberte, pokud potřebujete navázat na stávající práci z aktuální pobočky.",
    viewPullRequests: "Zobrazit žádosti o stažení"
  },
  "he-IL": {
    add: "לְהוֹסִיף",
    basedOn: "מבוסס על",
    branchName: "שם הסניף",
    cancel: "לְבַטֵל",
    branches: "ענפים",
    clear: "נקי",
    collection: "אוסף",
    create: "לִיצוֹר",
    createPullRequest: "צור בקשת משיכה",
    collections: "אוספים",
    currentBranch: "סניף נוכחי",
    dashboard: "לוּחַ מַחווָנִים",
    defaultBranch: "סניף ברירת מחדל",
    "delete": "לִמְחוֹק",
    deleteBranch: "מחק סניף",
    edit: "לַעֲרוֹך",
    loading: "טוען",
    newBranch: "סניף חדש",
    otherBranches: "סניפים אחרים",
    pullRequests: "משוך בקשות",
    save: "להציל",
    search: "חפש",
    singleton: "קְלָף בּוֹדֵד",
    singletons: "רווקים",
    theCurrentlyCheckedOutBranch: "הסניף שנקבע כעת. בחר באפשרות זו אם אתה צריך לבנות על עבודה קיימת מהסניף הנוכחי.",
    theDefaultBranchInYourRepository: "סניף ברירת המחדל במאגר שלך. בחר באפשרות זו כדי להתחיל משהו חדש שאינו תלוי בסניף הנוכחי שלך.",
    viewPullRequests: "הצג בקשות משיכה"
  },
  "hr-HR": {
    add: "Dodati",
    basedOn: "Na temelju",
    branches: "Podružnice",
    branchName: "Naziv podružnice",
    cancel: "Otkazati",
    collections: "Zbirke",
    collection: "Kolekcija",
    clear: "Izbriši",
    create: "Stvoriti",
    currentBranch: "Trenutna grana",
    createPullRequest: "Kreirajte zahtjev za povlačenjem",
    dashboard: "Nadzorna ploča",
    defaultBranch: "Zadana grana",
    "delete": "Izbrisati",
    deleteBranch: "Izbriši granu",
    edit: "Uredi",
    loading: "Učitavam",
    newBranch: "Nova grana",
    otherBranches: "Ostale grane",
    pullRequests: "Zahtjevi za povlačenjem",
    save: "Uštedjeti",
    search: "Traži",
    singleton: "samac",
    singletons: "Samci",
    theDefaultBranchInYourRepository: "Zadana grana u vašem spremištu. Odaberite ovo da započnete nešto novo što ne ovisi o vašoj trenutnoj grani.",
    theCurrentlyCheckedOutBranch: "Trenutno odjavljena poslovnica. Odaberite ovo ako trebate graditi na postojećem radu iz trenutne grane.",
    viewPullRequests: "Pregledajte zahtjeve za povlačenjem"
  },
  "hu-HU": {
    basedOn: "Alapján",
    add: "Hozzáadás",
    branchName: "Fiók neve",
    branches: "Ágak",
    cancel: "Megszünteti",
    clear: "Törlés",
    collections: "Gyűjtemények",
    collection: "Gyűjtemény",
    create: "Teremt",
    createPullRequest: "Lehívási kérelem létrehozása",
    currentBranch: "Jelenlegi ág",
    dashboard: "Irányítópult",
    defaultBranch: "Alapértelmezett ág",
    "delete": "Töröl",
    deleteBranch: "Elágazás törlése",
    edit: "Szerkesztés",
    loading: "Betöltés folyamatban",
    newBranch: "Új ág",
    otherBranches: "Egyéb ágak",
    pullRequests: "Lehívási kérések",
    save: "Megment",
    singleton: "szingli",
    search: "Keresés",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "A jelenleg kivett fiók. Válassza ezt, ha az aktuális ág meglévő munkájára kell építenie.",
    viewPullRequests: "Lehívási kérelmek megtekintése",
    theDefaultBranchInYourRepository: "Az alapértelmezett ág az adattárban. Válassza ezt, ha valami újat szeretne indítani, amely nem függ az aktuális ágtól."
  },
  "it-IT": {
    basedOn: "Basato su",
    branchName: "Nome ramo",
    add: "Aggiungere",
    branches: "Rami",
    cancel: "Annulla",
    clear: "Cancella",
    collection: "Collezione",
    create: "Creare",
    collections: "Collezioni",
    createPullRequest: "Crea richiesta pull",
    currentBranch: "Ramo attuale",
    dashboard: "Pannello di controllo",
    defaultBranch: "Ramo predefinito",
    "delete": "Eliminare",
    deleteBranch: "Elimina ramo",
    edit: "Modificare",
    loading: "Caricamento in corso",
    newBranch: "Nuova filiale",
    pullRequests: "Richieste pull",
    save: "Salva",
    otherBranches: "Altri rami",
    search: "Cerca",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "La filiale attualmente verificata. Scegli questa opzione se devi basarti su un lavoro esistente dal ramo corrente.",
    theDefaultBranchInYourRepository: "Il ramo predefinito nel tuo repository. Scegli questa opzione per iniziare qualcosa di nuovo che non dipenda dal tuo ramo attuale.",
    viewPullRequests: "Visualizza le richieste pull"
  },
  "ja-JP": {
    add: "追加",
    basedOn: "に基づく",
    branchName: "支店名",
    cancel: "キャンセル",
    branches: "支店",
    clear: "クリア",
    collection: "コレクション",
    create: "作成",
    collections: "コレクション",
    createPullRequest: "プルリクエストを作成",
    currentBranch: "現在のブランチ",
    dashboard: "ダッシュボード",
    defaultBranch: "デフォルトのブランチ",
    "delete": "消去",
    deleteBranch: "ブランチを削除",
    edit: "編集",
    loading: "読み込み中",
    newBranch: "新しい支店",
    otherBranches: "その他の支店",
    pullRequests: "プルリクエスト",
    save: "保存",
    search: "検索",
    singleton: "シングルトン",
    singletons: "シングルトン",
    theCurrentlyCheckedOutBranch: "現在チェックアウトされているブランチ。 現在のブランチの既存の作業に基づいて構築する必要がある場合は、これを選択してください。",
    theDefaultBranchInYourRepository: "リポジトリのデフォルト ブランチ。 これを選択して、現在のブランチに依存しない新しい何かを開始します。",
    viewPullRequests: "プル リクエストを表示"
  },
  "ko-KR": {
    basedOn: "기반으로",
    branchName: "지점명",
    add: "추가하다",
    branches: "가지",
    cancel: "취소",
    clear: "지우기",
    collection: "수집",
    collections: "컬렉션",
    create: "만들다",
    createPullRequest: "풀 요청 생성",
    currentBranch: "현재 지점",
    dashboard: "계기반",
    defaultBranch: "기본 분기",
    "delete": "삭제",
    deleteBranch: "분기 삭제",
    edit: "편집하다",
    loading: "로드 중",
    newBranch: "새 지점",
    otherBranches: "기타 지점",
    pullRequests: "풀 리퀘스트",
    save: "구하다",
    search: "검색",
    singleton: "하나씩 일어나는 것",
    singletons: "싱글톤",
    theCurrentlyCheckedOutBranch: "현재 체크아웃된 브랜치. 현재 브랜치의 기존 작업을 기반으로 빌드해야 하는 경우 이 옵션을 선택하세요.",
    viewPullRequests: "풀 요청 보기",
    theDefaultBranchInYourRepository: "리포지토리의 기본 브랜치입니다. 현재 분기에 의존하지 않는 새로운 것을 시작하려면 이것을 선택하십시오."
  },
  "el-GR": {
    add: "Προσθήκη",
    basedOn: "Βασισμένο στο",
    branchName: "Όνομα υποκαταστήματος",
    branches: "Κλαδια δεντρου",
    cancel: "Ματαίωση",
    clear: "Καθαρισμός",
    collection: "Συλλογή",
    collections: "Συλλογές",
    create: "Δημιουργώ",
    createPullRequest: "Δημιουργία αιτήματος έλξης",
    currentBranch: "Τρέχον υποκατάστημα",
    dashboard: "Ταμπλό",
    defaultBranch: "Προεπιλεγμένος κλάδος",
    "delete": "Διαγράφω",
    deleteBranch: "Διαγραφή υποκαταστήματος",
    edit: "Επεξεργασία",
    loading: "Φόρτωση",
    newBranch: "Νέο υποκατάστημα",
    otherBranches: "Άλλα υποκαταστήματα",
    pullRequests: "Τραβήξτε αιτήματα",
    save: "Αποθηκεύσετε",
    search: "Αναζήτηση",
    singleton: "Μοναδικό χαρτί",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Το υποκατάστημα που ελέγχεται αυτήν τη στιγμή. Επιλέξτε αυτό εάν χρειάζεται να βασιστείτε σε υπάρχουσες εργασίες από τον τρέχοντα κλάδο.",
    theDefaultBranchInYourRepository: "Ο προεπιλεγμένος κλάδος στο αποθετήριο σας. Επιλέξτε αυτό για να ξεκινήσετε κάτι νέο που δεν εξαρτάται από το τρέχον υποκατάστημά σας.",
    viewPullRequests: "Προβολή αιτημάτων έλξης"
  },
  "ar-AE": {
    add: "يضيف",
    basedOn: "مرتكز على",
    branches: "الفروع",
    branchName: "اسم الفرع",
    cancel: "يلغي",
    clear: "مسح",
    collection: "مجموعة",
    create: "يخلق",
    collections: "المجموعات",
    createPullRequest: "إنشاء طلب سحب",
    currentBranch: "الفرع الحالي",
    defaultBranch: "الفرع الافتراضي",
    dashboard: "لوحة القيادة",
    "delete": "يمسح",
    deleteBranch: "حذف الفرع",
    loading: "جارٍ التحميل",
    edit: "يحرر",
    newBranch: "فرع جديد",
    otherBranches: "الفروع الأخرى",
    pullRequests: "طلبات السحب",
    save: "يحفظ",
    search: "بحث",
    singletons: "الفردي",
    singleton: "سينجلتون",
    theCurrentlyCheckedOutBranch: "الفرع المعاد حاليا. اختر هذا إذا كنت بحاجة إلى البناء على العمل الحالي من الفرع الحالي.",
    theDefaultBranchInYourRepository: "الفرع الافتراضي في المستودع الخاص بك. اختر هذا لبدء شيء جديد لا يعتمد على فرعك الحالي.",
    viewPullRequests: "عرض طلبات السحب"
  },
  "bg-BG": {
    add: "Добавете",
    basedOn: "Базиран на",
    branchName: "Име на клон",
    branches: "Клонове",
    cancel: "Отказ",
    clear: "Изчисти",
    collection: "колекция",
    collections: "Колекции",
    create: "Създавайте",
    createPullRequest: "Създайте заявка за изтегляне",
    currentBranch: "Текущ клон",
    dashboard: "Табло",
    "delete": "Изтрий",
    defaultBranch: "Клон по подразбиране",
    deleteBranch: "Изтриване на клон",
    edit: "редактиране",
    newBranch: "Нов клон",
    loading: "Зареждане",
    otherBranches: "Други клонове",
    pullRequests: "Заявки за изтегляне",
    save: "Запазване",
    search: "Търсене",
    singleton: "Сингълтън",
    theCurrentlyCheckedOutBranch: "Текущо провереният клон. Изберете това, ако трябва да надграждате върху съществуваща работа от текущия клон.",
    singletons: "Единични",
    theDefaultBranchInYourRepository: "Клонът по подразбиране във вашето хранилище. Изберете това, за да започнете с нещо ново, което не зависи от текущия ви клон.",
    viewPullRequests: "Преглед на заявките за изтегляне"
  },
  "da-DK": {
    basedOn: "Baseret på",
    add: "Tilføje",
    branchName: "Afdelingsnavn",
    branches: "Grene",
    clear: "Ryd",
    cancel: "Afbestille",
    collection: "Kollektion",
    collections: "Samlinger",
    create: "skab",
    currentBranch: "Nuværende filial",
    createPullRequest: "Opret pull-anmodning",
    dashboard: "Dashboard",
    defaultBranch: "Standard gren",
    "delete": "Slet",
    deleteBranch: "Slet filial",
    edit: "Redigere",
    loading: "Indlæser",
    otherBranches: "Andre grene",
    pullRequests: "Træk anmodninger",
    newBranch: "Ny filial",
    save: "Gemme",
    search: "Søg",
    singleton: "Singleton",
    singletons: "Singletoner",
    theCurrentlyCheckedOutBranch: "Den aktuelt tjekkede filial. Vælg dette, hvis du skal bygge videre på eksisterende arbejde fra den nuværende filial.",
    theDefaultBranchInYourRepository: "Standardgrenen i dit lager. Vælg dette for at starte på noget nyt, der ikke er afhængigt af din nuværende filial.",
    viewPullRequests: "Se pull-anmodninger"
  },
  "de-DE": {
    defaultBranch: "Standardzweig",
    "delete": "Löschen",
    deleteBranch: "Zweig löschen",
    edit: "Bearbeiten",
    loading: "Wird geladen",
    newBranch: "Neue Zweig",
    otherBranches: "Andere Filialen",
    pullRequests: "Pull-Requests",
    save: "Speichern",
    search: "Suchen",
    singleton: "Einzelling",
    singletons: "Singles",
    theCurrentlyCheckedOutBranch: "Der aktuell ausgecheckte Zweig. Wählen Sie diese Option, wenn Sie auf vorhandener Arbeit aus dem aktuellen Zweig aufbauen müssen.",
    theDefaultBranchInYourRepository: "Der Standard-Branch in Ihrem Repository. Wählen Sie dies, um etwas Neues zu starten, das nicht von Ihrem aktuellen Zweig abhängt.",
    viewPullRequests: "Pull-Requests anzeigen",
    add: "Hinzufügen",
    basedOn: "Bezogen auf",
    branchName: "Zweigname",
    branches: "Geäst",
    clear: "Löschen",
    collection: "Sammlung",
    cancel: "Stornieren",
    create: "Erstellen",
    collections: "Sammlungen",
    createPullRequest: "Pull-Request erstellen",
    currentBranch: "Aktueller Zweig",
    dashboard: "Armaturenbrett"
  },
  "es-ES": {
    branchName: "Nombre de la sucursal",
    add: "Agregar",
    branches: "Sucursales",
    clear: "Borrar",
    basedOn: "Residencia en",
    cancel: "Cancelar",
    collection: "Colección",
    collections: "Colecciones",
    create: "Crear",
    createPullRequest: "Crear solicitud de extracción",
    currentBranch: "Rama actual",
    dashboard: "Panel",
    defaultBranch: "Rama predeterminada",
    deleteBranch: "Eliminar rama",
    "delete": "Borrar",
    edit: "Editar",
    loading: "Cargando",
    newBranch: "Nueva sucursal",
    otherBranches: "Otras sucursales",
    save: "Ahorrar",
    pullRequests: "Solicitudes de extracción",
    search: "Buscar",
    singleton: "Semifallo",
    theCurrentlyCheckedOutBranch: "La sucursal actualmente desprotegida. Elija esto si necesita desarrollar el trabajo existente de la rama actual.",
    viewPullRequests: "Ver solicitudes de extracción",
    singletons: "Solteros",
    theDefaultBranchInYourRepository: "La rama predeterminada en su repositorio. Elija esto para comenzar algo nuevo que no dependa de su sucursal actual."
  },
  "et-EE": {
    add: "Lisama",
    basedOn: "Põhineb",
    branchName: "Filiaali nimi",
    branches: "Filiaalid",
    cancel: "Tühista",
    clear: "Puhasta",
    collection: "Kollektsioon",
    createPullRequest: "Loo tõmbamistaotlus",
    create: "Loo",
    collections: "Kollektsioonid",
    currentBranch: "Praegune filiaal",
    dashboard: "Armatuurlaud",
    defaultBranch: "Vaikeharu",
    deleteBranch: "Kustuta haru",
    "delete": "Kustuta",
    edit: "Muuda",
    loading: "Laadimine",
    newBranch: "Uus filiaal",
    otherBranches: "Muud oksad",
    pullRequests: "Tõmbetaotlused",
    save: "Salvesta",
    singleton: "üksikud",
    search: "Otsi",
    singletons: "Üksikud",
    theCurrentlyCheckedOutBranch: "Praegu välja registreeritud filiaal. Valige see, kui peate kasutama praeguse haru olemasolevaid töid.",
    theDefaultBranchInYourRepository: "Vaikeharu teie hoidlas. Valige see, et alustada midagi uut, mis ei sõltu teie praegusest harust.",
    viewPullRequests: "Vaadake tõmbamistaotlusi"
  },
  "fi-FI": {
    add: "Lisätä",
    basedOn: "Perustuen",
    branchName: "Sivukonttorin nimi",
    branches: "Oksat",
    cancel: "Tühista",
    clear: "Kirkas",
    collection: "Kokoelma",
    collections: "Kokoelmat",
    createPullRequest: "Luo vetopyyntö",
    defaultBranch: "Oletushaara",
    create: "Luoda",
    currentBranch: "Nykyinen haara",
    dashboard: "Kojelauta",
    "delete": "Poistaa",
    edit: "Muokata",
    deleteBranch: "Poista haara",
    loading: "Ladataan",
    newBranch: "Uusi haara",
    otherBranches: "Muut haarat",
    save: "Tallentaa",
    pullRequests: "Vedä pyyntöjä",
    search: "Hae",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Tällä hetkellä uloskirjautunut sivuliike. Valitse tämä, jos haluat rakentaa nykyisen haaran olemassa olevaan työhön.",
    theDefaultBranchInYourRepository: "Oletushaara arkistossasi. Valitse tämä aloittaaksesi jotain uutta, joka ei ole riippuvainen nykyisestä haarastasi.",
    viewPullRequests: "Näytä vetopyynnöt"
  },
  "fr-FR": {
    collection: "Collection",
    collections: "Collections",
    currentBranch: "Succursale actuelle",
    create: "Créer",
    dashboard: "Tableau de bord",
    defaultBranch: "Branche par défaut",
    "delete": "Supprimer",
    deleteBranch: "Supprimer la branche",
    edit: "Modifier",
    loading: "Chargement en cours",
    newBranch: "Nouvelle branche",
    otherBranches: "Autres succursales",
    pullRequests: "Demandes d'extraction",
    save: "Sauvegarder",
    search: "Rechercher",
    singleton: "Singleton",
    singletons: "Célibataires",
    theCurrentlyCheckedOutBranch: "La branche actuellement extraite. Choisissez cette option si vous devez vous appuyer sur le travail existant de la branche actuelle.",
    theDefaultBranchInYourRepository: "La branche par défaut de votre référentiel. Choisissez ceci pour commencer quelque chose de nouveau qui ne dépend pas de votre branche actuelle.",
    viewPullRequests: "Afficher les demandes d'extraction",
    createPullRequest: "Créer une demande d'extraction",
    basedOn: "Basé sur",
    add: "Ajouter",
    cancel: "Annuler",
    branches: "Branches",
    branchName: "Nom de la filiale",
    clear: "Effacer"
  },
  "en-US": {
    add: "Add",
    basedOn: "Based on",
    branchName: "Branch name",
    branches: "Branches",
    cancel: "Cancel",
    clear: "Clear",
    collection: "Collection",
    collections: "Collections",
    create: "Create",
    createPullRequest: "Create pull request",
    currentBranch: "Current branch",
    dashboard: "Dashboard",
    defaultBranch: "Default branch",
    "delete": "Delete",
    deleteBranch: "Delete branch",
    edit: "Edit",
    loading: "Loading",
    newBranch: "New branch…",
    otherBranches: "Other branches",
    pullRequests: "Pull requests",
    save: "Save",
    theCurrentlyCheckedOutBranch: "The currently checked out branch. Choose this if you need to build on existing work from the current branch.",
    singletons: "Singletons",
    search: "Search",
    viewPullRequests: "View pull requests",
    theDefaultBranchInYourRepository: "The default branch in your repository. Choose this to start something new that's not dependent on your current branch.",
    singleton: "Singleton"
  },
  "lv-LV": {
    add: "Pievienot",
    basedOn: "Balstoties uz",
    branches: "Nozares",
    branchName: "Filiāles nosaukums",
    clear: "Notīrīt",
    cancel: "Atcelt",
    collection: "Kolekcija",
    collections: "Kolekcijas",
    create: "Izveidot",
    createPullRequest: "Izveidot izvilkšanas pieprasījumu",
    currentBranch: "Pašreizējā filiāle",
    dashboard: "Mērinstrumentu panelis",
    "delete": "Dzēst",
    deleteBranch: "Dzēst filiāli",
    edit: "Rediģēt",
    defaultBranch: "Noklusējuma filiāle",
    loading: "Notiek ielāde",
    newBranch: "Jauna filiāle",
    otherBranches: "Citas filiāles",
    pullRequests: "Izvilkšanas pieprasījumi",
    save: "Saglabāt",
    search: "Meklēt",
    singleton: "Singleton",
    singletons: "Vientuļi",
    theCurrentlyCheckedOutBranch: "Pašlaik izrakstītā filiāle. Izvēlieties šo, ja vēlaties izmantot esošo darbu no pašreizējās filiāles.",
    theDefaultBranchInYourRepository: "Noklusējuma filiāle jūsu repozitorijā. Izvēlieties šo, lai sāktu kaut ko jaunu, kas nav atkarīgs no jūsu pašreizējās filiāles.",
    viewPullRequests: "Skatīt izvilkšanas pieprasījumus"
  },
  "lt-LT": {
    add: "Papildyti",
    basedOn: "Remiantis",
    branchName: "Filialo pavadinimas",
    branches: "Filialai",
    cancel: "Atšaukti",
    clear: "Skaidrus",
    collection: "Kolekcija",
    create: "Sukurti",
    collections: "Kolekcijos",
    createPullRequest: "Sukurti ištraukimo užklausą",
    currentBranch: "Dabartinis filialas",
    dashboard: "Prietaisų skydelis",
    defaultBranch: "Numatytoji šaka",
    "delete": "Ištrinti",
    deleteBranch: "Ištrinti šaką",
    edit: "Redaguoti",
    loading: "Įkeliama",
    newBranch: "Naujas filialas",
    otherBranches: "Kitos šakos",
    pullRequests: "Ištraukti užklausas",
    singletons: "Vienišiai",
    singleton: "vienvietis",
    theCurrentlyCheckedOutBranch: "Šiuo metu išregistruotas filialas. Pasirinkite tai, jei reikia remtis esamu darbu iš dabartinės šakos.",
    search: "Ieškoti",
    theDefaultBranchInYourRepository: "Numatytoji šaka jūsų saugykloje. Pasirinkite tai, kad pradėtumėte ką nors naujo, nepriklausančio nuo dabartinės šakos.",
    viewPullRequests: "Peržiūrėkite ištraukimo užklausas",
    save: "Sutaupyti"
  },
  "nb-NO": {
    add: "Legg til",
    basedOn: "Basert på",
    branches: "Grener",
    branchName: "Filialnavn",
    cancel: "Avbryt",
    clear: "Tøm",
    collection: "Samling",
    collections: "Samlinger",
    create: "Skape",
    createPullRequest: "Opprett pull-forespørsel",
    currentBranch: "Nåværende gren",
    dashboard: "Dashbord",
    defaultBranch: "Standard gren",
    "delete": "Slett",
    deleteBranch: "Slett filial",
    edit: "Redigere",
    loading: "Laster inn",
    newBranch: "Ny gren",
    otherBranches: "Andre grener",
    pullRequests: "Trekk forespørsler",
    save: "Lagre",
    singleton: "Singleton",
    search: "Søk",
    singletons: "Singletoner",
    theDefaultBranchInYourRepository: "Standardgrenen i depotet ditt. Velg dette for å starte noe nytt som ikke er avhengig av din nåværende filial.",
    theCurrentlyCheckedOutBranch: "Den utsjekkede grenen. Velg dette hvis du skal bygge på eksisterende arbeid fra gjeldende gren.",
    viewPullRequests: "Se pull-forespørsler"
  },
  "nl-NL": {
    add: "Toevoegen",
    basedOn: "Gebaseerd op",
    branchName: "Filiaal naam",
    branches: "Takken",
    clear: "Helder",
    cancel: "Annuleren",
    collection: "Verzameling",
    create: "Creëren",
    collections: "Collecties",
    currentBranch: "Huidige tak",
    createPullRequest: "Pull-aanvraag maken",
    dashboard: "Dashboard",
    "delete": "Verwijderen",
    deleteBranch: "Filiaal verwijderen",
    defaultBranch: "Standaard filiaal",
    edit: "Bewerking",
    loading: "Laden",
    newBranch: "Nieuwe tak",
    otherBranches: "Andere takken",
    pullRequests: "Trek verzoeken",
    search: "Zoeken",
    singleton: "eenling",
    save: "Redden",
    singletons: "Eenlingen",
    theCurrentlyCheckedOutBranch: "Het momenteel uitgecheckte filiaal. Kies dit als u moet voortbouwen op bestaand werk van de huidige branch.",
    theDefaultBranchInYourRepository: "De standaard branch in uw repository. Kies dit om iets nieuws te starten dat niet afhankelijk is van uw huidige branche.",
    viewPullRequests: "Bekijk pull-aanvragen"
  },
  "pl-PL": {
    add: "Dodać",
    basedOn: "Oparte na",
    branchName: "Nazwa filii",
    branches: "Gałęzie",
    cancel: "Anulować",
    clear: "Wyczyść",
    collections: "Kolekcje",
    collection: "Kolekcja",
    create: "Tworzyć",
    createPullRequest: "Utwórz żądanie ściągnięcia",
    defaultBranch: "Oddział domyślny",
    dashboard: "Panel",
    currentBranch: "Obecny oddział",
    "delete": "Usuwać",
    deleteBranch: "Usuń oddział",
    edit: "Edytować",
    loading: "Trwa ładowanie",
    newBranch: "Nowa gałąź",
    otherBranches: "Inne gałęzie",
    pullRequests: "Żądania ściągnięcia",
    save: "Ratować",
    search: "Szukaj",
    singleton: "singel",
    singletons: "Singletony",
    theCurrentlyCheckedOutBranch: "Aktualnie wyewidencjonowana gałąź. Wybierz tę opcję, jeśli chcesz oprzeć się na istniejącej pracy z bieżącej gałęzi.",
    theDefaultBranchInYourRepository: "Domyślna gałąź w twoim repozytorium. Wybierz tę opcję, aby rozpocząć coś nowego, co nie jest zależne od bieżącej gałęzi.",
    viewPullRequests: "Wyświetl żądania ściągnięcia"
  },
  "pt-BR": {
    add: "Adicionar",
    branchName: "Nome da filial",
    basedOn: "Baseado em",
    branches: "Galhos",
    collection: "Coleção",
    clear: "Limpar",
    cancel: "Cancelar",
    create: "Criar",
    createPullRequest: "Criar solicitação pull",
    currentBranch: "filial atual",
    collections: "Coleções",
    dashboard: "Painel",
    defaultBranch: "ramo padrão",
    "delete": "Excluir",
    deleteBranch: "Excluir ramificação",
    edit: "Editar",
    otherBranches: "Outros ramos",
    loading: "Carregando",
    newBranch: "Nova filial",
    save: "Guardar",
    pullRequests: "Requisições pull",
    singleton: "solteiro",
    search: "Pesquisar",
    singletons: "Solteiros",
    theCurrentlyCheckedOutBranch: "A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
    theDefaultBranchInYourRepository: "A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
    viewPullRequests: "Ver solicitações pull"
  },
  "pt-PT": {
    add: "Adicionar",
    basedOn: "Baseado em",
    branchName: "Nome da filial",
    branches: "Galhos",
    cancel: "Cancelar",
    clear: "Limpar",
    collection: "Coleção",
    collections: "Coleções",
    create: "Criar",
    createPullRequest: "Criar solicitação pull",
    dashboard: "Painel",
    currentBranch: "filial atual",
    defaultBranch: "ramo padrão",
    deleteBranch: "Excluir ramificação",
    "delete": "Excluir",
    edit: "Editar",
    newBranch: "Nova filial",
    loading: "A carregar",
    pullRequests: "Requisições pull",
    otherBranches: "Outros ramos",
    save: "Guardar",
    search: "Procurar",
    singleton: "solteiro",
    singletons: "Solteiros",
    theDefaultBranchInYourRepository: "A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
    theCurrentlyCheckedOutBranch: "A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
    viewPullRequests: "Ver solicitações pull"
  },
  "ro-RO": {
    add: "Adăuga",
    branchName: "Numele sucursalei",
    branches: "Ramuri",
    basedOn: "Bazat pe",
    cancel: "Anulare",
    clear: "Golire",
    collection: "Colectie",
    collections: "Colecții",
    create: "Crea",
    createPullRequest: "Creați cerere de tragere",
    currentBranch: "Filiala actuală",
    dashboard: "Bord",
    defaultBranch: "Ramura implicită",
    edit: "Editați",
    deleteBranch: "Ștergeți ramura",
    "delete": "Șterge",
    otherBranches: "Alte ramuri",
    newBranch: "Filiala noua",
    search: "Căutare",
    save: "Salvați",
    pullRequests: "Solicitări de tragere",
    singleton: "Singleton",
    loading: "Se încarcă",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Sucursala verificată în prezent. Alegeți acest lucru dacă trebuie să vă bazați pe munca existentă din ramura curentă.",
    theDefaultBranchInYourRepository: "Ramura implicită din depozitul dvs. Alegeți acest lucru pentru a începe ceva nou, care nu depinde de ramura dvs. actuală.",
    viewPullRequests: "Vizualizați solicitările de extragere"
  },
  "ru-RU": {
    add: "Добавлять",
    basedOn: "На основе",
    branchName: "Название филиала",
    branches: "Ветви",
    clear: "Очистить",
    cancel: "Отмена",
    collection: "Коллекция",
    collections: "Коллекции",
    create: "Создавать",
    createPullRequest: "Создать запрос на включение",
    currentBranch: "Текущая ветвь",
    dashboard: "Панель приборов",
    defaultBranch: "Ветка по умолчанию",
    "delete": "Удалить",
    deleteBranch: "Удалить ветку",
    loading: "Загрузка",
    edit: "Редактировать",
    newBranch: "Новая ветка",
    otherBranches: "Другие филиалы",
    pullRequests: "Пулл-реквесты",
    save: "Сохранять",
    search: "Поиск",
    singleton: "Синглтон",
    singletons: "Одиночки",
    theCurrentlyCheckedOutBranch: "Текущая проверенная ветвь. Выберите это, если вам нужно опираться на существующую работу из текущей ветки.",
    theDefaultBranchInYourRepository: "Ветка по умолчанию в вашем репозитории. Выберите это, чтобы начать что-то новое, не зависящее от вашей текущей ветки.",
    viewPullRequests: "Посмотреть пул-реквесты"
  },
  "sk-SK": {
    add: "Pridať",
    basedOn: "Založené na",
    branchName: "Meno pobočky",
    branches: "Pobočky",
    clear: "Vymazať",
    cancel: "Zrušiť",
    collections: "zbierky",
    collection: "Zbierka",
    create: "Vytvorte",
    createPullRequest: "Vytvorte požiadavku na stiahnutie",
    dashboard: "Dashboard",
    currentBranch: "Aktuálna pobočka",
    defaultBranch: "Predvolená vetva",
    "delete": "Odstrániť",
    deleteBranch: "Odstrániť vetvu",
    edit: "Upraviť",
    loading: "Načítava sa",
    newBranch: "Nová pobočka",
    otherBranches: "Ostatné pobočky",
    pullRequests: "Vytiahnite žiadosti",
    search: "Vyhľadávať",
    save: "Uložiť",
    singleton: "Singleton",
    singletons: "Singletons",
    theCurrentlyCheckedOutBranch: "Aktuálne odhlásená pobočka. Túto možnosť vyberte, ak potrebujete stavať na existujúcej práci z aktuálnej pobočky.",
    theDefaultBranchInYourRepository: "Predvolená vetva vo vašom úložisku. Zvoľte túto možnosť, ak chcete začať niečo nové, čo nezávisí od vašej aktuálnej pobočky.",
    viewPullRequests: "Zobraziť požiadavky na stiahnutie"
  },
  "sl-SI": {
    add: "Dodaj",
    basedOn: "Temelji na",
    branches: "Podružnice",
    branchName: "Ime podružnice",
    cancel: "Prekliči",
    clear: "Jasen",
    collection: "Zbirka",
    collections: "Zbirke",
    create: "Ustvari",
    currentBranch: "Trenutna veja",
    defaultBranch: "Privzeta veja",
    createPullRequest: "Ustvari zahtevo za vleko",
    dashboard: "Nadzorna plošča",
    "delete": "Izbriši",
    edit: "Uredi",
    loading: "Nalaganje",
    deleteBranch: "Izbriši vejo",
    newBranch: "Nova podružnica",
    save: "Shrani",
    pullRequests: "Zahteve za vlečenje",
    otherBranches: "Druge veje",
    search: "Iskanje",
    singleton: "Singleton",
    singletons: "Samski",
    theCurrentlyCheckedOutBranch: "Trenutno odjavljena podružnica. To izberite, če morate graditi na obstoječem delu iz trenutne veje.",
    theDefaultBranchInYourRepository: "Privzeta veja v vašem skladišču. Izberite to, da začnete nekaj novega, kar ni odvisno od vaše trenutne veje.",
    viewPullRequests: "Oglejte si zahteve za vlečenje"
  },
  "sr-SP": {
    basedOn: "На бази",
    add: "Додати",
    branchName: "Назив огранка",
    branches: "Огранци",
    cancel: "Поништити, отказати",
    clear: "Izbriši",
    collections: "Збирке",
    collection: "Цоллецтион",
    create: "Креирај",
    currentBranch: "Тренутна грана",
    dashboard: "Командна табла",
    createPullRequest: "Креирајте захтев за повлачење",
    defaultBranch: "Подразумевана грана",
    "delete": "Избриши",
    edit: "Уредити",
    loading: "Učitavam",
    newBranch: "Нова грана",
    otherBranches: "Остале гране",
    deleteBranch: "Обриши грану",
    pullRequests: "Захтеви за повлачење",
    search: "Pretraga",
    singleton: "Синглетон",
    save: "сачувати",
    singletons: "Синглетонс",
    theCurrentlyCheckedOutBranch: "Тренутно одјављена филијала. Изаберите ово ако треба да надоградите постојећи рад из тренутне гране.",
    theDefaultBranchInYourRepository: "Подразумевана грана у вашем спремишту. Изаберите ово да започнете нешто ново што не зависи од ваше тренутне гране.",
    viewPullRequests: "Прегледајте захтеве за повлачењем"
  },
  "sv-SE": {
    add: "Lägg till",
    basedOn: "Baserat på",
    branches: "Grenar",
    branchName: "Filialens namn",
    cancel: "Поништити, отказати",
    clear: "Rensa",
    collection: "Samling",
    collections: "Samlingar",
    createPullRequest: "Skapa pull-förfrågan",
    create: "Skapa",
    currentBranch: "Nuvarande gren",
    dashboard: "instrumentbräda",
    defaultBranch: "Standardgren",
    "delete": "Radera",
    deleteBranch: "Ta bort gren",
    edit: "Redigera",
    loading: "Läser in",
    otherBranches: "Andra grenar",
    newBranch: "Ny gren",
    pullRequests: "Dra förfrågningar",
    search: "Sök",
    save: "Spara",
    singleton: "Singleton",
    singletons: "Singlar",
    theCurrentlyCheckedOutBranch: "Den utcheckade filialen. Välj detta om du behöver bygga på befintligt arbete från den aktuella grenen.",
    theDefaultBranchInYourRepository: "Standardgrenen i ditt arkiv. Välj detta för att starta något nytt som inte är beroende av din nuvarande filial.",
    viewPullRequests: "Visa pull-förfrågningar"
  },
  "tr-TR": {
    add: "Avbryt",
    basedOn: "Dayalı",
    branches: "Şubeler",
    branchName: "şube adı",
    cancel: "iptal etmek",
    clear: "Temizle",
    collection: "Toplamak",
    collections: "Koleksiyonlar",
    createPullRequest: "Çekme isteği oluştur",
    create: "Yaratmak",
    defaultBranch: "varsayılan dal",
    dashboard: "Gösterge Paneli",
    currentBranch: "Mevcut şube",
    "delete": "Silmek",
    deleteBranch: "Şubeyi sil",
    edit: "Düzenlemek",
    loading: "Yükleniyor",
    newBranch: "Yeni dal",
    otherBranches: "Diğer şubeler",
    save: "Kaydetmek",
    pullRequests: "Çekme istekleri",
    singleton: "Tekil",
    singletons: "Singleton'lar",
    theCurrentlyCheckedOutBranch: "Şu anda kontrol edilen şube. Geçerli daldaki mevcut işi geliştirmeniz gerekiyorsa bunu seçin.",
    viewPullRequests: "Çekme isteklerini görüntüle",
    search: "Ara",
    theDefaultBranchInYourRepository: "Deponuzdaki varsayılan şube. Mevcut şubenize bağlı olmayan yeni bir şey başlatmak için bunu seçin."
  },
  "uk-UA": {
    add: "додати",
    basedOn: "На основі",
    branchName: "Назва гілки",
    branches: "Відділення",
    cancel: "скасувати",
    clear: "Очистити",
    collection: "Колекція",
    collections: "Колекції",
    create: "Створити",
    createPullRequest: "Створити запит на отримання",
    currentBranch: "Поточне відділення",
    dashboard: "Панель приладів",
    defaultBranch: "Гілка за замовчуванням",
    "delete": "Видалити",
    deleteBranch: "Видалити гілку",
    edit: "Редагувати",
    newBranch: "Нова гілка",
    loading: "Завантаження",
    otherBranches: "Інші гілки",
    pullRequests: "Запити на витягування",
    save: "зберегти",
    search: "Пошук",
    singleton: "Синглтон",
    singletons: "Одиночки",
    viewPullRequests: "Перегляд запитів на отримання",
    theDefaultBranchInYourRepository: "Стандартна гілка у вашому сховищі. Виберіть це, щоб почати щось нове, що не залежить від вашої поточної гілки.",
    theCurrentlyCheckedOutBranch: "Поточна перевірена гілка. Виберіть це, якщо вам потрібно створити на основі існуючої роботи з поточної гілки."
  },
  "zh-CN": {
    add: "添加",
    basedOn: "基于",
    branchName: "分店名称",
    branches: "分支机构",
    cancel: "取消",
    clear: "透明",
    collections: "收藏品",
    collection: "收藏",
    create: "创造",
    createPullRequest: "创建拉取请求",
    currentBranch: "当前分支",
    dashboard: "仪表板",
    defaultBranch: "默认分支",
    "delete": "删除",
    deleteBranch: "删除分支",
    edit: "编辑",
    loading: "正在加载",
    newBranch: "新分行",
    otherBranches: "其他分行",
    pullRequests: "拉取请求",
    save: "节省",
    singleton: "单例",
    search: "搜索",
    theCurrentlyCheckedOutBranch: "当前签出的分支。 如果您需要在当前分支的现有工作的基础上构建，请选择此项。",
    singletons: "单例",
    theDefaultBranchInYourRepository: "存储库中的默认分支。 选择此选项可开始一些不依赖于当前分支的新操作。",
    viewPullRequests: "查看拉取请求"
  },
  "zh-TW": {
    add: "添加",
    basedOn: "基於",
    branchName: "分店名稱",
    branches: "分支機構",
    cancel: "取消",
    clear: "清除",
    collection: "收藏",
    collections: "收藏品",
    create: "創造",
    createPullRequest: "創建拉取請求",
    dashboard: "儀表板",
    currentBranch: "當前分支",
    deleteBranch: "刪除分支",
    defaultBranch: "默認分支",
    "delete": "刪除",
    edit: "編輯",
    newBranch: "新分行",
    loading: "正在載入",
    otherBranches: "其他分行",
    pullRequests: "拉取請求",
    save: "節省",
    search: "搜尋",
    singleton: "單例",
    singletons: "單例",
    theCurrentlyCheckedOutBranch: "當前簽出的分支。 如果您需要在當前分支的現有工作的基礎上構建，請選擇此項。",
    theDefaultBranchInYourRepository: "存儲庫中的默認分支。 選擇此選項可開始一些不依賴於當前分支的新操作。",
    viewPullRequests: "查看拉取請求"
  }
};
globalThis.Prism = {
  manual: true
};
var _self = globalThis;
var Prism = function(_self2) {
  var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
  var uniqueId = 0;
  var plainTextGrammar = {};
  var _2 = {
    /**
     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
     * additional languages or plugins yourself.
     *
     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
     *
     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.manual = true;
     * // add a new <script> to load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */
    manual: _self2.Prism && _self2.Prism.manual,
    /**
     * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
     * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
     * own worker, you don't want it to do this.
     *
     * By setting this value to `true`, Prism will not add its own listeners to the worker.
     *
     * You obviously have to change this value before Prism executes. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.disableWorkerMessageHandler = true;
     * // Load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */
    disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
    /**
     * A namespace for utility methods.
     *
     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
     * change or disappear at any time.
     *
     * @namespace
     * @memberof Prism
     */
    util: {
      encode: function encode(tokens) {
        if (tokens instanceof Token2) {
          return new Token2(tokens.type, encode(tokens.content), tokens.alias);
        } else if (Array.isArray(tokens)) {
          return tokens.map(encode);
        } else {
          return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        }
      },
      /**
       * Returns the name of the type of the given value.
       *
       * @param {any} o
       * @returns {string}
       * @example
       * type(null)      === 'Null'
       * type(undefined) === 'Undefined'
       * type(123)       === 'Number'
       * type('foo')     === 'String'
       * type(true)      === 'Boolean'
       * type([1, 2])    === 'Array'
       * type({})        === 'Object'
       * type(String)    === 'Function'
       * type(/abc+/)    === 'RegExp'
       */
      type: function(o5) {
        return Object.prototype.toString.call(o5).slice(8, -1);
      },
      /**
       * Returns a unique number for the given object. Later calls will still return the same number.
       *
       * @param {Object} obj
       * @returns {number}
       */
      objId: function(obj) {
        if (!obj["__id"]) {
          Object.defineProperty(obj, "__id", {
            value: ++uniqueId
          });
        }
        return obj["__id"];
      },
      /**
       * Creates a deep clone of the given object.
       *
       * The main intended use of this function is to clone language definitions.
       *
       * @param {T} o
       * @param {Record<number, any>} [visited]
       * @returns {T}
       * @template T
       */
      clone: function deepClone(o5, visited) {
        visited = visited || {};
        var clone;
        var id;
        switch (_2.util.type(o5)) {
          case "Object":
            id = _2.util.objId(o5);
            if (visited[id]) {
              return visited[id];
            }
            clone = /** @type {Record<string, any>} */
            {};
            visited[id] = clone;
            for (var key in o5) {
              if (o5.hasOwnProperty(key)) {
                clone[key] = deepClone(o5[key], visited);
              }
            }
            return (
              /** @type {any} */
              clone
            );
          case "Array":
            id = _2.util.objId(o5);
            if (visited[id]) {
              return visited[id];
            }
            clone = [];
            visited[id] = clone;
            o5.forEach(function(v5, i6) {
              clone[i6] = deepClone(v5, visited);
            });
            return (
              /** @type {any} */
              clone
            );
          default:
            return o5;
        }
      },
      /**
       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
       *
       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
       *
       * @param {Element} element
       * @returns {string}
       */
      getLanguage: function(element2) {
        while (element2) {
          var m2 = lang.exec(element2.className);
          if (m2) {
            return m2[1].toLowerCase();
          }
          element2 = element2.parentElement;
        }
        return "none";
      },
      /**
       * Sets the Prism `language-xxxx` class of the given element.
       *
       * @param {Element} element
       * @param {string} language
       * @returns {void}
       */
      setLanguage: function(element2, language) {
        element2.className = element2.className.replace(RegExp(lang, "gi"), "");
        element2.classList.add("language-" + language);
      },
      /**
       * Returns the script element that is currently executing.
       *
       * This does __not__ work for line script element.
       *
       * @returns {HTMLScriptElement | null}
       */
      currentScript: function() {
        if (typeof document === "undefined") {
          return null;
        }
        if ("currentScript" in document && 1 < 2) {
          return (
            /** @type {any} */
            document.currentScript
          );
        }
        try {
          throw new Error();
        } catch (err) {
          var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
          if (src) {
            var scripts = document.getElementsByTagName("script");
            for (var i6 in scripts) {
              if (scripts[i6].src == src) {
                return scripts[i6];
              }
            }
          }
          return null;
        }
      },
      /**
       * Returns whether a given class is active for `element`.
       *
       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
       * given class is just the given class with a `no-` prefix.
       *
       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
       * ancestors have the given class or the negated version of it, then the default activation will be returned.
       *
       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
       * version of it, the class is considered active.
       *
       * @param {Element} element
       * @param {string} className
       * @param {boolean} [defaultActivation=false]
       * @returns {boolean}
       */
      isActive: function(element2, className, defaultActivation) {
        var no = "no-" + className;
        while (element2) {
          var classList = element2.classList;
          if (classList.contains(className)) {
            return true;
          }
          if (classList.contains(no)) {
            return false;
          }
          element2 = element2.parentElement;
        }
        return !!defaultActivation;
      }
    },
    /**
     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
     *
     * @namespace
     * @memberof Prism
     * @public
     */
    languages: {
      /**
       * The grammar for plain, unformatted text.
       */
      plain: plainTextGrammar,
      plaintext: plainTextGrammar,
      text: plainTextGrammar,
      txt: plainTextGrammar,
      /**
       * Creates a deep copy of the language with the given id and appends the given tokens.
       *
       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
       * will be overwritten at its original position.
       *
       * ## Best practices
       *
       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
       *
       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
       *
       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
       * @param {Grammar} redef The new tokens to append.
       * @returns {Grammar} The new language created.
       * @public
       * @example
       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
       *     // at its original position
       *     'comment': { ... },
       *     // CSS doesn't have a 'color' token, so this token will be appended
       *     'color': /\b(?:red|green|blue)\b/
       * });
       */
      extend: function(id, redef) {
        var lang2 = _2.util.clone(_2.languages[id]);
        for (var key in redef) {
          lang2[key] = redef[key];
        }
        return lang2;
      },
      /**
       * Inserts tokens _before_ another token in a language definition or any other grammar.
       *
       * ## Usage
       *
       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
       * this:
       *
       * ```js
       * Prism.languages.markup.style = {
       *     // token
       * };
       * ```
       *
       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
       * before existing tokens. For the CSS example above, you would use it like this:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'cdata', {
       *     'style': {
       *         // token
       *     }
       * });
       * ```
       *
       * ## Special cases
       *
       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
       * will be ignored.
       *
       * This behavior can be used to insert tokens after `before`:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'comment', {
       *     'comment': Prism.languages.markup.comment,
       *     // tokens after 'comment'
       * });
       * ```
       *
       * ## Limitations
       *
       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
       * deleting properties which is necessary to insert at arbitrary positions.
       *
       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
       * Instead, it will create a new object and replace all references to the target object with the new one. This
       * can be done without temporarily deleting properties, so the iteration order is well-defined.
       *
       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
       * you hold the target object in a variable, then the value of the variable will not change.
       *
       * ```js
       * var oldMarkup = Prism.languages.markup;
       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
       *
       * assert(oldMarkup !== Prism.languages.markup);
       * assert(newMarkup === Prism.languages.markup);
       * ```
       *
       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
       * object to be modified.
       * @param {string} before The key to insert before.
       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
       * object to be modified.
       *
       * Defaults to `Prism.languages`.
       * @returns {Grammar} The new grammar object.
       * @public
       */
      insertBefore: function(inside, before, insert, root) {
        root = root || /** @type {any} */
        _2.languages;
        var grammar = root[inside];
        var ret = {};
        for (var token2 in grammar) {
          if (grammar.hasOwnProperty(token2)) {
            if (token2 == before) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }
            if (!insert.hasOwnProperty(token2)) {
              ret[token2] = grammar[token2];
            }
          }
        }
        var old = root[inside];
        root[inside] = ret;
        _2.languages.DFS(_2.languages, function(key, value2) {
          if (value2 === old && key != inside) {
            this[key] = ret;
          }
        });
        return ret;
      },
      // Traverse a language definition with Depth First Search
      DFS: function DFS(o5, callback, type2, visited) {
        visited = visited || {};
        var objId = _2.util.objId;
        for (var i6 in o5) {
          if (o5.hasOwnProperty(i6)) {
            callback.call(o5, i6, o5[i6], type2 || i6);
            var property = o5[i6];
            var propertyType = _2.util.type(property);
            if (propertyType === "Object" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, null, visited);
            } else if (propertyType === "Array" && !visited[objId(property)]) {
              visited[objId(property)] = true;
              DFS(property, callback, i6, visited);
            }
          }
        }
      }
    },
    plugins: {},
    /**
     * This is the most high-level function in Prism’s API.
     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
     * each one of them.
     *
     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
     *
     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
     * @memberof Prism
     * @public
     */
    highlightAll: function(async, callback) {
      _2.highlightAllUnder(document, async, callback);
    },
    /**
     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
     * {@link Prism.highlightElement} on each one of them.
     *
     * The following hooks will be run:
     * 1. `before-highlightall`
     * 2. `before-all-elements-highlight`
     * 3. All hooks of {@link Prism.highlightElement} for each element.
     *
     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
     * @memberof Prism
     * @public
     */
    highlightAllUnder: function(container, async, callback) {
      var env = {
        callback,
        container,
        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
      };
      _2.hooks.run("before-highlightall", env);
      env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
      _2.hooks.run("before-all-elements-highlight", env);
      for (var i6 = 0, element2; element2 = env.elements[i6++]; ) {
        _2.highlightElement(element2, async === true, env.callback);
      }
    },
    /**
     * Highlights the code inside a single element.
     *
     * The following hooks will be run:
     * 1. `before-sanity-check`
     * 2. `before-highlight`
     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
     * 4. `before-insert`
     * 5. `after-highlight`
     * 6. `complete`
     *
     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
     * the element's language.
     *
     * @param {Element} element The element containing the code.
     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
     *
     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
     * asynchronous highlighting to work. You can build your own bundle on the
     * [Download page](https://prismjs.com/download.html).
     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
     * @memberof Prism
     * @public
     */
    highlightElement: function(element2, async, callback) {
      var language = _2.util.getLanguage(element2);
      var grammar = _2.languages[language];
      _2.util.setLanguage(element2, language);
      var parent = element2.parentElement;
      if (parent && parent.nodeName.toLowerCase() === "pre") {
        _2.util.setLanguage(parent, language);
      }
      var code2 = element2.textContent;
      var env = {
        element: element2,
        language,
        grammar,
        code: code2
      };
      function insertHighlightedCode(highlightedCode) {
        env.highlightedCode = highlightedCode;
        _2.hooks.run("before-insert", env);
        env.element.innerHTML = env.highlightedCode;
        _2.hooks.run("after-highlight", env);
        _2.hooks.run("complete", env);
        callback && callback.call(env.element);
      }
      _2.hooks.run("before-sanity-check", env);
      parent = env.element.parentElement;
      if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
        parent.setAttribute("tabindex", "0");
      }
      if (!env.code) {
        _2.hooks.run("complete", env);
        callback && callback.call(env.element);
        return;
      }
      _2.hooks.run("before-highlight", env);
      if (!env.grammar) {
        insertHighlightedCode(_2.util.encode(env.code));
        return;
      }
      if (async && _self2.Worker) {
        var worker = new Worker(_2.filename);
        worker.onmessage = function(evt) {
          insertHighlightedCode(evt.data);
        };
        worker.postMessage(JSON.stringify({
          language: env.language,
          code: env.code,
          immediateClose: true
        }));
      } else {
        insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
      }
    },
    /**
     * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
     * and the language definitions to use, and returns a string with the HTML produced.
     *
     * The following hooks will be run:
     * 1. `before-tokenize`
     * 2. `after-tokenize`
     * 3. `wrap`: On each {@link Token}.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @param {string} language The name of the language definition passed to `grammar`.
     * @returns {string} The highlighted HTML.
     * @memberof Prism
     * @public
     * @example
     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
     */
    highlight: function(text3, grammar, language) {
      var env = {
        code: text3,
        grammar,
        language
      };
      _2.hooks.run("before-tokenize", env);
      if (!env.grammar) {
        throw new Error('The language "' + env.language + '" has no grammar.');
      }
      env.tokens = _2.tokenize(env.code, env.grammar);
      _2.hooks.run("after-tokenize", env);
      return Token2.stringify(_2.util.encode(env.tokens), env.language);
    },
    /**
     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
     * and the language definitions to use, and returns an array with the tokenized code.
     *
     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
     *
     * This method could be useful in other contexts as well, as a very crude parser.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @returns {TokenStream} An array of strings and tokens, a token stream.
     * @memberof Prism
     * @public
     * @example
     * let code = `var foo = 0;`;
     * let tokens = Prism.tokenize(code, Prism.languages.javascript);
     * tokens.forEach(token => {
     *     if (token instanceof Prism.Token && token.type === 'number') {
     *         console.log(`Found numeric literal: ${token.content}`);
     *     }
     * });
     */
    tokenize: function(text3, grammar) {
      var rest = grammar.rest;
      if (rest) {
        for (var token2 in rest) {
          grammar[token2] = rest[token2];
        }
        delete grammar.rest;
      }
      var tokenList = new LinkedList();
      addAfter(tokenList, tokenList.head, text3);
      matchGrammar(text3, tokenList, grammar, tokenList.head, 0);
      return toArray(tokenList);
    },
    /**
     * @namespace
     * @memberof Prism
     * @public
     */
    hooks: {
      all: {},
      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string} name The name of the hook.
       * @param {HookCallback} callback The callback function which is given environment variables.
       * @public
       */
      add: function(name2, callback) {
        var hooks = _2.hooks.all;
        hooks[name2] = hooks[name2] || [];
        hooks[name2].push(callback);
      },
      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run: function(name2, env) {
        var callbacks2 = _2.hooks.all[name2];
        if (!callbacks2 || !callbacks2.length) {
          return;
        }
        for (var i6 = 0, callback; callback = callbacks2[i6++]; ) {
          callback(env);
        }
      }
    },
    Token: Token2
  };
  _self2.Prism = _2;
  function Token2(type2, content, alias, matchedStr) {
    this.type = type2;
    this.content = content;
    this.alias = alias;
    this.length = (matchedStr || "").length | 0;
  }
  Token2.stringify = function stringify3(o5, language) {
    if (typeof o5 == "string") {
      return o5;
    }
    if (Array.isArray(o5)) {
      var s4 = "";
      o5.forEach(function(e6) {
        s4 += stringify3(e6, language);
      });
      return s4;
    }
    var env = {
      type: o5.type,
      content: stringify3(o5.content, language),
      tag: "span",
      classes: ["token", o5.type],
      attributes: {},
      language
    };
    var aliases = o5.alias;
    if (aliases) {
      if (Array.isArray(aliases)) {
        Array.prototype.push.apply(env.classes, aliases);
      } else {
        env.classes.push(aliases);
      }
    }
    _2.hooks.run("wrap", env);
    var attributes = "";
    for (var name2 in env.attributes) {
      attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
    }
    return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
  };
  function matchPattern(pattern, pos, text3, lookbehind) {
    pattern.lastIndex = pos;
    var match3 = pattern.exec(text3);
    if (match3 && lookbehind && match3[1]) {
      var lookbehindLength = match3[1].length;
      match3.index += lookbehindLength;
      match3[0] = match3[0].slice(lookbehindLength);
    }
    return match3;
  }
  function matchGrammar(text3, tokenList, grammar, startNode, startPos, rematch) {
    for (var token2 in grammar) {
      if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
        continue;
      }
      var patterns = grammar[token2];
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      for (var j3 = 0; j3 < patterns.length; ++j3) {
        if (rematch && rematch.cause == token2 + "," + j3) {
          return;
        }
        var patternObj = patterns[j3];
        var inside = patternObj.inside;
        var lookbehind = !!patternObj.lookbehind;
        var greedy = !!patternObj.greedy;
        var alias = patternObj.alias;
        if (greedy && !patternObj.pattern.global) {
          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
          patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
        }
        var pattern = patternObj.pattern || patternObj;
        for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
          if (rematch && pos >= rematch.reach) {
            break;
          }
          var str = currentNode.value;
          if (tokenList.length > text3.length) {
            return;
          }
          if (str instanceof Token2) {
            continue;
          }
          var removeCount = 1;
          var match3;
          if (greedy) {
            match3 = matchPattern(pattern, pos, text3, lookbehind);
            if (!match3 || match3.index >= text3.length) {
              break;
            }
            var from2 = match3.index;
            var to = match3.index + match3[0].length;
            var p5 = pos;
            p5 += currentNode.value.length;
            while (from2 >= p5) {
              currentNode = currentNode.next;
              p5 += currentNode.value.length;
            }
            p5 -= currentNode.value.length;
            pos = p5;
            if (currentNode.value instanceof Token2) {
              continue;
            }
            for (var k2 = currentNode; k2 !== tokenList.tail && (p5 < to || typeof k2.value === "string"); k2 = k2.next) {
              removeCount++;
              p5 += k2.value.length;
            }
            removeCount--;
            str = text3.slice(pos, p5);
            match3.index -= pos;
          } else {
            match3 = matchPattern(pattern, 0, str, lookbehind);
            if (!match3) {
              continue;
            }
          }
          var from2 = match3.index;
          var matchStr = match3[0];
          var before = str.slice(0, from2);
          var after = str.slice(from2 + matchStr.length);
          var reach = pos + str.length;
          if (rematch && reach > rematch.reach) {
            rematch.reach = reach;
          }
          var removeFrom = currentNode.prev;
          if (before) {
            removeFrom = addAfter(tokenList, removeFrom, before);
            pos += before.length;
          }
          removeRange(tokenList, removeFrom, removeCount);
          var wrapped = new Token2(token2, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
          currentNode = addAfter(tokenList, removeFrom, wrapped);
          if (after) {
            addAfter(tokenList, currentNode, after);
          }
          if (removeCount > 1) {
            var nestedRematch = {
              cause: token2 + "," + j3,
              reach
            };
            matchGrammar(text3, tokenList, grammar, currentNode.prev, pos, nestedRematch);
            if (rematch && nestedRematch.reach > rematch.reach) {
              rematch.reach = nestedRematch.reach;
            }
          }
        }
      }
    }
  }
  function LinkedList() {
    var head = {
      value: null,
      prev: null,
      next: null
    };
    var tail = {
      value: null,
      prev: head,
      next: null
    };
    head.next = tail;
    this.head = head;
    this.tail = tail;
    this.length = 0;
  }
  function addAfter(list2, node3, value2) {
    var next2 = node3.next;
    var newNode = {
      value: value2,
      prev: node3,
      next: next2
    };
    node3.next = newNode;
    next2.prev = newNode;
    list2.length++;
    return newNode;
  }
  function removeRange(list2, node3, count) {
    var next2 = node3.next;
    for (var i6 = 0; i6 < count && next2 !== list2.tail; i6++) {
      next2 = next2.next;
    }
    node3.next = next2;
    next2.prev = node3;
    list2.length -= i6;
  }
  function toArray(list2) {
    var array = [];
    var node3 = list2.head.next;
    while (node3 !== list2.tail) {
      array.push(node3.value);
      node3 = node3.next;
    }
    return array;
  }
  if (!_self2.document) {
    if (!_self2.addEventListener) {
      return _2;
    }
    if (!_2.disableWorkerMessageHandler) {
      _self2.addEventListener("message", function(evt) {
        var message = JSON.parse(evt.data);
        var lang2 = message.language;
        var code2 = message.code;
        var immediateClose = message.immediateClose;
        _self2.postMessage(_2.highlight(code2, _2.languages[lang2], lang2));
        if (immediateClose) {
          _self2.close();
        }
      }, false);
    }
    return _2;
  }
  var script = _2.util.currentScript();
  if (script) {
    _2.filename = script.src;
    if (script.hasAttribute("data-manual")) {
      _2.manual = true;
    }
  }
  function highlightAutomaticallyCallback() {
    if (!_2.manual) {
      _2.highlightAll();
    }
  }
  if (!_2.manual) {
    var readyState = document.readyState;
    if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
      document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
    } else {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(highlightAutomaticallyCallback);
      } else {
        window.setTimeout(highlightAutomaticallyCallback, 16);
      }
    }
  }
  return _2;
}(_self);
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, {
            pattern: /^(\s*)["']|["']$/,
            lookbehind: true
          }]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined(tagName3, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName3] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName3;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism2) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
Prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [Prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function() {
  if (typeof Prism === "undefined" || typeof document === "undefined") {
    return;
  }
  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  }
  var LOADING_MESSAGE = "Loading…";
  var FAILURE_MESSAGE = function(status, message) {
    return "✖ Error " + status + " while fetching file: " + message;
  };
  var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
  var EXTENSIONS = {
    "js": "javascript",
    "py": "python",
    "rb": "ruby",
    "ps1": "powershell",
    "psm1": "powershell",
    "sh": "bash",
    "bat": "batch",
    "h": "c",
    "tex": "latex"
  };
  var STATUS_ATTR = "data-src-status";
  var STATUS_LOADING = "loading";
  var STATUS_LOADED = "loaded";
  var STATUS_FAILED = "failed";
  var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
  function loadFile(src, success, error3) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", src, true);
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) {
        if (xhr.status < 400 && xhr.responseText) {
          success(xhr.responseText);
        } else {
          if (xhr.status >= 400) {
            error3(FAILURE_MESSAGE(xhr.status, xhr.statusText));
          } else {
            error3(FAILURE_EMPTY_MESSAGE);
          }
        }
      }
    };
    xhr.send(null);
  }
  function parseRange(range) {
    var m2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
    if (m2) {
      var start2 = Number(m2[1]);
      var comma = m2[2];
      var end = m2[3];
      if (!comma) {
        return [start2, start2];
      }
      if (!end) {
        return [start2, void 0];
      }
      return [start2, Number(end)];
    }
    return void 0;
  }
  Prism.hooks.add("before-highlightall", function(env) {
    env.selector += ", " + SELECTOR;
  });
  Prism.hooks.add("before-sanity-check", function(env) {
    var pre = (
      /** @type {HTMLPreElement} */
      env.element
    );
    if (pre.matches(SELECTOR)) {
      env.code = "";
      pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
      var code2 = pre.appendChild(document.createElement("CODE"));
      code2.textContent = LOADING_MESSAGE;
      var src = pre.getAttribute("data-src");
      var language = env.language;
      if (language === "none") {
        var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
        language = EXTENSIONS[extension] || extension;
      }
      Prism.util.setLanguage(code2, language);
      Prism.util.setLanguage(pre, language);
      var autoloader = Prism.plugins.autoloader;
      if (autoloader) {
        autoloader.loadLanguages(language);
      }
      loadFile(src, function(text3) {
        pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
        var range = parseRange(pre.getAttribute("data-range"));
        if (range) {
          var lines = text3.split(/\r\n?|\n/g);
          var start2 = range[0];
          var end = range[1] == null ? lines.length : range[1];
          if (start2 < 0) {
            start2 += lines.length;
          }
          start2 = Math.max(0, Math.min(start2 - 1, lines.length));
          if (end < 0) {
            end += lines.length;
          }
          end = Math.max(0, Math.min(end, lines.length));
          text3 = lines.slice(start2, end).join("\n");
          if (!pre.hasAttribute("data-start")) {
            pre.setAttribute("data-start", String(start2 + 1));
          }
        }
        code2.textContent = text3;
        Prism.highlightElement(code2);
      }, function(error3) {
        pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
        code2.textContent = error3;
      });
    }
  });
  Prism.plugins.fileHighlight = {
    /**
     * Executes the File Highlight plugin for all matching `pre` elements under the given container.
     *
     * Note: Elements which are already loaded or currently loading will not be touched by this method.
     *
     * @param {ParentNode} [container=document]
     */
    highlight: function highlight(container) {
      var elements = (container || document).querySelectorAll(SELECTOR);
      for (var i6 = 0, element2; element2 = elements[i6++]; ) {
        Prism.highlightElement(element2);
      }
    }
  };
  var logged = false;
  Prism.fileHighlight = function() {
    if (!logged) {
      console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
      logged = true;
    }
    Prism.plugins.fileHighlight.highlight.apply(this, arguments);
  };
})();
Prism.languages.clike = {
  "comment": [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true,
    greedy: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    lookbehind: true,
    inside: {
      "punctuation": /[.\\]/
    }
  },
  "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
  "boolean": /\b(?:false|true)\b/,
  "function": /\b\w+(?=\()/,
  "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
  "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [{
        // highlight the path of the include statement as a string
        pattern: /^(#\s*include\s*)<[^>]+>/,
        lookbehind: true
      }, Prism.languages.c["string"]],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [{
        pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
        lookbehind: true
      }, {
        pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
        lookbehind: true,
        alias: "function"
      }],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + // header-name
      /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
      /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
        return modName;
      }) + ")"),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);
Prism.languages.arduino = Prism.languages.extend("cpp", {
  "keyword": /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
  "constant": /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
  "builtin": /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
});
Prism.languages.ino = Prism.languages.arduino;
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [{
            pattern: /(^\$\(\([\s\S]+)\)\)/,
            lookbehind: true
          }, /^\$\(\(/],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    // Highlight parameter names as variables
    "parameter": {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = ["comment", "function-name", "for-or-select", "assign-left", "parameter", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"];
  var inside = insideString.variable[1].inside;
  for (var i6 = 0; i6 < toBeCopied.length; i6++) {
    inside[toBeCopied[i6]] = Prism2.languages.bash[toBeCopied[i6]];
  }
  Prism2.languages.sh = Prism2.languages.bash;
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);
(function(Prism2) {
  function replace2(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
      return "(?:" + replacements[+index2] + ")";
    });
  }
  function re(pattern, replacements, flags) {
    return RegExp(replace2(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i6 = 0; i6 < depthLog2; i6++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    // keywords which represent a return or variable type
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    // keywords which are used to declare a type
    typeDeclaration: "class enum interface record struct",
    // contextual keywords
    // ("var" and "dynamic" are missing because they are used like types)
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    // all other keywords
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name2 = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace2(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
  var identifier2 = replace2(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace2(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier2, array]);
  var tupleElement = replace2(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
  var tuple = replace2(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace2(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier2, array]);
  var typeInside = {
    "keyword": keywords,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character2 = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism2.languages.csharp = Prism2.languages.extend("clike", {
    "string": [{
      pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
      lookbehind: true,
      greedy: true
    }, {
      pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
      lookbehind: true,
      greedy: true
    }],
    "class-name": [{
      // Using static
      // using static System.Math;
      pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier2]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (type)
      // using Project = PC.MyCompany.Project;
      pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name2, typeExpression]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Using alias (alias)
      // using Project = PC.MyCompany.Project;
      pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
      lookbehind: true
    }, {
      // Type declarations
      // class Foo<A, B>
      // interface Foo<out A, B>
      pattern: re(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Single catch exception declaration
      // catch(Foo)
      // (things like catch(Foo e) is covered by variable declaration)
      pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier2]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Name of the type parameter of generic constraints
      // where Foo : class
      pattern: re(/(\bwhere\s+)<<0>>/.source, [name2]),
      lookbehind: true
    }, {
      // Casts and checks via as and is.
      // as Foo<A>, is Bar<B>
      // (things like if(a is Foo b) is covered by variable declaration)
      pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
      lookbehind: true,
      inside: typeInside
    }, {
      // Variable, field and parameter declaration
      // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
      pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name2]),
      inside: typeInside
    }],
    "keyword": keywords,
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism2.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism2.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      // namespace Foo.Bar {}
      // using Foo.Bar;
      pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name2]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      // default(Foo), typeof(Foo<Bar>), sizeof(int)
      pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
      // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
      // int Foo => 0; int Foo { get; set } = 0;
      pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier2]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      // new List<Foo<Bar[]>> { }
      pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    /*'explicit-implementation': {
    	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
    	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
    	inside: classNameInside,
    	alias: 'class-name'
    },*/
    "generic-method": {
      // foo<Bar>()
      pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
      inside: {
        "function": re(/^<<0>>/.source, [name2]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      // The list of types inherited or of generic constraints
      // class Foo<F> : Bar, IList<FooBar>
      // where F : Bar, IList<int>
      pattern: re(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [typeDeclarationKeywords, genericName, name2, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.csharp
        },
        "keyword": keywords,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        // highlight preprocessor directives as keywords
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character2;
  var regularStringCharacterOrComment = replace2(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace2(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier2, roundExpression]);
  Prism2.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      // Attributes
      // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
      pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism2.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier2),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace2(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism2.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism2.languages.insertBefore("csharp", "string", {
    "interpolation-string": [{
      pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(mInterpolation, mInterpolationRound)
    }, {
      pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
      lookbehind: true,
      greedy: true,
      inside: createInterpolationInside(sInterpolation, sInterpolationRound)
    }],
    "char": {
      pattern: RegExp(character2),
      greedy: true
    }
  });
  Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
})(Prism);
Prism.languages.markup = {
  "comment": {
    pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    greedy: true
  },
  "prolog": {
    pattern: /<\?[\s\S]+?\?>/,
    greedy: true
  },
  "doctype": {
    // https://www.w3.org/TR/xml/#NT-doctypedecl
    pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    greedy: true,
    inside: {
      "internal-subset": {
        pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      "string": {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      "punctuation": /^<!|>$|[[\]]/,
      "doctype-tag": /^DOCTYPE/i,
      "name": /[^\s<>'"]+/
    }
  },
  "cdata": {
    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    greedy: true
  },
  "tag": {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    greedy: true,
    inside: {
      "tag": {
        pattern: /^<\/?[^\s>\/]+/,
        inside: {
          "punctuation": /^<\/?/,
          "namespace": /^[^\s>\/:]+:/
        }
      },
      "special-attr": [],
      "attr-value": {
        pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
        inside: {
          "punctuation": [{
            pattern: /^=/,
            alias: "attr-equals"
          }, {
            pattern: /^(\s*)["']|["']$/,
            lookbehind: true
          }]
        }
      },
      "punctuation": /\/?>/,
      "attr-name": {
        pattern: /[^\s>\/]+/,
        inside: {
          "namespace": /^[^\s>\/:]+:/
        }
      }
    }
  },
  "entity": [{
    pattern: /&[\da-z]{1,8};/i,
    alias: "named-entity"
  }, /&#x?[\da-f]{1,8};/i]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
  /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */
  value: function addInlined2(tagName3, lang) {
    var includedCdataInside = {};
    includedCdataInside["language-" + lang] = {
      pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
      lookbehind: true,
      inside: Prism.languages[lang]
    };
    includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
    var inside = {
      "included-cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        inside: includedCdataInside
      }
    };
    inside["language-" + lang] = {
      pattern: /[\s\S]+/,
      inside: Prism.languages[lang]
    };
    var def = {};
    def[tagName3] = {
      pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return tagName3;
      }), "i"),
      lookbehind: true,
      greedy: true,
      inside
    };
    Prism.languages.insertBefore("markup", "cdata", def);
  }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
  /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */
  value: function(attrName, lang) {
    Prism.languages.markup.tag.inside["special-attr"].push({
      pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
      lookbehind: true,
      inside: {
        "attr-name": /^[^\s=]+/,
        "attr-value": {
          pattern: /=[\s\S]+/,
          inside: {
            "value": {
              pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
              lookbehind: true,
              alias: [lang, "language-" + lang],
              inside: Prism.languages[lang]
            },
            "punctuation": [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        }
      }
    });
  }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism2) {
  var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
(function(Prism2) {
  Prism2.languages.diff = {
    "coord": [
      // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
      /^(?:\*{3}|-{3}|\+{3}).*$/m,
      // Match "@@ ... @@" coord lines in unified diff.
      /^@@.*@@$/m,
      // Match coord lines in normal diff (starts with a number).
      /^\d.*$/m
    ]
    // deleted, inserted, unchanged, diff
  };
  var PREFIXES = {
    "deleted-sign": "-",
    "deleted-arrow": "<",
    "inserted-sign": "+",
    "inserted-arrow": ">",
    "unchanged": " ",
    "diff": "!"
  };
  Object.keys(PREFIXES).forEach(function(name2) {
    var prefix3 = PREFIXES[name2];
    var alias = [];
    if (!/^\w+$/.test(name2)) {
      alias.push(/\w+/.exec(name2)[0]);
    }
    if (name2 === "diff") {
      alias.push("bold");
    }
    Prism2.languages.diff[name2] = {
      pattern: RegExp("^(?:[" + prefix3 + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
      alias,
      inside: {
        "line": {
          pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
          lookbehind: true
        },
        "prefix": {
          pattern: /[\s\S]/,
          alias: /\w+/.exec(name2)[0]
        }
      }
    };
  });
  Object.defineProperty(Prism2.languages.diff, "PREFIXES", {
    value: PREFIXES
  });
})(Prism);
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];
Prism.languages.ini = {
  /**
   * The component mimics the behavior of the Win32 API parser.
   *
   * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
   */
  "comment": {
    pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
    lookbehind: true
  },
  "section": {
    pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
    lookbehind: true,
    inside: {
      "section-name": {
        pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
        lookbehind: true,
        alias: "selector"
      },
      "punctuation": /\[|\]/
    }
  },
  "key": {
    pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
    lookbehind: true,
    alias: "attr-name"
  },
  "value": {
    pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
    lookbehind: true,
    alias: "attr-value",
    inside: {
      "inner-value": {
        pattern: /^("|').+(?=\1$)/,
        lookbehind: true
      }
    }
  },
  "punctuation": /=/
};
(function(Prism2) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix2 = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix2 + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [className, {
      // variables, parameters, and constructor references
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix2 + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
      lookbehind: true,
      inside: className.inside
    }, {
      // class names based on keyword
      // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
      pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix2 + /[A-Z]\w*\b/.source),
      lookbehind: true,
      inside: className.inside
    }],
    "keyword": keywords,
    "function": [Prism2.languages.clike.function, {
      pattern: /(::\s*)[a-z_]\w*/,
      lookbehind: true
    }],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    },
    "constant": /\b[A-Z][A-Z_\d]+\b/
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [{
      pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix2 + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
      lookbehind: true,
      inside: {
        "namespace": className.inside.namespace,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }, {
      pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix2 + /(?:\w+|\*)(?=\s*;)/.source),
      lookbehind: true,
      alias: "static",
      inside: {
        "namespace": className.inside.namespace,
        "static": /\b\w+$/,
        "punctuation": /\./,
        "operator": /\*/,
        "class-name": /\w+/
      }
    }],
    "namespace": {
      pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
        return keywords.source;
      })),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);
(function(Prism2) {
  var specialEscape = {
    pattern: /\\[\\(){}[\]^$+*?|.]/,
    alias: "escape"
  };
  var escape2 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
  var charSet2 = {
    pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
    alias: "class-name"
  };
  var charSetWithoutDot = {
    pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
    alias: "class-name"
  };
  var rangeChar = "(?:[^\\\\-]|" + escape2.source + ")";
  var range = RegExp(rangeChar + "-" + rangeChar);
  var groupName = {
    pattern: /(<|')[^<>']+(?=[>']$)/,
    lookbehind: true,
    alias: "variable"
  };
  Prism2.languages.regex = {
    "char-class": {
      pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
      lookbehind: true,
      inside: {
        "char-class-negation": {
          pattern: /(^\[)\^/,
          lookbehind: true,
          alias: "operator"
        },
        "char-class-punctuation": {
          pattern: /^\[|\]$/,
          alias: "punctuation"
        },
        "range": {
          pattern: range,
          inside: {
            "escape": escape2,
            "range-punctuation": {
              pattern: /-/,
              alias: "operator"
            }
          }
        },
        "special-escape": specialEscape,
        "char-set": charSetWithoutDot,
        "escape": escape2
      }
    },
    "special-escape": specialEscape,
    "char-set": charSet2,
    "backreference": [{
      // a backreference which is not an octal escape
      pattern: /\\(?![123][0-7]{2})[1-9]/,
      alias: "keyword"
    }, {
      pattern: /\\k<[^<>']+>/,
      alias: "keyword",
      inside: {
        "group-name": groupName
      }
    }],
    "anchor": {
      pattern: /[$^]|\\[ABbGZz]/,
      alias: "function"
    },
    "escape": escape2,
    "group": [{
      // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
      // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
      // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
      pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
      alias: "punctuation",
      inside: {
        "group-name": groupName
      }
    }, {
      pattern: /\)/,
      alias: "punctuation"
    }],
    "quantifier": {
      pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
      alias: "number"
    },
    "alternation": {
      pattern: /\|/,
      alias: "keyword"
    }
  };
})(Prism);
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [Prism.languages.clike["class-name"], {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    lookbehind: true
  }],
  "keyword": [{
    pattern: /((?:^|\})\s*)catch\b/,
    lookbehind: true
  }, {
    pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    lookbehind: true
  }],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
    (/NaN|Infinity/.source + "|" + // binary integer
    /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
    /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
    /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
    /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [{
    pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }, {
    pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    lookbehind: true,
    inside: Prism.languages.javascript
  }],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function(Prism2) {
  var javascript = Prism2.util.clone(Prism2.languages.javascript);
  var space3 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
  var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
  var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function re(source, flags) {
    source = source.replace(/<S>/g, function() {
      return space3;
    }).replace(/<BRACES>/g, function() {
      return braces;
    }).replace(/<SPREAD>/g, function() {
      return spread;
    });
    return RegExp(source, flags);
  }
  spread = re(spread).source;
  Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
  Prism2.languages.jsx.tag.pattern = re(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
  Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
  Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
  Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
  Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
  Prism2.languages.insertBefore("inside", "attr-name", {
    "spread": {
      pattern: re(/<SPREAD>/.source),
      inside: Prism2.languages.jsx
    }
  }, Prism2.languages.jsx.tag);
  Prism2.languages.insertBefore("inside", "special-attr", {
    "script": {
      // Allow for two levels of nesting
      pattern: re(/=<BRACES>/.source),
      alias: "language-javascript",
      inside: {
        "script-punctuation": {
          pattern: /^=(?=\{)/,
          alias: "punctuation"
        },
        rest: Prism2.languages.jsx
      }
    }
  }, Prism2.languages.jsx.tag);
  var stringifyToken = function(token2) {
    if (!token2) {
      return "";
    }
    if (typeof token2 === "string") {
      return token2;
    }
    if (typeof token2.content === "string") {
      return token2.content;
    }
    return token2.content.map(stringifyToken).join("");
  };
  var walkTokens = function(tokens) {
    var openedTags = [];
    for (var i6 = 0; i6 < tokens.length; i6++) {
      var token2 = tokens[i6];
      var notTagNorBrace = false;
      if (typeof token2 !== "string") {
        if (token2.type === "tag" && token2.content[0] && token2.content[0].type === "tag") {
          if (token2.content[0].content[0].content === "</") {
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token2.content[0].content[1])) {
              openedTags.pop();
            }
          } else {
            if (token2.content[token2.content.length - 1].content === "/>")
              ;
            else {
              openedTags.push({
                tagName: stringifyToken(token2.content[0].content[1]),
                openedBraces: 0
              });
            }
          }
        } else if (openedTags.length > 0 && token2.type === "punctuation" && token2.content === "{") {
          openedTags[openedTags.length - 1].openedBraces++;
        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token2.type === "punctuation" && token2.content === "}") {
          openedTags[openedTags.length - 1].openedBraces--;
        } else {
          notTagNorBrace = true;
        }
      }
      if (notTagNorBrace || typeof token2 === "string") {
        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
          var plainText = stringifyToken(token2);
          if (i6 < tokens.length - 1 && (typeof tokens[i6 + 1] === "string" || tokens[i6 + 1].type === "plain-text")) {
            plainText += stringifyToken(tokens[i6 + 1]);
            tokens.splice(i6 + 1, 1);
          }
          if (i6 > 0 && (typeof tokens[i6 - 1] === "string" || tokens[i6 - 1].type === "plain-text")) {
            plainText = stringifyToken(tokens[i6 - 1]) + plainText;
            tokens.splice(i6 - 1, 1);
            i6--;
          }
          tokens[i6] = new Prism2.Token("plain-text", plainText, null, plainText);
        }
      }
      if (token2.content && typeof token2.content !== "string") {
        walkTokens(token2.content);
      }
    }
  };
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "jsx" && env.language !== "tsx") {
      return;
    }
    walkTokens(env.tokens);
  });
})(Prism);
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism2) {
  Prism2.languages.kotlin = Prism2.languages.extend("clike", {
    "keyword": {
      // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
      pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
      lookbehind: true
    },
    "function": [{
      pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
      greedy: true
    }, {
      pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
      lookbehind: true,
      greedy: true
    }],
    "number": /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
    "operator": /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
  });
  delete Prism2.languages.kotlin["class-name"];
  var interpolationInside = {
    "interpolation-punctuation": {
      pattern: /^\$\{?|\}$/,
      alias: "punctuation"
    },
    "expression": {
      pattern: /[\s\S]+/,
      inside: Prism2.languages.kotlin
    }
  };
  Prism2.languages.insertBefore("kotlin", "string", {
    // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
    "string-literal": [{
      pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
      alias: "multiline",
      inside: {
        "interpolation": {
          pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
          inside: interpolationInside
        },
        "string": /[\s\S]+/
      }
    }, {
      pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
      alias: "singleline",
      inside: {
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
          lookbehind: true,
          inside: interpolationInside
        },
        "string": /[\s\S]+/
      }
    }],
    "char": {
      // https://kotlinlang.org/spec/expressions.html#character-literals
      pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
      greedy: true
    }
  });
  delete Prism2.languages.kotlin["string"];
  Prism2.languages.insertBefore("kotlin", "keyword", {
    "annotation": {
      pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
      alias: "builtin"
    }
  });
  Prism2.languages.insertBefore("kotlin", "function", {
    "label": {
      pattern: /\b\w+@|@\w+\b/,
      alias: "symbol"
    }
  });
  Prism2.languages.kt = Prism2.languages.kotlin;
  Prism2.languages.kts = Prism2.languages.kotlin;
})(Prism);
Prism.languages.less = Prism.languages.extend("css", {
  "comment": [/\/\*[\s\S]*?\*\//, {
    pattern: /(^|[^\\])\/\/.*/,
    lookbehind: true
  }],
  "atrule": {
    pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      "punctuation": /[:()]/
    }
  },
  // selectors and mixins are considered the same
  "selector": {
    pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      // mixin parameters
      "variable": /@+[\w-]+/
    }
  },
  "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
  "operator": /[+\-*\/]/
});
Prism.languages.insertBefore("less", "property", {
  "variable": [
    // Variable declaration (the colon must be consumed!)
    {
      pattern: /@[\w-]+\s*:/,
      inside: {
        "punctuation": /:/
      }
    },
    // Variable usage
    /@@?[\w-]+/
  ],
  "mixin-usage": {
    pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
    lookbehind: true,
    alias: "function"
  }
});
Prism.languages.lua = {
  "comment": /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
  // \z may be used to skip the following space
  "string": {
    pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
    greedy: true
  },
  "number": /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
  "keyword": /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
  "function": /(?!\d)\w+(?=\s*(?:[({]))/,
  "operator": [/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/, {
    // Match ".." but don't break "..."
    pattern: /(^|[^.])\.\.(?!\.)/,
    lookbehind: true
  }],
  "punctuation": /[\[\](){},;]|\.+|:+/
};
Prism.languages.makefile = {
  "comment": {
    pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
    lookbehind: true
  },
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "builtin-target": {
    pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
    alias: "builtin"
  },
  "target": {
    pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
    alias: "symbol",
    inside: {
      "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
    }
  },
  "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
  // Directives
  "keyword": /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
  "function": {
    pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
    lookbehind: true
  },
  "operator": /(?:::|[?:+!])?=|[|@]/,
  "punctuation": /[:;(){}]/
};
(function(Prism2) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value2, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value2;
    });
    return RegExp(pattern, flags);
  }
  Prism2.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism2.languages.yml = Prism2.languages.yaml;
})(Prism);
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [{
      // Prefixed by 4 spaces or 1 tab and preceded by an empty line
      pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
      lookbehind: true,
      alias: "keyword"
    }, {
      // ```optional language
      // code block
      // ```
      pattern: /^```[\s\S]*?^```$/m,
      greedy: true,
      inside: {
        "code-block": {
          pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
          lookbehind: true
        },
        "code-language": {
          pattern: /^(```).+/,
          lookbehind: true
        },
        "punctuation": /```/
      }
    }],
    "title": [{
      // title 1
      // =======
      // title 2
      // -------
      pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
      alias: "important",
      inside: {
        punctuation: /==+$|--+$/
      }
    }, {
      // # title 1
      // ###### title 6
      pattern: /(^\s*)#.+/m,
      lookbehind: true,
      alias: "important",
      inside: {
        punctuation: /^#+|#+$/
      }
    }],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token2) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token2 !== inside) {
        Prism2.languages.markdown[token2].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens) {
      if (!tokens || typeof tokens === "string") {
        return;
      }
      for (var i6 = 0, l6 = tokens.length; i6 < l6; i6++) {
        var token2 = tokens[i6];
        if (token2.type !== "code") {
          walkTokens(token2.content);
          continue;
        }
        var codeLang = token2.content[1];
        var codeBlock = token2.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
          var alias = "language-" + lang;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i6 = 0, l6 = env.classes.length; i6 < l6; i6++) {
      var cls = env.classes[i6];
      var match3 = /language-(.+)/.exec(cls);
      if (match3) {
        codeLang = match3[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint3 = String.fromCodePoint || String.fromCharCode;
  function textContent(html) {
    var text3 = html.replace(tagPattern, "");
    text3 = text3.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code2) {
      code2 = code2.toLowerCase();
      if (code2[0] === "#") {
        var value2;
        if (code2[1] === "x") {
          value2 = parseInt(code2.slice(2), 16);
        } else {
          value2 = Number(code2.slice(1));
        }
        return fromCodePoint3(value2);
      } else {
        var known = KNOWN_ENTITY_NAMES[code2];
        if (known) {
          return known;
        }
        return m2;
      }
    });
    return text3;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
(function(Prism2) {
  var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
  Prism2.languages.perl = {
    "comment": [{
      // POD
      pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
      lookbehind: true,
      greedy: true
    }, {
      pattern: /(^|[^\\$])#.*/,
      lookbehind: true,
      greedy: true
    }],
    // TODO Could be nice to handle Heredoc too.
    "string": [
      {
        pattern: RegExp(/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // q/.../
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
          // q a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // q(...)
          // q{...}
          // q[...]
          // q<...>
          brackets
        ].join("|") + ")"),
        greedy: true
      },
      // "...", `...`
      {
        pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
        greedy: true
      },
      // '...'
      // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
      {
        pattern: /'(?:[^'\\\r\n]|\\.)*'/,
        greedy: true
      }
    ],
    "regex": [
      {
        pattern: RegExp(/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // m/.../
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
          // m a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // m(...)
          // m{...}
          // m[...]
          // m<...>
          brackets
        ].join("|") + ")" + /[msixpodualngc]*/.source),
        greedy: true
      },
      // The lookbehinds prevent -s from breaking
      {
        pattern: RegExp(/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
          // s/.../.../
          // eslint-disable-next-line regexp/strict
          /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
          // s a...a...a
          // eslint-disable-next-line regexp/strict
          /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
          // s(...)(...)
          // s{...}{...}
          // s[...][...]
          // s<...><...>
          // s(...)[...]
          brackets + /\s*/.source + brackets
        ].join("|") + ")" + /[msixpodualngcer]*/.source),
        lookbehind: true,
        greedy: true
      },
      // /.../
      // The look-ahead tries to prevent two divisions on
      // the same line from being highlighted as regex.
      // This does not support multi-line regex.
      {
        pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
        greedy: true
      }
    ],
    // FIXME Not sure about the handling of ::, ', and #
    "variable": [
      // ${^POSTMATCH}
      /[&*$@%]\{\^[A-Z]+\}/,
      // $^V
      /[&*$@%]\^[A-Z_]/,
      // ${...}
      /[&*$@%]#?(?=\{)/,
      // $foo
      /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
      // $1
      /[&*$@%]\d+/,
      // $_, @_, %!
      // The negative lookahead prevents from breaking the %= operator
      /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
    ],
    "filehandle": {
      // <>, <FOO>, _
      pattern: /<(?![<=])\S*?>|\b_\b/,
      alias: "symbol"
    },
    "v-string": {
      // v1.2, 1.2.3
      pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
      alias: "string"
    },
    "function": {
      pattern: /(\bsub[ \t]+)\w+/,
      lookbehind: true
    },
    "keyword": /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
    "operator": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
    "punctuation": /[{}[\];(),:]/
  };
})(Prism);
(function(Prism2) {
  function getPlaceholder(language, index2) {
    return "___" + language.toUpperCase() + index2 + "___";
  }
  Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
    buildPlaceholders: {
      /**
       * Tokenize all inline templating expressions matching `placeholderPattern`.
       *
       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
       * `true` will be replaced.
       *
       * @param {object} env The environment of the `before-tokenize` hook.
       * @param {string} language The language id.
       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
       * @param {(match: string) => boolean} [replaceFilter]
       */
      value: function(env, language, placeholderPattern, replaceFilter) {
        if (env.language !== language) {
          return;
        }
        var tokenStack = env.tokenStack = [];
        env.code = env.code.replace(placeholderPattern, function(match3) {
          if (typeof replaceFilter === "function" && !replaceFilter(match3)) {
            return match3;
          }
          var i6 = tokenStack.length;
          var placeholder;
          while (env.code.indexOf(placeholder = getPlaceholder(language, i6)) !== -1) {
            ++i6;
          }
          tokenStack[i6] = match3;
          return placeholder;
        });
        env.grammar = Prism2.languages.markup;
      }
    },
    tokenizePlaceholders: {
      /**
       * Replace placeholders with proper tokens after tokenizing.
       *
       * @param {object} env The environment of the `after-tokenize` hook.
       * @param {string} language The language id.
       */
      value: function(env, language) {
        if (env.language !== language || !env.tokenStack) {
          return;
        }
        env.grammar = Prism2.languages[language];
        var j3 = 0;
        var keys = Object.keys(env.tokenStack);
        function walkTokens(tokens) {
          for (var i6 = 0; i6 < tokens.length; i6++) {
            if (j3 >= keys.length) {
              break;
            }
            var token2 = tokens[i6];
            if (typeof token2 === "string" || token2.content && typeof token2.content === "string") {
              var k2 = keys[j3];
              var t5 = env.tokenStack[k2];
              var s4 = typeof token2 === "string" ? token2 : token2.content;
              var placeholder = getPlaceholder(language, k2);
              var index2 = s4.indexOf(placeholder);
              if (index2 > -1) {
                ++j3;
                var before = s4.substring(0, index2);
                var middle = new Prism2.Token(language, Prism2.tokenize(t5, env.grammar), "language-" + language, t5);
                var after = s4.substring(index2 + placeholder.length);
                var replacement = [];
                if (before) {
                  replacement.push.apply(replacement, walkTokens([before]));
                }
                replacement.push(middle);
                if (after) {
                  replacement.push.apply(replacement, walkTokens([after]));
                }
                if (typeof token2 === "string") {
                  tokens.splice.apply(tokens, [i6, 1].concat(replacement));
                } else {
                  token2.content = replacement;
                }
              }
            } else if (token2.content) {
              walkTokens(token2.content);
            }
          }
          return tokens;
        }
        walkTokens(env.tokens);
      }
    }
  });
})(Prism);
(function(Prism2) {
  var comment3 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
  var constant = [{
    pattern: /\b(?:false|true)\b/i,
    alias: "boolean"
  }, {
    pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
    greedy: true,
    lookbehind: true
  }, {
    pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
    greedy: true,
    lookbehind: true
  }, /\b(?:null)\b/i, /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/];
  var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
  var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
  var punctuation = /[{}\[\](),:;]/;
  Prism2.languages.php = {
    "delimiter": {
      pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
      alias: "important"
    },
    "comment": comment3,
    "variable": /\$+(?:\w+\b|(?=\{))/,
    "package": {
      pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "class-name-definition": {
      pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
      lookbehind: true,
      alias: "class-name"
    },
    "function-definition": {
      pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
      lookbehind: true,
      alias: "function"
    },
    "keyword": [
      {
        pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
        alias: "type-casting",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
        alias: "type-declaration",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:parent|self|static)(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      {
        // yield from
        pattern: /(\byield\s+)from\b/i,
        lookbehind: true
      },
      // `class` is always a keyword unlike other keywords
      /\bclass\b/i,
      {
        // https://www.php.net/manual/en/reserved.keywords.php
        //
        // keywords cannot be preceded by "->"
        // the complex lookbehind means `(?<!(?:->|::)\s*)`
        pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
        lookbehind: true
      }
    ],
    "argument-name": {
      pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
      lookbehind: true
    },
    "class-name": [{
      pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
      greedy: true,
      lookbehind: true
    }, {
      pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
      greedy: true,
      lookbehind: true
    }, {
      pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
      greedy: true
    }, {
      pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      alias: "class-name-fully-qualified",
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /\b[a-z_]\w*(?=\s*\$)/i,
      alias: "type-declaration",
      greedy: true
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
      alias: ["class-name-fully-qualified", "type-declaration"],
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /\b[a-z_]\w*(?=\s*::)/i,
      alias: "static-context",
      greedy: true
    }, {
      pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
      alias: ["class-name-fully-qualified", "static-context"],
      greedy: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
      alias: "type-hint",
      greedy: true,
      lookbehind: true
    }, {
      pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
      alias: ["class-name-fully-qualified", "type-hint"],
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }, {
      pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
      alias: "return-type",
      greedy: true,
      lookbehind: true
    }, {
      pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      alias: ["class-name-fully-qualified", "return-type"],
      greedy: true,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    }],
    "constant": constant,
    "function": {
      pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "property": {
      pattern: /(->\s*)\w+/,
      lookbehind: true
    },
    "number": number,
    "operator": operator,
    "punctuation": punctuation
  };
  var string_interpolation = {
    pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
    lookbehind: true,
    inside: Prism2.languages.php
  };
  var string = [{
    pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
    alias: "nowdoc-string",
    greedy: true,
    inside: {
      "delimiter": {
        pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
        alias: "symbol",
        inside: {
          "punctuation": /^<<<'?|[';]$/
        }
      }
    }
  }, {
    pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
    alias: "heredoc-string",
    greedy: true,
    inside: {
      "delimiter": {
        pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
        alias: "symbol",
        inside: {
          "punctuation": /^<<<"?|[";]$/
        }
      },
      "interpolation": string_interpolation
    }
  }, {
    pattern: /`(?:\\[\s\S]|[^\\`])*`/,
    alias: "backtick-quoted-string",
    greedy: true
  }, {
    pattern: /'(?:\\[\s\S]|[^\\'])*'/,
    alias: "single-quoted-string",
    greedy: true
  }, {
    pattern: /"(?:\\[\s\S]|[^\\"])*"/,
    alias: "double-quoted-string",
    greedy: true,
    inside: {
      "interpolation": string_interpolation
    }
  }];
  Prism2.languages.insertBefore("php", "variable", {
    "string": string,
    "attribute": {
      pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
      greedy: true,
      inside: {
        "attribute-content": {
          pattern: /^(#\[)[\s\S]+(?=\]$)/,
          lookbehind: true,
          // inside can appear subset of php
          inside: {
            "comment": comment3,
            "string": string,
            "attribute-class-name": [{
              pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
              alias: "class-name",
              greedy: true,
              lookbehind: true
            }, {
              pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
              alias: ["class-name", "class-name-fully-qualified"],
              greedy: true,
              lookbehind: true,
              inside: {
                "punctuation": /\\/
              }
            }],
            "constant": constant,
            "number": number,
            "operator": operator,
            "punctuation": punctuation
          }
        },
        "delimiter": {
          pattern: /^#\[|\]$/,
          alias: "punctuation"
        }
      }
    }
  });
  Prism2.hooks.add("before-tokenize", function(env) {
    if (!/<\?/.test(env.code)) {
      return;
    }
    var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
    Prism2.languages["markup-templating"].buildPlaceholders(env, "php", phpPattern);
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    Prism2.languages["markup-templating"].tokenizePlaceholders(env, "php");
  });
})(Prism);
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
Prism.languages.r = {
  "comment": /#.*/,
  "string": {
    pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "percent-operator": {
    // Includes user-defined operators
    // and %%, %*%, %/%, %in%, %o%, %x%
    pattern: /%[^%\s]*%/,
    alias: "operator"
  },
  "boolean": /\b(?:FALSE|TRUE)\b/,
  "ellipsis": /\.\.(?:\.|\d+)/,
  "number": [/\b(?:Inf|NaN)\b/, /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/],
  "keyword": /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
  "operator": /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
  "punctuation": /[(){}\[\],;]/
};
(function(Prism2) {
  Prism2.languages.ruby = Prism2.languages.extend("clike", {
    "comment": {
      pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
    "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
    "punctuation": /[(){}[\].,;]/
  });
  Prism2.languages.insertBefore("ruby", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  var interpolation = {
    pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
    lookbehind: true,
    inside: {
      "content": {
        pattern: /^(#\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: Prism2.languages.ruby
      },
      "delimiter": {
        pattern: /^#\{|\}$/,
        alias: "punctuation"
      }
    }
  };
  delete Prism2.languages.ruby.function;
  var percentExpression = "(?:" + [/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source, /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source, /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source].join("|") + ")";
  var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
  Prism2.languages.insertBefore("ruby", "keyword", {
    "regex-literal": [{
      pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }, {
      pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "regex": /[\s\S]+/
      }
    }],
    "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
    "symbol": [{
      pattern: RegExp(/(^|[^:]):/.source + symbolName),
      lookbehind: true,
      greedy: true
    }, {
      pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
      lookbehind: true,
      greedy: true
    }],
    "method-definition": {
      pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
      lookbehind: true,
      inside: {
        "function": /\b\w+$/,
        "keyword": /^self\b/,
        "class-name": /^\w+/,
        "punctuation": /\./
      }
    }
  });
  Prism2.languages.insertBefore("ruby", "string", {
    "string-literal": [{
      pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?/
          }
        },
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }, {
      pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
          inside: {
            "symbol": /\b\w+/,
            "punctuation": /^<<[-~]?'|'$/
          }
        },
        "string": /[\s\S]+/
      }
    }],
    "command-literal": [{
      pattern: RegExp(/%x/.source + percentExpression),
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }, {
      pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "command": {
          pattern: /[\s\S]+/,
          alias: "string"
        }
      }
    }]
  });
  delete Prism2.languages.ruby.string;
  Prism2.languages.insertBefore("ruby", "number", {
    "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
    "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
  });
  Prism2.languages.rb = Prism2.languages.ruby;
})(Prism);
(function(Prism2) {
  var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
  for (var i6 = 0; i6 < 2; i6++) {
    multilineComment = multilineComment.replace(/<self>/g, function() {
      return multilineComment;
    });
  }
  multilineComment = multilineComment.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  });
  Prism2.languages.rust = {
    "comment": [{
      pattern: RegExp(/(^|[^\\])/.source + multilineComment),
      lookbehind: true,
      greedy: true
    }, {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }],
    "string": {
      pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
      greedy: true
    },
    "char": {
      pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
      greedy: true
    },
    "attribute": {
      pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
      greedy: true,
      alias: "attr-name",
      inside: {
        "string": null
        // see below
      }
    },
    // Closure params should not be confused with bitwise OR |
    "closure-params": {
      pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "closure-punctuation": {
          pattern: /^\||\|$/,
          alias: "punctuation"
        },
        rest: null
        // see below
      }
    },
    "lifetime-annotation": {
      pattern: /'\w+/,
      alias: "symbol"
    },
    "fragment-specifier": {
      pattern: /(\$\w+:)[a-z]+/,
      lookbehind: true,
      alias: "punctuation"
    },
    "variable": /\$\w+/,
    "function-definition": {
      pattern: /(\bfn\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "type-definition": {
      pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
      lookbehind: true,
      alias: "class-name"
    },
    "module-declaration": [{
      pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
      lookbehind: true,
      alias: "namespace"
    }, {
      pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
      lookbehind: true,
      alias: "namespace",
      inside: {
        "punctuation": /::/
      }
    }],
    "keyword": [
      // https://github.com/rust-lang/reference/blob/master/src/keywords.md
      /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
      // primitives and str
      // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
      /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    ],
    // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    // and Rust's naming conventions recommend snake_case anyway.
    // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    "macro": {
      pattern: /\b\w+!/,
      alias: "property"
    },
    "constant": /\b[A-Z_][A-Z_\d]+\b/,
    "class-name": /\b[A-Z]\w*\b/,
    "namespace": {
      pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
      inside: {
        "punctuation": /::/
      }
    },
    // Hex, oct, bin, dec numbers with visual separators and type suffix
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    "boolean": /\b(?:false|true)\b/,
    "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
  };
  Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
  Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
})(Prism);
(function(Prism2) {
  Prism2.languages.sass = Prism2.languages.extend("css", {
    // Sass comments don't need to be closed, only indented
    "comment": {
      pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
      lookbehind: true,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("sass", "atrule", {
    // We want to consume the whole line
    "atrule-line": {
      // Includes support for = and + shortcuts
      pattern: /^(?:[ \t]*)[@+=].+/m,
      greedy: true,
      inside: {
        "atrule": /(?:@[\w-]+|[+=])/
      }
    }
  });
  delete Prism2.languages.sass.atrule;
  var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
  var operator = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
    pattern: /(\s)-(?=\s)/,
    lookbehind: true
  }];
  Prism2.languages.insertBefore("sass", "property", {
    // We want to consume the whole line
    "variable-line": {
      pattern: /^[ \t]*\$.+/m,
      greedy: true,
      inside: {
        "punctuation": /:/,
        "variable": variable,
        "operator": operator
      }
    },
    // We want to consume the whole line
    "property-line": {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
      greedy: true,
      inside: {
        "property": [/[^:\s]+(?=\s*:)/, {
          pattern: /(:)[^:\s]+/,
          lookbehind: true
        }],
        "punctuation": /:/,
        "variable": variable,
        "operator": operator,
        "important": Prism2.languages.sass.important
      }
    }
  });
  delete Prism2.languages.sass.property;
  delete Prism2.languages.sass.important;
  Prism2.languages.insertBefore("sass", "punctuation", {
    "selector": {
      pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
      lookbehind: true,
      greedy: true
    }
  });
})(Prism);
Prism.languages.scss = Prism.languages.extend("css", {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true
  },
  "atrule": {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      "rule": /@[\w-]+/
      // See rest below
    }
  },
  // url, compassified
  "url": /(?:[-a-z]+-)?url(?=\()/i,
  // CSS selector regex is not appropriate for Sass
  // since there can be lot more things (var, @ directive, nesting..)
  // a selector must start at the end of a property or after a brace (end of other rules or nesting)
  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
  // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
  // can "pass" as a selector- e.g: proper#{$erty})
  // this one was hard to do, so please be careful if you edit this one :)
  "selector": {
    // Initial look-ahead is used to prevent matching of blank selectors
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      "parent": {
        pattern: /&/,
        alias: "important"
      },
      "placeholder": /%[-\w]+/,
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  "property": {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
Prism.languages.insertBefore("scss", "atrule", {
  "keyword": [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
    pattern: /( )(?:from|through)(?= )/,
    lookbehind: true
  }]
});
Prism.languages.insertBefore("scss", "important", {
  // var and interpolated vars
  "variable": /\$[-\w]+|#\{\$[-\w]+\}/
});
Prism.languages.insertBefore("scss", "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  "placeholder": {
    pattern: /%[-\w]+/,
    alias: "selector"
  },
  "statement": {
    pattern: /\B!(?:default|optional)\b/i,
    alias: "keyword"
  },
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  },
  "operator": {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: true
  }
});
Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [{
    pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    greedy: true
  }, /@[\w.$]+/],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};
Prism.languages.swift = {
  "comment": {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    // directives with conditions
    pattern: RegExp(/#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);
(function(Prism2) {
  var typescript = Prism2.util.clone(Prism2.languages.typescript);
  Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
  delete Prism2.languages.tsx["parameter"];
  delete Prism2.languages.tsx["literal-property"];
  var tag = Prism2.languages.tsx.tag;
  tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
  tag.lookbehind = true;
})(Prism);
Prism.languages.basic = {
  "comment": {
    pattern: /(?:!|REM\b).+/i,
    inside: {
      "keyword": /^REM/i
    }
  },
  "string": {
    pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
    greedy: true
  },
  "number": /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
  "keyword": /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
  "function": /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
  "operator": /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
  "punctuation": /[,;:()]/
};
Prism.languages.vbnet = Prism.languages.extend("basic", {
  "comment": [{
    pattern: /(?:!|REM\b).+/i,
    inside: {
      "keyword": /^REM/i
    }
  }, {
    pattern: /(^|[^\\:])'.*/,
    lookbehind: true,
    greedy: true
  }],
  "string": {
    pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
  "punctuation": /[,;:(){}]/
});
function isValidURL(url) {
  return url === (0, import_sanitize_url.sanitizeUrl)(url);
}
var languages = [{
  label: "C",
  value: "c"
}, {
  label: "C++",
  value: "cpp"
}, {
  label: "Arduino",
  value: "arduino"
}, {
  label: "Bash",
  value: "bash"
}, {
  label: "C#",
  value: "csharp"
}, {
  label: "CSS",
  value: "css"
}, {
  label: "Diff",
  value: "diff"
}, {
  label: "Go",
  value: "go"
}, {
  label: "INI",
  value: "ini"
}, {
  label: "Java",
  value: "java"
}, {
  label: "JavaScript",
  value: "javascript"
}, {
  label: "JSX",
  value: "jsx"
}, {
  label: "JSON",
  value: "json"
}, {
  label: "Kotlin",
  value: "kotlin"
}, {
  label: "Less",
  value: "less"
}, {
  label: "Lua",
  value: "lua"
}, {
  label: "Makefile",
  value: "makefile"
}, {
  label: "Markdown",
  value: "markdown"
}, {
  label: "Objective-C",
  value: "objectivec"
}, {
  label: "Perl",
  value: "perl"
}, {
  label: "PHP",
  value: "php"
}, {
  label: "Python",
  value: "python"
}, {
  label: "R",
  value: "r"
}, {
  label: "Ruby",
  value: "ruby"
}, {
  label: "Rust",
  value: "rust"
}, {
  label: "Sass",
  value: "sass"
}, {
  label: "SCSS",
  value: "scss"
}, {
  label: "SQL",
  value: "sql"
}, {
  label: "Swift",
  value: "swift"
}, {
  label: "TypeScript",
  value: "typescript"
}, {
  label: "TSX",
  value: "tsx"
}, {
  label: "VB.NET",
  value: "vbnet"
}, {
  label: "YAML",
  value: "yaml"
}];
var canonicalNameToLabel = new Map(languages.map((x3) => [x3.value, x3.label]));
var labelToCanonicalName = new Map(languages.map((x3) => [x3.label, x3.value]));
var languageToCanonicalName = new Map(languages.map((lang) => [Prism.languages[lang.value], lang.value]));
var aliasesToCanonicalName = new Map(Object.keys(Prism.languages).flatMap((lang) => {
  const canonicalName = languageToCanonicalName.get(Prism.languages[lang]);
  if (canonicalName === void 0) {
    return [];
  }
  return [[lang, canonicalName]];
}));
var languagesToAliases = new Map(languages.map((lang) => [lang.value, []]));
for (const [alias, canonicalName] of aliasesToCanonicalName) {
  languagesToAliases.get(canonicalName).push(alias);
}
var languagesWithAliases = [{
  label: "Plain text",
  value: "plain",
  aliases: []
}, ...[...languagesToAliases].map(([canonicalName, aliases]) => ({
  label: canonicalNameToLabel.get(canonicalName),
  value: canonicalName,
  aliases
}))];
var aliasesToLabel = new Map([...aliasesToCanonicalName].map(([alias, canonicalName]) => [alias, canonicalNameToLabel.get(canonicalName)]));

// node_modules/.pnpm/@markdoc+markdoc@0.3.5_@types+react@18.2.41_react@18.2.0/node_modules/@markdoc/markdoc/dist/index.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var require_tag = __commonJS2({
  "src/grammar/tag.js"(exports, module) {
    "use strict";
    function peg$subclass(child, parent) {
      function C2() {
        this.constructor = child;
      }
      C2.prototype = parent.prototype;
      child.prototype = new C2();
    }
    function peg$SyntaxError(message, expected, found, location2) {
      this.message = message;
      this.expected = expected;
      this.found = found;
      this.location = location2;
      this.name = "SyntaxError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, peg$SyntaxError);
      }
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found, location2) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        },
        not: function(expectation) {
          return "not " + describeExpectation(expectation.expected);
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s22) {
        return s22.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i6, j3;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i6 = 1, j3 = 1; i6 < descriptions.length; i6++) {
            if (descriptions[i6 - 1] !== descriptions[i6]) {
              descriptions[j3] = descriptions[i6];
              j3++;
            }
          }
          descriptions.length = j3;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$startRuleFunctions = { Top: peg$parseTop };
      var peg$startRuleFunction = peg$parseTop;
      var peg$c0 = "/";
      var peg$c1 = ".";
      var peg$c2 = "#";
      var peg$c3 = "=";
      var peg$c4 = "(";
      var peg$c5 = ")";
      var peg$c6 = ",";
      var peg$c7 = "[";
      var peg$c8 = "]";
      var peg$c9 = "null";
      var peg$c10 = "true";
      var peg$c11 = "false";
      var peg$c12 = "{";
      var peg$c13 = "}";
      var peg$c14 = ":";
      var peg$c15 = "-";
      var peg$c16 = '"';
      var peg$c17 = "\\";
      var peg$r0 = /^[$@]/;
      var peg$r1 = /^[0-9]/;
      var peg$r2 = /^[^\0-\x1F"\\]/;
      var peg$r3 = /^[a-zA-Z0-9_\-]/;
      var peg$r4 = /^[ \n\t]/;
      var peg$e0 = peg$literalExpectation("/", false);
      var peg$e1 = peg$otherExpectation("tag name");
      var peg$e2 = peg$otherExpectation("class");
      var peg$e3 = peg$otherExpectation("id");
      var peg$e4 = peg$literalExpectation("=", false);
      var peg$e5 = peg$literalExpectation("(", false);
      var peg$e6 = peg$literalExpectation(")", false);
      var peg$e7 = peg$literalExpectation(",", false);
      var peg$e8 = peg$otherExpectation("variable");
      var peg$e9 = peg$otherExpectation("null");
      var peg$e10 = peg$otherExpectation("boolean");
      var peg$e11 = peg$literalExpectation("[", false);
      var peg$e12 = peg$literalExpectation("]", false);
      var peg$e13 = peg$literalExpectation("{", false);
      var peg$e14 = peg$literalExpectation("}", false);
      var peg$e15 = peg$literalExpectation(":", false);
      var peg$e16 = peg$otherExpectation("number");
      var peg$e17 = peg$otherExpectation("string");
      var peg$e18 = peg$otherExpectation("identifier");
      var peg$e19 = peg$otherExpectation("whitespace");
      var peg$f0 = function(variable) {
        return { type: "variable", meta: { variable } };
      };
      var peg$f1 = function(attributes) {
        return { type: "annotation", meta: { attributes } };
      };
      var peg$f2 = function(tag, value2) {
        return value2;
      };
      var peg$f3 = function(tag, primary, attributes, close) {
        if (primary) {
          attributes = attributes || [];
          attributes.unshift({
            type: "attribute",
            name: "primary",
            value: primary
          });
        }
        const [type2, nesting] = close ? ["tag", 0] : ["tag_open", 1];
        return { type: type2, nesting, meta: { tag, attributes } };
      };
      var peg$f4 = function(tag) {
        return { type: "tag_close", nesting: -1, meta: { tag } };
      };
      var peg$f5 = function(head, tail) {
        return !head ? [] : [head, ...tail];
      };
      var peg$f6 = function(item2) {
        return item2;
      };
      var peg$f7 = function(ids) {
        return ids;
      };
      var peg$f8 = function(classes) {
        return classes;
      };
      var peg$f9 = function(attribute) {
        return attribute;
      };
      var peg$f10 = function(name2) {
        return { type: "class", name: name2, value: true };
      };
      var peg$f11 = function(value2) {
        return { type: "attribute", name: "id", value: value2 };
      };
      var peg$f12 = function(name2, value2) {
        return { type: "attribute", name: name2, value: value2 };
      };
      var peg$f13 = function(name2, head, tail) {
        return head ? [head, ...tail] : [];
      };
      var peg$f14 = function(name2, params) {
        let parameters = {};
        for (let [index2, { name: name22, value: value2 }] of params.entries())
          parameters[name22 || index2] = value2;
        return new Function3(name2, parameters);
      };
      var peg$f15 = function(name2) {
        return name2;
      };
      var peg$f16 = function(name2, value2) {
        return { name: name2, value: value2 };
      };
      var peg$f17 = function(value2) {
        return value2;
      };
      var peg$f18 = function(prefix3, head, tail) {
        if (prefix3 === "@")
          return [head, ...tail];
        return new Variable2([head, ...tail]);
      };
      var peg$f19 = function() {
        return null;
      };
      var peg$f20 = function() {
        return true;
      };
      var peg$f21 = function() {
        return false;
      };
      var peg$f22 = function(head, tail) {
        return [head, ...tail];
      };
      var peg$f23 = function(value2) {
        return value2 || [];
      };
      var peg$f24 = function(head, tail) {
        return Object.assign(head, ...tail);
      };
      var peg$f25 = function(value2) {
        return value2 || {};
      };
      var peg$f26 = function(key, value2) {
        return key === "$$mdtype" ? {} : { [key]: value2 };
      };
      var peg$f27 = function() {
        return parseFloat(text22());
      };
      var peg$f28 = function(value2) {
        return value2.join("");
      };
      var peg$f29 = function(sequence) {
        return sequence;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$expected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text22() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return [peg$savedPos, peg$currPos];
      }
      function location2() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location22) {
        location22 = location22 !== void 0 ? location22 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location22);
      }
      function error22(message, location22) {
        location22 = location22 !== void 0 ? location22 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location22);
      }
      function peg$literalExpectation(text3, ignoreCase) {
        return { type: "literal", text: text3, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
          type: "class",
          parts,
          inverted,
          ignoreCase
        };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p5;
        if (details) {
          return details;
        } else {
          p5 = pos - 1;
          while (!peg$posDetailsCache[p5]) {
            p5--;
          }
          details = peg$posDetailsCache[p5];
          details = {
            line: details.line,
            column: details.column
          };
          while (p5 < pos) {
            if (input.charCodeAt(p5) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p5++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      var peg$VALIDFILENAME = typeof options.filename === "string" && options.filename.length > 0;
      function peg$computeLocation(startPos, endPos) {
        var loc = {};
        if (peg$VALIDFILENAME)
          loc.filename = options.filename;
        var startPosDetails = peg$computePosDetails(startPos);
        loc.start = {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        };
        var endPosDetails = peg$computePosDetails(endPos);
        loc.end = {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        };
        return loc;
      }
      function peg$begin() {
        peg$expected.push({ pos: peg$currPos, variants: [] });
      }
      function peg$expect(expected2) {
        var top = peg$expected[peg$expected.length - 1];
        if (peg$currPos < top.pos) {
          return;
        }
        if (peg$currPos > top.pos) {
          top.pos = peg$currPos;
          top.variants = [];
        }
        top.variants.push(expected2);
      }
      function peg$end(invert) {
        var expected2 = peg$expected.pop();
        var top = peg$expected[peg$expected.length - 1];
        var variants = expected2.variants;
        if (top.pos !== expected2.pos) {
          return;
        }
        if (invert) {
          variants = variants.map(function(e6) {
            return e6.type === "not" ? e6.expected : { type: "not", expected: e6 };
          });
        }
        Array.prototype.push.apply(top.variants, variants);
      }
      function peg$buildSimpleError(message, location22) {
        return new peg$SyntaxError(message, null, null, location22);
      }
      function peg$buildStructuredError(expected2, found, location22) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found, location22), expected2, found, location22);
      }
      function peg$buildError() {
        var expected2 = peg$expected[0];
        var failPos = expected2.pos;
        return peg$buildStructuredError(expected2.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));
      }
      function peg$parseTop() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$parseTopLevelValue();
        if (s0 === peg$FAILED) {
          s0 = peg$parseAnnotation();
          if (s0 === peg$FAILED) {
            s0 = peg$parseTagOpen();
            if (s0 === peg$FAILED) {
              s0 = peg$parseTagClose();
            }
          }
        }
        return s0;
      }
      function peg$parseTopLevelValue() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseVariable();
        if (s1 === peg$FAILED) {
          s1 = peg$parseFunction();
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f0(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parseAnnotation() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagAttributes();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          peg$savedPos = s0;
          s0 = peg$f1(s1);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagOpen() {
        var s0, s1, s22, s32, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagName();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            peg$savedPos = s32;
            s32 = peg$f2(s1, s4);
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s4 = peg$parseTagAttributes();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          s5 = [];
          s6 = peg$parse_();
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$parse_();
          }
          rule$expects(peg$e0);
          if (input.charCodeAt(peg$currPos) === 47) {
            s6 = peg$c0;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f3(s1, s32, s4, s6);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagClose() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e0);
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseTagName();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f4(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagName() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e1);
        peg$silentFails++;
        s0 = peg$parseIdentifier();
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttributes() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagAttributesItem();
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseTagAttributesTail();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseTagAttributesTail();
          }
          peg$savedPos = s0;
          s0 = peg$f5(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesTail() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parse_();
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseTagAttributesItem();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTagAttributesItem() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseTagShortcutId();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f7(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseTagShortcutClass();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseTagAttribute();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$f9(s1);
            }
            s0 = s1;
          }
        }
        return s0;
      }
      function peg$parseTagShortcutClass() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e2);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseIdentifier();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f10(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagShortcutId() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e3);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c2;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseIdentifier();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f11(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseTagAttribute() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s22 = peg$c3;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = peg$parseValue();
            if (s32 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f12(s1, s32);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunction() {
        var s0, s1, s22, s32, s4, s5, s6, s7;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e5);
          if (input.charCodeAt(peg$currPos) === 40) {
            s22 = peg$c4;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$currPos;
            s5 = peg$parseFunctionParameter();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s6 = [];
            s7 = peg$parseFunctionParameterTail();
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              s7 = peg$parseFunctionParameterTail();
            }
            peg$savedPos = s4;
            s4 = peg$f13(s1, s5, s6);
            rule$expects(peg$e6);
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c5;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f14(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameter() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$currPos;
        s22 = peg$parseIdentifier();
        if (s22 !== peg$FAILED) {
          rule$expects(peg$e4);
          if (input.charCodeAt(peg$currPos) === 61) {
            s32 = peg$c3;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f15(s22);
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = peg$parseValue();
        if (s22 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f16(s1, s22);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseFunctionParameterTail() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s22 = peg$c6;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s32.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseFunctionParameter();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseTrailingComma() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s22 = peg$c6;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s1 = [s1, s22];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        return s0;
      }
      function peg$parseVariable() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e8);
        peg$silentFails++;
        s0 = peg$currPos;
        if (peg$r0.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseIdentifier();
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parseVariableTail();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parseVariableTail();
            }
            peg$savedPos = s0;
            s0 = peg$f18(s1, s22, s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseVariableTail() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = peg$parseIdentifier();
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f15(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseValueNumber();
            if (s22 === peg$FAILED) {
              s22 = peg$parseValueString();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s32 = peg$c8;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
              }
              if (s32 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f17(s22);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseValue() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$parseValueNull();
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueBoolean();
          if (s0 === peg$FAILED) {
            s0 = peg$parseValueString();
            if (s0 === peg$FAILED) {
              s0 = peg$parseValueNumber();
              if (s0 === peg$FAILED) {
                s0 = peg$parseValueArray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseValueHash();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseFunction();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseVariable();
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseValueNull() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e9);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c9) {
          s1 = peg$c9;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f19();
        }
        s0 = s1;
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueBoolean() {
        var s0, s1;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e10);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c10) {
          s1 = peg$c10;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f20();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c11) {
            s1 = peg$c11;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f21();
          }
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueArray() {
        var s0, s1, s22, s32, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e11);
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$currPos;
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueArrayTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueArrayTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s32;
            s32 = peg$f22(s4, s5);
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e12);
          if (input.charCodeAt(peg$currPos) === 93) {
            s5 = peg$c8;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueArrayTail() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s22 = peg$c6;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s32.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValue();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f17(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHash() {
        var s0, s1, s22, s32, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        rule$expects(peg$e13);
        if (input.charCodeAt(peg$currPos) === 123) {
          s1 = peg$c12;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parse_();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parse_();
          }
          s32 = peg$currPos;
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseValueHashTail();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parseValueHashTail();
            }
            s6 = peg$parseTrailingComma();
            peg$savedPos = s32;
            s32 = peg$f24(s4, s5);
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          s4 = [];
          s5 = peg$parse_();
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parse_();
          }
          rule$expects(peg$e14);
          if (input.charCodeAt(peg$currPos) === 125) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s32);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashTail() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = [];
        s22 = peg$parse_();
        while (s22 !== peg$FAILED) {
          s1.push(s22);
          s22 = peg$parse_();
        }
        rule$expects(peg$e7);
        if (input.charCodeAt(peg$currPos) === 44) {
          s22 = peg$c6;
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = [];
          s4 = peg$parse_();
          while (s4 !== peg$FAILED) {
            s32.push(s4);
            s4 = peg$parse_();
          }
          s4 = peg$parseValueHashItem();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f6(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueHashItem() {
        var s0, s1, s22, s32, s4;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        s1 = peg$parseIdentifier();
        if (s1 === peg$FAILED) {
          s1 = peg$parseValueString();
        }
        if (s1 !== peg$FAILED) {
          rule$expects(peg$e15);
          if (input.charCodeAt(peg$currPos) === 58) {
            s22 = peg$c14;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 !== peg$FAILED) {
            s32 = [];
            s4 = peg$parse_();
            while (s4 !== peg$FAILED) {
              s32.push(s4);
              s4 = peg$parse_();
            }
            s4 = peg$parseValue();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f26(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseValueNumber() {
        var s0, s1, s22, s32, s4, s5, s6;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e16);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c15;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s22 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s32 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s32 = peg$FAILED;
        }
        if (s32 !== peg$FAILED) {
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s32 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s32 = peg$FAILED;
            }
          }
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          s32 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c1;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s32 = s4;
            } else {
              peg$currPos = s32;
              s32 = peg$FAILED;
            }
          } else {
            peg$currPos = s32;
            s32 = peg$FAILED;
          }
          if (s32 === peg$FAILED) {
            s32 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f27();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueString() {
        var s0, s1, s22, s32;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e17);
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c16;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s22 = [];
          s32 = peg$parseValueStringChars();
          while (s32 !== peg$FAILED) {
            s22.push(s32);
            s32 = peg$parseValueStringChars();
          }
          if (input.charCodeAt(peg$currPos) === 34) {
            s32 = peg$c16;
            peg$currPos++;
          } else {
            s32 = peg$FAILED;
          }
          if (s32 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f28(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parseValueStringChars() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseValueStringEscapes();
        }
        return s0;
      }
      function peg$parseValueStringEscapes() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c17;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s22 = peg$c16;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
          }
          if (s22 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 92) {
              s22 = peg$c17;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
            }
          }
          if (s22 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f29(s22);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseIdentifier() {
        var s0, s1, s22;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e18);
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s22 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s22 = peg$FAILED;
        }
        if (s22 !== peg$FAILED) {
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        peg$silentFails--;
        return s0;
      }
      function peg$parse_() {
        var s0;
        var rule$expects = function(expected2) {
          if (peg$silentFails === 0)
            peg$expect(expected2);
        };
        rule$expects(peg$e19);
        peg$silentFails++;
        if (peg$r4.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
        }
        peg$silentFails--;
        return s0;
      }
      const { Variable: Variable2, Function: Function3 } = options;
      peg$begin();
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$expect(peg$endExpectation());
        }
        throw peg$buildError();
      }
    }
    module.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});
var require_entities = __commonJS2({
  "node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: "\n", nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "	", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
  }
});
var require_entities2 = __commonJS2({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module) {
    "use strict";
    module.exports = require_entities();
  }
});
var require_regex = __commonJS2({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module) {
    module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});
var require_encode = __commonJS2({
  "node_modules/mdurl/encode.js"(exports, module) {
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i6, ch, cache3 = encodeCache[exclude];
      if (cache3) {
        return cache3;
      }
      cache3 = encodeCache[exclude] = [];
      for (i6 = 0; i6 < 128; i6++) {
        ch = String.fromCharCode(i6);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache3.push(ch);
        } else {
          cache3.push("%" + ("0" + i6.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i6 = 0; i6 < exclude.length; i6++) {
        cache3[exclude.charCodeAt(i6)] = exclude[i6];
      }
      return cache3;
    }
    function encode(string, exclude, keepEscaped) {
      var i6, l6, code2, nextCode, cache3, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache3 = getEncodeCache(exclude);
      for (i6 = 0, l6 = string.length; i6 < l6; i6++) {
        code2 = string.charCodeAt(i6);
        if (keepEscaped && code2 === 37 && i6 + 2 < l6) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i6 + 1, i6 + 3))) {
            result += string.slice(i6, i6 + 3);
            i6 += 2;
            continue;
          }
        }
        if (code2 < 128) {
          result += cache3[code2];
          continue;
        }
        if (code2 >= 55296 && code2 <= 57343) {
          if (code2 >= 55296 && code2 <= 56319 && i6 + 1 < l6) {
            nextCode = string.charCodeAt(i6 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i6] + string[i6 + 1]);
              i6++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i6]);
      }
      return result;
    }
    encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";
    module.exports = encode;
  }
});
var require_decode = __commonJS2({
  "node_modules/mdurl/decode.js"(exports, module) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i6, ch, cache3 = decodeCache[exclude];
      if (cache3) {
        return cache3;
      }
      cache3 = decodeCache[exclude] = [];
      for (i6 = 0; i6 < 128; i6++) {
        ch = String.fromCharCode(i6);
        cache3.push(ch);
      }
      for (i6 = 0; i6 < exclude.length; i6++) {
        ch = exclude.charCodeAt(i6);
        cache3[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache3;
    }
    function decode(string, exclude) {
      var cache3;
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      cache3 = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i6, l6, b1, b2, b3, b4, chr, result = "";
        for (i6 = 0, l6 = seq.length; i6 < l6; i6 += 3) {
          b1 = parseInt(seq.slice(i6 + 1, i6 + 3), 16);
          if (b1 < 128) {
            result += cache3[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i6 + 3 < l6) {
            b2 = parseInt(seq.slice(i6 + 4, i6 + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "��";
              } else {
                result += String.fromCharCode(chr);
              }
              i6 += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i6 + 6 < l6) {
            b2 = parseInt(seq.slice(i6 + 4, i6 + 6), 16);
            b3 = parseInt(seq.slice(i6 + 7, i6 + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "���";
              } else {
                result += String.fromCharCode(chr);
              }
              i6 += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i6 + 9 < l6) {
            b2 = parseInt(seq.slice(i6 + 4, i6 + 6), 16);
            b3 = parseInt(seq.slice(i6 + 7, i6 + 9), 16);
            b4 = parseInt(seq.slice(i6 + 10, i6 + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "����";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i6 += 9;
              continue;
            }
          }
          result += "�";
        }
        return result;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    module.exports = decode;
  }
});
var require_format = __commonJS2({
  "node_modules/mdurl/format.js"(exports, module) {
    "use strict";
    module.exports = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});
var require_parse = __commonJS2({
  "node_modules/mdurl/parse.js"(exports, module) {
    "use strict";
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u4 = new Url();
      u4.parse(url, slashesDenoteHost);
      return u4;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i6, l6, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i6 = 0; i6 < hostEndingChars.length; i6++) {
          hec = rest.indexOf(hostEndingChars[i6]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i6 = 0; i6 < nonHostChars.length; i6++) {
          hec = rest.indexOf(nonHostChars[i6]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i6 = 0, l6 = hostparts.length; i6 < l6; i6++) {
            var part = hostparts[i6];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j3 = 0, k2 = part.length; j3 < k2; j3++) {
                if (part.charCodeAt(j3) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j3];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i6);
                var notHost = hostparts.slice(i6 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash2 = rest.indexOf("#");
      if (hash2 !== -1) {
        this.hash = rest.substr(hash2);
        rest = rest.slice(0, hash2);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module.exports = urlParse;
  }
});
var require_mdurl = __commonJS2({
  "node_modules/mdurl/index.js"(exports, module) {
    "use strict";
    module.exports.encode = require_encode();
    module.exports.decode = require_decode();
    module.exports.format = require_format();
    module.exports.parse = require_parse();
  }
});
var require_regex2 = __commonJS2({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module) {
    module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});
var require_regex3 = __commonJS2({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module) {
    module.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});
var require_regex4 = __commonJS2({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module) {
    module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});
var require_regex5 = __commonJS2({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module) {
    module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});
var require_uc = __commonJS2({
  "node_modules/uc.micro/index.js"(exports) {
    "use strict";
    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});
var require_utils = __commonJS2({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString2(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object2, key) {
      return _hasOwnProperty.call(object2, key);
    }
    function assign2(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c5) {
      if (c5 >= 55296 && c5 <= 57343) {
        return false;
      }
      if (c5 >= 64976 && c5 <= 65007) {
        return false;
      }
      if ((c5 & 65535) === 65535 || (c5 & 65535) === 65534) {
        return false;
      }
      if (c5 >= 0 && c5 <= 8) {
        return false;
      }
      if (c5 === 11) {
        return false;
      }
      if (c5 >= 14 && c5 <= 31) {
        return false;
      }
      if (c5 >= 127 && c5 <= 159) {
        return false;
      }
      if (c5 > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint3(c5) {
      if (c5 > 65535) {
        c5 -= 65536;
        var surrogate1 = 55296 + (c5 >> 10), surrogate2 = 56320 + (c5 & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c5);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match3, name2) {
      var code2 = 0;
      if (has(entities, name2)) {
        return entities[name2];
      }
      if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
        code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
        if (isValidEntityCode(code2)) {
          return fromCodePoint3(code2);
        }
      }
      return match3;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match3, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match3, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml2(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code2) {
      switch (code2) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace2(code2) {
      if (code2 >= 8192 && code2 <= 8202) {
        return true;
      }
      switch (code2) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("ẞ".toLowerCase() === "Ṿ") {
        str = str.replace(/ẞ/g, "ß");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign2;
    exports.isString = isString2;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint3;
    exports.escapeHtml = escapeHtml2;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace2;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});
var require_parse_link_label = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module) {
    "use strict";
    module.exports = function parseLinkLabel(state, start2, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max2 = state.posMax, oldPos = state.pos;
      state.pos = start2 + 1;
      level = 1;
      while (state.pos < max2) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});
var require_parse_link_destination = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkDestination(str, pos, max2) {
      var code2, level, lines = 0, start2 = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max2) {
          code2 = str.charCodeAt(pos);
          if (code2 === 10) {
            return result;
          }
          if (code2 === 60) {
            return result;
          }
          if (code2 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start2 + 1, pos));
            result.ok = true;
            return result;
          }
          if (code2 === 92 && pos + 1 < max2) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max2) {
        code2 = str.charCodeAt(pos);
        if (code2 === 32) {
          break;
        }
        if (code2 < 32 || code2 === 127) {
          break;
        }
        if (code2 === 92 && pos + 1 < max2) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code2 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code2 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start2 === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start2, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});
var require_parse_link_title = __commonJS2({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkTitle(str, pos, max2) {
      var code2, marker, lines = 0, start2 = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max2) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max2) {
        code2 = str.charCodeAt(pos);
        if (code2 === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start2 + 1, pos));
          result.ok = true;
          return result;
        } else if (code2 === 40 && marker === 41) {
          return result;
        } else if (code2 === 10) {
          lines++;
        } else if (code2 === 92 && pos + 1 < max2) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});
var require_helpers = __commonJS2({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});
var require_renderer = __commonJS2({
  "node_modules/markdown-it/lib/renderer.js"(exports, module) {
    "use strict";
    var assign2 = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml2 = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml2(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml2(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i6, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml2(token2.content);
      } else {
        highlighted = escapeHtml2(token2.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i6 = token2.attrIndex("class");
        tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
        if (i6 < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i6] = tmpAttrs[i6].slice();
          tmpAttrs[i6][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token2 = tokens[idx];
      token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml2(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign2({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token2) {
      var i6, l6, result;
      if (!token2.attrs) {
        return "";
      }
      result = "";
      for (i6 = 0, l6 = token2.attrs.length; i6 < l6; i6++) {
        result += " " + escapeHtml2(token2.attrs[i6][0]) + '="' + escapeHtml2(token2.attrs[i6][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token2 = tokens[idx];
      if (token2.hidden) {
        return "";
      }
      if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
      result += this.renderAttrs(token2);
      if (token2.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token2.block) {
        needLf = true;
        if (token2.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type2, result = "", rules = this.rules;
      for (var i6 = 0, len = tokens.length; i6 < len; i6++) {
        type2 = tokens[i6].type;
        if (typeof rules[type2] !== "undefined") {
          result += rules[type2](tokens, i6, options, env, this);
        } else {
          result += this.renderToken(tokens, i6, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i6 = 0, len = tokens.length; i6 < len; i6++) {
        if (tokens[i6].type === "text") {
          result += tokens[i6].content;
        } else if (tokens[i6].type === "image") {
          result += this.renderInlineAsText(tokens[i6].children, options, env);
        } else if (tokens[i6].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i6, len, type2, result = "", rules = this.rules;
      for (i6 = 0, len = tokens.length; i6 < len; i6++) {
        type2 = tokens[i6].type;
        if (type2 === "inline") {
          result += this.renderInline(tokens[i6].children, options, env);
        } else if (typeof rules[type2] !== "undefined") {
          result += rules[tokens[i6].type](tokens, i6, options, env, this);
        } else {
          result += this.renderToken(tokens, i6, options, env);
        }
      }
      return result;
    };
    module.exports = Renderer;
  }
});
var require_ruler = __commonJS2({
  "node_modules/markdown-it/lib/ruler.js"(exports, module) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name2) {
      for (var i6 = 0; i6 < this.__rules__.length; i6++) {
        if (this.__rules__[i6].name === name2) {
          return i6;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name2, fn2, options) {
      var index2 = this.__find__(name2);
      var opt = options || {};
      if (index2 === -1) {
        throw new Error("Parser rule not found: " + name2);
      }
      this.__rules__[index2].fn = fn2;
      this.__rules__[index2].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn2, options) {
      var index2 = this.__find__(beforeName);
      var opt = options || {};
      if (index2 === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index2, 0, {
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn2, options) {
      var index2 = this.__find__(afterName);
      var opt = options || {};
      if (index2 === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index2 + 1, 0, {
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn2, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn: fn2,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = true;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = false;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module.exports = Ruler;
  }
});
var require_normalize = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module.exports = function normalize2(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "�");
      state.src = str;
    };
  }
});
var require_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module) {
    "use strict";
    module.exports = function block42(state) {
      var token2;
      if (state.inlineMode) {
        token2 = new state.Token("inline", "", 0);
        token2.content = state.src;
        token2.map = [0, 1];
        token2.children = [];
        state.tokens.push(token2);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});
var require_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module) {
    "use strict";
    module.exports = function inline4(state) {
      var tokens = state.tokens, tok, i6, l6;
      for (i6 = 0, l6 = tokens.length; i6 < l6; i6++) {
        tok = tokens[i6];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});
var require_linkify = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module) {
    "use strict";
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module.exports = function linkify(state) {
      var i6, j3, l6, tokens, token2, currentToken, nodes, ln2, text22, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j3 = 0, l6 = blockTokens.length; j3 < l6; j3++) {
        if (blockTokens[j3].type !== "inline" || !state.md.linkify.pretest(blockTokens[j3].content)) {
          continue;
        }
        tokens = blockTokens[j3].children;
        htmlLinkLevel = 0;
        for (i6 = tokens.length - 1; i6 >= 0; i6--) {
          currentToken = tokens[i6];
          if (currentToken.type === "link_close") {
            i6--;
            while (tokens[i6].level !== currentToken.level && tokens[i6].type !== "link_open") {
              i6--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text22 = currentToken.content;
            links = state.md.linkify.match(text22);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            for (ln2 = 0; ln2 < links.length; ln2++) {
              url = links[ln2].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln2].text;
              if (!links[ln2].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln2].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln2].index;
              if (pos > lastPos) {
                token2 = new state.Token("text", "", 0);
                token2.content = text22.slice(lastPos, pos);
                token2.level = level;
                nodes.push(token2);
              }
              token2 = new state.Token("link_open", "a", 1);
              token2.attrs = [["href", fullUrl]];
              token2.level = level++;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              token2 = new state.Token("text", "", 0);
              token2.content = urlText;
              token2.level = level;
              nodes.push(token2);
              token2 = new state.Token("link_close", "a", -1);
              token2.level = --level;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              lastPos = links[ln2].lastIndex;
            }
            if (lastPos < text22.length) {
              token2 = new state.Token("text", "", 0);
              token2.content = text22.slice(lastPos);
              token2.level = level;
              nodes.push(token2);
            }
            blockTokens[j3].children = tokens = arrayReplaceAt(tokens, i6, nodes);
          }
        }
      }
    };
  }
});
var require_replacements = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
    var SCOPED_ABBR = {
      c: "©",
      r: "®",
      p: "§",
      tm: "™"
    };
    function replaceFn(match3, name2) {
      return SCOPED_ABBR[name2.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i6, token2, inside_autolink = 0;
      for (i6 = inlineTokens.length - 1; i6 >= 0; i6--) {
        token2 = inlineTokens[i6];
        if (token2.type === "text" && !inside_autolink) {
          token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i6, token2, inside_autolink = 0;
      for (i6 = inlineTokens.length - 1; i6 >= 0; i6--) {
        token2 = inlineTokens[i6];
        if (token2.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token2.content)) {
            token2.content = token2.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
          }
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module.exports = function replace2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});
var require_smartquotes = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module) {
    "use strict";
    var isWhiteSpace2 = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "’";
    function replaceAt(str, index2, ch) {
      return str.substr(0, index2) + ch + str.substr(index2 + 1);
    }
    function process_inlines(tokens, state) {
      var i6, token2, text22, t5, pos, max2, thisLevel, item2, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j3, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i6 = 0; i6 < tokens.length; i6++) {
        token2 = tokens[i6];
        thisLevel = tokens[i6].level;
        for (j3 = stack.length - 1; j3 >= 0; j3--) {
          if (stack[j3].level <= thisLevel) {
            break;
          }
        }
        stack.length = j3 + 1;
        if (token2.type !== "text") {
          continue;
        }
        text22 = token2.content;
        pos = 0;
        max2 = text22.length;
        OUTER:
          while (pos < max2) {
            QUOTE_RE.lastIndex = pos;
            t5 = QUOTE_RE.exec(text22);
            if (!t5) {
              break;
            }
            canOpen = canClose = true;
            pos = t5.index + 1;
            isSingle = t5[0] === "'";
            lastChar = 32;
            if (t5.index - 1 >= 0) {
              lastChar = text22.charCodeAt(t5.index - 1);
            } else {
              for (j3 = i6 - 1; j3 >= 0; j3--) {
                if (tokens[j3].type === "softbreak" || tokens[j3].type === "hardbreak")
                  break;
                if (!tokens[j3].content)
                  continue;
                lastChar = tokens[j3].content.charCodeAt(tokens[j3].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max2) {
              nextChar = text22.charCodeAt(pos);
            } else {
              for (j3 = i6 + 1; j3 < tokens.length; j3++) {
                if (tokens[j3].type === "softbreak" || tokens[j3].type === "hardbreak")
                  break;
                if (!tokens[j3].content)
                  continue;
                nextChar = tokens[j3].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace2(lastChar);
            isNextWhiteSpace = isWhiteSpace2(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t5[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token2.content = replaceAt(token2.content, t5.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j3 = stack.length - 1; j3 >= 0; j3--) {
                item2 = stack[j3];
                if (stack[j3].level < thisLevel) {
                  break;
                }
                if (item2.single === isSingle && stack[j3].level === thisLevel) {
                  item2 = stack[j3];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token2.content = replaceAt(token2.content, t5.index, closeQuote);
                  tokens[item2.token].content = replaceAt(tokens[item2.token].content, item2.pos, openQuote);
                  pos += closeQuote.length - 1;
                  if (item2.token === i6) {
                    pos += openQuote.length - 1;
                  }
                  text22 = token2.content;
                  max2 = text22.length;
                  stack.length = j3;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i6,
                pos: t5.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token2.content = replaceAt(token2.content, t5.index, APOSTROPHE);
            }
          }
      }
    }
    module.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});
var require_token = __commonJS2({
  "node_modules/markdown-it/lib/token.js"(exports, module) {
    "use strict";
    function Token2(type2, tag, nesting) {
      this.type = type2;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token2.prototype.attrIndex = function attrIndex(name2) {
      var attrs, i6, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i6 = 0, len = attrs.length; i6 < len; i6++) {
        if (attrs[i6][0] === name2) {
          return i6;
        }
      }
      return -1;
    };
    Token2.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token2.prototype.attrSet = function attrSet(name2, value2) {
      var idx = this.attrIndex(name2), attrData = [name2, value2];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token2.prototype.attrGet = function attrGet(name2) {
      var idx = this.attrIndex(name2), value2 = null;
      if (idx >= 0) {
        value2 = this.attrs[idx][1];
      }
      return value2;
    };
    Token2.prototype.attrJoin = function attrJoin(name2, value2) {
      var idx = this.attrIndex(name2);
      if (idx < 0) {
        this.attrPush([name2, value2]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value2;
      }
    };
    module.exports = Token2;
  }
});
var require_state_core = __commonJS2({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token2;
    module.exports = StateCore;
  }
});
var require_parser_core = __commonJS2({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i6 = 0; i6 < _rules.length; i6++) {
        this.ruler.push(_rules[i6][0], _rules[i6][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i6, l6, rules;
      rules = this.ruler.getRules("");
      for (i6 = 0, l6 = rules.length; i6 < l6; i6++) {
        rules[i6](state);
      }
    };
    Core.prototype.State = require_state_core();
    module.exports = Core;
  }
});
var require_table = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function getLine2(state, line2) {
      var pos = state.bMarks[line2] + state.tShift[line2], max2 = state.eMarks[line2];
      return state.src.substr(pos, max2 - pos);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max2 = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max2) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    module.exports = function table3(state, startLine, endLine, silent) {
      var ch, lineText, pos, i6, l6, nextLine, columns, columnCount, token2, aligns, t5, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine2(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i6 = 0; i6 < columns.length; i6++) {
        t5 = columns[i6].trim();
        if (!t5) {
          if (i6 === 0 || i6 === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t5)) {
          return false;
        }
        if (t5.charCodeAt(t5.length - 1) === 58) {
          aligns.push(t5.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t5.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine2(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token2 = state.push("table_open", "table", 1);
      token2.map = tableLines = [startLine, 0];
      token2 = state.push("thead_open", "thead", 1);
      token2.map = [startLine, startLine + 1];
      token2 = state.push("tr_open", "tr", 1);
      token2.map = [startLine, startLine + 1];
      for (i6 = 0; i6 < columns.length; i6++) {
        token2 = state.push("th_open", "th", 1);
        if (aligns[i6]) {
          token2.attrs = [["style", "text-align:" + aligns[i6]]];
        }
        token2 = state.push("inline", "", 0);
        token2.content = columns[i6].trim();
        token2.children = [];
        token2 = state.push("th_close", "th", -1);
      }
      token2 = state.push("tr_close", "tr", -1);
      token2 = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i6 = 0, l6 = terminatorRules.length; i6 < l6; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine2(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token2 = state.push("tbody_open", "tbody", 1);
          token2.map = tbodyLines = [startLine + 2, 0];
        }
        token2 = state.push("tr_open", "tr", 1);
        token2.map = [nextLine, nextLine + 1];
        for (i6 = 0; i6 < columnCount; i6++) {
          token2 = state.push("td_open", "td", 1);
          if (aligns[i6]) {
            token2.attrs = [["style", "text-align:" + aligns[i6]]];
          }
          token2 = state.push("inline", "", 0);
          token2.content = columns[i6] ? columns[i6].trim() : "";
          token2.children = [];
          token2 = state.push("td_close", "td", -1);
        }
        token2 = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token2 = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token2 = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});
var require_code = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module) {
    "use strict";
    module.exports = function code2(state, startLine, endLine) {
      if (state.md.options.allowIndentation) {
        return false;
      }
      var nextLine, last, token2;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token2 = state.push("code_block", "code", 0);
      token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token2.map = [startLine, state.line];
      return true;
    };
  }
});
var require_fence = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module) {
    "use strict";
    module.exports = function fence3(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max2) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max2);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max2 = state.eMarks[nextLine];
        if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max2) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token2 = state.push("fence", "code", 0);
      token2.info = params;
      token2.content = state.getLines(startLine + 1, nextLine, len, true);
      token2.markup = markup;
      token2.map = [startLine, state.line];
      return true;
    };
  }
});
var require_blockquote = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function blockquote2(state, startLine, endLine, silent) {
      var adjustTab, ch, i6, initial, l6, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max2;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max2 = state.eMarks[nextLine];
        if (pos >= max2) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max2) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max2;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i6 = 0, l6 = terminatorRules.length; i6 < l6; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token2 = state.push("blockquote_open", "blockquote", 1);
      token2.markup = ">";
      token2.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token2 = state.push("blockquote_close", "blockquote", -1);
      token2.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i6 = 0; i6 < oldTShift.length; i6++) {
        state.bMarks[i6 + startLine] = oldBMarks[i6];
        state.tShift[i6 + startLine] = oldTShift[i6];
        state.sCount[i6 + startLine] = oldSCount[i6];
        state.bsCount[i6 + startLine] = oldBSCount[i6];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});
var require_hr = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function hr2(state, startLine, endLine, silent) {
      var marker, cnt, ch, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max2) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token2 = state.push("hr", "hr", 0);
      token2.map = [startLine, state.line];
      token2.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});
var require_list = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max2, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max2 = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start2 = state.bMarks[startLine] + state.tShift[startLine], pos = start2, max2 = state.eMarks[startLine];
      if (pos + 1 >= max2) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max2) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start2 >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i6, l6, level = state.level + 2;
      for (i6 = idx + 2, l6 = state.tokens.length - 2; i6 < l6; i6++) {
        if (state.tokens[i6].level === level && state.tokens[i6].type === "paragraph_open") {
          state.tokens[i6 + 2].hidden = true;
          state.tokens[i6].hidden = true;
          i6 += 2;
        }
      }
    }
    module.exports = function list2(state, startLine, endLine, silent) {
      var ch, contentStart, i6, indent2, indentAfterMarker, initial, isOrdered, itemLines, l6, listLines, listTokIdx, markerCharCode, markerValue, max2, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start2, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.allowIndentation && state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start2 = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start2, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token2 = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token2.attrs = [["start", markerValue]];
        }
      } else {
        token2 = state.push("bullet_list_open", "ul", 1);
      }
      token2.map = listLines = [startLine, 0];
      token2.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max2 = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max2) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max2) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (!state.md.options.allowIndentation && indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent2 = initial + indentAfterMarker;
        token2 = state.push("list_item_open", "li", 1);
        token2.markup = String.fromCharCode(markerCharCode);
        token2.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token2.info = state.src.slice(start2, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent2;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max2 && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token2 = state.push("list_item_close", "li", -1);
        token2.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i6 = 0, l6 = terminatorRules.length; i6 < l6; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start2 = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token2 = state.push("ordered_list_close", "ol", -1);
      } else {
        token2 = state.push("bullet_list_close", "ul", -1);
      }
      token2.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});
var require_reference = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i6, l6, label, labelEnd, oldParentType, res, start2, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine], nextLine = startLine + 1;
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max2) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max2) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i6 = 0, l6 = terminatorRules.length; i6 < l6; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max2 = str.length;
      for (pos = 1; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max2 && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max2);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start2 = pos;
      for (; pos < max2; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max2);
      if (pos < max2 && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max2) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max2 && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max2) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max2 && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});
var require_html_blocks = __commonJS2({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module) {
    "use strict";
    module.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});
var require_html_re = __commonJS2({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module) {
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment22 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration2 = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment22 + "|" + processing + "|" + declaration2 + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module.exports.HTML_TAG_RE = HTML_TAG_RE;
    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});
var require_html_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module.exports = function html_block(state, startLine, endLine, silent) {
      var i6, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max2);
      for (i6 = 0; i6 < HTML_SEQUENCES.length; i6++) {
        if (HTML_SEQUENCES[i6][0].test(lineText)) {
          break;
        }
      }
      if (i6 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i6][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i6][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max2 = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max2);
          if (HTML_SEQUENCES[i6][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token2 = state.push("html_block", "", 0);
      token2.map = [startLine, nextLine];
      token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});
var require_heading = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function heading2(state, startLine, endLine, silent) {
      var ch, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max2) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max2 && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max2 && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max2 = state.skipSpacesBack(max2, pos);
      tmp = state.skipCharsBack(max2, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max2 = tmp;
      }
      state.line = startLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = "########".slice(0, level);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = state.src.slice(pos, max2).trim();
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = "########".slice(0, level);
      return true;
    };
  }
});
var require_lheading = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module) {
    "use strict";
    module.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i6, l6, token2, pos, max2, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max2 = state.eMarks[nextLine];
          if (pos < max2) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max2) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i6 = 0, l6 = terminatorRules.length; i6 < l6; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = String.fromCharCode(marker);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content;
      token2.map = [startLine, state.line - 1];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});
var require_paragraph = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module) {
    "use strict";
    module.exports = function paragraph2(state, startLine) {
      var content, terminate, i6, l6, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i6 = 0, l6 = terminatorRules.length; i6 < l6; i6++) {
          if (terminatorRules[i6](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token2 = state.push("paragraph_open", "p", 1);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content;
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});
var require_state_block = __commonJS2({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s22, start2, pos, len, indent2, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s22 = this.src;
      indent_found = false;
      for (start2 = pos = indent2 = offset = 0, len = s22.length; pos < len; pos++) {
        ch = s22.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent2++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start2);
          this.eMarks.push(pos);
          this.tShift.push(indent2);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent2 = 0;
          offset = 0;
          start2 = pos + 1;
        }
      }
      this.bMarks.push(s22.length);
      this.eMarks.push(s22.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type2, tag, nesting) {
      var token2 = new Token2(type2, tag, nesting);
      token2.block = true;
      if (nesting < 0)
        this.level--;
      token2.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token2);
      return token2;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line2) {
      return this.bMarks[line2] + this.tShift[line2] >= this.eMarks[line2];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from2) {
      for (var max2 = this.lineMax; from2 < max2; from2++) {
        if (this.bMarks[from2] + this.tShift[from2] < this.eMarks[from2]) {
          break;
        }
      }
      return from2;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max2 = this.src.length; pos < max2; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code2) {
      for (var max2 = this.src.length; pos < max2; pos++) {
        if (this.src.charCodeAt(pos) !== code2) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code2 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent2, keepLastLF) {
      var i6, lineIndent, ch, first, last, queue, lineStart, line2 = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i6 = 0; line2 < end; line2++, i6++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line2];
        if (line2 + 1 < end || keepLastLF) {
          last = this.eMarks[line2] + 1;
        } else {
          last = this.eMarks[line2];
        }
        while (first < last && lineIndent < indent2) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line2]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line2]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent2) {
          queue[i6] = new Array(lineIndent - indent2 + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i6] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token2;
    module.exports = StateBlock;
  }
});
var require_parser_block = __commonJS2({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i6 = 0; i6 < _rules.length; i6++) {
        this.ruler.push(_rules[i6][0], _rules[i6][1], { alt: (_rules[i6][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i6, rules = this.ruler.getRules(""), len = rules.length, line2 = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line2 < endLine) {
        state.line = line2 = state.skipEmptyLines(line2);
        if (line2 >= endLine) {
          break;
        }
        if (state.sCount[line2] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i6 = 0; i6 < len; i6++) {
          ok = rules[i6](state, line2, endLine, false);
          if (ok) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line2 = state.line;
        if (line2 < endLine && state.isEmpty(line2)) {
          hasEmptyLines = true;
          line2++;
          state.line = line2;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module.exports = ParserBlock;
  }
});
var require_text = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module.exports = function text22(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});
var require_newline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function newline(state, silent) {
      var pmax, max2, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max2 = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max2 && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});
var require_escape = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module) {
    "use strict";
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i6 = 0; i6 < 256; i6++) {
      ESCAPED.push(0);
    }
    var i6;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module.exports = function escape2(state, silent) {
      var ch, pos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 92) {
        return false;
      }
      pos++;
      if (pos < max2) {
        ch = state.src.charCodeAt(pos);
        if (ch < 256 && ESCAPED[ch] !== 0) {
          if (!silent) {
            state.pending += state.src[pos];
          }
          state.pos += 2;
          return true;
        }
        if (ch === 10) {
          if (!silent) {
            state.push("hardbreak", "br", 0);
          }
          pos++;
          while (pos < max2) {
            ch = state.src.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
          state.pos = pos;
          return true;
        }
      }
      if (!silent) {
        state.pending += "\\";
      }
      state.pos++;
      return true;
    };
  }
});
var require_backticks = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module) {
    "use strict";
    module.exports = function backtick(state, silent) {
      var start2, max2, marker, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start2 = pos;
      pos++;
      max2 = state.posMax;
      while (pos < max2 && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start2, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start2) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token2 = state.push("code_inline", "code", 0);
            token2.markup = marker;
            token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});
var require_strikethrough = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function strikethrough(state, silent) {
      var i6, scanned, token2, len, ch, start2 = state.pos, marker = state.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch;
        len--;
      }
      for (i6 = 0; i6 < len; i6 += 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i6, j3, startDelim, endDelim, token2, loneMarkers = [], max2 = delimiters.length;
      for (i6 = 0; i6 < max2; i6++) {
        startDelim = delimiters[i6];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token2 = state.tokens[startDelim.token];
        token2.type = "s_open";
        token2.tag = "s";
        token2.nesting = 1;
        token2.markup = "~~";
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = "s_close";
        token2.tag = "s";
        token2.nesting = -1;
        token2.markup = "~~";
        token2.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i6 = loneMarkers.pop();
        j3 = i6 + 1;
        while (j3 < state.tokens.length && state.tokens[j3].type === "s_close") {
          j3++;
        }
        j3--;
        if (i6 !== j3) {
          token2 = state.tokens[j3];
          state.tokens[j3] = state.tokens[i6];
          state.tokens[i6] = token2;
        }
      }
    }
    module.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_emphasis = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function emphasis(state, silent) {
      var i6, scanned, token2, start2 = state.pos, marker = state.src.charCodeAt(start2);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i6 = 0; i6 < scanned.length; i6++) {
        token2 = state.push("text", "", 0);
        token2.content = String.fromCharCode(marker);
        state.delimiters.push({
          marker,
          length: scanned.length,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i6, startDelim, endDelim, token2, ch, isStrong, max2 = delimiters.length;
      for (i6 = max2 - 1; i6 >= 0; i6--) {
        startDelim = delimiters[i6];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i6 > 0 && delimiters[i6 - 1].end === startDelim.end + 1 && delimiters[i6 - 1].marker === startDelim.marker && delimiters[i6 - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token2 = state.tokens[startDelim.token];
        token2.type = isStrong ? "strong_open" : "em_open";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = 1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = isStrong ? "strong_close" : "em_close";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = -1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        if (isStrong) {
          state.tokens[delimiters[i6 - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i6--;
        }
      }
    }
    module.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_link = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function link2(state, silent) {
      var attrs, code2, label, labelEnd, labelStart, pos, res, ref, token2, href = "", title = "", oldPos = state.pos, max2 = state.posMax, start2 = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max2 && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max2) {
          return false;
        }
        start2 = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start2 = pos;
          for (; pos < max2; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max2 && start2 !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max2; pos++) {
              code2 = state.src.charCodeAt(pos);
              if (!isSpace(code2) && code2 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max2 && state.src.charCodeAt(pos) === 91) {
          start2 = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start2, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token2 = state.push("link_open", "a", 1);
        token2.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.md.inline.tokenize(state);
        token2 = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max2;
      return true;
    };
  }
});
var require_image = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function image2(state, silent) {
      var attrs, code2, content, label, labelEnd, labelStart, pos, ref, res, title, token2, tokens, start2, href = "", oldPos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max2 && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max2) {
          return false;
        }
        start2 = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start2 = pos;
        for (; pos < max2; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max2 && start2 !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max2; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max2 && state.src.charCodeAt(pos) === 91) {
          start2 = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start2, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(content, state.md, state.env, tokens = []);
        token2 = state.push("image", "img", 0);
        token2.attrs = attrs = [["src", href], ["alt", ""]];
        token2.children = tokens;
        token2.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max2;
      return true;
    };
  }
});
var require_autolink = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module) {
    "use strict";
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module.exports = function autolink(state, silent) {
      var url, fullUrl, token2, ch, start2, max2, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start2 = state.pos;
      max2 = state.posMax;
      for (; ; ) {
        if (++pos >= max2)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start2 + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});
var require_html_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module) {
    "use strict";
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLetter2(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module.exports = function html_inline(state, silent) {
      var ch, match3, max2, token2, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter2(ch)) {
        return false;
      }
      match3 = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match3) {
        return false;
      }
      if (!silent) {
        token2 = state.push("html_inline", "", 0);
        token2.content = state.src.slice(pos, pos + match3[0].length);
      }
      state.pos += match3[0].length;
      return true;
    };
  }
});
var require_entity = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module) {
    "use strict";
    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint3 = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module.exports = function entity(state, silent) {
      var ch, code2, match3, pos = state.pos, max2 = state.posMax;
      if (state.src.charCodeAt(pos) !== 38) {
        return false;
      }
      if (pos + 1 < max2) {
        ch = state.src.charCodeAt(pos + 1);
        if (ch === 35) {
          match3 = state.src.slice(pos).match(DIGITAL_RE);
          if (match3) {
            if (!silent) {
              code2 = match3[1][0].toLowerCase() === "x" ? parseInt(match3[1].slice(1), 16) : parseInt(match3[1], 10);
              state.pending += isValidEntityCode(code2) ? fromCodePoint3(code2) : fromCodePoint3(65533);
            }
            state.pos += match3[0].length;
            return true;
          }
        } else {
          match3 = state.src.slice(pos).match(NAMED_RE);
          if (match3) {
            if (has(entities, match3[1])) {
              if (!silent) {
                state.pending += entities[match3[1]];
              }
              state.pos += match3[0].length;
              return true;
            }
          }
        }
      }
      if (!silent) {
        state.pending += "&";
      }
      state.pos++;
      return true;
    };
  }
});
var require_balance_pairs = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module) {
    "use strict";
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max2 = delimiters.length;
      if (!max2)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max2; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max2; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});
var require_text_collapse = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/text_collapse.js"(exports, module) {
    "use strict";
    module.exports = function text_collapse(state) {
      var curr, last, level = 0, tokens = state.tokens, max2 = state.tokens.length;
      for (curr = last = 0; curr < max2; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max2 && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});
var require_state_inline = __commonJS2({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module) {
    "use strict";
    var Token2 = require_token();
    var isWhiteSpace2 = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
    }
    StateInline.prototype.pushPending = function() {
      var token2 = new Token2("text", "", 0);
      token2.content = this.pending;
      token2.level = this.pendingLevel;
      this.tokens.push(token2);
      this.pending = "";
      return token2;
    };
    StateInline.prototype.push = function(type2, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token2 = new Token2(type2, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token2.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token2);
      this.tokens_meta.push(token_meta);
      return token2;
    };
    StateInline.prototype.scanDelims = function(start2, canSplitWord) {
      var pos = start2, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max2 = this.posMax, marker = this.src.charCodeAt(start2);
      lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
      while (pos < max2 && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start2;
      nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace2(lastChar);
      isNextWhiteSpace = isWhiteSpace2(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token2;
    module.exports = StateInline;
  }
});
var require_parser_inline = __commonJS2({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      ["text_collapse", require_text_collapse()]
    ];
    function ParserInline() {
      var i6;
      this.ruler = new Ruler();
      for (i6 = 0; i6 < _rules.length; i6++) {
        this.ruler.push(_rules[i6][0], _rules[i6][1]);
      }
      this.ruler2 = new Ruler();
      for (i6 = 0; i6 < _rules2.length; i6++) {
        this.ruler2.push(_rules2[i6][0], _rules2[i6][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i6, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache3 = state.cache;
      if (typeof cache3[pos] !== "undefined") {
        state.pos = cache3[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i6 = 0; i6 < len; i6++) {
          state.level++;
          ok = rules[i6](state, true);
          state.level--;
          if (ok) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache3[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i6, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i6 = 0; i6 < len; i6++) {
            ok = rules[i6](state, false);
            if (ok) {
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md, env, outTokens) {
      var i6, rules, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i6 = 0; i6 < len; i6++) {
        rules[i6](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module.exports = ParserInline;
  }
});
var require_re = __commonJS2({
  "node_modules/linkify-it/lib/re.js"(exports, module) {
    "use strict";
    module.exports = function(opts) {
      var re = {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><｜]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|;(?!" + re.src_ZCc + ").|\\!+(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});
var require_linkify_it = __commonJS2({
  "node_modules/linkify-it/index.js"(exports, module) {
    "use strict";
    function assign2(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString2(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject2(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction2(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k2) {
        return acc || defaultOptions.hasOwnProperty(k2);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text22[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text22[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text22, pos, self2) {
          var tail = text22.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text22, pos) {
        var tail = text22.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match3, self2) {
        self2.normalize(match3);
      };
    }
    function compile2(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name2, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name2) {
        var val = self2.__schemas__[name2];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name2] = compiled;
        if (isObject2(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction2(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name2, val);
          }
          if (isFunction2(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name2, val);
          }
          return;
        }
        if (isString2(val)) {
          aliases.push(name2);
          return;
        }
        schemaError(name2, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name2) {
        return name2.length > 0 && self2.__compiled__[name2];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start2 = self2.__index__, end = self2.__last_index__, text22 = self2.__text_cache__.slice(start2, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start2 + shift;
      this.lastIndex = end + shift;
      this.raw = text22;
      this.text = text22;
      this.url = text22;
    }
    function createMatch(self2, shift) {
      var match3 = new Match(self2, shift);
      self2.__compiled__[match3.schema].normalize(match3, self2);
      return match3;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign2({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign2({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile2(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile2(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign2(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text22) {
      this.__text_cache__ = text22;
      this.__index__ = -1;
      if (!text22.length) {
        return false;
      }
      var m2, ml, me, len, shift, next2, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text22)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m2 = re.exec(text22)) !== null) {
          len = this.testSchemaAt(text22, m2[2], re.lastIndex);
          if (len) {
            this.__schema__ = m2[2];
            this.__index__ = m2.index + m2[1].length;
            this.__last_index__ = m2.index + m2[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text22.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text22.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text22.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text22.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next2 = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next2 > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next2;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text22) {
      return this.re.pretest.test(text22);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text22, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text22, pos, this);
    };
    LinkifyIt.prototype.match = function match3(text22) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text22) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text22.slice(shift) : text22;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
      list2 = Array.isArray(list2) ? list2 : [list2];
      if (!keepOld) {
        this.__tlds__ = list2.slice();
        this.__tlds_replaced__ = true;
        compile2(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile2(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize2(match3) {
      if (!match3.schema) {
        match3.url = "http://" + match3.url;
      }
      if (match3.schema === "mailto:" && !/^mailto:/i.test(match3.url)) {
        match3.url = "mailto:" + match3.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module.exports = LinkifyIt;
  }
});
var require_punycode = __commonJS2({
  "node_modules/punycode/punycode.js"(exports, module) {
    "use strict";
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter2 = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error22(type2) {
      throw new RangeError(errors[type2]);
    }
    function map2(array, fn2) {
      const result = [];
      let length2 = array.length;
      while (length2--) {
        result[length2] = fn2(array[length2]);
      }
      return result;
    }
    function mapDomain(string, fn2) {
      const parts = string.split("@");
      let result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      const labels = string.split(".");
      const encoded = map2(labels, fn2).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      const output = [];
      let counter2 = 0;
      const length2 = string.length;
      while (counter2 < length2) {
        const value2 = string.charCodeAt(counter2++);
        if (value2 >= 55296 && value2 <= 56319 && counter2 < length2) {
          const extra = string.charCodeAt(counter2++);
          if ((extra & 64512) == 56320) {
            output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value2);
            counter2--;
          }
        } else {
          output.push(value2);
        }
      }
      return output;
    }
    var ucs2encode = (array) => String.fromCodePoint(...array);
    var basicToDigit = function(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function(delta, numPoints, firstTime) {
      let k2 = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i6 = 0;
      let n6 = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter2);
      if (basic < 0) {
        basic = 0;
      }
      for (let j3 = 0; j3 < basic; ++j3) {
        if (input.charCodeAt(j3) >= 128) {
          error22("not-basic");
        }
        output.push(input.charCodeAt(j3));
      }
      for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
        let oldi = i6;
        for (let w2 = 1, k2 = base; ; k2 += base) {
          if (index2 >= inputLength) {
            error22("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index2++));
          if (digit >= base || digit > floor((maxInt - i6) / w2)) {
            error22("overflow");
          }
          i6 += digit * w2;
          const t5 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t5) {
            break;
          }
          const baseMinusT = base - t5;
          if (w2 > floor(maxInt / baseMinusT)) {
            error22("overflow");
          }
          w2 *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i6 - oldi, out, oldi == 0);
        if (floor(i6 / out) > maxInt - n6) {
          error22("overflow");
        }
        n6 += floor(i6 / out);
        i6 %= out;
        output.splice(i6++, 0, n6);
      }
      return String.fromCodePoint(...output);
    };
    var encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      let inputLength = input.length;
      let n6 = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      let basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter2);
      }
      while (handledCPCount < inputLength) {
        let m2 = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n6 && currentValue < m2) {
            m2 = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n6 > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error22("overflow");
        }
        delta += (m2 - n6) * handledCPCountPlusOne;
        n6 = m2;
        for (const currentValue of input) {
          if (currentValue < n6 && ++delta > maxInt) {
            error22("overflow");
          }
          if (currentValue == n6) {
            let q2 = delta;
            for (let k2 = base; ; k2 += base) {
              const t5 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q2 < t5) {
                break;
              }
              const qMinusT = q2 - t5;
              const baseMinusT = base - t5;
              output.push(stringFromCharCode(digitToBasic(t5 + qMinusT % baseMinusT, 0)));
              q2 = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q2, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n6;
      }
      return output.join("");
    };
    var toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    module.exports = punycode;
  }
});
var require_default = __commonJS2({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});
var require_zero = __commonJS2({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "text_collapse"
          ]
        }
      }
    };
  }
});
var require_commonmark = __commonJS2({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "“”‘’",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "text_collapse"
          ]
        }
      }
    };
  }
});
var require_lib2 = __commonJS2({
  "node_modules/markdown-it/lib/index.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = require_punycode();
    var config2 = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt3(presetName, options) {
      if (!(this instanceof MarkdownIt3)) {
        return new MarkdownIt3(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt3.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt3.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config2[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name2) {
          if (presets.components[name2].rules) {
            self2[name2].ruler.enableOnly(presets.components[name2].rules);
          }
          if (presets.components[name2].rules2) {
            self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt3.prototype.enable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      var missed = list2.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.disable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      var missed = list2.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt3.prototype.use = function(plugin4) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin4.apply(plugin4, args);
      return this;
    };
    MarkdownIt3.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt3.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt3.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module.exports = MarkdownIt3;
  }
});
var require_markdown_it = __commonJS2({
  "node_modules/markdown-it/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib2();
  }
});
var base_exports = {};
__export(base_exports, {
  getAstValues: () => getAstValues,
  isAst: () => isAst,
  isFunction: () => isFunction,
  isVariable: () => isVariable,
  resolve: () => resolve
});
function isAst(value2) {
  return !!(value2 == null ? void 0 : value2.$$mdtype);
}
function isFunction(value2) {
  return !!((value2 == null ? void 0 : value2.$$mdtype) === "Function");
}
function isVariable(value2) {
  return !!((value2 == null ? void 0 : value2.$$mdtype) === "Variable");
}
function* getAstValues(value2) {
  if (value2 == null || typeof value2 !== "object")
    return;
  if (Array.isArray(value2))
    for (const v5 of value2)
      yield* getAstValues(v5);
  if (isAst(value2))
    yield value2;
  if (Object.getPrototypeOf(value2) !== Object.prototype)
    return;
  for (const v5 of Object.values(value2))
    yield* getAstValues(v5);
}
function resolve(value2, config2 = {}) {
  if (value2 == null || typeof value2 !== "object")
    return value2;
  if (Array.isArray(value2))
    return value2.map((item2) => resolve(item2, config2));
  if (isAst(value2) && (value2 == null ? void 0 : value2.resolve) instanceof Function)
    return value2.resolve(config2);
  if (Object.getPrototypeOf(value2) !== Object.prototype)
    return value2;
  const output = {};
  for (const [k2, v5] of Object.entries(value2))
    output[k2] = resolve(v5, config2);
  return output;
}
var Tag = class {
  constructor(name2 = "div", attributes = {}, children = []) {
    this.$$mdtype = "Tag";
    this.name = name2;
    this.attributes = attributes;
    this.children = children;
  }
};
Tag.isTag = (tag) => {
  return !!((tag == null ? void 0 : tag.$$mdtype) === "Tag");
};
var Class = class {
  validate(value2, _config, key) {
    if (typeof value2 === "string" || typeof value2 === "object")
      return [];
    return [
      {
        id: "attribute-type-invalid",
        level: "error",
        message: `Attribute '${key}' must be type 'string | object'`
      }
    ];
  }
  transform(value2) {
    if (!value2 || typeof value2 === "string")
      return value2;
    const classes = [];
    for (const [k2, v5] of Object.entries(value2 ?? {}))
      if (v5)
        classes.push(k2);
    return classes.join(" ");
  }
};
var Id = class {
  validate(value2) {
    if (typeof value2 === "string" && value2.match(/^[a-zA-Z]/))
      return [];
    return [
      {
        id: "attribute-value-invalid",
        level: "error",
        message: "The 'id' attribute must start with a letter"
      }
    ];
  }
};
var import_tag = __toModule(require_tag());
var Variable = class {
  constructor(path2 = []) {
    this.$$mdtype = "Variable";
    this.path = path2;
  }
  resolve({ variables } = {}) {
    return variables instanceof Function ? variables(this.path) : this.path.reduce((obj = {}, key) => obj[key], variables);
  }
};
var Function2 = class {
  constructor(name2, parameters) {
    this.$$mdtype = "Function";
    this.name = name2;
    this.parameters = parameters;
  }
  resolve(config2 = {}) {
    var _a2, _b;
    const fn2 = (_a2 = config2 == null ? void 0 : config2.functions) == null ? void 0 : _a2[this.name];
    if (!fn2)
      return null;
    const parameters = resolve(this.parameters, config2);
    return (_b = fn2.transform) == null ? void 0 : _b.call(fn2, parameters, config2);
  }
};
var STATES;
(function(STATES2) {
  STATES2[STATES2["normal"] = 0] = "normal";
  STATES2[STATES2["string"] = 1] = "string";
  STATES2[STATES2["escape"] = 2] = "escape";
})(STATES || (STATES = {}));
var OPEN = "{%";
var CLOSE = "%}";
var IDENTIFIER_REGEX = /^[a-zA-Z0-9_-]+$/;
function isIdentifier(s22) {
  return typeof s22 === "string" && IDENTIFIER_REGEX.test(s22);
}
function isPromise(a3) {
  return a3 && typeof a3 === "object" && typeof a3.then === "function";
}
function findTagEnd(content, start2 = 0) {
  let state = 0;
  for (let pos = start2; pos < content.length; pos++) {
    const char2 = content[pos];
    switch (state) {
      case 1:
        switch (char2) {
          case '"':
            state = 0;
            break;
          case "\\":
            state = 2;
            break;
        }
        break;
      case 2:
        state = 1;
        break;
      case 0:
        if (char2 === '"')
          state = 1;
        else if (content.startsWith(CLOSE, pos))
          return pos;
    }
  }
  return null;
}
function parseTag(content, line2, contentStart) {
  try {
    return (0, import_tag.parse)(content, { Variable, Function: Function2 });
  } catch (error22) {
    if (!(error22 instanceof import_tag.SyntaxError))
      throw error22;
    const {
      message,
      location: { start: start2, end }
    } = error22;
    const location2 = {
      start: { line: line2, character: start2.offset + contentStart },
      end: { line: line2 + 1, character: end.offset + contentStart }
    };
    return { type: "error", meta: { error: { message, location: location2 } } };
  }
}
function parseTags(content, firstLine = 0) {
  let line2 = firstLine + 1;
  const output = [];
  let start2 = 0;
  for (let pos = 0; pos < content.length; pos++) {
    if (content[pos] === "\n") {
      line2++;
      continue;
    }
    if (!content.startsWith(OPEN, pos))
      continue;
    const end = findTagEnd(content, pos);
    if (end == null) {
      pos = pos + OPEN.length;
      continue;
    }
    const text22 = content.slice(pos, end + CLOSE.length);
    const inner = content.slice(pos + OPEN.length, end);
    const lineStart = content.lastIndexOf("\n", pos);
    const lineEnd = content.indexOf("\n", end);
    const lineContent = content.slice(lineStart, lineEnd);
    const tag = parseTag(inner.trim(), line2, pos - lineStart);
    const precedingTextEnd = lineContent.trim() === text22 ? lineStart : pos;
    const precedingText = content.slice(start2, precedingTextEnd);
    output.push({
      type: "text",
      start: start2,
      end: pos - 1,
      content: precedingText
    });
    output.push({
      map: [line2, line2 + 1],
      position: {
        start: pos - lineStart,
        end: pos - lineStart + text22.length
      },
      start: pos,
      end: pos + text22.length - 1,
      info: text22,
      ...tag
    });
    start2 = end + CLOSE.length;
    pos = start2 - 1;
  }
  output.push({
    type: "text",
    start: start2,
    end: content.length - 1,
    content: content.slice(start2)
  });
  return output;
}
var globalAttributes = {
  class: { type: Class, render: true },
  id: { type: Id, render: true }
};
var transformer_default = {
  findSchema(node22, { nodes = {}, tags = {} } = {}) {
    return node22.tag ? tags[node22.tag] : nodes[node22.type];
  },
  attributes(node22, config2 = {}) {
    const schema = this.findSchema(node22, config2) ?? {};
    const output = {};
    const attrs = { ...globalAttributes, ...schema.attributes };
    for (const [key, attr] of Object.entries(attrs)) {
      if (attr.render == false)
        continue;
      const name2 = typeof attr.render === "string" ? attr.render : key;
      let value2 = node22.attributes[key];
      if (typeof attr.type === "function") {
        const instance = new attr.type();
        if (instance.transform) {
          value2 = instance.transform(value2, config2);
        }
      }
      value2 = value2 === void 0 ? attr.default : value2;
      if (value2 === void 0)
        continue;
      output[name2] = value2;
    }
    if (schema.slots) {
      for (const [key, slot2] of Object.entries(schema.slots)) {
        if (slot2.render === false)
          continue;
        const name2 = typeof slot2.render === "string" ? slot2.render : key;
        if (node22.slots[key])
          output[name2] = this.node(node22.slots[key], config2);
      }
    }
    return output;
  },
  children(node22, config2 = {}) {
    const children = node22.children.flatMap((child) => this.node(child, config2));
    if (children.some(isPromise)) {
      return Promise.all(children);
    }
    return children;
  },
  node(node22, config2 = {}) {
    const schema = this.findSchema(node22, config2) ?? {};
    if (schema && schema.transform instanceof Function)
      return schema.transform(node22, config2);
    const children = this.children(node22, config2);
    if (!schema || !schema.render)
      return children;
    const attributes = this.attributes(node22, config2);
    if (isPromise(attributes) || isPromise(children)) {
      return Promise.all([attributes, children]).then((values2) => new Tag(schema.render, ...values2));
    }
    return new Tag(schema.render, attributes, children);
  }
};
var Node2 = class {
  constructor(type2 = "node", attributes = {}, children = [], tag) {
    this.$$mdtype = "Node";
    this.errors = [];
    this.lines = [];
    this.inline = false;
    this.attributes = attributes;
    this.children = children;
    this.type = type2;
    this.tag = tag;
    this.annotations = [];
    this.slots = {};
  }
  *walk() {
    for (const child of [...Object.values(this.slots), ...this.children]) {
      yield child;
      yield* child.walk();
    }
  }
  push(node22) {
    this.children.push(node22);
  }
  resolve(config2 = {}) {
    return Object.assign(new Node2(), this, {
      children: this.children.map((child) => child.resolve(config2)),
      attributes: resolve(this.attributes, config2),
      slots: Object.fromEntries(Object.entries(this.slots).map(([name2, slot2]) => [
        name2,
        slot2.resolve(config2)
      ]))
    });
  }
  findSchema(config2 = {}) {
    return transformer_default.findSchema(this, config2);
  }
  transformAttributes(config2 = {}) {
    return transformer_default.attributes(this, config2);
  }
  transformChildren(config2) {
    return transformer_default.children(this, config2);
  }
  transform(config2) {
    return transformer_default.node(this, config2);
  }
};
var AstTypes = {
  Function: Function2,
  Node: Node2,
  Variable
};
function reviver(_2, value2) {
  if (!value2)
    return value2;
  const klass = AstTypes[value2.$$mdtype];
  return klass ? Object.assign(new klass(), value2) : value2;
}
function fromJSON(text22) {
  return JSON.parse(text22, reviver);
}
var ast_default = {
  ...AstTypes,
  ...base_exports,
  fromJSON
};
var SPACE = " ";
var SEP = ", ";
var NL = "\n";
var OL = ".";
var UL = "-";
var MAX_TAG_OPENING_WIDTH = 80;
var WRAPPING_TYPES = ["strong", "em", "s"];
var max = (a3, b2) => Math.max(a3, b2);
var increment = (o5, n6 = 2) => ({
  ...o5,
  indent: (o5.indent || 0) + n6
});
function* formatChildren(a3, options) {
  for (const child of a3.children) {
    yield* formatValue(child, options);
  }
}
function* formatInline(g3) {
  yield [...g3].join("").trim();
}
function* formatTableRow(items) {
  yield `| ${items.join(" | ")} |`;
}
function formatScalar(v5) {
  if (v5 === void 0) {
    return void 0;
  }
  if (ast_default.isAst(v5)) {
    return format(v5);
  }
  if (v5 === null) {
    return "null";
  }
  if (Array.isArray(v5)) {
    return "[" + v5.map(formatScalar).join(SEP) + "]";
  }
  if (typeof v5 === "object") {
    return "{" + Object.entries(v5).map(([key, value2]) => `${isIdentifier(key) ? key : `"${key}"`}: ${formatScalar(value2)}`).join(SEP) + "}";
  }
  return JSON.stringify(v5);
}
function formatAnnotationValue(a3) {
  const formattedValue = formatScalar(a3.value);
  if (formattedValue === void 0)
    return void 0;
  if (a3.name === "primary")
    return formattedValue;
  if (a3.name === "id" && typeof a3.value === "string" && isIdentifier(a3.value))
    return "#" + a3.value;
  if (a3.type === "class" && isIdentifier(a3.name))
    return "." + a3.name;
  return `${a3.name}=${formattedValue}`;
}
function* formatAttributes(n6) {
  for (const [key, value2] of Object.entries(n6.attributes)) {
    if (key === "class" && typeof value2 === "object" && !ast_default.isAst(value2))
      for (const name2 of Object.keys(value2)) {
        yield formatAnnotationValue({ type: "class", name: name2, value: value2 });
      }
    else
      yield formatAnnotationValue({ type: "attribute", name: key, value: value2 });
  }
}
function* formatAnnotations(n6) {
  if (n6.annotations.length) {
    yield OPEN + SPACE;
    yield n6.annotations.map(formatAnnotationValue).join(SPACE);
    yield SPACE + CLOSE;
  }
}
function* formatVariable(v5) {
  yield "$";
  yield v5.path.map((p5, i6) => {
    if (i6 === 0)
      return p5;
    if (isIdentifier(p5))
      return "." + p5;
    if (typeof p5 === "number")
      return `[${p5}]`;
    return `["${p5}"]`;
  }).join("");
}
function* formatFunction(f5) {
  yield f5.name;
  yield "(";
  yield Object.values(f5.parameters).map(formatScalar).join(SEP);
  yield ")";
}
function* trimStart4(g3) {
  let n6;
  do {
    const { value: value2, done } = g3.next();
    if (done)
      return;
    n6 = value2.trimStart();
  } while (!n6.length);
  yield n6;
  yield* g3;
}
function* escapeMarkdownCharacters(s22, characters2) {
  yield s22.replace(characters2, "\\$&").replace(new RegExp(" ", "g"), "&nbsp;");
}
function* formatNode(n6, o5 = {}) {
  const no = { ...o5, parent: n6 };
  const indent2 = SPACE.repeat(no.indent || 0);
  switch (n6.type) {
    case "document": {
      if (n6.attributes.frontmatter && n6.attributes.frontmatter.length) {
        yield "---" + NL + n6.attributes.frontmatter + NL + "---" + NL + NL;
      }
      yield* trimStart4(formatChildren(n6, no));
      break;
    }
    case "heading": {
      yield NL;
      yield indent2;
      yield "#".repeat(n6.attributes.level || 1);
      yield SPACE;
      yield* trimStart4(formatChildren(n6, no));
      yield* formatAnnotations(n6);
      yield NL;
      break;
    }
    case "paragraph": {
      yield NL;
      yield* formatChildren(n6, no);
      yield* formatAnnotations(n6);
      yield NL;
      break;
    }
    case "inline": {
      yield indent2;
      yield* formatChildren(n6, no);
      break;
    }
    case "image": {
      yield "!";
      yield "[";
      yield* formatValue(n6.attributes.alt, no);
      yield "]";
      yield "(";
      yield* typeof n6.attributes.src === "string" ? escapeMarkdownCharacters(n6.attributes.src, /[()]/) : formatValue(n6.attributes.src, no);
      if (n6.attributes.title) {
        yield SPACE + `"${n6.attributes.title}"`;
      }
      yield ")";
      break;
    }
    case "link": {
      yield "[";
      yield* formatChildren(n6, no);
      yield "]";
      yield "(";
      yield* typeof n6.attributes.href === "string" ? escapeMarkdownCharacters(n6.attributes.href, /[()]/g) : formatValue(n6.attributes.href, no);
      if (n6.attributes.title) {
        yield SPACE + `"${n6.attributes.title}"`;
      }
      yield ")";
      break;
    }
    case "text": {
      const { content } = n6.attributes;
      if (ast_default.isAst(content)) {
        yield OPEN + SPACE;
        yield* formatValue(content, no);
        yield SPACE + CLOSE;
      } else {
        if (o5.parent && WRAPPING_TYPES.includes(o5.parent.type)) {
          yield* escapeMarkdownCharacters(content, /[*_~]/g);
        } else {
          yield* escapeMarkdownCharacters(content, /^[*>#]/);
        }
      }
      break;
    }
    case "blockquote": {
      const prefix3 = ">" + SPACE;
      yield n6.children.map((child) => format(child, no).trimStart()).map((d5) => NL + indent2 + prefix3 + d5).join(indent2 + prefix3);
      break;
    }
    case "hr": {
      yield NL;
      yield indent2;
      yield "---";
      yield NL;
      break;
    }
    case "fence": {
      yield NL;
      yield indent2;
      const innerFence = n6.attributes.content.match(/`{3,}/g) || [];
      const innerFenceLength = innerFence.map((s22) => s22.length).reduce(max, 0);
      const boundary = "`".repeat(innerFenceLength ? innerFenceLength + 1 : 3);
      yield boundary;
      if (n6.attributes.language)
        yield n6.attributes.language;
      if (n6.annotations.length)
        yield SPACE;
      yield* formatAnnotations(n6);
      yield NL;
      yield indent2;
      yield n6.attributes.content.split(NL).join(NL + indent2);
      yield boundary;
      yield NL;
      break;
    }
    case "tag": {
      if (!n6.inline) {
        yield NL;
        yield indent2;
      }
      const open = OPEN + SPACE;
      const attributes = [...formatAttributes(n6)].filter((v5) => v5 !== void 0);
      const tag = [open + n6.tag, ...attributes];
      const inlineTag = tag.join(SPACE);
      const isLongTagOpening = inlineTag.length + open.length * 2 > (o5.maxTagOpeningWidth || MAX_TAG_OPENING_WIDTH);
      yield (!n6.inline && isLongTagOpening ? tag.join(NL + SPACE.repeat(open.length) + indent2) : inlineTag) + SPACE + (n6.children.length ? "" : "/") + CLOSE;
      if (n6.children.length) {
        yield* formatChildren(n6, no.allowIndentation ? increment(no) : no);
        if (!n6.inline) {
          yield indent2;
        }
        yield OPEN + SPACE + "/" + n6.tag + SPACE + CLOSE;
      }
      if (!n6.inline) {
        yield NL;
      }
      break;
    }
    case "list": {
      const isLoose = n6.children.some((n22) => n22.children.some((c5) => c5.type === "paragraph"));
      for (let i6 = 0; i6 < n6.children.length; i6++) {
        const prefix3 = n6.attributes.ordered ? `${i6 === 0 ? n6.attributes.start ?? "1" : "1"}${n6.attributes.marker ?? OL}` : n6.attributes.marker ?? UL;
        let d5 = format(n6.children[i6], increment(no, prefix3.length + 1));
        if (!isLoose || i6 === n6.children.length - 1) {
          d5 = d5.trim();
        }
        yield NL + indent2 + prefix3 + " " + d5;
      }
      yield NL;
      break;
    }
    case "item": {
      for (let i6 = 0; i6 < n6.children.length; i6++) {
        yield* formatValue(n6.children[i6], no);
        if (i6 === 0)
          yield* formatAnnotations(n6);
      }
      break;
    }
    case "strong": {
      yield n6.attributes.marker ?? "**";
      yield* formatInline(formatChildren(n6, no));
      yield n6.attributes.marker ?? "**";
      break;
    }
    case "em": {
      yield n6.attributes.marker ?? "*";
      yield* formatInline(formatChildren(n6, no));
      yield n6.attributes.marker ?? "*";
      break;
    }
    case "code": {
      yield "`";
      yield* formatInline(formatValue(n6.attributes.content, no));
      yield "`";
      break;
    }
    case "s": {
      yield "~~";
      yield* formatInline(formatChildren(n6, no));
      yield "~~";
      break;
    }
    case "hardbreak": {
      yield "\\" + NL;
      yield indent2;
      break;
    }
    case "softbreak": {
      yield NL;
      yield indent2;
      break;
    }
    case "table": {
      const table3 = [...formatChildren(n6, increment(no))];
      if (o5.parent && o5.parent.type === "tag" && o5.parent.tag === "table") {
        for (let i6 = 0; i6 < table3.length; i6++) {
          const row = table3[i6];
          if (typeof row === "string") {
            if (row.trim().length) {
              yield NL;
              yield row;
            }
          } else {
            if (i6 !== 0) {
              yield NL;
              yield indent2 + "---";
            }
            for (const d5 of row) {
              yield NL + indent2 + UL + " " + d5;
            }
          }
        }
        yield NL;
      } else {
        const widths = [];
        for (const row of table3) {
          for (let i6 = 0; i6 < row.length; i6++) {
            widths[i6] = widths[i6] ? Math.max(widths[i6], row[i6].length) : row[i6].length;
          }
        }
        const [head, ...rows] = table3;
        yield NL;
        yield* formatTableRow(head.map((cell2, i6) => cell2 + SPACE.repeat(widths[i6] - cell2.length)));
        yield NL;
        yield* formatTableRow(head.map((cell2, i6) => "-".repeat(widths[i6])));
        yield NL;
        for (const row of rows) {
          yield* formatTableRow(row.map((cell2, i6) => cell2 + SPACE.repeat(widths[i6] - cell2.length)));
          yield NL;
        }
      }
      break;
    }
    case "thead": {
      const [head] = [...formatChildren(n6, no)];
      yield head || [];
      break;
    }
    case "tr": {
      yield [...formatChildren(n6, no)];
      break;
    }
    case "td":
    case "th": {
      yield [...formatChildren(n6, no), ...formatAnnotations(n6)].join("").trim();
      break;
    }
    case "tbody": {
      yield* formatChildren(n6, no);
      break;
    }
    case "comment": {
      yield "<!-- " + n6.attributes.content + " -->\n";
      break;
    }
    case "error":
    case "node":
      break;
  }
}
function* formatValue(v5, o5 = {}) {
  switch (typeof v5) {
    case "undefined":
      break;
    case "boolean":
    case "number":
    case "string": {
      yield v5.toString();
      break;
    }
    case "object": {
      if (v5 === null)
        break;
      if (Array.isArray(v5)) {
        for (const n6 of v5)
          yield* formatValue(n6, o5);
        break;
      }
      switch (v5.$$mdtype) {
        case "Function": {
          yield* formatFunction(v5);
          break;
        }
        case "Node":
          yield* formatNode(v5, o5);
          break;
        case "Variable": {
          yield* formatVariable(v5);
          break;
        }
        default:
          throw new Error(`Unimplemented: "${v5.$$mdtype}"`);
      }
      break;
    }
  }
}
function format(v5, options) {
  let doc = "";
  for (const s22 of formatValue(v5, options))
    doc += s22;
  return doc.trimStart();
}
function truthy(value2) {
  return value2 !== false && value2 !== void 0 && value2 !== null;
}
function renderConditions(node22) {
  const conditions = [
    { condition: node22.attributes.primary, children: [] }
  ];
  for (const child of node22.children) {
    if (child.type === "tag" && child.tag === "else")
      conditions.push({
        condition: "primary" in child.attributes ? child.attributes.primary : true,
        children: []
      });
    else
      conditions[conditions.length - 1].children.push(child);
  }
  return conditions;
}
var tagIf = {
  attributes: {
    primary: { type: Object, render: false }
  },
  transform(node22, config2) {
    const conditions = renderConditions(node22);
    for (const { condition, children } of conditions)
      if (truthy(condition)) {
        const nodes = children.flatMap((child) => child.transform(config2));
        if (nodes.some(isPromise)) {
          return Promise.all(nodes).then((nodes2) => nodes2.flat());
        }
        return nodes;
      }
    return [];
  }
};
var tagElse = {
  selfClosing: true,
  attributes: {
    primary: { type: Object, render: false }
  }
};
var and = {
  transform(parameters) {
    return Object.values(parameters).every((x3) => truthy(x3));
  }
};
var or = {
  transform(parameters) {
    return Object.values(parameters).find((x3) => truthy(x3)) !== void 0;
  }
};
var not = {
  parameters: {
    0: { required: true }
  },
  transform(parameters) {
    return !truthy(parameters[0]);
  }
};
var equals = {
  transform(parameters) {
    const values2 = Object.values(parameters);
    return values2.every((v5) => v5 === values2[0]);
  }
};
var debug = {
  transform(parameters) {
    return JSON.stringify(parameters[0], null, 2);
  }
};
var defaultFn = {
  transform(parameters) {
    return parameters[0] === void 0 ? parameters[1] : parameters[0];
  }
};
var functions_default = { and, or, not, equals, default: defaultFn, debug };
function convertToRow(node22, cellType = "td") {
  node22.type = "tr";
  node22.attributes = {};
  for (const cell2 of node22.children)
    cell2.type = cellType;
  return node22;
}
function transform(document22) {
  for (const node22 of document22.walk()) {
    if (node22.type !== "tag" || node22.tag !== "table")
      continue;
    const [first, ...rest] = node22.children;
    if (!first || first.type === "table")
      continue;
    const table3 = new ast_default.Node("table", node22.attributes, [
      new ast_default.Node("thead"),
      new ast_default.Node("tbody")
    ]);
    const [thead2, tbody2] = table3.children;
    if (first.type === "list")
      thead2.push(convertToRow(first, "th"));
    for (const row of rest) {
      if (row.type === "list")
        convertToRow(row);
      else if (row.type === "tag" && row.tag === "if") {
        const children = [];
        for (const child of row.children) {
          if (child.type === "hr")
            continue;
          if (child.type === "list")
            convertToRow(child);
          children.push(child);
        }
        row.children = children;
      } else
        continue;
      tbody2.push(row);
    }
    node22.children = [table3];
  }
}
var transforms_default = [transform];
var mappings = {
  ordered_list: "list",
  bullet_list: "list",
  code_inline: "code",
  list_item: "item",
  variable: "text"
};
function annotate(node22, attributes) {
  for (const attribute of attributes) {
    node22.annotations.push(attribute);
    const { name: name2, value: value2, type: type2 } = attribute;
    if (type2 === "attribute") {
      if (node22.attributes[name2] !== void 0)
        node22.errors.push({
          id: "duplicate-attribute",
          level: "warning",
          message: `Attribute '${name2}' already set`
        });
      node22.attributes[name2] = value2;
    } else if (type2 === "class")
      if (node22.attributes.class)
        node22.attributes.class[name2] = value2;
      else
        node22.attributes.class = { [name2]: value2 };
  }
}
function handleAttrs(token2, type2) {
  switch (type2) {
    case "heading":
      return { level: Number(token2.tag.replace("h", "")) };
    case "list": {
      const attrs = token2.attrs ? Object.fromEntries(token2.attrs) : void 0;
      const ordered = token2.type.startsWith("ordered");
      return ordered && (attrs == null ? void 0 : attrs.start) ? { ordered: true, start: attrs.start, marker: token2.markup } : { ordered, marker: token2.markup };
    }
    case "link": {
      const attrs = Object.fromEntries(token2.attrs);
      return attrs.title ? { href: attrs.href, title: attrs.title } : { href: attrs.href };
    }
    case "image": {
      const attrs = Object.fromEntries(token2.attrs);
      return attrs.title ? { alt: token2.content, src: attrs.src, title: attrs.title } : { alt: token2.content, src: attrs.src };
    }
    case "em":
    case "strong":
      return { marker: token2.markup };
    case "text":
    case "code":
    case "comment":
      return { content: (token2.meta || {}).variable || token2.content };
    case "fence": {
      const [language] = token2.info.split(" ", 1);
      return language === "" || language === OPEN ? { content: token2.content } : { content: token2.content, language };
    }
    case "td":
    case "th": {
      if (token2.attrs) {
        const attrs = Object.fromEntries(token2.attrs);
        let align;
        if (attrs.style) {
          if (attrs.style.includes("left")) {
            align = "left";
          } else if (attrs.style.includes("center")) {
            align = "center";
          } else if (attrs.style.includes("right")) {
            align = "right";
          }
        }
        if (align) {
          return { align };
        }
      }
      return {};
    }
    default:
      return {};
  }
}
function handleToken(token2, nodes, file, handleSlots, addLocation, inlineParent) {
  if (token2.type === "frontmatter") {
    nodes[0].attributes.frontmatter = token2.content;
    return;
  }
  if (token2.hidden || token2.type === "text" && token2.content === "")
    return;
  const errors = token2.errors || [];
  const parent = nodes[nodes.length - 1];
  const { tag, attributes, error: error22 } = token2.meta || {};
  if (token2.type === "annotation") {
    if (inlineParent)
      return annotate(inlineParent, attributes);
    return parent.errors.push({
      id: "no-inline-annotations",
      level: "error",
      message: `Can't apply inline annotations to '${parent.type}'`
    });
  }
  let typeName = token2.type.replace(/_(open|close)$/, "");
  if (mappings[typeName])
    typeName = mappings[typeName];
  if (typeName === "error") {
    const { message, location: location2 } = error22;
    errors.push({ id: "parse-error", level: "critical", message, location: location2 });
  }
  if (token2.nesting < 0) {
    if (parent.type === typeName && parent.tag === tag) {
      if (parent.lines && token2.map)
        parent.lines.push(...token2.map);
      return nodes.pop();
    }
    errors.push({
      id: "missing-opening",
      level: "critical",
      message: `Node '${typeName}' is missing opening`
    });
  }
  const attrs = handleAttrs(token2, typeName);
  const node22 = new Node2(typeName, attrs, void 0, tag || void 0);
  const { position: position2 = {} } = token2;
  node22.errors = errors;
  if (addLocation !== false) {
    node22.lines = token2.map || parent.lines || [];
    node22.location = {
      file,
      start: {
        line: node22.lines[0],
        character: position2.start
      },
      end: {
        line: node22.lines[1],
        character: position2.end
      }
    };
  }
  if (inlineParent)
    node22.inline = true;
  if (attributes && ["tag", "fence", "image"].includes(typeName))
    annotate(node22, attributes);
  if (handleSlots && tag === "slot" && typeof node22.attributes.primary === "string")
    parent.slots[node22.attributes.primary] = node22;
  else
    parent.push(node22);
  if (token2.nesting > 0)
    nodes.push(node22);
  if (!Array.isArray(token2.children))
    return;
  if (node22.type === "inline")
    inlineParent = parent;
  nodes.push(node22);
  const isLeafNode = typeName === "image";
  if (!isLeafNode) {
    for (const child of token2.children)
      handleToken(child, nodes, file, handleSlots, addLocation, inlineParent);
  }
  nodes.pop();
}
function parser(tokens, args) {
  const doc = new Node2("document");
  const nodes = [doc];
  if (typeof args === "string")
    args = { file: args };
  for (const token2 of tokens)
    handleToken(token2, nodes, args == null ? void 0 : args.file, args == null ? void 0 : args.slots, args == null ? void 0 : args.location);
  if (nodes.length > 1)
    for (const node22 of nodes.slice(1))
      node22.errors.push({
        id: "missing-closing",
        level: "critical",
        message: `Node '${node22.tag || node22.type}' is missing closing`
      });
  for (const transform3 of transforms_default)
    transform3(doc);
  return doc;
}
var schema_exports = {};
__export(schema_exports, {
  blockquote: () => blockquote,
  code: () => code,
  comment: () => comment2,
  document: () => document2,
  em: () => em,
  error: () => error,
  fence: () => fence,
  hardbreak: () => hardbreak,
  heading: () => heading,
  hr: () => hr,
  image: () => image,
  inline: () => inline,
  item: () => item,
  link: () => link,
  list: () => list,
  node: () => node2,
  paragraph: () => paragraph,
  s: () => s,
  softbreak: () => softbreak,
  strong: () => strong,
  table: () => table,
  tbody: () => tbody,
  td: () => td,
  text: () => text,
  th: () => th,
  thead: () => thead,
  tr: () => tr
});
var document2 = {
  render: "article",
  children: [
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "comment",
    "list",
    "hr"
  ],
  attributes: {
    frontmatter: { render: false }
  }
};
var heading = {
  children: ["inline"],
  attributes: {
    level: { type: Number, render: false, required: true }
  },
  transform(node22, config2) {
    return new Tag(`h${node22.attributes["level"]}`, node22.transformAttributes(config2), node22.transformChildren(config2));
  }
};
var paragraph = {
  render: "p",
  children: ["inline"]
};
var image = {
  render: "img",
  attributes: {
    src: { type: String, required: true },
    alt: { type: String },
    title: { type: String }
  }
};
var fence = {
  render: "pre",
  attributes: {
    content: { type: String, render: false, required: true },
    language: { type: String, render: "data-language" },
    process: { type: Boolean, render: false, default: true }
  },
  transform(node22, config2) {
    const attributes = node22.transformAttributes(config2);
    const children = node22.children.length ? node22.transformChildren(config2) : [node22.attributes.content];
    return new Tag("pre", attributes, children);
  }
};
var blockquote = {
  render: "blockquote",
  children: [
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ]
};
var item = {
  render: "li",
  children: [
    "inline",
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ]
};
var list = {
  children: ["item"],
  attributes: {
    ordered: { type: Boolean, render: false, required: true },
    start: { type: Number },
    marker: { type: String, render: false }
  },
  transform(node22, config2) {
    return new Tag(node22.attributes.ordered ? "ol" : "ul", node22.transformAttributes(config2), node22.transformChildren(config2));
  }
};
var hr = {
  render: "hr"
};
var table = {
  render: "table"
};
var td = {
  render: "td",
  children: [
    "inline",
    "heading",
    "paragraph",
    "image",
    "table",
    "tag",
    "fence",
    "blockquote",
    "list",
    "hr"
  ],
  attributes: {
    align: { type: String },
    colspan: { type: Number, render: "colSpan" },
    rowspan: { type: Number, render: "rowSpan" }
  }
};
var th = {
  render: "th",
  attributes: {
    width: { type: Number },
    align: { type: String },
    colspan: { type: Number, render: "colSpan" },
    rowspan: { type: Number, render: "rowSpan" }
  }
};
var tr = {
  render: "tr",
  children: ["th", "td"]
};
var tbody = {
  render: "tbody",
  children: ["tr", "tag"]
};
var thead = {
  render: "thead",
  children: ["tr"]
};
var strong = {
  render: "strong",
  children: ["em", "s", "link", "code", "text", "tag"],
  attributes: {
    marker: { type: String, render: false }
  }
};
var em = {
  render: "em",
  children: ["strong", "s", "link", "code", "text", "tag"],
  attributes: {
    marker: { type: String, render: false }
  }
};
var s = {
  render: "s",
  children: ["strong", "em", "link", "code", "text", "tag"]
};
var inline = {
  children: [
    "strong",
    "em",
    "s",
    "code",
    "text",
    "tag",
    "link",
    "image",
    "hardbreak",
    "softbreak",
    "comment"
  ]
};
var link = {
  render: "a",
  children: ["strong", "em", "s", "code", "text", "tag"],
  attributes: {
    href: { type: String, required: true },
    title: { type: String }
  }
};
var code = {
  render: "code",
  attributes: {
    content: { type: String, render: false, required: true }
  },
  transform(node22, config2) {
    const attributes = node22.transformAttributes(config2);
    return new Tag("code", attributes, [node22.attributes.content]);
  }
};
var text = {
  attributes: {
    content: { type: String, required: true }
  },
  transform(node22) {
    return node22.attributes.content;
  }
};
var hardbreak = {
  render: "br"
};
var softbreak = {
  transform() {
    return " ";
  }
};
var comment2 = {
  attributes: {
    content: { type: String, required: true }
  }
};
var error = {};
var node2 = {};
var import_markdown_it = __toModule(require_markdown_it());
var { escapeHtml } = (0, import_markdown_it.default)().utils;
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node22) {
  if (typeof node22 === "string" || typeof node22 === "number")
    return escapeHtml(String(node22));
  if (Array.isArray(node22))
    return node22.map(render).join("");
  if (node22 === null || typeof node22 !== "object" || !Tag.isTag(node22))
    return "";
  const { name: name2, attributes, children = [] } = node22;
  if (!name2)
    return render(children);
  let output = `<${name2}`;
  for (const [k2, v5] of Object.entries(attributes ?? {}))
    output += ` ${k2.toLowerCase()}="${escapeHtml(String(v5))}"`;
  output += ">";
  if (voidElements.has(name2))
    return output;
  if (children.length)
    output += render(children);
  output += `</${name2}>`;
  return output;
}
function tagName(name2, components) {
  return typeof name2 !== "string" ? name2 : name2[0] !== name2[0].toUpperCase() ? name2 : components instanceof Function ? components(name2) : components[name2];
}
function dynamic(node22, React15, { components = {} } = {}) {
  function deepRender2(value2) {
    if (value2 == null || typeof value2 !== "object")
      return value2;
    if (Array.isArray(value2))
      return value2.map((item2) => deepRender2(item2));
    if (value2.$$mdtype === "Tag")
      return render3(value2);
    if (typeof value2 !== "object")
      return value2;
    const output = {};
    for (const [k2, v5] of Object.entries(value2))
      output[k2] = deepRender2(v5);
    return output;
  }
  function render3(node3) {
    if (Array.isArray(node3))
      return React15.createElement(React15.Fragment, null, ...node3.map(render3));
    if (node3 === null || typeof node3 !== "object" || !Tag.isTag(node3))
      return node3;
    const {
      name: name2,
      attributes: { class: className, ...attrs } = {},
      children = []
    } = node3;
    if (className)
      attrs.className = className;
    return React15.createElement(tagName(name2, components), Object.keys(attrs).length == 0 ? null : deepRender2(attrs), ...children.map(render3));
  }
  return render3(node22);
}
function tagName2(name2, components) {
  return typeof name2 !== "string" ? "Fragment" : name2[0] !== name2[0].toUpperCase() ? name2 : components instanceof Function ? components(name2) : components[name2];
}
function renderArray(children) {
  return children.map(render2).join(", ");
}
function deepRender(value2) {
  if (value2 == null || typeof value2 !== "object")
    return JSON.stringify(value2);
  if (Array.isArray(value2))
    return `[${value2.map((item2) => deepRender(item2)).join(", ")}]`;
  if (value2.$$mdtype === "Tag")
    return render2(value2);
  if (typeof value2 !== "object")
    return JSON.stringify(value2);
  const object2 = Object.entries(value2).map(([k2, v5]) => [JSON.stringify(k2), deepRender(v5)].join(": ")).join(", ");
  return `{${object2}}`;
}
function render2(node22) {
  if (Array.isArray(node22))
    return `React.createElement(React.Fragment, null, ${renderArray(node22)})`;
  if (node22 === null || typeof node22 !== "object" || !Tag.isTag(node22))
    return JSON.stringify(node22);
  const {
    name: name2,
    attributes: { class: className, ...attrs } = {},
    children = []
  } = node22;
  if (className)
    attrs.className = className;
  return `React.createElement(
    tagName(${JSON.stringify(name2)}, components),
    ${Object.keys(attrs).length == 0 ? "null" : deepRender(attrs)},
    ${renderArray(children)})`;
}
function reactStatic(node22) {
  return `
  (({components = {}} = {}) => {
    ${tagName2}
    return ${render2(node22)};
  })
`;
}
var renderers_default = { html: render, react: dynamic, reactStatic };
var PartialFile = class {
  validate(file, config2) {
    const { partials = {} } = config2;
    const partial2 = partials[file];
    if (!partial2)
      return [
        {
          id: "attribute-value-invalid",
          level: "error",
          message: `Partial \`${file}\` not found. The 'file' attribute must be set in \`config.partials\``
        }
      ];
    return [];
  }
};
var partial = {
  inline: false,
  selfClosing: true,
  attributes: {
    file: { type: PartialFile, render: false, required: true },
    variables: { type: Object, render: false }
  },
  transform(node22, config2) {
    const { partials = {} } = config2;
    const { file, variables } = node22.attributes;
    const partial2 = partials[file];
    if (!partial2)
      return null;
    const scopedConfig = {
      ...config2,
      variables: {
        ...config2.variables,
        ...variables,
        ["$$partial:filename"]: file
      }
    };
    const transformChildren = (part) => part.resolve(scopedConfig).transformChildren(scopedConfig);
    return Array.isArray(partial2) ? partial2.flatMap(transformChildren) : transformChildren(partial2);
  }
};
var table2 = {
  children: ["table"],
  inline: false
};
var slot = {
  attributes: {
    primary: { type: String, required: true }
  }
};
var tags_default = {
  else: tagElse,
  if: tagIf,
  partial,
  slot,
  table: table2
};
var import_lib = __toModule(require_lib2());
var import_tag7 = __toModule(require_tag());
function createToken(state, content, contentStart) {
  try {
    const { type: type2, meta, nesting = 0 } = (0, import_tag7.parse)(content, { Variable, Function: Function2 });
    const token2 = state.push(type2, "", nesting);
    token2.info = content;
    token2.meta = meta;
    if (!state.delimiters) {
      state.delimiters = [];
    }
    return token2;
  } catch (error22) {
    if (!(error22 instanceof import_tag7.SyntaxError))
      throw error22;
    const {
      message,
      location: { start: start2, end }
    } = error22;
    const location2 = contentStart ? {
      start: { offset: start2.offset + contentStart },
      end: { offset: end.offset + contentStart }
    } : null;
    const token2 = state.push("error", "", 0);
    token2.meta = { error: { message, location: location2 } };
    return token2;
  }
}
function block(state, startLine, endLine, silent) {
  const start2 = state.bMarks[startLine] + state.tShift[startLine];
  const finish = state.eMarks[startLine];
  if (!state.src.startsWith(OPEN, start2))
    return false;
  const tagEnd = findTagEnd(state.src, start2);
  const lastPossible = state.src.slice(0, finish).trim().length;
  if (!tagEnd || tagEnd < lastPossible - CLOSE.length)
    return false;
  const contentStart = start2 + OPEN.length;
  const content = state.src.slice(contentStart, tagEnd).trim();
  const lines = state.src.slice(start2, tagEnd + CLOSE.length).split("\n").length;
  if (content[0] === "$")
    return false;
  if (silent)
    return true;
  const token2 = createToken(state, content, contentStart);
  token2.map = [startLine, startLine + lines];
  state.line += lines;
  return true;
}
function inline2(state, silent) {
  if (!state.src.startsWith(OPEN, state.pos))
    return false;
  const tagEnd = findTagEnd(state.src, state.pos);
  if (!tagEnd)
    return false;
  const content = state.src.slice(state.pos + OPEN.length, tagEnd);
  if (!silent)
    createToken(state, content.trim());
  state.pos = tagEnd + CLOSE.length;
  return true;
}
function core(state) {
  var _a2, _b;
  let token2;
  for (token2 of state.tokens) {
    if (token2.type !== "fence")
      continue;
    if (token2.info.includes(OPEN)) {
      const start2 = token2.info.indexOf(OPEN);
      const end = findTagEnd(token2.info, start2);
      const content = token2.info.slice(start2 + OPEN.length, end);
      try {
        const { meta } = (0, import_tag7.parse)(content.trim(), { Variable, Function: Function2 });
        token2.meta = meta;
      } catch (error22) {
        if (!(error22 instanceof import_tag7.SyntaxError))
          throw error22;
        if (!token2.errors)
          token2.errors = [];
        token2.errors.push({
          id: "fence-tag-error",
          level: "error",
          message: `Syntax error in fence tag: ${error22.message}`
        });
      }
    }
    if ((_b = (_a2 = token2 == null ? void 0 : token2.meta) == null ? void 0 : _a2.attributes) == null ? void 0 : _b.find((attr) => attr.name === "process" && !attr.value))
      continue;
    token2.children = parseTags(token2.content, token2.map[0]);
  }
}
function plugin(md) {
  md.block.ruler.before("paragraph", "annotations", block, {
    alt: ["paragraph", "blockquote"]
  });
  md.inline.ruler.push("containers", inline2);
  md.core.ruler.push("annotations", core);
}
var fence2 = "---";
function getLine(state, n6) {
  return state.src.slice(state.bMarks[n6], state.eMarks[n6]).trim();
}
function findClose(state, endLine) {
  for (let line2 = 1; line2 < endLine; line2++)
    if (getLine(state, line2) === fence2)
      return line2;
}
function block2(state, startLine, endLine, silent) {
  if (startLine != 0 || getLine(state, 0) != fence2)
    return false;
  const close = findClose(state, endLine);
  if (!close)
    return false;
  if (silent)
    return true;
  const token2 = state.push("frontmatter", "", 0);
  token2.content = state.src.slice(state.eMarks[0], state.bMarks[close]).trim();
  token2.map = [0, close];
  token2.hidden = true;
  state.line = close + 1;
  return true;
}
function plugin2(md) {
  md.block.ruler.before("hr", "frontmatter", block2);
}
var OPEN2 = "<!--";
var CLOSE2 = "-->";
function block3(state, startLine, endLine, silent) {
  const start2 = state.bMarks[startLine] + state.tShift[startLine];
  if (!state.src.startsWith(OPEN2, start2))
    return false;
  const close = state.src.indexOf(CLOSE2, start2);
  if (!close)
    return false;
  if (silent)
    return true;
  const content = state.src.slice(start2 + OPEN2.length, close);
  const lines = content.split("\n").length;
  const token2 = state.push("comment", "", 0);
  token2.content = content.trim();
  token2.map = [startLine, startLine + lines];
  state.line += lines;
  return true;
}
function inline3(state, silent) {
  if (!state.src.startsWith(OPEN2, state.pos))
    return false;
  const close = state.src.indexOf(CLOSE2, state.pos);
  if (!close)
    return false;
  if (silent)
    return true;
  const content = state.src.slice(state.pos + OPEN2.length, close);
  const token2 = state.push("comment", "", 0);
  token2.content = content.trim();
  state.pos = close + CLOSE2.length;
  return true;
}
function plugin3(md) {
  md.block.ruler.before("table", "comment", block3, { alt: ["paragraph"] });
  md.inline.ruler.push("comment", inline3);
}
var Tokenizer = class {
  constructor(config2 = {}) {
    this.parser = new import_lib.default(config2);
    this.parser.use(plugin, "annotations", {});
    this.parser.use(plugin2, "frontmatter", {});
    this.parser.disable([
      "lheading",
      "code"
    ]);
    if (config2.allowComments)
      this.parser.use(plugin3, "comments", {});
  }
  tokenize(content) {
    return this.parser.parse(content.toString(), {});
  }
};
var TypeMappings = {
  String,
  Number,
  Array,
  Object,
  Boolean
};
function validateType(type2, value2, config2, key) {
  var _a2, _b;
  if (!type2)
    return true;
  if (ast_default.isFunction(value2) && ((_a2 = config2.validation) == null ? void 0 : _a2.validateFunctions)) {
    const schema = (_b = config2.functions) == null ? void 0 : _b[value2.name];
    return !(schema == null ? void 0 : schema.returns) ? true : Array.isArray(schema.returns) ? schema.returns.find((t5) => t5 === type2) !== void 0 : schema.returns === type2;
  }
  if (ast_default.isAst(value2))
    return true;
  if (Array.isArray(type2))
    return type2.some((t5) => validateType(t5, value2, config2, key));
  if (typeof type2 === "string")
    type2 = TypeMappings[type2];
  if (typeof type2 === "function") {
    const instance = new type2();
    if (instance.validate) {
      return instance.validate(value2, config2, key);
    }
  }
  return value2 != null && value2.constructor === type2;
}
function typeToString(type2) {
  if (typeof type2 === "string")
    return type2;
  if (Array.isArray(type2))
    return type2.map(typeToString).join(" | ");
  return type2.name;
}
function validateFunction(fn2, config2) {
  var _a2, _b;
  const schema = (_a2 = config2.functions) == null ? void 0 : _a2[fn2.name];
  const errors = [];
  if (!schema)
    return [
      {
        id: "function-undefined",
        level: "critical",
        message: `Undefined function: '${fn2.name}'`
      }
    ];
  if (schema.validate)
    errors.push(...schema.validate(fn2, config2));
  if (schema.parameters) {
    for (const [key, value2] of Object.entries(fn2.parameters)) {
      const param = (_b = schema.parameters) == null ? void 0 : _b[key];
      if (!param) {
        errors.push({
          id: "parameter-undefined",
          level: "error",
          message: `Invalid parameter: '${key}'`
        });
        continue;
      }
      if (ast_default.isAst(value2) && !ast_default.isFunction(value2))
        continue;
      if (param.type) {
        const valid = validateType(param.type, value2, config2, key);
        if (valid === false) {
          errors.push({
            id: "parameter-type-invalid",
            level: "error",
            message: `Parameter '${key}' of '${fn2.name}' must be type of '${typeToString(param.type)}'`
          });
        } else if (Array.isArray(valid)) {
          errors.push(...valid);
        }
      }
    }
  }
  for (const [key, { required }] of Object.entries(schema.parameters ?? {}))
    if (required && fn2.parameters[key] === void 0)
      errors.push({
        id: "parameter-missing-required",
        level: "error",
        message: `Missing required parameter: '${key}'`
      });
  return errors;
}
function displayMatches(matches, n6) {
  if (matches.length <= n6)
    return JSON.stringify(matches);
  const items = matches.slice(0, n6).map((item2) => JSON.stringify(item2));
  return `[${items.join(",")}, ... ${matches.length - n6} more]`;
}
function validator(node22, config2) {
  var _a2, _b;
  const schema = node22.findSchema(config2);
  const errors = [...node22.errors || []];
  if (!schema) {
    errors.push({
      id: node22.tag ? "tag-undefined" : "node-undefined",
      level: "critical",
      message: node22.tag ? `Undefined tag: '${node22.tag}'` : `Undefined node: '${node22.type}'`
    });
    return errors;
  }
  if (schema.inline != void 0 && node22.inline !== schema.inline)
    errors.push({
      id: "tag-placement-invalid",
      level: "critical",
      message: `'${node22.tag}' tag should be ${schema.inline ? "inline" : "block"}`
    });
  if (schema.selfClosing && node22.children.length > 0)
    errors.push({
      id: "tag-selfclosing-has-children",
      level: "critical",
      message: `'${node22.tag}' tag should be self-closing`
    });
  const attributes = {
    ...globalAttributes,
    ...schema.attributes
  };
  for (const key of Object.keys(node22.slots)) {
    const slot2 = (_a2 = schema.slots) == null ? void 0 : _a2[key];
    if (!slot2)
      errors.push({
        id: "slot-undefined",
        level: "error",
        message: `Invalid slot: '${key}'`
      });
  }
  for (let [key, value2] of Object.entries(node22.attributes)) {
    const attrib = attributes[key];
    if (!attrib) {
      errors.push({
        id: "attribute-undefined",
        level: "error",
        message: `Invalid attribute: '${key}'`
      });
      continue;
    }
    let { type: type2, matches, errorLevel } = attrib;
    if (ast_default.isAst(value2)) {
      if (ast_default.isFunction(value2) && ((_b = config2.validation) == null ? void 0 : _b.validateFunctions))
        errors.push(...validateFunction(value2, config2));
      else if (ast_default.isVariable(value2) && config2.variables) {
        let missing = false;
        let variables = config2.variables;
        for (const key2 of value2.path) {
          if (!Object.prototype.hasOwnProperty.call(variables, key2)) {
            missing = true;
            break;
          }
          variables = variables[key2];
        }
        if (missing) {
          errors.push({
            id: "variable-undefined",
            level: "error",
            message: `Undefined variable: '${value2.path.join(".")}'`
          });
        }
      } else
        continue;
    }
    value2 = value2;
    if (type2) {
      const valid = validateType(type2, value2, config2, key);
      if (valid === false) {
        errors.push({
          id: "attribute-type-invalid",
          level: errorLevel || "error",
          message: `Attribute '${key}' must be type of '${typeToString(type2)}'`
        });
      }
      if (Array.isArray(valid)) {
        errors.push(...valid);
      }
    }
    if (typeof matches === "function")
      matches = matches(config2);
    if (Array.isArray(matches) && !matches.includes(value2))
      errors.push({
        id: "attribute-value-invalid",
        level: errorLevel || "error",
        message: `Attribute '${key}' must match one of ${displayMatches(matches, 8)}. Got '${value2}' instead.`
      });
    if (matches instanceof RegExp && !matches.test(value2))
      errors.push({
        id: "attribute-value-invalid",
        level: errorLevel || "error",
        message: `Attribute '${key}' must match ${matches}. Got '${value2}' instead.`
      });
    if (typeof attrib.validate === "function") {
      const attribErrors = attrib.validate(value2, config2, key);
      if (Array.isArray(attribErrors))
        errors.push(...attribErrors);
    }
  }
  for (const [key, { required }] of Object.entries(attributes))
    if (required && node22.attributes[key] === void 0)
      errors.push({
        id: "attribute-missing-required",
        level: "error",
        message: `Missing required attribute: '${key}'`
      });
  if (schema.slots) {
    for (const [key, { required }] of Object.entries(schema.slots))
      if (required && node22.slots[key] === void 0)
        errors.push({
          id: "slot-missing-required",
          level: "error",
          message: `Missing required slot: '${key}'`
        });
  }
  for (const { type: type2 } of node22.children) {
    if (schema.children && type2 !== "error" && !schema.children.includes(type2))
      errors.push({
        id: "child-invalid",
        level: "warning",
        message: `Can't nest '${type2}' in '${node22.tag || node22.type}'`
      });
  }
  if (schema.validate) {
    const schemaErrors = schema.validate(node22, config2);
    if (isPromise(schemaErrors)) {
      return schemaErrors.then((e6) => errors.concat(e6));
    }
    errors.push(...schemaErrors);
  }
  return errors;
}
function* walkWithParents(node22, parents = []) {
  yield [node22, parents];
  for (const child of [...Object.values(node22.slots), ...node22.children])
    yield* walkWithParents(child, [...parents, node22]);
}
function validateTree(content, config2) {
  const output = [...walkWithParents(content)].map(([node22, parents]) => {
    const { type: type2, lines, location: location2 } = node22;
    const updatedConfig = {
      ...config2,
      validation: { ...config2.validation, parents }
    };
    const errors = validator(node22, updatedConfig);
    if (isPromise(errors)) {
      return errors.then((e6) => e6.map((error22) => ({ type: type2, lines, location: location2, error: error22 })));
    }
    return errors.map((error22) => ({ type: type2, lines, location: location2, error: error22 }));
  });
  if (output.some(isPromise)) {
    return Promise.all(output).then((o5) => o5.flat());
  }
  return output.flat();
}
var tokenizer = new Tokenizer();
function mergeConfig2(config2 = {}) {
  return {
    ...config2,
    tags: {
      ...tags_default,
      ...config2.tags
    },
    nodes: {
      ...schema_exports,
      ...config2.nodes
    },
    functions: {
      ...functions_default,
      ...config2.functions
    }
  };
}
function parse3(content, args) {
  if (typeof content === "string")
    content = tokenizer.tokenize(content);
  return parser(content, args);
}
function resolve2(content, config2) {
  if (Array.isArray(content))
    return content.flatMap((child) => child.resolve(config2));
  return content.resolve(config2);
}
function transform2(nodes, options) {
  const config2 = mergeConfig2(options);
  const content = resolve2(nodes, config2);
  if (Array.isArray(content))
    return content.flatMap((child) => child.transform(config2));
  return content.transform(config2);
}
function validate(content, options) {
  const config2 = mergeConfig2(options);
  return validateTree(content, config2);
}
function createElement(name2, attributes = {}, ...children) {
  return { name: name2, attributes, children };
}
var Markdoc = class {
  constructor(config2) {
    this.parse = parse3;
    this.resolve = (content) => resolve2(content, this.config);
    this.transform = (content) => transform2(content, this.config);
    this.validate = (content) => validate(content, this.config);
    this.config = config2;
  }
};
Markdoc.nodes = schema_exports;
Markdoc.tags = tags_default;
Markdoc.functions = functions_default;
Markdoc.globalAttributes = globalAttributes;
Markdoc.renderers = renderers_default;
Markdoc.transforms = transforms_default;
Markdoc.Ast = ast_default;
Markdoc.Tag = Tag;
Markdoc.Tokenizer = Tokenizer;
Markdoc.parseTags = parseTags;
Markdoc.transformer = transformer_default;
Markdoc.validator = validator;
Markdoc.parse = parse3;
Markdoc.transform = transform2;
Markdoc.validate = validate;
Markdoc.createElement = createElement;
Markdoc.truthy = truthy;
Markdoc.format = format;

// node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o5) {
  return Object.prototype.toString.call(o5) === "[object Object]";
}
function isPlainObject(o5) {
  var ctor, prot;
  if (isObject(o5) === false)
    return false;
  ctor = o5.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/immer.esm.mjs
function n(n6) {
  for (var r7 = arguments.length, t5 = Array(r7 > 1 ? r7 - 1 : 0), e6 = 1; e6 < r7; e6++)
    t5[e6 - 1] = arguments[e6];
  if (true) {
    var i6 = Y[n6], o5 = i6 ? "function" == typeof i6 ? i6.apply(null, t5) : i6 : "unknown error nr: " + n6;
    throw Error("[Immer] " + o5);
  }
  throw Error("[Immer] minified error nr: " + n6 + (t5.length ? " " + t5.map(function(n7) {
    return "'" + n7 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r2(n6) {
  return !!n6 && !!n6[Q];
}
function t(n6) {
  var r7;
  return !!n6 && (function(n7) {
    if (!n7 || "object" != typeof n7)
      return false;
    var r8 = Object.getPrototypeOf(n7);
    if (null === r8)
      return true;
    var t5 = Object.hasOwnProperty.call(r8, "constructor") && r8.constructor;
    return t5 === Object || "function" == typeof t5 && Function.toString.call(t5) === Z;
  }(n6) || Array.isArray(n6) || !!n6[L] || !!(null === (r7 = n6.constructor) || void 0 === r7 ? void 0 : r7[L]) || s2(n6) || v(n6));
}
function i(n6, r7, t5) {
  void 0 === t5 && (t5 = false), 0 === o(n6) ? (t5 ? Object.keys : nn)(n6).forEach(function(e6) {
    t5 && "symbol" == typeof e6 || r7(e6, n6[e6], n6);
  }) : n6.forEach(function(t6, e6) {
    return r7(e6, t6, n6);
  });
}
function o(n6) {
  var r7 = n6[Q];
  return r7 ? r7.i > 3 ? r7.i - 4 : r7.i : Array.isArray(n6) ? 1 : s2(n6) ? 2 : v(n6) ? 3 : 0;
}
function u(n6, r7) {
  return 2 === o(n6) ? n6.has(r7) : Object.prototype.hasOwnProperty.call(n6, r7);
}
function a(n6, r7) {
  return 2 === o(n6) ? n6.get(r7) : n6[r7];
}
function f(n6, r7, t5) {
  var e6 = o(n6);
  2 === e6 ? n6.set(r7, t5) : 3 === e6 ? n6.add(t5) : n6[r7] = t5;
}
function c(n6, r7) {
  return n6 === r7 ? 0 !== n6 || 1 / n6 == 1 / r7 : n6 != n6 && r7 != r7;
}
function s2(n6) {
  return X && n6 instanceof Map;
}
function v(n6) {
  return q && n6 instanceof Set;
}
function p(n6) {
  return n6.o || n6.t;
}
function l(n6) {
  if (Array.isArray(n6))
    return Array.prototype.slice.call(n6);
  var r7 = rn(n6);
  delete r7[Q];
  for (var t5 = nn(r7), e6 = 0; e6 < t5.length; e6++) {
    var i6 = t5[e6], o5 = r7[i6];
    false === o5.writable && (o5.writable = true, o5.configurable = true), (o5.get || o5.set) && (r7[i6] = { configurable: true, writable: true, enumerable: o5.enumerable, value: n6[i6] });
  }
  return Object.create(Object.getPrototypeOf(n6), r7);
}
function d(n6, e6) {
  return void 0 === e6 && (e6 = false), y(n6) || r2(n6) || !t(n6) || (o(n6) > 1 && (n6.set = n6.add = n6.clear = n6.delete = h), Object.freeze(n6), e6 && i(n6, function(n7, r7) {
    return d(r7, true);
  }, true)), n6;
}
function h() {
  n(2);
}
function y(n6) {
  return null == n6 || "object" != typeof n6 || Object.isFrozen(n6);
}
function b(r7) {
  var t5 = tn[r7];
  return t5 || n(18, r7), t5;
}
function _() {
  return U || n(0), U;
}
function j(n6, r7) {
  r7 && (b("Patches"), n6.u = [], n6.s = [], n6.v = r7);
}
function g(n6) {
  O(n6), n6.p.forEach(S), n6.p = null;
}
function O(n6) {
  n6 === U && (U = n6.l);
}
function w(n6) {
  return U = { p: [], l: U, h: n6, m: true, _: 0 };
}
function S(n6) {
  var r7 = n6[Q];
  0 === r7.i || 1 === r7.i ? r7.j() : r7.g = true;
}
function P(r7, e6) {
  e6._ = e6.p.length;
  var i6 = e6.p[0], o5 = void 0 !== r7 && r7 !== i6;
  return e6.h.O || b("ES5").S(e6, r7, o5), o5 ? (i6[Q].P && (g(e6), n(4)), t(r7) && (r7 = M(e6, r7), e6.l || x(e6, r7)), e6.u && b("Patches").M(i6[Q].t, r7, e6.u, e6.s)) : r7 = M(e6, i6, []), g(e6), e6.u && e6.v(e6.u, e6.s), r7 !== H ? r7 : void 0;
}
function M(n6, r7, t5) {
  if (y(r7))
    return r7;
  var e6 = r7[Q];
  if (!e6)
    return i(r7, function(i6, o6) {
      return A(n6, e6, r7, i6, o6, t5);
    }, true), r7;
  if (e6.A !== n6)
    return r7;
  if (!e6.P)
    return x(n6, e6.t, true), e6.t;
  if (!e6.I) {
    e6.I = true, e6.A._--;
    var o5 = 4 === e6.i || 5 === e6.i ? e6.o = l(e6.k) : e6.o, u4 = o5, a3 = false;
    3 === e6.i && (u4 = new Set(o5), o5.clear(), a3 = true), i(u4, function(r8, i6) {
      return A(n6, e6, o5, r8, i6, t5, a3);
    }), x(n6, o5, false), t5 && n6.u && b("Patches").N(e6, t5, n6.u, n6.s);
  }
  return e6.o;
}
function A(e6, i6, o5, a3, c5, s4, v5) {
  if (c5 === o5 && n(5), r2(c5)) {
    var p5 = M(e6, c5, s4 && i6 && 3 !== i6.i && !u(i6.R, a3) ? s4.concat(a3) : void 0);
    if (f(o5, a3, p5), !r2(p5))
      return;
    e6.m = false;
  } else
    v5 && o5.add(c5);
  if (t(c5) && !y(c5)) {
    if (!e6.h.D && e6._ < 1)
      return;
    M(e6, c5), i6 && i6.A.l || x(e6, c5);
  }
}
function x(n6, r7, t5) {
  void 0 === t5 && (t5 = false), !n6.l && n6.h.D && n6.m && d(r7, t5);
}
function z2(n6, r7) {
  var t5 = n6[Q];
  return (t5 ? p(t5) : n6)[r7];
}
function I(n6, r7) {
  if (r7 in n6)
    for (var t5 = Object.getPrototypeOf(n6); t5; ) {
      var e6 = Object.getOwnPropertyDescriptor(t5, r7);
      if (e6)
        return e6;
      t5 = Object.getPrototypeOf(t5);
    }
}
function k(n6) {
  n6.P || (n6.P = true, n6.l && k(n6.l));
}
function E(n6) {
  n6.o || (n6.o = l(n6.t));
}
function N(n6, r7, t5) {
  var e6 = s2(r7) ? b("MapSet").F(r7, t5) : v(r7) ? b("MapSet").T(r7, t5) : n6.O ? function(n7, r8) {
    var t6 = Array.isArray(n7), e7 = { i: t6 ? 1 : 0, A: r8 ? r8.A : _(), P: false, I: false, R: {}, l: r8, t: n7, k: null, o: null, j: null, C: false }, i6 = e7, o5 = en;
    t6 && (i6 = [e7], o5 = on);
    var u4 = Proxy.revocable(i6, o5), a3 = u4.revoke, f5 = u4.proxy;
    return e7.k = f5, e7.j = a3, f5;
  }(r7, t5) : b("ES5").J(r7, t5);
  return (t5 ? t5.A : _()).p.push(e6), e6;
}
function R(e6) {
  return r2(e6) || n(22, e6), function n6(r7) {
    if (!t(r7))
      return r7;
    var e7, u4 = r7[Q], c5 = o(r7);
    if (u4) {
      if (!u4.P && (u4.i < 4 || !b("ES5").K(u4)))
        return u4.t;
      u4.I = true, e7 = D(r7, c5), u4.I = false;
    } else
      e7 = D(r7, c5);
    return i(e7, function(r8, t5) {
      u4 && a(u4.t, r8) === t5 || f(e7, r8, n6(t5));
    }), 3 === c5 ? new Set(e7) : e7;
  }(e6);
}
function D(n6, r7) {
  switch (r7) {
    case 2:
      return new Map(n6);
    case 3:
      return Array.from(n6);
  }
  return l(n6);
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n6) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n6;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n6) {
  return "Cannot apply patch, path doesn't resolve: " + n6;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n6) {
  return "Unsupported patch operation: " + n6;
}, 18: function(n6) {
  return "The plugin for '" + n6 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n6 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n6) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n6 + "'";
}, 22: function(n6) {
  return "'current' expects a draft, got: " + n6;
}, 23: function(n6) {
  return "'original' expects a draft, got: " + n6;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n6) {
  return Object.getOwnPropertyNames(n6).concat(Object.getOwnPropertySymbols(n6));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n6) {
  var r7 = {};
  return nn(n6).forEach(function(t5) {
    r7[t5] = Object.getOwnPropertyDescriptor(n6, t5);
  }), r7;
};
var tn = {};
var en = { get: function(n6, r7) {
  if (r7 === Q)
    return n6;
  var e6 = p(n6);
  if (!u(e6, r7))
    return function(n7, r8, t5) {
      var e7, i7 = I(r8, t5);
      return i7 ? "value" in i7 ? i7.value : null === (e7 = i7.get) || void 0 === e7 ? void 0 : e7.call(n7.k) : void 0;
    }(n6, e6, r7);
  var i6 = e6[r7];
  return n6.I || !t(i6) ? i6 : i6 === z2(n6.t, r7) ? (E(n6), n6.o[r7] = N(n6.A.h, i6, n6)) : i6;
}, has: function(n6, r7) {
  return r7 in p(n6);
}, ownKeys: function(n6) {
  return Reflect.ownKeys(p(n6));
}, set: function(n6, r7, t5) {
  var e6 = I(p(n6), r7);
  if (null == e6 ? void 0 : e6.set)
    return e6.set.call(n6.k, t5), true;
  if (!n6.P) {
    var i6 = z2(p(n6), r7), o5 = null == i6 ? void 0 : i6[Q];
    if (o5 && o5.t === t5)
      return n6.o[r7] = t5, n6.R[r7] = false, true;
    if (c(t5, i6) && (void 0 !== t5 || u(n6.t, r7)))
      return true;
    E(n6), k(n6);
  }
  return n6.o[r7] === t5 && (void 0 !== t5 || r7 in n6.o) || Number.isNaN(t5) && Number.isNaN(n6.o[r7]) || (n6.o[r7] = t5, n6.R[r7] = true), true;
}, deleteProperty: function(n6, r7) {
  return void 0 !== z2(n6.t, r7) || r7 in n6.t ? (n6.R[r7] = false, E(n6), k(n6)) : delete n6.R[r7], n6.o && delete n6.o[r7], true;
}, getOwnPropertyDescriptor: function(n6, r7) {
  var t5 = p(n6), e6 = Reflect.getOwnPropertyDescriptor(t5, r7);
  return e6 ? { writable: true, configurable: 1 !== n6.i || "length" !== r7, enumerable: e6.enumerable, value: t5[r7] } : e6;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n6) {
  return Object.getPrototypeOf(n6.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n6, r7) {
  on[n6] = function() {
    return arguments[0] = arguments[0][0], r7.apply(this, arguments);
  };
}), on.deleteProperty = function(r7, t5) {
  return isNaN(parseInt(t5)) && n(13), on.set.call(this, r7, t5, void 0);
}, on.set = function(r7, t5, e6) {
  return "length" !== t5 && isNaN(parseInt(t5)) && n(14), en.set.call(this, r7[0], t5, e6, r7[0]);
};
var un = function() {
  function e6(r7) {
    var e7 = this;
    this.O = B, this.D = true, this.produce = function(r8, i7, o5) {
      if ("function" == typeof r8 && "function" != typeof i7) {
        var u4 = i7;
        i7 = r8;
        var a3 = e7;
        return function(n6) {
          var r9 = this;
          void 0 === n6 && (n6 = u4);
          for (var t5 = arguments.length, e8 = Array(t5 > 1 ? t5 - 1 : 0), o6 = 1; o6 < t5; o6++)
            e8[o6 - 1] = arguments[o6];
          return a3.produce(n6, function(n7) {
            var t6;
            return (t6 = i7).call.apply(t6, [r9, n7].concat(e8));
          });
        };
      }
      var f5;
      if ("function" != typeof i7 && n(6), void 0 !== o5 && "function" != typeof o5 && n(7), t(r8)) {
        var c5 = w(e7), s4 = N(e7, r8, void 0), v5 = true;
        try {
          f5 = i7(s4), v5 = false;
        } finally {
          v5 ? g(c5) : O(c5);
        }
        return "undefined" != typeof Promise && f5 instanceof Promise ? f5.then(function(n6) {
          return j(c5, o5), P(n6, c5);
        }, function(n6) {
          throw g(c5), n6;
        }) : (j(c5, o5), P(f5, c5));
      }
      if (!r8 || "object" != typeof r8) {
        if (void 0 === (f5 = i7(r8)) && (f5 = r8), f5 === H && (f5 = void 0), e7.D && d(f5, true), o5) {
          var p5 = [], l6 = [];
          b("Patches").M(r8, f5, p5, l6), o5(p5, l6);
        }
        return f5;
      }
      n(21, r8);
    }, this.produceWithPatches = function(n6, r8) {
      if ("function" == typeof n6)
        return function(r9) {
          for (var t6 = arguments.length, i8 = Array(t6 > 1 ? t6 - 1 : 0), o6 = 1; o6 < t6; o6++)
            i8[o6 - 1] = arguments[o6];
          return e7.produceWithPatches(r9, function(r10) {
            return n6.apply(void 0, [r10].concat(i8));
          });
        };
      var t5, i7, o5 = e7.produce(n6, r8, function(n7, r9) {
        t5 = n7, i7 = r9;
      });
      return "undefined" != typeof Promise && o5 instanceof Promise ? o5.then(function(n7) {
        return [n7, t5, i7];
      }) : [o5, t5, i7];
    }, "boolean" == typeof (null == r7 ? void 0 : r7.useProxies) && this.setUseProxies(r7.useProxies), "boolean" == typeof (null == r7 ? void 0 : r7.autoFreeze) && this.setAutoFreeze(r7.autoFreeze);
  }
  var i6 = e6.prototype;
  return i6.createDraft = function(e7) {
    t(e7) || n(8), r2(e7) && (e7 = R(e7));
    var i7 = w(this), o5 = N(this, e7, void 0);
    return o5[Q].C = true, O(i7), o5;
  }, i6.finishDraft = function(r7, t5) {
    var e7 = r7 && r7[Q];
    e7 && e7.C || n(9), e7.I && n(10);
    var i7 = e7.A;
    return j(i7, t5), P(void 0, i7);
  }, i6.setAutoFreeze = function(n6) {
    this.D = n6;
  }, i6.setUseProxies = function(r7) {
    r7 && !B && n(20), this.O = r7;
  }, i6.applyPatches = function(n6, t5) {
    var e7;
    for (e7 = t5.length - 1; e7 >= 0; e7--) {
      var i7 = t5[e7];
      if (0 === i7.path.length && "replace" === i7.op) {
        n6 = i7.value;
        break;
      }
    }
    e7 > -1 && (t5 = t5.slice(e7 + 1));
    var o5 = b("Patches").$;
    return r2(n6) ? o5(n6, t5) : this.produce(n6, function(n7) {
      return o5(n7, t5);
    });
  }, e6;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);

// node_modules/.pnpm/slate@0.91.4/node_modules/slate/dist/index.es.js
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
var DIRTY_PATHS = /* @__PURE__ */ new WeakMap();
var DIRTY_PATH_KEYS = /* @__PURE__ */ new WeakMap();
var FLUSHING = /* @__PURE__ */ new WeakMap();
var NORMALIZING = /* @__PURE__ */ new WeakMap();
var PATH_REFS = /* @__PURE__ */ new WeakMap();
var POINT_REFS = /* @__PURE__ */ new WeakMap();
var RANGE_REFS = /* @__PURE__ */ new WeakMap();
function ownKeys$9(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$9(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var createEditor = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isInline: () => false,
    isVoid: () => false,
    markableVoid: () => false,
    onChange: () => {
    },
    apply: (op) => {
      for (var ref of Editor.pathRefs(editor)) {
        PathRef.transform(ref, op);
      }
      for (var _ref of Editor.pointRefs(editor)) {
        PointRef.transform(_ref, op);
      }
      for (var _ref2 of Editor.rangeRefs(editor)) {
        RangeRef.transform(_ref2, op);
      }
      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || /* @__PURE__ */ new Set();
      var dirtyPaths;
      var dirtyPathKeys;
      var add = (path3) => {
        if (path3) {
          var key = path3.join(",");
          if (!dirtyPathKeys.has(key)) {
            dirtyPathKeys.add(key);
            dirtyPaths.push(path3);
          }
        }
      };
      if (Path.operationCanTransformPath(op)) {
        dirtyPaths = [];
        dirtyPathKeys = /* @__PURE__ */ new Set();
        for (var path2 of oldDirtyPaths) {
          var newPath = Path.transform(path2, op);
          add(newPath);
        }
      } else {
        dirtyPaths = oldDirtyPaths;
        dirtyPathKeys = oldDirtyPathKeys;
      }
      var newDirtyPaths = editor.getDirtyPaths(op);
      for (var _path of newDirtyPaths) {
        add(_path);
      }
      DIRTY_PATHS.set(editor, dirtyPaths);
      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
      Transforms.transform(editor, op);
      editor.operations.push(op);
      Editor.normalize(editor, {
        operation: op
      });
      if (op.type === "set_selection") {
        editor.marks = null;
      }
      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange({
            operation: op
          });
          editor.operations = [];
        });
      }
    },
    addMark: (key, value2) => {
      var {
        selection,
        markableVoid
      } = editor;
      if (selection) {
        var match3 = (node3, path2) => {
          if (!Text2.isText(node3)) {
            return false;
          }
          var [parentNode2, parentPath] = Editor.parent(editor, path2);
          return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
          var [selectedNode, selectedPath] = Editor.node(editor, selection);
          if (selectedNode && match3(selectedNode, selectedPath)) {
            var [parentNode] = Editor.parent(editor, selectedPath);
            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
          }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
          Transforms.setNodes(editor, {
            [key]: value2
          }, {
            match: match3,
            split: true,
            voids: true
          });
        } else {
          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {
            [key]: value2
          });
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    deleteBackward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    },
    deleteForward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    },
    deleteFragment: (direction) => {
      var {
        selection
      } = editor;
      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor, {
          reverse: direction === "backward"
        });
      }
    },
    getFragment: () => {
      var {
        selection
      } = editor;
      if (selection) {
        return Node3.fragment(editor, selection);
      }
      return [];
    },
    insertBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertSoftBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertFragment: (fragment) => {
      Transforms.insertFragment(editor, fragment);
    },
    insertNode: (node3) => {
      Transforms.insertNodes(editor, node3);
    },
    insertText: (text3) => {
      var {
        selection,
        marks
      } = editor;
      if (selection) {
        if (marks) {
          var node3 = _objectSpread$9({
            text: text3
          }, marks);
          Transforms.insertNodes(editor, node3);
        } else {
          Transforms.insertText(editor, text3);
        }
        editor.marks = null;
      }
    },
    normalizeNode: (entry) => {
      var [node3, path2] = entry;
      if (Text2.isText(node3)) {
        return;
      }
      if (Element2.isElement(node3) && node3.children.length === 0) {
        var child = {
          text: ""
        };
        Transforms.insertNodes(editor, child, {
          at: path2.concat(0),
          voids: true
        });
        return;
      }
      var shouldHaveInlines = Editor.isEditor(node3) ? false : Element2.isElement(node3) && (editor.isInline(node3) || node3.children.length === 0 || Text2.isText(node3.children[0]) || editor.isInline(node3.children[0]));
      var n6 = 0;
      for (var i6 = 0; i6 < node3.children.length; i6++, n6++) {
        var currentNode = Node3.get(editor, path2);
        if (Text2.isText(currentNode))
          continue;
        var _child = node3.children[i6];
        var prev2 = currentNode.children[n6 - 1];
        var isLast = i6 === node3.children.length - 1;
        var isInlineOrText = Text2.isText(_child) || Element2.isElement(_child) && editor.isInline(_child);
        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path2.concat(n6),
            voids: true
          });
          n6--;
        } else if (Element2.isElement(_child)) {
          if (editor.isInline(_child)) {
            if (prev2 == null || !Text2.isText(prev2)) {
              var newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, newChild, {
                at: path2.concat(n6),
                voids: true
              });
              n6++;
            } else if (isLast) {
              var _newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path2.concat(n6 + 1),
                voids: true
              });
              n6++;
            }
          }
        } else {
          if (prev2 != null && Text2.isText(prev2)) {
            if (Text2.equals(_child, prev2, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path2.concat(n6),
                voids: true
              });
              n6--;
            } else if (prev2.text === "") {
              Transforms.removeNodes(editor, {
                at: path2.concat(n6 - 1),
                voids: true
              });
              n6--;
            } else if (_child.text === "") {
              Transforms.removeNodes(editor, {
                at: path2.concat(n6),
                voids: true
              });
              n6--;
            }
          }
        }
      }
    },
    removeMark: (key) => {
      var {
        selection
      } = editor;
      if (selection) {
        var match3 = (node3, path2) => {
          if (!Text2.isText(node3)) {
            return false;
          }
          var [parentNode2, parentPath] = Editor.parent(editor, path2);
          return !editor.isVoid(parentNode2) || editor.markableVoid(parentNode2);
        };
        var expandedSelection = Range.isExpanded(selection);
        var markAcceptingVoidSelected = false;
        if (!expandedSelection) {
          var [selectedNode, selectedPath] = Editor.node(editor, selection);
          if (selectedNode && match3(selectedNode, selectedPath)) {
            var [parentNode] = Editor.parent(editor, selectedPath);
            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
          }
        }
        if (expandedSelection || markAcceptingVoidSelected) {
          Transforms.unsetNodes(editor, key, {
            match: match3,
            split: true,
            voids: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor.marks(editor) || {});
          delete marks[key];
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    /**
     * Get the "dirty" paths generated from an operation.
     */
    getDirtyPaths: (op) => {
      switch (op.type) {
        case "insert_text":
        case "remove_text":
        case "set_node": {
          var {
            path: path2
          } = op;
          return Path.levels(path2);
        }
        case "insert_node": {
          var {
            node: node3,
            path: _path2
          } = op;
          var levels2 = Path.levels(_path2);
          var descendants = Text2.isText(node3) ? [] : Array.from(Node3.nodes(node3), (_ref3) => {
            var [, p6] = _ref3;
            return _path2.concat(p6);
          });
          return [...levels2, ...descendants];
        }
        case "merge_node": {
          var {
            path: _path3
          } = op;
          var ancestors = Path.ancestors(_path3);
          var previousPath = Path.previous(_path3);
          return [...ancestors, previousPath];
        }
        case "move_node": {
          var {
            path: _path4,
            newPath
          } = op;
          if (Path.equals(_path4, newPath)) {
            return [];
          }
          var oldAncestors = [];
          var newAncestors = [];
          for (var ancestor of Path.ancestors(_path4)) {
            var p5 = Path.transform(ancestor, op);
            oldAncestors.push(p5);
          }
          for (var _ancestor of Path.ancestors(newPath)) {
            var _p = Path.transform(_ancestor, op);
            newAncestors.push(_p);
          }
          var newParent = newAncestors[newAncestors.length - 1];
          var newIndex = newPath[newPath.length - 1];
          var resultPath = newParent.concat(newIndex);
          return [...oldAncestors, ...newAncestors, resultPath];
        }
        case "remove_node": {
          var {
            path: _path5
          } = op;
          var _ancestors = Path.ancestors(_path5);
          return [..._ancestors];
        }
        case "split_node": {
          var {
            path: _path6
          } = op;
          var _levels = Path.levels(_path6);
          var nextPath = Path.next(_path6);
          return [..._levels, nextPath];
        }
        default: {
          return [];
        }
      }
    },
    shouldNormalize: (_ref4) => {
      var {
        iteration,
        initialDirtyPathsLength
      } = _ref4;
      var maxIterations = initialDirtyPathsLength * 42;
      if (iteration > maxIterations) {
        throw new Error("Could not completely normalize the editor after ".concat(maxIterations, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
      }
      return true;
    }
  };
  return editor;
};
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i6;
  for (i6 = 0; i6 < sourceKeys.length; i6++) {
    key = sourceKeys[i6];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i6;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i6 = 0; i6 < sourceSymbolKeys.length; i6++) {
      key = sourceSymbolKeys[i6];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var getCharacterDistance = function getCharacterDistance2(str) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var isLTR = !isRTL;
  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;
  var left = CodepointType.None;
  var right = CodepointType.None;
  var distance = 0;
  var gb11 = null;
  var gb12Or13 = null;
  for (var char2 of codepoints) {
    var code2 = char2.codePointAt(0);
    if (!code2)
      break;
    var type2 = getCodepointType(char2, code2);
    [left, right] = isLTR ? [right, type2] : [type2, left];
    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
      if (isLTR) {
        gb11 = endsWithEmojiZWJ(str.substring(0, distance));
      } else {
        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));
      }
      if (!gb11)
        break;
    }
    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
      if (gb12Or13 !== null) {
        gb12Or13 = !gb12Or13;
      } else {
        if (isLTR) {
          gb12Or13 = true;
        } else {
          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));
        }
      }
      if (!gb12Or13)
        break;
    }
    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
      break;
    }
    distance += char2.length;
  }
  return distance || 1;
};
var SPACE2 = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var getWordDistance = function getWordDistance2(text3) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var dist = 0;
  var started = false;
  while (text3.length > 0) {
    var charDist = getCharacterDistance(text3, isRTL);
    var [char2, remaining] = splitByCharacterDistance(text3, charDist, isRTL);
    if (isWordCharacter(char2, remaining, isRTL)) {
      started = true;
      dist += charDist;
    } else if (!started) {
      dist += charDist;
    } else {
      break;
    }
    text3 = remaining;
  }
  return dist;
};
var splitByCharacterDistance = (str, dist, isRTL) => {
  if (isRTL) {
    var at = str.length - dist;
    return [str.slice(at, str.length), str.slice(0, at)];
  }
  return [str.slice(0, dist), str.slice(dist)];
};
var isWordCharacter = function isWordCharacter2(char2, remaining) {
  var isRTL = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (SPACE2.test(char2)) {
    return false;
  }
  if (CHAMELEON.test(char2)) {
    var charDist = getCharacterDistance(remaining, isRTL);
    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);
    if (isWordCharacter2(nextChar, nextRemaining, isRTL)) {
      return true;
    }
  }
  if (PUNCTUATION.test(char2)) {
    return false;
  }
  return true;
};
var codepointsIteratorRTL = function* codepointsIteratorRTL2(str) {
  var end = str.length - 1;
  for (var i6 = 0; i6 < str.length; i6++) {
    var char1 = str.charAt(end - i6);
    if (isLowSurrogate(char1.charCodeAt(0))) {
      var char2 = str.charAt(end - i6 - 1);
      if (isHighSurrogate(char2.charCodeAt(0))) {
        yield char2 + char1;
        i6++;
        continue;
      }
    }
    yield char1;
  }
};
var isHighSurrogate = (charCode) => {
  return charCode >= 55296 && charCode <= 56319;
};
var isLowSurrogate = (charCode) => {
  return charCode >= 56320 && charCode <= 57343;
};
var CodepointType;
(function(CodepointType2) {
  CodepointType2[CodepointType2["None"] = 0] = "None";
  CodepointType2[CodepointType2["Extend"] = 1] = "Extend";
  CodepointType2[CodepointType2["ZWJ"] = 2] = "ZWJ";
  CodepointType2[CodepointType2["RI"] = 4] = "RI";
  CodepointType2[CodepointType2["Prepend"] = 8] = "Prepend";
  CodepointType2[CodepointType2["SpacingMark"] = 16] = "SpacingMark";
  CodepointType2[CodepointType2["L"] = 32] = "L";
  CodepointType2[CodepointType2["V"] = 64] = "V";
  CodepointType2[CodepointType2["T"] = 128] = "T";
  CodepointType2[CodepointType2["LV"] = 256] = "LV";
  CodepointType2[CodepointType2["LVT"] = 512] = "LVT";
  CodepointType2[CodepointType2["ExtPict"] = 1024] = "ExtPict";
  CodepointType2[CodepointType2["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
var getCodepointType = (char2, code2) => {
  var type2 = CodepointType.Any;
  if (char2.search(reExtend) !== -1) {
    type2 |= CodepointType.Extend;
  }
  if (code2 === 8205) {
    type2 |= CodepointType.ZWJ;
  }
  if (code2 >= 127462 && code2 <= 127487) {
    type2 |= CodepointType.RI;
  }
  if (char2.search(rePrepend) !== -1) {
    type2 |= CodepointType.Prepend;
  }
  if (char2.search(reSpacingMark) !== -1) {
    type2 |= CodepointType.SpacingMark;
  }
  if (char2.search(reL) !== -1) {
    type2 |= CodepointType.L;
  }
  if (char2.search(reV) !== -1) {
    type2 |= CodepointType.V;
  }
  if (char2.search(reT) !== -1) {
    type2 |= CodepointType.T;
  }
  if (char2.search(reLV) !== -1) {
    type2 |= CodepointType.LV;
  }
  if (char2.search(reLVT) !== -1) {
    type2 |= CodepointType.LVT;
  }
  if (char2.search(reExtPict) !== -1) {
    type2 |= CodepointType.ExtPict;
  }
  return type2;
};
function intersects(x3, y4) {
  return (x3 & y4) !== 0;
}
var NonBoundaryPairs = [
  // GB6
  [CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],
  // GB7
  [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],
  // GB8
  [CodepointType.LVT | CodepointType.T, CodepointType.T],
  // GB9
  [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],
  // GB9a
  [CodepointType.Any, CodepointType.SpacingMark],
  // GB9b
  [CodepointType.Prepend, CodepointType.Any],
  // GB11
  [CodepointType.ZWJ, CodepointType.ExtPict],
  // GB12 and GB13
  [CodepointType.RI, CodepointType.RI]
];
function isBoundaryPair(left, right) {
  return NonBoundaryPairs.findIndex((r7) => intersects(left, r7[0]) && intersects(right, r7[1])) === -1;
}
var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
var endsWithEmojiZWJ = (str) => {
  return str.search(endingEmojiZWJ) !== -1;
};
var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
var endsWithOddNumberOfRIs = (str) => {
  var match3 = str.match(endingRIs);
  if (match3 === null) {
    return false;
  } else {
    var numRIs = match3[0].length / 2;
    return numRIs % 2 === 1;
  }
};
var isElement = (value2) => {
  return isPlainObject(value2) && Node3.isNodeList(value2.children) && !Editor.isEditor(value2);
};
var Element2 = {
  /**
   * Check if a value implements the 'Ancestor' interface.
   */
  isAncestor(value2) {
    return isPlainObject(value2) && Node3.isNodeList(value2.children);
  },
  /**
   * Check if a value implements the `Element` interface.
   */
  isElement,
  /**
   * Check if a value is an array of `Element` objects.
   */
  isElementList(value2) {
    return Array.isArray(value2) && value2.every((val) => Element2.isElement(val));
  },
  /**
   * Check if a set of props is a partial of Element.
   */
  isElementProps(props) {
    return props.children !== void 0;
  },
  /**
   * Check if a value implements the `Element` interface and has elementKey with selected value.
   * Default it check to `type` key value
   */
  isElementType: function isElementType(value2, elementVal) {
    var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return isElement(value2) && value2[elementKey] === elementVal;
  },
  /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */
  matches(element2, props) {
    for (var key in props) {
      if (key === "children") {
        continue;
      }
      if (element2[key] !== props[key]) {
        return false;
      }
    }
    return true;
  }
};
var _excluded$4 = ["text"];
var _excluded2$3 = ["text"];
function ownKeys$8(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$8(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();
var Editor = {
  /**
   * Get the ancestor above a location in the document.
   */
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      voids = false,
      mode = "lowest",
      at = editor.selection,
      match: match3
    } = options;
    if (!at) {
      return;
    }
    var path2 = Editor.path(editor, at);
    var reverse = mode === "lowest";
    for (var [n6, p5] of Editor.levels(editor, {
      at: path2,
      voids,
      match: match3,
      reverse
    })) {
      if (Text2.isText(n6))
        continue;
      if (Range.isRange(at)) {
        if (Path.isAncestor(p5, at.anchor.path) && Path.isAncestor(p5, at.focus.path)) {
          return [n6, p5];
        }
      } else {
        if (!Path.equals(path2, p5)) {
          return [n6, p5];
        }
      }
    }
  },
  /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */
  addMark(editor, key, value2) {
    editor.addMark(key, value2);
  },
  /**
   * Get the point after a location.
   */
  after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor.point(editor, at, {
      edge: "end"
    });
    var focus = Editor.end(editor, []);
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d5 = 0;
    var target;
    for (var p5 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range
    }))) {
      if (d5 > distance) {
        break;
      }
      if (d5 !== 0) {
        target = p5;
      }
      d5++;
    }
    return target;
  },
  /**
   * Get the point before a location.
   */
  before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor.start(editor, []);
    var focus = Editor.point(editor, at, {
      edge: "start"
    });
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d5 = 0;
    var target;
    for (var p5 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range,
      reverse: true
    }))) {
      if (d5 > distance) {
        break;
      }
      if (d5 !== 0) {
        target = p5;
      }
      d5++;
    }
    return target;
  },
  /**
   * Delete content in the editor backward from the current selection.
   */
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteBackward(unit);
  },
  /**
   * Delete content in the editor forward from the current selection.
   */
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteForward(unit);
  },
  /**
   * Delete the content in the current selection.
   */
  deleteFragment(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      direction = "forward"
    } = options;
    editor.deleteFragment(direction);
  },
  /**
   * Get the start and end points of a location.
   */
  edges(editor, at) {
    return [Editor.start(editor, at), Editor.end(editor, at)];
  },
  /**
   * Get the end point of a location.
   */
  end(editor, at) {
    return Editor.point(editor, at, {
      edge: "end"
    });
  },
  /**
   * Get the first node at a location.
   */
  first(editor, at) {
    var path2 = Editor.path(editor, at, {
      edge: "start"
    });
    return Editor.node(editor, path2);
  },
  /**
   * Get the fragment at a location.
   */
  fragment(editor, at) {
    var range = Editor.range(editor, at);
    var fragment = Node3.fragment(editor, range);
    return fragment;
  },
  /**
   * Check if a node has block children.
   */
  hasBlocks(editor, element2) {
    return element2.children.some((n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6));
  },
  /**
   * Check if a node has inline and text children.
   */
  hasInlines(editor, element2) {
    return element2.children.some((n6) => Text2.isText(n6) || Editor.isInline(editor, n6));
  },
  /**
   * Check if a node has text children.
   */
  hasTexts(editor, element2) {
    return element2.children.every((n6) => Text2.isText(n6));
  },
  /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertBreak(editor) {
    editor.insertBreak();
  },
  /**
   * Insert a soft break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertSoftBreak(editor) {
    editor.insertSoftBreak();
  },
  /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertFragment(editor, fragment) {
    editor.insertFragment(fragment);
  },
  /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertNode(editor, node3) {
    editor.insertNode(node3);
  },
  /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertText(editor, text3) {
    editor.insertText(text3);
  },
  /**
   * Check if a value is a block `Element` object.
   */
  isBlock(editor, value2) {
    return !editor.isInline(value2);
  },
  /**
   * Check if a value is an `Editor` object.
   */
  isEditor(value2) {
    var cachedIsEditor = IS_EDITOR_CACHE.get(value2);
    if (cachedIsEditor !== void 0) {
      return cachedIsEditor;
    }
    if (!isPlainObject(value2)) {
      return false;
    }
    var isEditor = typeof value2.addMark === "function" && typeof value2.apply === "function" && typeof value2.deleteBackward === "function" && typeof value2.deleteForward === "function" && typeof value2.deleteFragment === "function" && typeof value2.insertBreak === "function" && typeof value2.insertSoftBreak === "function" && typeof value2.insertFragment === "function" && typeof value2.insertNode === "function" && typeof value2.insertText === "function" && typeof value2.isInline === "function" && typeof value2.isVoid === "function" && typeof value2.normalizeNode === "function" && typeof value2.onChange === "function" && typeof value2.removeMark === "function" && typeof value2.getDirtyPaths === "function" && (value2.marks === null || isPlainObject(value2.marks)) && (value2.selection === null || Range.isRange(value2.selection)) && Node3.isNodeList(value2.children) && Operation.isOperationList(value2.operations);
    IS_EDITOR_CACHE.set(value2, isEditor);
    return isEditor;
  },
  /**
   * Check if a point is the end point of a location.
   */
  isEnd(editor, point, at) {
    var end = Editor.end(editor, at);
    return Point.equals(point, end);
  },
  /**
   * Check if a point is an edge of a location.
   */
  isEdge(editor, point, at) {
    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);
  },
  /**
   * Check if an element is empty, accounting for void nodes.
   */
  isEmpty(editor, element2) {
    var {
      children
    } = element2;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text2.isText(first) && first.text === "" && !editor.isVoid(element2);
  },
  /**
   * Check if a value is an inline `Element` object.
   */
  isInline(editor, value2) {
    return editor.isInline(value2);
  },
  /**
   * Check if the editor is currently normalizing after each operation.
   */
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === void 0 ? true : isNormalizing;
  },
  /**
   * Check if a point is the start point of a location.
   */
  isStart(editor, point, at) {
    if (point.offset !== 0) {
      return false;
    }
    var start2 = Editor.start(editor, at);
    return Point.equals(point, start2);
  },
  /**
   * Check if a value is a void `Element` object.
   */
  isVoid(editor, value2) {
    return editor.isVoid(value2);
  },
  /**
   * Get the last node at a location.
   */
  last(editor, at) {
    var path2 = Editor.path(editor, at, {
      edge: "end"
    });
    return Editor.node(editor, path2);
  },
  /**
   * Get the leaf text node at a location.
   */
  leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path2 = Editor.path(editor, at, options);
    var node3 = Node3.leaf(editor, path2);
    return [node3, path2];
  },
  /**
   * Iterate through all of the levels at a location.
   */
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match3
    } = options;
    if (match3 == null) {
      match3 = () => true;
    }
    if (!at) {
      return;
    }
    var levels2 = [];
    var path2 = Editor.path(editor, at);
    for (var [n6, p5] of Node3.levels(editor, path2)) {
      if (!match3(n6, p5)) {
        continue;
      }
      levels2.push([n6, p5]);
      if (!voids && Element2.isElement(n6) && Editor.isVoid(editor, n6)) {
        break;
      }
    }
    if (reverse) {
      levels2.reverse();
    }
    yield* levels2;
  },
  /**
   * Get the marks that would be added to text at the current selection.
   */
  marks(editor) {
    var {
      marks,
      selection
    } = editor;
    if (!selection) {
      return null;
    }
    if (marks) {
      return marks;
    }
    if (Range.isExpanded(selection)) {
      var [match3] = Editor.nodes(editor, {
        match: Text2.isText
      });
      if (match3) {
        var [_node] = match3;
        var _rest = _objectWithoutProperties(_node, _excluded$4);
        return _rest;
      } else {
        return {};
      }
    }
    var {
      anchor
    } = selection;
    var {
      path: path2
    } = anchor;
    var [node3] = Editor.leaf(editor, path2);
    if (anchor.offset === 0) {
      var prev2 = Editor.previous(editor, {
        at: path2,
        match: Text2.isText
      });
      var markedVoid = Editor.above(editor, {
        match: (n6) => Element2.isElement(n6) && Editor.isVoid(editor, n6) && editor.markableVoid(n6)
      });
      if (!markedVoid) {
        var block5 = Editor.above(editor, {
          match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6)
        });
        if (prev2 && block5) {
          var [prevNode, prevPath] = prev2;
          var [, blockPath] = block5;
          if (Path.isAncestor(blockPath, prevPath)) {
            node3 = prevNode;
          }
        }
      }
    }
    var rest = _objectWithoutProperties(node3, _excluded2$3);
    return rest;
  },
  /**
   * Get the matching node in the branch of the document after a location.
   */
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match: match3,
      at = editor.selection
    } = options;
    if (!at) {
      return;
    }
    var pointAfterLocation = Editor.after(editor, at, {
      voids
    });
    if (!pointAfterLocation)
      return;
    var [, to] = Editor.last(editor, []);
    var span = [pointAfterLocation.path, to];
    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }
    if (match3 == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);
        match3 = (n6) => parent.children.includes(n6);
      } else {
        match3 = () => true;
      }
    }
    var [next2] = Editor.nodes(editor, {
      at: span,
      match: match3,
      mode,
      voids
    });
    return next2;
  },
  /**
   * Get the node at a location.
   */
  node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path2 = Editor.path(editor, at, options);
    var node3 = Node3.get(editor, path2);
    return [node3, path2];
  },
  /**
   * Iterate through all of the nodes in the Editor.
   */
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      mode = "all",
      universal = false,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match3
    } = options;
    if (!match3) {
      match3 = () => true;
    }
    if (!at) {
      return;
    }
    var from2;
    var to;
    if (Span.isSpan(at)) {
      from2 = at[0];
      to = at[1];
    } else {
      var first = Editor.path(editor, at, {
        edge: "start"
      });
      var last = Editor.path(editor, at, {
        edge: "end"
      });
      from2 = reverse ? last : first;
      to = reverse ? first : last;
    }
    var nodeEntries = Node3.nodes(editor, {
      reverse,
      from: from2,
      to,
      pass: (_ref) => {
        var [n6] = _ref;
        return voids ? false : Element2.isElement(n6) && Editor.isVoid(editor, n6);
      }
    });
    var matches = [];
    var hit;
    for (var [node3, path2] of nodeEntries) {
      var isLower = hit && Path.compare(path2, hit[1]) === 0;
      if (mode === "highest" && isLower) {
        continue;
      }
      if (!match3(node3, path2)) {
        if (universal && !isLower && Text2.isText(node3)) {
          return;
        } else {
          continue;
        }
      }
      if (mode === "lowest" && isLower) {
        hit = [node3, path2];
        continue;
      }
      var emit = mode === "lowest" ? hit : [node3, path2];
      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }
      hit = [node3, path2];
    }
    if (mode === "lowest" && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    }
    if (universal) {
      yield* matches;
    }
  },
  /**
   * Normalize any dirty objects in the editor.
   */
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      force = false,
      operation
    } = options;
    var getDirtyPaths = (editor2) => {
      return DIRTY_PATHS.get(editor2) || [];
    };
    var getDirtyPathKeys = (editor2) => {
      return DIRTY_PATH_KEYS.get(editor2) || /* @__PURE__ */ new Set();
    };
    var popDirtyPath = (editor2) => {
      var path2 = getDirtyPaths(editor2).pop();
      var key = path2.join(",");
      getDirtyPathKeys(editor2).delete(key);
      return path2;
    };
    if (!Editor.isNormalizing(editor)) {
      return;
    }
    if (force) {
      var allPaths = Array.from(Node3.nodes(editor), (_ref2) => {
        var [, p5] = _ref2;
        return p5;
      });
      var allPathKeys = new Set(allPaths.map((p5) => p5.join(",")));
      DIRTY_PATHS.set(editor, allPaths);
      DIRTY_PATH_KEYS.set(editor, allPathKeys);
    }
    if (getDirtyPaths(editor).length === 0) {
      return;
    }
    Editor.withoutNormalizing(editor, () => {
      for (var dirtyPath of getDirtyPaths(editor)) {
        if (Node3.has(editor, dirtyPath)) {
          var entry = Editor.node(editor, dirtyPath);
          var [node3, _2] = entry;
          if (Element2.isElement(node3) && node3.children.length === 0) {
            editor.normalizeNode(entry, {
              operation
            });
          }
        }
      }
      var dirtyPaths = getDirtyPaths(editor);
      var initialDirtyPathsLength = dirtyPaths.length;
      var iteration = 0;
      while (dirtyPaths.length !== 0) {
        if (!editor.shouldNormalize({
          dirtyPaths,
          iteration,
          initialDirtyPathsLength,
          operation
        })) {
          return;
        }
        var _dirtyPath = popDirtyPath(editor);
        if (Node3.has(editor, _dirtyPath)) {
          var _entry = Editor.node(editor, _dirtyPath);
          editor.normalizeNode(_entry, {
            operation
          });
        }
        iteration++;
        dirtyPaths = getDirtyPaths(editor);
      }
    });
  },
  /**
   * Get the parent node of a location.
   */
  parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path2 = Editor.path(editor, at, options);
    var parentPath = Path.parent(path2);
    var entry = Editor.node(editor, parentPath);
    return entry;
  },
  /**
   * Get the path of a location.
   */
  path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;
    if (Path.isPath(at)) {
      if (edge === "start") {
        var [, firstPath] = Node3.first(editor, at);
        at = firstPath;
      } else if (edge === "end") {
        var [, lastPath] = Node3.last(editor, at);
        at = lastPath;
      }
    }
    if (Range.isRange(at)) {
      if (edge === "start") {
        at = Range.start(at);
      } else if (edge === "end") {
        at = Range.end(at);
      } else {
        at = Path.common(at.anchor.path, at.focus.path);
      }
    }
    if (Point.isPoint(at)) {
      at = at.path;
    }
    if (depth != null) {
      at = at.slice(0, depth);
    }
    return at;
  },
  hasPath(editor, path2) {
    return Node3.has(editor, path2);
  },
  /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pathRef(editor, path2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: path2,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var pathRefs = Editor.pathRefs(editor);
        pathRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.pathRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked path refs of the editor.
   */
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      PATH_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Get the start or end point of a location.
   */
  point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      edge = "start"
    } = options;
    if (Path.isPath(at)) {
      var path2;
      if (edge === "end") {
        var [, lastPath] = Node3.last(editor, at);
        path2 = lastPath;
      } else {
        var [, firstPath] = Node3.first(editor, at);
        path2 = firstPath;
      }
      var node3 = Node3.get(editor, path2);
      if (!Text2.isText(node3)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
      }
      return {
        path: path2,
        offset: edge === "end" ? node3.text.length : 0
      };
    }
    if (Range.isRange(at)) {
      var [start2, end] = Range.edges(at);
      return edge === "start" ? start2 : end;
    }
    return at;
  },
  /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: point,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var pointRefs = Editor.pointRefs(editor);
        pointRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.pointRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked point refs of the editor.
   */
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      POINT_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Return all the positions in `at` range where a `Point` can be placed.
   *
   * By default, moves forward by individual offsets at a time, but
   * the `unit` option can be used to to move by character, word, line, or block.
   *
   * The `reverse` option can be used to change iteration direction.
   *
   * Note: By default void nodes are treated as a single point and iteration
   * will not happen inside their content unless you pass in true for the
   * `voids` option, then iteration will occur.
   */
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      unit = "offset",
      reverse = false,
      voids = false
    } = options;
    if (!at) {
      return;
    }
    var range = Editor.range(editor, at);
    var [start2, end] = Range.edges(range);
    var first = reverse ? end : start2;
    var isNewBlock = false;
    var blockText = "";
    var distance = 0;
    var leafTextRemaining = 0;
    var leafTextOffset = 0;
    for (var [node3, path2] of Editor.nodes(editor, {
      at,
      reverse,
      voids
    })) {
      if (Element2.isElement(node3)) {
        if (!voids && editor.isVoid(node3)) {
          yield Editor.start(editor, path2);
          continue;
        }
        if (editor.isInline(node3))
          continue;
        if (Editor.hasInlines(editor, node3)) {
          var e6 = Path.isAncestor(path2, end.path) ? end : Editor.end(editor, path2);
          var s4 = Path.isAncestor(path2, start2.path) ? start2 : Editor.start(editor, path2);
          blockText = Editor.string(editor, {
            anchor: s4,
            focus: e6
          }, {
            voids
          });
          isNewBlock = true;
        }
      }
      if (Text2.isText(node3)) {
        var isFirst = Path.equals(path2, first.path);
        if (isFirst) {
          leafTextRemaining = reverse ? first.offset : node3.text.length - first.offset;
          leafTextOffset = first.offset;
        } else {
          leafTextRemaining = node3.text.length;
          leafTextOffset = reverse ? leafTextRemaining : 0;
        }
        if (isFirst || isNewBlock || unit === "offset") {
          yield {
            path: path2,
            offset: leafTextOffset
          };
          isNewBlock = false;
        }
        while (true) {
          if (distance === 0) {
            if (blockText === "")
              break;
            distance = calcDistance(blockText, unit, reverse);
            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];
          }
          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;
          leafTextRemaining = leafTextRemaining - distance;
          if (leafTextRemaining < 0) {
            distance = -leafTextRemaining;
            break;
          }
          distance = 0;
          yield {
            path: path2,
            offset: leafTextOffset
          };
        }
      }
    }
    function calcDistance(text3, unit2, reverse2) {
      if (unit2 === "character") {
        return getCharacterDistance(text3, reverse2);
      } else if (unit2 === "word") {
        return getWordDistance(text3, reverse2);
      } else if (unit2 === "line" || unit2 === "block") {
        return text3.length;
      }
      return 1;
    }
  },
  /**
   * Get the matching node in the branch of the document before a location.
   */
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match: match3,
      at = editor.selection
    } = options;
    if (!at) {
      return;
    }
    var pointBeforeLocation = Editor.before(editor, at, {
      voids
    });
    if (!pointBeforeLocation) {
      return;
    }
    var [, to] = Editor.first(editor, []);
    var span = [pointBeforeLocation.path, to];
    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }
    if (match3 == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);
        match3 = (n6) => parent.children.includes(n6);
      } else {
        match3 = () => true;
      }
    }
    var [previous] = Editor.nodes(editor, {
      reverse: true,
      at: span,
      match: match3,
      mode,
      voids
    });
    return previous;
  },
  /**
   * Get a range of a location.
   */
  range(editor, at, to) {
    if (Range.isRange(at) && !to) {
      return at;
    }
    var start2 = Editor.start(editor, at);
    var end = Editor.end(editor, to || at);
    return {
      anchor: start2,
      focus: end
    };
  },
  /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref = {
      current: range,
      affinity,
      unref() {
        var {
          current
        } = ref;
        var rangeRefs = Editor.rangeRefs(editor);
        rangeRefs.delete(ref);
        ref.current = null;
        return current;
      }
    };
    var refs = Editor.rangeRefs(editor);
    refs.add(ref);
    return ref;
  },
  /**
   * Get the set of currently tracked range refs of the editor.
   */
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      RANGE_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */
  removeMark(editor, key) {
    editor.removeMark(key);
  },
  /**
   * Manually set if the editor should currently be normalizing.
   *
   * Note: Using this incorrectly can leave the editor in an invalid state.
   *
   */
  setNormalizing(editor, isNormalizing) {
    NORMALIZING.set(editor, isNormalizing);
  },
  /**
   * Get the start point of a location.
   */
  start(editor, at) {
    return Editor.point(editor, at, {
      edge: "start"
    });
  },
  /**
   * Get the text string content of a location.
   *
   * Note: by default the text of void nodes is considered to be an empty
   * string, regardless of content, unless you pass in true for the voids option
   */
  string(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var range = Editor.range(editor, at);
    var [start2, end] = Range.edges(range);
    var text3 = "";
    for (var [node3, path2] of Editor.nodes(editor, {
      at: range,
      match: Text2.isText,
      voids
    })) {
      var t5 = node3.text;
      if (Path.equals(path2, end.path)) {
        t5 = t5.slice(0, end.offset);
      }
      if (Path.equals(path2, start2.path)) {
        t5 = t5.slice(start2.offset);
      }
      text3 += t5;
    }
    return text3;
  },
  /**
   * Convert a range into a non-hanging one.
   */
  unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start2, end] = Range.edges(range);
    if (start2.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {
      return range;
    }
    var endBlock = Editor.above(editor, {
      at: end,
      match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
      voids
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor.start(editor, start2);
    var before = {
      anchor: first,
      focus: end
    };
    var skip = true;
    for (var [node3, path2] of Editor.nodes(editor, {
      at: before,
      match: Text2.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }
      if (node3.text !== "" || Path.isBefore(path2, blockPath)) {
        end = {
          path: path2,
          offset: node3.text.length
        };
        break;
      }
    }
    return {
      anchor: start2,
      focus: end
    };
  },
  /**
   * Match a void node in the current branch of the editor.
   */
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      match: (n6) => Element2.isElement(n6) && Editor.isVoid(editor, n6)
    }));
  },
  /**
   * Call a function, deferring normalization until after it completes.
   */
  withoutNormalizing(editor, fn2) {
    var value2 = Editor.isNormalizing(editor);
    Editor.setNormalizing(editor, false);
    try {
      fn2();
    } finally {
      Editor.setNormalizing(editor, value2);
    }
    Editor.normalize(editor);
  }
};
var Span = {
  /**
   * Check if a value implements the `Span` interface.
   */
  isSpan(value2) {
    return Array.isArray(value2) && value2.length === 2 && value2.every(Path.isPath);
  }
};
var _excluded$3 = ["children"];
var _excluded2$2 = ["text"];
var IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();
var Node3 = {
  /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */
  ancestor(root, path2) {
    var node3 = Node3.get(root, path2);
    if (Text2.isText(node3)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path2, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node3)));
    }
    return node3;
  },
  /**
   * Return a generator of all the ancestor nodes above a specific path.
   *
   * By default the order is top-down, from highest to lowest ancestor in
   * the tree, but you can pass the `reverse: true` option to go bottom-up.
   */
  *ancestors(root, path2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p5 of Path.ancestors(path2, options)) {
      var n6 = Node3.ancestor(root, p5);
      var entry = [n6, p5];
      yield entry;
    }
  },
  /**
   * Get the child of a node at a specific index.
   */
  child(root, index2) {
    if (Text2.isText(root)) {
      throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root)));
    }
    var c5 = root.children[index2];
    if (c5 == null) {
      throw new Error("Cannot get child at index `".concat(index2, "` in node: ").concat(Scrubber.stringify(root)));
    }
    return c5;
  },
  /**
   * Iterate over the children of a node at a specific path.
   */
  *children(root, path2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      reverse = false
    } = options;
    var ancestor = Node3.ancestor(root, path2);
    var {
      children
    } = ancestor;
    var index2 = reverse ? children.length - 1 : 0;
    while (reverse ? index2 >= 0 : index2 < children.length) {
      var child = Node3.child(ancestor, index2);
      var childPath = path2.concat(index2);
      yield [child, childPath];
      index2 = reverse ? index2 - 1 : index2 + 1;
    }
  },
  /**
   * Get an entry for the common ancesetor node of two paths.
   */
  common(root, path2, another) {
    var p5 = Path.common(path2, another);
    var n6 = Node3.get(root, p5);
    return [n6, p5];
  },
  /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */
  descendant(root, path2) {
    var node3 = Node3.get(root, path2);
    if (Editor.isEditor(node3)) {
      throw new Error("Cannot get the descendant node at path [".concat(path2, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node3)));
    }
    return node3;
  },
  /**
   * Return a generator of all the descendant node entries inside a root node.
   */
  *descendants(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node3, path2] of Node3.nodes(root, options)) {
      if (path2.length !== 0) {
        yield [node3, path2];
      }
    }
  },
  /**
   * Return a generator of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */
  *elements(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node3, path2] of Node3.nodes(root, options)) {
      if (Element2.isElement(node3)) {
        yield [node3, path2];
      }
    }
  },
  /**
   * Extract props from a Node.
   */
  extractProps(node3) {
    if (Element2.isAncestor(node3)) {
      var properties = _objectWithoutProperties(node3, _excluded$3);
      return properties;
    } else {
      var properties = _objectWithoutProperties(node3, _excluded2$2);
      return properties;
    }
  },
  /**
   * Get the first node entry in a root node from a path.
   */
  first(root, path2) {
    var p5 = path2.slice();
    var n6 = Node3.get(root, p5);
    while (n6) {
      if (Text2.isText(n6) || n6.children.length === 0) {
        break;
      } else {
        n6 = n6.children[0];
        p5.push(0);
      }
    }
    return [n6, p5];
  },
  /**
   * Get the sliced fragment represented by a range inside a root node.
   */
  fragment(root, range) {
    if (Text2.isText(root)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root)));
    }
    var newRoot = fn({
      children: root.children
    }, (r7) => {
      var [start2, end] = Range.edges(range);
      var nodeEntries = Node3.nodes(r7, {
        reverse: true,
        pass: (_ref) => {
          var [, path3] = _ref;
          return !Range.includes(range, path3);
        }
      });
      for (var [, path2] of nodeEntries) {
        if (!Range.includes(range, path2)) {
          var parent = Node3.parent(r7, path2);
          var index2 = path2[path2.length - 1];
          parent.children.splice(index2, 1);
        }
        if (Path.equals(path2, end.path)) {
          var leaf = Node3.leaf(r7, path2);
          leaf.text = leaf.text.slice(0, end.offset);
        }
        if (Path.equals(path2, start2.path)) {
          var _leaf = Node3.leaf(r7, path2);
          _leaf.text = _leaf.text.slice(start2.offset);
        }
      }
      if (Editor.isEditor(r7)) {
        r7.selection = null;
      }
    });
    return newRoot.children;
  },
  /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */
  get(root, path2) {
    var node3 = root;
    for (var i6 = 0; i6 < path2.length; i6++) {
      var p5 = path2[i6];
      if (Text2.isText(node3) || !node3.children[p5]) {
        throw new Error("Cannot find a descendant at path [".concat(path2, "] in node: ").concat(Scrubber.stringify(root)));
      }
      node3 = node3.children[p5];
    }
    return node3;
  },
  /**
   * Check if a descendant node exists at a specific path.
   */
  has(root, path2) {
    var node3 = root;
    for (var i6 = 0; i6 < path2.length; i6++) {
      var p5 = path2[i6];
      if (Text2.isText(node3) || !node3.children[p5]) {
        return false;
      }
      node3 = node3.children[p5];
    }
    return true;
  },
  /**
   * Check if a value implements the `Node` interface.
   */
  isNode(value2) {
    return Text2.isText(value2) || Element2.isElement(value2) || Editor.isEditor(value2);
  },
  /**
   * Check if a value is a list of `Node` objects.
   */
  isNodeList(value2) {
    if (!Array.isArray(value2)) {
      return false;
    }
    var cachedResult = IS_NODE_LIST_CACHE.get(value2);
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    var isNodeList = value2.every((val) => Node3.isNode(val));
    IS_NODE_LIST_CACHE.set(value2, isNodeList);
    return isNodeList;
  },
  /**
   * Get the last node entry in a root node from a path.
   */
  last(root, path2) {
    var p5 = path2.slice();
    var n6 = Node3.get(root, p5);
    while (n6) {
      if (Text2.isText(n6) || n6.children.length === 0) {
        break;
      } else {
        var i6 = n6.children.length - 1;
        n6 = n6.children[i6];
        p5.push(i6);
      }
    }
    return [n6, p5];
  },
  /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */
  leaf(root, path2) {
    var node3 = Node3.get(root, path2);
    if (!Text2.isText(node3)) {
      throw new Error("Cannot get the leaf node at path [".concat(path2, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node3)));
    }
    return node3;
  },
  /**
   * Return a generator of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from highest to lowest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */
  *levels(root, path2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p5 of Path.levels(path2, options)) {
      var n6 = Node3.get(root, p5);
      yield [n6, p5];
    }
  },
  /**
   * Check if a node matches a set of props.
   */
  matches(node3, props) {
    return Element2.isElement(node3) && Element2.isElementProps(props) && Element2.matches(node3, props) || Text2.isText(node3) && Text2.isTextProps(props) && Text2.matches(node3, props);
  },
  /**
   * Return a generator of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */
  *nodes(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      pass,
      reverse = false
    } = options;
    var {
      from: from2 = [],
      to
    } = options;
    var visited = /* @__PURE__ */ new Set();
    var p5 = [];
    var n6 = root;
    while (true) {
      if (to && (reverse ? Path.isBefore(p5, to) : Path.isAfter(p5, to))) {
        break;
      }
      if (!visited.has(n6)) {
        yield [n6, p5];
      }
      if (!visited.has(n6) && !Text2.isText(n6) && n6.children.length !== 0 && (pass == null || pass([n6, p5]) === false)) {
        visited.add(n6);
        var nextIndex = reverse ? n6.children.length - 1 : 0;
        if (Path.isAncestor(p5, from2)) {
          nextIndex = from2[p5.length];
        }
        p5 = p5.concat(nextIndex);
        n6 = Node3.get(root, p5);
        continue;
      }
      if (p5.length === 0) {
        break;
      }
      if (!reverse) {
        var newPath = Path.next(p5);
        if (Node3.has(root, newPath)) {
          p5 = newPath;
          n6 = Node3.get(root, p5);
          continue;
        }
      }
      if (reverse && p5[p5.length - 1] !== 0) {
        var _newPath = Path.previous(p5);
        p5 = _newPath;
        n6 = Node3.get(root, p5);
        continue;
      }
      p5 = Path.parent(p5);
      n6 = Node3.get(root, p5);
      visited.add(n6);
    }
  },
  /**
   * Get the parent of a node at a specific path.
   */
  parent(root, path2) {
    var parentPath = Path.parent(path2);
    var p5 = Node3.get(root, parentPath);
    if (Text2.isText(p5)) {
      throw new Error("Cannot get the parent of path [".concat(path2, "] because it does not exist in the root."));
    }
    return p5;
  },
  /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */
  string(node3) {
    if (Text2.isText(node3)) {
      return node3.text;
    } else {
      return node3.children.map(Node3.string).join("");
    }
  },
  /**
   * Return a generator of all leaf text nodes in a root node.
   */
  *texts(root) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node3, path2] of Node3.nodes(root, options)) {
      if (Text2.isText(node3)) {
        yield [node3, path2];
      }
    }
  }
};
function ownKeys$7(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$7(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Operation = {
  /**
   * Check if a value is a `NodeOperation` object.
   */
  isNodeOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_node");
  },
  /**
   * Check if a value is an `Operation` object.
   */
  isOperation(value2) {
    if (!isPlainObject(value2)) {
      return false;
    }
    switch (value2.type) {
      case "insert_node":
        return Path.isPath(value2.path) && Node3.isNode(value2.node);
      case "insert_text":
        return typeof value2.offset === "number" && typeof value2.text === "string" && Path.isPath(value2.path);
      case "merge_node":
        return typeof value2.position === "number" && Path.isPath(value2.path) && isPlainObject(value2.properties);
      case "move_node":
        return Path.isPath(value2.path) && Path.isPath(value2.newPath);
      case "remove_node":
        return Path.isPath(value2.path) && Node3.isNode(value2.node);
      case "remove_text":
        return typeof value2.offset === "number" && typeof value2.text === "string" && Path.isPath(value2.path);
      case "set_node":
        return Path.isPath(value2.path) && isPlainObject(value2.properties) && isPlainObject(value2.newProperties);
      case "set_selection":
        return value2.properties === null && Range.isRange(value2.newProperties) || value2.newProperties === null && Range.isRange(value2.properties) || isPlainObject(value2.properties) && isPlainObject(value2.newProperties);
      case "split_node":
        return Path.isPath(value2.path) && typeof value2.position === "number" && isPlainObject(value2.properties);
      default:
        return false;
    }
  },
  /**
   * Check if a value is a list of `Operation` objects.
   */
  isOperationList(value2) {
    return Array.isArray(value2) && value2.every((val) => Operation.isOperation(val));
  },
  /**
   * Check if a value is a `SelectionOperation` object.
   */
  isSelectionOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_selection");
  },
  /**
   * Check if a value is a `TextOperation` object.
   */
  isTextOperation(value2) {
    return Operation.isOperation(value2) && value2.type.endsWith("_text");
  },
  /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */
  inverse(op) {
    switch (op.type) {
      case "insert_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "remove_node"
        });
      }
      case "insert_text": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "remove_text"
        });
      }
      case "merge_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "split_node",
          path: Path.previous(op.path)
        });
      }
      case "move_node": {
        var {
          newPath,
          path: path2
        } = op;
        if (Path.equals(newPath, path2)) {
          return op;
        }
        if (Path.isSibling(path2, newPath)) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            path: newPath,
            newPath: path2
          });
        }
        var inversePath = Path.transform(path2, op);
        var inverseNewPath = Path.transform(Path.next(path2), op);
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          path: inversePath,
          newPath: inverseNewPath
        });
      }
      case "remove_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "insert_node"
        });
      }
      case "remove_text": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "insert_text"
        });
      }
      case "set_node": {
        var {
          properties,
          newProperties
        } = op;
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          properties: newProperties,
          newProperties: properties
        });
      }
      case "set_selection": {
        var {
          properties: _properties,
          newProperties: _newProperties
        } = op;
        if (_properties == null) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: _newProperties,
            newProperties: null
          });
        } else if (_newProperties == null) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: null,
            newProperties: _properties
          });
        } else {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: _newProperties,
            newProperties: _properties
          });
        }
      }
      case "split_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "merge_node",
          path: Path.next(op.path)
        });
      }
    }
  }
};
var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from shallowest to deepest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var paths = Path.levels(path2, options);
    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }
    return paths;
  },
  /**
   * Get the common ancestor path of two paths.
   */
  common(path2, another) {
    var common = [];
    for (var i6 = 0; i6 < path2.length && i6 < another.length; i6++) {
      var av = path2[i6];
      var bv = another[i6];
      if (av !== bv) {
        break;
      }
      common.push(av);
    }
    return common;
  },
  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path2, another) {
    var min = Math.min(path2.length, another.length);
    for (var i6 = 0; i6 < min; i6++) {
      if (path2[i6] < another[i6])
        return -1;
      if (path2[i6] > another[i6])
        return 1;
    }
    return 0;
  },
  /**
   * Check if a path ends after one of the indexes in another.
   */
  endsAfter(path2, another) {
    var i6 = path2.length - 1;
    var as = path2.slice(0, i6);
    var bs = another.slice(0, i6);
    var av = path2[i6];
    var bv = another[i6];
    return Path.equals(as, bs) && av > bv;
  },
  /**
   * Check if a path ends at one of the indexes in another.
   */
  endsAt(path2, another) {
    var i6 = path2.length;
    var as = path2.slice(0, i6);
    var bs = another.slice(0, i6);
    return Path.equals(as, bs);
  },
  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path2, another) {
    var i6 = path2.length - 1;
    var as = path2.slice(0, i6);
    var bs = another.slice(0, i6);
    var av = path2[i6];
    var bv = another[i6];
    return Path.equals(as, bs) && av < bv;
  },
  /**
   * Check if a path is exactly equal to another.
   */
  equals(path2, another) {
    return path2.length === another.length && path2.every((n6, i6) => n6 === another[i6]);
  },
  /**
   * Check if the path of previous sibling node exists
   */
  hasPrevious(path2) {
    return path2[path2.length - 1] > 0;
  },
  /**
   * Check if a path is after another.
   */
  isAfter(path2, another) {
    return Path.compare(path2, another) === 1;
  },
  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path2, another) {
    return path2.length < another.length && Path.compare(path2, another) === 0;
  },
  /**
   * Check if a path is before another.
   */
  isBefore(path2, another) {
    return Path.compare(path2, another) === -1;
  },
  /**
   * Check if a path is a child of another.
   */
  isChild(path2, another) {
    return path2.length === another.length + 1 && Path.compare(path2, another) === 0;
  },
  /**
   * Check if a path is equal to or an ancestor of another.
   */
  isCommon(path2, another) {
    return path2.length <= another.length && Path.compare(path2, another) === 0;
  },
  /**
   * Check if a path is a descendant of another.
   */
  isDescendant(path2, another) {
    return path2.length > another.length && Path.compare(path2, another) === 0;
  },
  /**
   * Check if a path is the parent of another.
   */
  isParent(path2, another) {
    return path2.length + 1 === another.length && Path.compare(path2, another) === 0;
  },
  /**
   * Check is a value implements the `Path` interface.
   */
  isPath(value2) {
    return Array.isArray(value2) && (value2.length === 0 || typeof value2[0] === "number");
  },
  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path2, another) {
    if (path2.length !== another.length) {
      return false;
    }
    var as = path2.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path2[path2.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },
  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var list2 = [];
    for (var i6 = 0; i6 <= path2.length; i6++) {
      list2.push(path2.slice(0, i6));
    }
    if (reverse) {
      list2.reverse();
    }
    return list2;
  },
  /**
   * Given a path, get the path to the next sibling node.
   */
  next(path2) {
    if (path2.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path2, "], because it has no next index."));
    }
    var last = path2[path2.length - 1];
    return path2.slice(0, -1).concat(last + 1);
  },
  /**
   * Returns whether this operation can affect paths or not. Used as an
   * optimization when updating dirty paths during normalization
   *
   * NOTE: This *must* be kept in sync with the implementation of 'transform'
   * below
   */
  operationCanTransformPath(operation) {
    switch (operation.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return true;
      default:
        return false;
    }
  },
  /**
   * Given a path, return a new path referring to the parent node above it.
   */
  parent(path2) {
    if (path2.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path2, "]."));
    }
    return path2.slice(0, -1);
  },
  /**
   * Given a path, get the path to the previous sibling node.
   */
  previous(path2) {
    if (path2.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path2, "], because it has no previous index."));
    }
    var last = path2[path2.length - 1];
    if (last <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path2, "] because it would result in a negative index."));
    }
    return path2.slice(0, -1).concat(last - 1);
  },
  /**
   * Get a path relative to an ancestor.
   */
  relative(path2, ancestor) {
    if (!Path.isAncestor(ancestor, path2) && !Path.equals(path2, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path2, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }
    return path2.slice(ancestor.length);
  },
  /**
   * Transform a path by an operation.
   */
  transform(path2, operation) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!path2)
      return null;
    var p5 = [...path2];
    var {
      affinity = "forward"
    } = options;
    if (path2.length === 0) {
      return p5;
    }
    switch (operation.type) {
      case "insert_node": {
        var {
          path: op
        } = operation;
        if (Path.equals(op, p5) || Path.endsBefore(op, p5) || Path.isAncestor(op, p5)) {
          p5[op.length - 1] += 1;
        }
        break;
      }
      case "remove_node": {
        var {
          path: _op
        } = operation;
        if (Path.equals(_op, p5) || Path.isAncestor(_op, p5)) {
          return null;
        } else if (Path.endsBefore(_op, p5)) {
          p5[_op.length - 1] -= 1;
        }
        break;
      }
      case "merge_node": {
        var {
          path: _op2,
          position: position2
        } = operation;
        if (Path.equals(_op2, p5) || Path.endsBefore(_op2, p5)) {
          p5[_op2.length - 1] -= 1;
        } else if (Path.isAncestor(_op2, p5)) {
          p5[_op2.length - 1] -= 1;
          p5[_op2.length] += position2;
        }
        break;
      }
      case "split_node": {
        var {
          path: _op3,
          position: _position
        } = operation;
        if (Path.equals(_op3, p5)) {
          if (affinity === "forward") {
            p5[p5.length - 1] += 1;
          } else if (affinity === "backward")
            ;
          else {
            return null;
          }
        } else if (Path.endsBefore(_op3, p5)) {
          p5[_op3.length - 1] += 1;
        } else if (Path.isAncestor(_op3, p5) && path2[_op3.length] >= _position) {
          p5[_op3.length - 1] += 1;
          p5[_op3.length] -= _position;
        }
        break;
      }
      case "move_node": {
        var {
          path: _op4,
          newPath: onp
        } = operation;
        if (Path.equals(_op4, onp)) {
          return p5;
        }
        if (Path.isAncestor(_op4, p5) || Path.equals(_op4, p5)) {
          var copy2 = onp.slice();
          if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
            copy2[_op4.length - 1] -= 1;
          }
          return copy2.concat(p5.slice(_op4.length));
        } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p5) || Path.equals(onp, p5))) {
          if (Path.endsBefore(_op4, p5)) {
            p5[_op4.length - 1] -= 1;
          } else {
            p5[_op4.length - 1] += 1;
          }
        } else if (Path.endsBefore(onp, p5) || Path.equals(onp, p5) || Path.isAncestor(onp, p5)) {
          if (Path.endsBefore(_op4, p5)) {
            p5[_op4.length - 1] -= 1;
          }
          p5[onp.length - 1] += 1;
        } else if (Path.endsBefore(_op4, p5)) {
          if (Path.equals(onp, p5)) {
            p5[onp.length - 1] += 1;
          }
          p5[_op4.length - 1] -= 1;
        }
        break;
      }
    }
    return p5;
  }
};
var PathRef = {
  /**
   * Transform the path ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var path2 = Path.transform(current, op, {
      affinity
    });
    ref.current = path2;
    if (path2 == null) {
      ref.unref();
    }
  }
};
function ownKeys$6(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Point = {
  /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */
  compare(point, another) {
    var result = Path.compare(point.path, another.path);
    if (result === 0) {
      if (point.offset < another.offset)
        return -1;
      if (point.offset > another.offset)
        return 1;
      return 0;
    }
    return result;
  },
  /**
   * Check if a point is after another.
   */
  isAfter(point, another) {
    return Point.compare(point, another) === 1;
  },
  /**
   * Check if a point is before another.
   */
  isBefore(point, another) {
    return Point.compare(point, another) === -1;
  },
  /**
   * Check if a point is exactly equal to another.
   */
  equals(point, another) {
    return point.offset === another.offset && Path.equals(point.path, another.path);
  },
  /**
   * Check if a value implements the `Point` interface.
   */
  isPoint(value2) {
    return isPlainObject(value2) && typeof value2.offset === "number" && Path.isPath(value2.path);
  },
  /**
   * Transform a point by an operation.
   */
  transform(point, op) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(point, (p5) => {
      if (p5 === null) {
        return null;
      }
      var {
        affinity = "forward"
      } = options;
      var {
        path: path2,
        offset
      } = p5;
      switch (op.type) {
        case "insert_node":
        case "move_node": {
          p5.path = Path.transform(path2, op, options);
          break;
        }
        case "insert_text": {
          if (Path.equals(op.path, path2) && (op.offset < offset || op.offset === offset && affinity === "forward")) {
            p5.offset += op.text.length;
          }
          break;
        }
        case "merge_node": {
          if (Path.equals(op.path, path2)) {
            p5.offset += op.position;
          }
          p5.path = Path.transform(path2, op, options);
          break;
        }
        case "remove_text": {
          if (Path.equals(op.path, path2) && op.offset <= offset) {
            p5.offset -= Math.min(offset - op.offset, op.text.length);
          }
          break;
        }
        case "remove_node": {
          if (Path.equals(op.path, path2) || Path.isAncestor(op.path, path2)) {
            return null;
          }
          p5.path = Path.transform(path2, op, options);
          break;
        }
        case "split_node": {
          if (Path.equals(op.path, path2)) {
            if (op.position === offset && affinity == null) {
              return null;
            } else if (op.position < offset || op.position === offset && affinity === "forward") {
              p5.offset -= op.position;
              p5.path = Path.transform(path2, op, _objectSpread$6(_objectSpread$6({}, options), {}, {
                affinity: "forward"
              }));
            }
          } else {
            p5.path = Path.transform(path2, op, options);
          }
          break;
        }
      }
    });
  }
};
var PointRef = {
  /**
   * Transform the point ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var point = Point.transform(current, op, {
      affinity
    });
    ref.current = point;
    if (point == null) {
      ref.unref();
    }
  }
};
var _excluded$2 = ["anchor", "focus"];
function ownKeys$5(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Range = {
  /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */
  edges(range) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var {
      anchor,
      focus
    } = range;
    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];
  },
  /**
   * Get the end point of a range.
   */
  end(range) {
    var [, end] = Range.edges(range);
    return end;
  },
  /**
   * Check if a range is exactly equal to another.
   */
  equals(range, another) {
    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
  },
  /**
   * Check if a range includes a path, a point or part of another range.
   */
  includes(range, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
        return true;
      }
      var [rs, re] = Range.edges(range);
      var [ts, te] = Range.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re, te);
    }
    var [start2, end] = Range.edges(range);
    var isAfterStart = false;
    var isBeforeEnd = false;
    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start2) >= 0;
      isBeforeEnd = Point.compare(target, end) <= 0;
    } else {
      isAfterStart = Path.compare(target, start2.path) >= 0;
      isBeforeEnd = Path.compare(target, end.path) <= 0;
    }
    return isAfterStart && isBeforeEnd;
  },
  /**
   * Get the intersection of a range with another.
   */
  intersection(range, another) {
    var rest = _objectWithoutProperties(range, _excluded$2);
    var [s1, e1] = Range.edges(range);
    var [s22, e22] = Range.edges(another);
    var start2 = Point.isBefore(s1, s22) ? s22 : s1;
    var end = Point.isBefore(e1, e22) ? e1 : e22;
    if (Point.isBefore(end, start2)) {
      return null;
    } else {
      return _objectSpread$5({
        anchor: start2,
        focus: end
      }, rest);
    }
  },
  /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */
  isBackward(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.isAfter(anchor, focus);
  },
  /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */
  isCollapsed(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.equals(anchor, focus);
  },
  /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */
  isExpanded(range) {
    return !Range.isCollapsed(range);
  },
  /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */
  isForward(range) {
    return !Range.isBackward(range);
  },
  /**
   * Check if a value implements the [[Range]] interface.
   */
  isRange(value2) {
    return isPlainObject(value2) && Point.isPoint(value2.anchor) && Point.isPoint(value2.focus);
  },
  /**
   * Iterate through all of the point entries in a range.
   */
  *points(range) {
    yield [range.anchor, "anchor"];
    yield [range.focus, "focus"];
  },
  /**
   * Get the start point of a range.
   */
  start(range) {
    var [start2] = Range.edges(range);
    return start2;
  },
  /**
   * Transform a range by an operation.
   */
  transform(range, op) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(range, (r7) => {
      if (r7 === null) {
        return null;
      }
      var {
        affinity = "inward"
      } = options;
      var affinityAnchor;
      var affinityFocus;
      if (affinity === "inward") {
        var isCollapsed = Range.isCollapsed(r7);
        if (Range.isForward(r7)) {
          affinityAnchor = "forward";
          affinityFocus = isCollapsed ? affinityAnchor : "backward";
        } else {
          affinityAnchor = "backward";
          affinityFocus = isCollapsed ? affinityAnchor : "forward";
        }
      } else if (affinity === "outward") {
        if (Range.isForward(r7)) {
          affinityAnchor = "backward";
          affinityFocus = "forward";
        } else {
          affinityAnchor = "forward";
          affinityFocus = "backward";
        }
      } else {
        affinityAnchor = affinity;
        affinityFocus = affinity;
      }
      var anchor = Point.transform(r7.anchor, op, {
        affinity: affinityAnchor
      });
      var focus = Point.transform(r7.focus, op, {
        affinity: affinityFocus
      });
      if (!anchor || !focus) {
        return null;
      }
      r7.anchor = anchor;
      r7.focus = focus;
    });
  }
};
var RangeRef = {
  /**
   * Transform the range ref's current value by an operation.
   */
  transform(ref, op) {
    var {
      current,
      affinity
    } = ref;
    if (current == null) {
      return;
    }
    var path2 = Range.transform(current, op, {
      affinity
    });
    ref.current = path2;
    if (path2 == null) {
      ref.unref();
    }
  }
};
var _scrubber = void 0;
var Scrubber = {
  setScrubber(scrubber) {
    _scrubber = scrubber;
  },
  stringify(value2) {
    return JSON.stringify(value2, _scrubber);
  }
};
var isDeepEqual = (node3, another) => {
  for (var key in node3) {
    var a3 = node3[key];
    var b2 = another[key];
    if (isPlainObject(a3) && isPlainObject(b2)) {
      if (!isDeepEqual(a3, b2))
        return false;
    } else if (Array.isArray(a3) && Array.isArray(b2)) {
      if (a3.length !== b2.length)
        return false;
      for (var i6 = 0; i6 < a3.length; i6++) {
        if (a3[i6] !== b2[i6])
          return false;
      }
    } else if (a3 !== b2) {
      return false;
    }
  }
  for (var _key in another) {
    if (node3[_key] === void 0 && another[_key] !== void 0) {
      return false;
    }
  }
  return true;
};
var _excluded$1 = ["text"];
var _excluded2$1 = ["anchor", "focus"];
function ownKeys$4(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Text2 = {
  /**
   * Check if two text nodes are equal.
   *
   * When loose is set, the text is not compared. This is
   * used to check whether sibling text nodes can be merged.
   */
  equals(text3, another) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      loose = false
    } = options;
    function omitText(obj) {
      var rest = _objectWithoutProperties(obj, _excluded$1);
      return rest;
    }
    return isDeepEqual(loose ? omitText(text3) : text3, loose ? omitText(another) : another);
  },
  /**
   * Check if a value implements the `Text` interface.
   */
  isText(value2) {
    return isPlainObject(value2) && typeof value2.text === "string";
  },
  /**
   * Check if a value is a list of `Text` objects.
   */
  isTextList(value2) {
    return Array.isArray(value2) && value2.every((val) => Text2.isText(val));
  },
  /**
   * Check if some props are a partial of Text.
   */
  isTextProps(props) {
    return props.text !== void 0;
  },
  /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */
  matches(text3, props) {
    for (var key in props) {
      if (key === "text") {
        continue;
      }
      if (!text3.hasOwnProperty(key) || text3[key] !== props[key]) {
        return false;
      }
    }
    return true;
  },
  /**
   * Get the leaves for a text node given decorations.
   */
  decorations(node3, decorations) {
    var leaves = [_objectSpread$4({}, node3)];
    for (var dec of decorations) {
      var rest = _objectWithoutProperties(dec, _excluded2$1);
      var [start2, end] = Range.edges(dec);
      var next2 = [];
      var leafEnd = 0;
      var decorationStart = start2.offset;
      var decorationEnd = end.offset;
      for (var leaf of leaves) {
        var {
          length: length2
        } = leaf.text;
        var leafStart = leafEnd;
        leafEnd += length2;
        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
          Object.assign(leaf, rest);
          next2.push(leaf);
          continue;
        }
        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
          next2.push(leaf);
          continue;
        }
        var middle = leaf;
        var before = void 0;
        var after = void 0;
        if (decorationEnd < leafEnd) {
          var off = decorationEnd - leafStart;
          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, off)
          });
        }
        if (decorationStart > leafStart) {
          var _off = decorationStart - leafStart;
          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(_off)
          });
        }
        Object.assign(middle, rest);
        if (before) {
          next2.push(before);
        }
        next2.push(middle);
        if (after) {
          next2.push(after);
        }
      }
      leaves = next2;
    }
    return leaves;
  }
};
function ownKeys$3(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var applyToDraft = (editor, selection, op) => {
  switch (op.type) {
    case "insert_node": {
      var {
        path: path2,
        node: node3
      } = op;
      var parent = Node3.parent(editor, path2);
      var index2 = path2[path2.length - 1];
      if (index2 > parent.children.length) {
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path2, "] because the destination is past the end of the node."));
      }
      parent.children.splice(index2, 0, node3);
      if (selection) {
        for (var [point, key] of Range.points(selection)) {
          selection[key] = Point.transform(point, op);
        }
      }
      break;
    }
    case "insert_text": {
      var {
        path: _path,
        offset,
        text: text3
      } = op;
      if (text3.length === 0)
        break;
      var _node = Node3.leaf(editor, _path);
      var before = _node.text.slice(0, offset);
      var after = _node.text.slice(offset);
      _node.text = before + text3 + after;
      if (selection) {
        for (var [_point, _key] of Range.points(selection)) {
          selection[_key] = Point.transform(_point, op);
        }
      }
      break;
    }
    case "merge_node": {
      var {
        path: _path2
      } = op;
      var _node2 = Node3.get(editor, _path2);
      var prevPath = Path.previous(_path2);
      var prev2 = Node3.get(editor, prevPath);
      var _parent = Node3.parent(editor, _path2);
      var _index = _path2[_path2.length - 1];
      if (Text2.isText(_node2) && Text2.isText(prev2)) {
        prev2.text += _node2.text;
      } else if (!Text2.isText(_node2) && !Text2.isText(prev2)) {
        prev2.children.push(..._node2.children);
      } else {
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev2)));
      }
      _parent.children.splice(_index, 1);
      if (selection) {
        for (var [_point2, _key2] of Range.points(selection)) {
          selection[_key2] = Point.transform(_point2, op);
        }
      }
      break;
    }
    case "move_node": {
      var {
        path: _path3,
        newPath
      } = op;
      if (Path.isAncestor(_path3, newPath)) {
        throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
      }
      var _node3 = Node3.get(editor, _path3);
      var _parent2 = Node3.parent(editor, _path3);
      var _index2 = _path3[_path3.length - 1];
      _parent2.children.splice(_index2, 1);
      var truePath = Path.transform(_path3, op);
      var newParent = Node3.get(editor, Path.parent(truePath));
      var newIndex = truePath[truePath.length - 1];
      newParent.children.splice(newIndex, 0, _node3);
      if (selection) {
        for (var [_point3, _key3] of Range.points(selection)) {
          selection[_key3] = Point.transform(_point3, op);
        }
      }
      break;
    }
    case "remove_node": {
      var {
        path: _path4
      } = op;
      var _index3 = _path4[_path4.length - 1];
      var _parent3 = Node3.parent(editor, _path4);
      _parent3.children.splice(_index3, 1);
      if (selection) {
        for (var [_point4, _key4] of Range.points(selection)) {
          var result = Point.transform(_point4, op);
          if (selection != null && result != null) {
            selection[_key4] = result;
          } else {
            var _prev = void 0;
            var next2 = void 0;
            for (var [n6, p5] of Node3.texts(editor)) {
              if (Path.compare(p5, _path4) === -1) {
                _prev = [n6, p5];
              } else {
                next2 = [n6, p5];
                break;
              }
            }
            var preferNext = false;
            if (_prev && next2) {
              if (Path.equals(next2[1], _path4)) {
                preferNext = !Path.hasPrevious(next2[1]);
              } else {
                preferNext = Path.common(_prev[1], _path4).length < Path.common(next2[1], _path4).length;
              }
            }
            if (_prev && !preferNext) {
              _point4.path = _prev[1];
              _point4.offset = _prev[0].text.length;
            } else if (next2) {
              _point4.path = next2[1];
              _point4.offset = 0;
            } else {
              selection = null;
            }
          }
        }
      }
      break;
    }
    case "remove_text": {
      var {
        path: _path5,
        offset: _offset,
        text: _text
      } = op;
      if (_text.length === 0)
        break;
      var _node4 = Node3.leaf(editor, _path5);
      var _before = _node4.text.slice(0, _offset);
      var _after = _node4.text.slice(_offset + _text.length);
      _node4.text = _before + _after;
      if (selection) {
        for (var [_point5, _key5] of Range.points(selection)) {
          selection[_key5] = Point.transform(_point5, op);
        }
      }
      break;
    }
    case "set_node": {
      var {
        path: _path6,
        properties,
        newProperties
      } = op;
      if (_path6.length === 0) {
        throw new Error("Cannot set properties on the root node!");
      }
      var _node5 = Node3.get(editor, _path6);
      for (var _key6 in newProperties) {
        if (_key6 === "children" || _key6 === "text") {
          throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
        }
        var value2 = newProperties[_key6];
        if (value2 == null) {
          delete _node5[_key6];
        } else {
          _node5[_key6] = value2;
        }
      }
      for (var _key7 in properties) {
        if (!newProperties.hasOwnProperty(_key7)) {
          delete _node5[_key7];
        }
      }
      break;
    }
    case "set_selection": {
      var {
        newProperties: _newProperties
      } = op;
      if (_newProperties == null) {
        selection = _newProperties;
      } else {
        if (selection == null) {
          if (!Range.isRange(_newProperties)) {
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
          }
          selection = _objectSpread$3({}, _newProperties);
        }
        for (var _key8 in _newProperties) {
          var _value = _newProperties[_key8];
          if (_value == null) {
            if (_key8 === "anchor" || _key8 === "focus") {
              throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
            }
            delete selection[_key8];
          } else {
            selection[_key8] = _value;
          }
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: _path7,
        position: position2,
        properties: _properties
      } = op;
      if (_path7.length === 0) {
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
      }
      var _node6 = Node3.get(editor, _path7);
      var _parent4 = Node3.parent(editor, _path7);
      var _index4 = _path7[_path7.length - 1];
      var newNode;
      if (Text2.isText(_node6)) {
        var _before2 = _node6.text.slice(0, position2);
        var _after2 = _node6.text.slice(position2);
        _node6.text = _before2;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          text: _after2
        });
      } else {
        var _before3 = _node6.children.slice(0, position2);
        var _after3 = _node6.children.slice(position2);
        _node6.children = _before3;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          children: _after3
        });
      }
      _parent4.children.splice(_index4 + 1, 0, newNode);
      if (selection) {
        for (var [_point6, _key9] of Range.points(selection)) {
          selection[_key9] = Point.transform(_point6, op);
        }
      }
      break;
    }
  }
  return selection;
};
var GeneralTransforms = {
  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = ln(editor.children);
    var selection = editor.selection && ln(editor.selection);
    try {
      selection = applyToDraft(editor, selection, op);
    } finally {
      editor.children = dn(editor.children);
      if (selection) {
        editor.selection = r2(selection) ? dn(selection) : selection;
      } else {
        editor.selection = null;
      }
    }
  }
};
var _excluded = ["text"];
var _excluded2 = ["children"];
function ownKeys$2(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var NodeTransforms = {
  /**
   * Insert nodes at a specific location in the Editor.
   */
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at,
        match: match3,
        select
      } = options;
      if (Node3.isNode(nodes)) {
        nodes = [nodes];
      }
      if (nodes.length === 0) {
        return;
      }
      var [node3] = nodes;
      if (!at) {
        if (editor.selection) {
          at = editor.selection;
        } else if (editor.children.length > 0) {
          at = Editor.end(editor, []);
        } else {
          at = [0];
        }
        select = true;
      }
      if (select == null) {
        select = false;
      }
      if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      }
      if (Point.isPoint(at)) {
        if (match3 == null) {
          if (Text2.isText(node3)) {
            match3 = (n6) => Text2.isText(n6);
          } else if (editor.isInline(node3)) {
            match3 = (n6) => Text2.isText(n6) || Editor.isInline(editor, n6);
          } else {
            match3 = (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
          }
        }
        var [entry] = Editor.nodes(editor, {
          at: at.path,
          match: match3,
          mode,
          voids
        });
        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor.pathRef(editor, _matchPath);
          var isAtEnd = Editor.isEnd(editor, at, _matchPath);
          Transforms.splitNodes(editor, {
            at,
            match: match3,
            mode,
            voids
          });
          var path2 = pathRef.unref();
          at = isAtEnd ? Path.next(path2) : path2;
        } else {
          return;
        }
      }
      var parentPath = Path.parent(at);
      var index2 = at[at.length - 1];
      if (!voids && Editor.void(editor, {
        at: parentPath
      })) {
        return;
      }
      for (var _node of nodes) {
        var _path = parentPath.concat(index2);
        index2++;
        editor.apply({
          type: "insert_node",
          path: _path,
          node: _node
        });
        at = Path.next(at);
      }
      at = Path.previous(at);
      if (select) {
        var point = Editor.end(editor, at);
        if (point) {
          Transforms.select(editor, point);
        }
      }
    });
  },
  /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        at = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match3
      } = options;
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (!at) {
        return;
      }
      var matches = Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p5] = _ref;
        return Editor.pathRef(editor, p5);
      });
      for (var pathRef of pathRefs) {
        var path2 = pathRef.unref();
        if (path2.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path2, "] because it has a depth of less than `2`."));
        }
        var parentNodeEntry = Editor.node(editor, Path.parent(path2));
        var [parent, parentPath] = parentNodeEntry;
        var index2 = path2[path2.length - 1];
        var {
          length: length2
        } = parent.children;
        if (length2 === 1) {
          var toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path2,
            to: toPath,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index2 === 0) {
          Transforms.moveNodes(editor, {
            at: path2,
            to: parentPath,
            voids
          });
        } else if (index2 === length2 - 1) {
          var _toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path2,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path2);
          var _toPath2 = Path.next(parentPath);
          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path2,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },
  /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match: match3,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        if (Path.isPath(at)) {
          var [parent] = Editor.parent(editor, at);
          match3 = (n6) => parent.children.includes(n6);
        } else {
          match3 = (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
        }
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
          if (options.at == null) {
            Transforms.select(editor, at);
          }
        }
      }
      var [current] = Editor.nodes(editor, {
        at,
        match: match3,
        voids,
        mode
      });
      var prev2 = Editor.previous(editor, {
        at,
        match: match3,
        voids,
        mode
      });
      if (!current || !prev2) {
        return;
      }
      var [node3, path2] = current;
      var [prevNode, prevPath] = prev2;
      if (path2.length === 0 || prevPath.length === 0) {
        return;
      }
      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path2, prevPath);
      var isPreviousSibling = Path.isSibling(path2, prevPath);
      var levels2 = Array.from(Editor.levels(editor, {
        at: path2
      }), (_ref2) => {
        var [n6] = _ref2;
        return n6;
      }).slice(commonPath.length).slice(0, -1);
      var emptyAncestor = Editor.above(editor, {
        at: path2,
        mode: "highest",
        match: (n6) => levels2.includes(n6) && hasSingleChildNest(editor, n6)
      });
      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position2;
      if (Text2.isText(node3) && Text2.isText(prevNode)) {
        var rest = _objectWithoutProperties(node3, _excluded);
        position2 = prevNode.text.length;
        properties = rest;
      } else if (Element2.isElement(node3) && Element2.isElement(prevNode)) {
        var rest = _objectWithoutProperties(node3, _excluded2);
        position2 = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path2, "] with the previous sibling because it is not the same kind: ").concat(Scrubber.stringify(node3), " ").concat(Scrubber.stringify(prevNode)));
      }
      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path2,
          to: newPath,
          voids
        });
      }
      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      }
      if (Element2.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text2.isText(prevNode) && prevNode.text === "" && prevPath[prevPath.length - 1] !== 0) {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: "merge_node",
          path: newPath,
          position: position2,
          properties
        });
      }
      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },
  /**
   * Move the nodes at a location to a new location.
   */
  moveNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        to,
        at = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match3
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      var toRef = Editor.pathRef(editor, to);
      var targets = Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, (_ref3) => {
        var [, p5] = _ref3;
        return Editor.pathRef(editor, p5);
      });
      for (var pathRef of pathRefs) {
        var path2 = pathRef.unref();
        var newPath = toRef.current;
        if (path2.length !== 0) {
          editor.apply({
            type: "move_node",
            path: path2,
            newPath
          });
        }
        if (toRef.current && Path.isSibling(newPath, path2) && Path.isAfter(newPath, path2)) {
          toRef.current = Path.next(toRef.current);
        }
      }
      toRef.unref();
    });
  },
  /**
   * Remove the nodes at a specific location in the document.
   */
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at = editor.selection,
        match: match3
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      var depths = Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, (_ref4) => {
        var [, p5] = _ref4;
        return Editor.pathRef(editor, p5);
      });
      for (var pathRef of pathRefs) {
        var path2 = pathRef.unref();
        if (path2) {
          var [node3] = Editor.node(editor, path2);
          editor.apply({
            type: "remove_node",
            path: path2,
            node: node3
          });
        }
      }
    });
  },
  /**
   * Set new properties on the nodes at a location.
   */
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match: match3,
        at = editor.selection,
        compare,
        merge: merge4
      } = options;
      var {
        hanging = false,
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at, {
          voids
        });
      }
      if (split2 && Range.isRange(at)) {
        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {
          return;
        }
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: "inward"
        });
        var [start2, end] = Range.edges(at);
        var splitMode = mode === "lowest" ? "lowest" : "highest";
        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);
        Transforms.splitNodes(editor, {
          at: end,
          match: match3,
          mode: splitMode,
          voids,
          always: !endAtEndOfNode
        });
        var startAtStartOfNode = Editor.isStart(editor, start2, start2.path);
        Transforms.splitNodes(editor, {
          at: start2,
          match: match3,
          mode: splitMode,
          voids,
          always: !startAtStartOfNode
        });
        at = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }
      if (!compare) {
        compare = (prop, nodeProp) => prop !== nodeProp;
      }
      for (var [node3, path2] of Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {};
        if (path2.length === 0) {
          continue;
        }
        var hasChanges = false;
        for (var k2 in props) {
          if (k2 === "children" || k2 === "text") {
            continue;
          }
          if (compare(props[k2], node3[k2])) {
            hasChanges = true;
            if (node3.hasOwnProperty(k2))
              properties[k2] = node3[k2];
            if (merge4) {
              if (props[k2] != null)
                newProperties[k2] = merge4(node3[k2], props[k2]);
            } else {
              if (props[k2] != null)
                newProperties[k2] = props[k2];
            }
          }
        }
        if (hasChanges) {
          editor.apply({
            type: "set_node",
            path: path2,
            properties,
            newProperties
          });
        }
      }
    });
  },
  /**
   * Split the nodes at a specific location.
   */
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match3,
        at = editor.selection,
        height = 0,
        always = false
      } = options;
      if (match3 == null) {
        match3 = (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (Range.isRange(at)) {
        at = deleteRange(editor, at);
      }
      if (Path.isPath(at)) {
        var path2 = at;
        var point = Editor.point(editor, path2);
        var [parent] = Editor.parent(editor, path2);
        match3 = (n6) => n6 === parent;
        height = point.path.length - path2.length + 1;
        at = point;
        always = true;
      }
      if (!at) {
        return;
      }
      var beforeRef = Editor.pointRef(editor, at, {
        affinity: "backward"
      });
      var afterRef;
      try {
        var [highest] = Editor.nodes(editor, {
          at,
          match: match3,
          mode,
          voids
        });
        if (!highest) {
          return;
        }
        var voidMatch = Editor.void(editor, {
          at,
          mode: "highest"
        });
        var nudge = 0;
        if (!voids && voidMatch) {
          var [voidNode, voidPath] = voidMatch;
          if (Element2.isElement(voidNode) && editor.isInline(voidNode)) {
            var after = Editor.after(editor, voidPath);
            if (!after) {
              var text3 = {
                text: ""
              };
              var afterPath = Path.next(voidPath);
              Transforms.insertNodes(editor, text3, {
                at: afterPath,
                voids
              });
              after = Editor.point(editor, afterPath);
            }
            at = after;
            always = true;
          }
          var siblingHeight = at.path.length - voidPath.length;
          height = siblingHeight + 1;
          always = true;
        }
        afterRef = Editor.pointRef(editor, at);
        var depth = at.path.length - height;
        var [, highestPath] = highest;
        var lowestPath = at.path.slice(0, depth);
        var position2 = height === 0 ? at.offset : at.path[depth] + nudge;
        for (var [node3, _path2] of Editor.levels(editor, {
          at: lowestPath,
          reverse: true,
          voids
        })) {
          var split2 = false;
          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element2.isElement(node3) && Editor.isVoid(editor, node3)) {
            break;
          }
          var _point = beforeRef.current;
          var isEnd = Editor.isEnd(editor, _point, _path2);
          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {
            split2 = true;
            var properties = Node3.extractProps(node3);
            editor.apply({
              type: "split_node",
              path: _path2,
              position: position2,
              properties
            });
          }
          position2 = _path2[_path2.length - 1] + (split2 || isEnd ? 1 : 0);
        }
        if (options.at == null) {
          var _point2 = afterRef.current || Editor.end(editor, []);
          Transforms.select(editor, _point2);
        }
      } finally {
        var _afterRef;
        beforeRef.unref();
        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();
      }
    });
  },
  /**
   * Unset properties on the nodes at a location.
   */
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!Array.isArray(props)) {
      props = [props];
    }
    var obj = {};
    for (var key of props) {
      obj[key] = null;
    }
    Transforms.setNodes(editor, obj, options);
  },
  /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */
  unwrapNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        at = editor.selection,
        match: match3
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        match3 = Path.isPath(at) ? matchPath(editor, at) : (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
      }
      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }
      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;
      var matches = Editor.nodes(editor, {
        at,
        match: match3,
        mode,
        voids
      });
      var pathRefs = Array.from(
        matches,
        (_ref5) => {
          var [, p5] = _ref5;
          return Editor.pathRef(editor, p5);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse();
      var _loop = function _loop2(pathRef2) {
        var path2 = pathRef2.unref();
        var [node3] = Editor.node(editor, path2);
        var range = Editor.range(editor, path2);
        if (split2 && rangeRef) {
          range = Range.intersection(rangeRef.current, range);
        }
        Transforms.liftNodes(editor, {
          at: range,
          match: (n6) => Element2.isAncestor(node3) && node3.children.includes(n6),
          voids
        });
      };
      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }
      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },
  /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */
  wrapNodes(editor, element2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        match: match3,
        at = editor.selection
      } = options;
      if (!at) {
        return;
      }
      if (match3 == null) {
        if (Path.isPath(at)) {
          match3 = matchPath(editor, at);
        } else if (editor.isInline(element2)) {
          match3 = (n6) => Element2.isElement(n6) && Editor.isInline(editor, n6) || Text2.isText(n6);
        } else {
          match3 = (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6);
        }
      }
      if (split2 && Range.isRange(at)) {
        var [start2, end] = Range.edges(at);
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: "inward"
        });
        Transforms.splitNodes(editor, {
          at: end,
          match: match3,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start2,
          match: match3,
          voids
        });
        at = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }
      var roots = Array.from(Editor.nodes(editor, {
        at,
        match: editor.isInline(element2) ? (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6) : (n6) => Editor.isEditor(n6),
        mode: "lowest",
        voids
      }));
      for (var [, rootPath] of roots) {
        var a3 = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;
        if (!a3) {
          continue;
        }
        var matches = Array.from(Editor.nodes(editor, {
          at: a3,
          match: match3,
          mode,
          voids
        }));
        if (matches.length > 0) {
          var _ret = function() {
            var [first] = matches;
            var last = matches[matches.length - 1];
            var [, firstPath] = first;
            var [, lastPath] = last;
            if (firstPath.length === 0 && lastPath.length === 0) {
              return "continue";
            }
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range = Editor.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));
            var wrapper = _objectSpread$2(_objectSpread$2({}, element2), {}, {
              children: []
            });
            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range,
              match: (n6) => Element2.isAncestor(commonNode) && commonNode.children.includes(n6),
              to: wrapperPath.concat(0),
              voids
            });
          }();
          if (_ret === "continue")
            continue;
        }
      }
    });
  }
};
var hasSingleChildNest = (editor, node3) => {
  if (Element2.isElement(node3)) {
    var element2 = node3;
    if (Editor.isVoid(editor, node3)) {
      return true;
    } else if (element2.children.length === 1) {
      return hasSingleChildNest(editor, element2.children[0]);
    } else {
      return false;
    }
  } else if (Editor.isEditor(node3)) {
    return false;
  } else {
    return true;
  }
};
var deleteRange = (editor, range) => {
  if (Range.isCollapsed(range)) {
    return range.anchor;
  } else {
    var [, end] = Range.edges(range);
    var pointRef = Editor.pointRef(editor, end);
    Transforms.delete(editor, {
      at: range
    });
    return pointRef.unref();
  }
};
var matchPath = (editor, path2) => {
  var [node3] = Editor.node(editor, path2);
  return (n6) => n6 === node3;
};
function ownKeys$1(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var SelectionTransforms = {
  /**
   * Collapse the selection.
   */
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      edge = "anchor"
    } = options;
    var {
      selection
    } = editor;
    if (!selection) {
      return;
    } else if (edge === "anchor") {
      Transforms.select(editor, selection.anchor);
    } else if (edge === "focus") {
      Transforms.select(editor, selection.focus);
    } else if (edge === "start") {
      var [start2] = Range.edges(selection);
      Transforms.select(editor, start2);
    } else if (edge === "end") {
      var [, end] = Range.edges(selection);
      Transforms.select(editor, end);
    }
  },
  /**
   * Unset the selection.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    if (selection) {
      editor.apply({
        type: "set_selection",
        properties: selection,
        newProperties: null
      });
    }
  },
  /**
   * Move the selection's point forward or backward.
   */
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance = 1,
      unit = "character",
      reverse = false
    } = options;
    var {
      edge = null
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus
    } = selection;
    var opts = {
      distance,
      unit
    };
    var props = {};
    if (edge == null || edge === "anchor") {
      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);
      if (point) {
        props.anchor = point;
      }
    }
    if (edge == null || edge === "focus") {
      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);
      if (_point) {
        props.focus = _point;
      }
    }
    Transforms.setSelection(editor, props);
  },
  /**
   * Set the selection to a new value.
   */
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor.range(editor, target);
    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }
    if (!Range.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Scrubber.stringify(target)));
    }
    editor.apply({
      type: "set_selection",
      properties: selection,
      newProperties: target
    });
  },
  /**
   * Set new properties on one of the selection's points.
   */
  setPoint(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      selection
    } = editor;
    var {
      edge = "both"
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus
    } = selection;
    var point = edge === "anchor" ? anchor : focus;
    Transforms.setSelection(editor, {
      [edge === "anchor" ? "anchor" : "focus"]: _objectSpread$1(_objectSpread$1({}, point), props)
    });
  },
  /**
   * Set new properties on the selection.
   */
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};
    if (!selection) {
      return;
    }
    for (var k2 in props) {
      if (k2 === "anchor" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k2 === "focus" && props.focus != null && !Point.equals(props.focus, selection.focus) || k2 !== "anchor" && k2 !== "focus" && props[k2] !== selection[k2]) {
        oldProps[k2] = selection[k2];
        newProps[k2] = props[k2];
      }
    }
    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: "set_selection",
        properties: oldProps,
        newProperties: newProps
      });
    }
  }
};
var TextTransforms = {
  /**
   * Delete content in the editor.
   */
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        reverse = false,
        unit = "character",
        distance = 1,
        voids = false
      } = options;
      var {
        at = editor.selection,
        hanging = false
      } = options;
      if (!at) {
        return;
      }
      var isCollapsed = false;
      if (Range.isRange(at) && Range.isCollapsed(at)) {
        isCollapsed = true;
        at = at.anchor;
      }
      if (Point.isPoint(at)) {
        var furthestVoid = Editor.void(editor, {
          at,
          mode: "highest"
        });
        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at = voidPath;
        } else {
          var opts = {
            unit,
            distance
          };
          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
          at = {
            anchor: at,
            focus: target
          };
          hanging = true;
        }
      }
      if (Path.isPath(at)) {
        Transforms.removeNodes(editor, {
          at,
          voids
        });
        return;
      }
      if (Range.isCollapsed(at)) {
        return;
      }
      if (!hanging) {
        var [, _end] = Range.edges(at);
        var endOfDoc = Editor.end(editor, []);
        if (!Point.equals(_end, endOfDoc)) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
      }
      var [start2, end] = Range.edges(at);
      var startBlock = Editor.above(editor, {
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
        at: start2,
        voids
      });
      var endBlock = Editor.above(editor, {
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
        at: end,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start2.path, end.path);
      var startVoid = voids ? null : Editor.void(editor, {
        at: start2,
        mode: "highest"
      });
      var endVoid = voids ? null : Editor.void(editor, {
        at: end,
        mode: "highest"
      });
      if (startVoid) {
        var before = Editor.before(editor, start2);
        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
          start2 = before;
        }
      }
      if (endVoid) {
        var after = Editor.after(editor, end);
        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
          end = after;
        }
      }
      var matches = [];
      var lastPath;
      for (var entry of Editor.nodes(editor, {
        at,
        voids
      })) {
        var [node3, path2] = entry;
        if (lastPath && Path.compare(path2, lastPath) === 0) {
          continue;
        }
        if (!voids && Element2.isElement(node3) && Editor.isVoid(editor, node3) || !Path.isCommon(path2, start2.path) && !Path.isCommon(path2, end.path)) {
          matches.push(entry);
          lastPath = path2;
        }
      }
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p5] = _ref;
        return Editor.pathRef(editor, p5);
      });
      var startRef = Editor.pointRef(editor, start2);
      var endRef = Editor.pointRef(editor, end);
      var removedText = "";
      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset
        } = start2;
        var text3 = _node.text.slice(offset);
        if (text3.length > 0) {
          editor.apply({
            type: "remove_text",
            path: _path,
            offset,
            text: text3
          });
          removedText = text3;
        }
      }
      pathRefs.reverse().map((r7) => r7.unref()).filter((r7) => r7 !== null).forEach((p5) => Transforms.removeNodes(editor, {
        at: p5,
        voids
      }));
      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor.leaf(editor, _point2);
        var {
          path: _path2
        } = _point2;
        var _offset = isSingleText ? start2.offset : 0;
        var _text = _node2.text.slice(_offset, end.offset);
        if (_text.length > 0) {
          editor.apply({
            type: "remove_text",
            path: _path2,
            offset: _offset,
            text: _text
          });
          removedText = _text;
        }
      }
      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }
      if (isCollapsed && reverse && unit === "character" && removedText.length > 1 && removedText.match(/[\u0E00-\u0E7F]+/)) {
        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));
      }
      var startUnref = startRef.unref();
      var endUnref = endRef.unref();
      var point = reverse ? startUnref || endUnref : endUnref || startUnref;
      if (options.at == null && point) {
        Transforms.select(editor, point);
      }
    });
  },
  /**
   * Insert a fragment at a specific location in the editor.
   */
  insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;
      if (!fragment.length) {
        return;
      }
      if (!at) {
        return;
      } else if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range.edges(at);
          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      } else if (Path.isPath(at)) {
        at = Editor.start(editor, at);
      }
      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }
      var inlineElementMatch = Editor.above(editor, {
        at,
        match: (n6) => Element2.isElement(n6) && Editor.isInline(editor, n6),
        mode: "highest",
        voids
      });
      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;
        if (Editor.isEnd(editor, at, _inlinePath)) {
          var after = Editor.after(editor, _inlinePath);
          at = after;
        } else if (Editor.isStart(editor, at, _inlinePath)) {
          var before = Editor.before(editor, _inlinePath);
          at = before;
        }
      }
      var blockMatch = Editor.above(editor, {
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
        at,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor.isStart(editor, at, blockPath);
      var isBlockEnd = Editor.isEnd(editor, at, blockPath);
      var isBlockEmpty = isBlockStart && isBlockEnd;
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node3.first({
        children: fragment
      }, []);
      var [, lastPath] = Node3.last({
        children: fragment
      }, []);
      var matches = [];
      var matcher = (_ref2) => {
        var [n6, p5] = _ref2;
        var isRoot = p5.length === 0;
        if (isRoot) {
          return false;
        }
        if (isBlockEmpty) {
          return true;
        }
        if (mergeStart && Path.isAncestor(p5, firstPath) && Element2.isElement(n6) && !editor.isVoid(n6) && !editor.isInline(n6)) {
          return false;
        }
        if (mergeEnd && Path.isAncestor(p5, lastPath) && Element2.isElement(n6) && !editor.isVoid(n6) && !editor.isInline(n6)) {
          return false;
        }
        return true;
      };
      for (var entry of Node3.nodes({
        children: fragment
      }, {
        pass: matcher
      })) {
        if (matcher(entry)) {
          matches.push(entry);
        }
      }
      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;
      for (var [node3] of matches) {
        if (Element2.isElement(node3) && !editor.isInline(node3)) {
          starting = false;
          hasBlocks = true;
          middles.push(node3);
        } else if (starting) {
          starts.push(node3);
        } else {
          ends.push(node3);
        }
      }
      var [inlineMatch] = Editor.nodes(editor, {
        at,
        match: (n6) => Text2.isText(n6) || Editor.isInline(editor, n6),
        mode: "highest",
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor.isStart(editor, at, inlinePath);
      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);
      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.splitNodes(editor, {
        at,
        match: (n6) => hasBlocks ? Element2.isElement(n6) && Editor.isBlock(editor, n6) : Text2.isText(n6) || Editor.isInline(editor, n6),
        mode: hasBlocks ? "lowest" : "highest",
        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),
        voids
      });
      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: (n6) => Text2.isText(n6) || Editor.isInline(editor, n6),
        mode: "highest",
        voids
      });
      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {
        Transforms.delete(editor, {
          at: blockPath,
          voids
        });
      }
      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
        mode: "lowest",
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: (n6) => Text2.isText(n6) || Editor.isInline(editor, n6),
        mode: "highest",
        voids
      });
      if (!options.at) {
        var path2;
        if (ends.length > 0 && endRef.current) {
          path2 = Path.previous(endRef.current);
        } else if (middles.length > 0 && middleRef.current) {
          path2 = Path.previous(middleRef.current);
        } else if (startRef.current) {
          path2 = Path.previous(startRef.current);
        }
        if (path2) {
          var _end2 = Editor.end(editor, path2);
          Transforms.select(editor, _end2);
        }
      }
      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },
  /**
   * Insert a string of text in the Editor.
   */
  insertText(editor, text3) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;
      if (!at) {
        return;
      }
      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }
      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var end = Range.end(at);
          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }
          var start2 = Range.start(at);
          var startRef = Editor.pointRef(editor, start2);
          var endRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at,
            voids
          });
          var startPoint = startRef.unref();
          var endPoint = endRef.unref();
          at = startPoint || endPoint;
          Transforms.setSelection(editor, {
            anchor: at,
            focus: at
          });
        }
      }
      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }
      var {
        path: path2,
        offset
      } = at;
      if (text3.length > 0)
        editor.apply({
          type: "insert_text",
          path: path2,
          offset,
          text: text3
        });
    });
  }
};
function ownKeys(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/split-view/dist/keystar-ui-split-view.esm.js
var import_react38 = __toESM(require_react());
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var SplitViewContext = (0, import_react38.createContext)({
  activity: void 0,
  id: "",
  isCollapsed: void 0
});
var SplitViewProvider = SplitViewContext.Provider;
function useSplitView() {
  return (0, import_react38.useContext)(SplitViewContext);
}
var currentState = null;
var element = null;
function getCursorStyle(state, isReversed) {
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "horizontal-max":
      return isReversed ? "e-resize" : "w-resize";
    case "horizontal-min":
      return isReversed ? "w-resize" : "e-resize";
  }
}
function resetGlobalCursorStyle() {
  if (element !== null) {
    document.head.removeChild(element);
    currentState = null;
    element = null;
  }
}
function setGlobalCursorStyle(state, isReversed) {
  if (currentState === state) {
    return;
  }
  currentState = state;
  const style = getCursorStyle(state, isReversed);
  if (element === null) {
    element = document.createElement("style");
    document.head.appendChild(element);
  }
  element.innerHTML = `*{cursor: ${style}!important;}`;
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name2) => {
        return localStorage.getItem(name2);
      };
      storageObject.setItem = (name2, value2) => {
        localStorage.setItem(name2, value2);
      };
    } else {
      throw new Error("localStorage not supported in this environment");
    }
  } catch (error3) {
    console.error(error3);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
var defaultStorage = {
  getItem: (name2) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name2);
  },
  setItem: (name2, value2) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name2, value2);
  }
};
function getPosition(e6) {
  if (isMouseEvent(e6)) {
    return e6.clientX;
  } else if (isTouchEvent(e6)) {
    return e6.touches[0].clientX;
  }
  return 0;
}
function getPercentage(value2, min, max2) {
  return Math.round((value2 - min) / (max2 - min) * 100);
}
function getPrimaryPaneId(id) {
  return `primary-pane-${id}`;
}
function getSecondaryPaneId(id) {
  return `secondary-pane-${id}`;
}
function getResizeHandleId(id) {
  return `resize-handle-${id}`;
}
function getPrimaryPane(id) {
  return document.getElementById(getPrimaryPaneId(id));
}
function getSecondaryPane(id) {
  return document.getElementById(getSecondaryPaneId(id));
}
function getResizeHandle(id) {
  return document.getElementById(getResizeHandleId(id));
}
function px(value2) {
  return `${value2}px`;
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
var MAX_WIDTH_PROP = "--primary-pane-max-width";
var MAX_WIDTH_VAR = `var(${MAX_WIDTH_PROP})`;
var MIN_WIDTH_PROP = "--primary-pane-min-width";
var MIN_WIDTH_VAR = `var(${MIN_WIDTH_PROP})`;
var WIDTH_PROP = "--primary-pane-width";
var WIDTH_VAR = `var(${WIDTH_PROP})`;
var SNAP_REGION_PX = 32;
var KEYBOARD_ARROW_STEPS = 10;
function SplitView(props) {
  let {
    autoSaveId,
    children,
    defaultSize,
    isCollapsed,
    minSize,
    maxSize,
    onCollapseChange,
    onResize,
    storage = defaultStorage
  } = props;
  const [startPane, endPane] = children;
  const getIsMounted = useIsMounted();
  const id = useId(props.id);
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const styleProps = useStyleProps(props);
  const [isReversed, setReversed] = (0, import_react38.useState)(false);
  const [isDragging, setDragging] = (0, import_react38.useState)(false);
  const [handleIsFocused, setHandleFocus] = (0, import_react38.useState)(false);
  const [size3, setSize] = (0, import_react38.useState)(() => {
    let size4 = defaultSize;
    if (autoSaveId) {
      let savedSize = storage.getItem(autoSaveId);
      if (savedSize) {
        size4 = Number.parseInt(savedSize);
      }
    }
    return size4;
  });
  const wrapperRef = (0, import_react38.useRef)(null);
  const offsetRef = (0, import_react38.useRef)(0);
  const moveRef = (0, import_react38.useRef)(0);
  (0, import_react38.useEffect)(() => {
    const resizeHandle = getResizeHandle(id);
    const primaryPane = getPrimaryPane(id);
    const secondaryPane = getSecondaryPane(id);
    setReversed(direction === "rtl" ? (resizeHandle === null || resizeHandle === void 0 ? void 0 : resizeHandle.previousElementSibling) === primaryPane : (resizeHandle === null || resizeHandle === void 0 ? void 0 : resizeHandle.previousElementSibling) === secondaryPane);
  }, [direction, id]);
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => onResize === null || onResize === void 0 ? void 0 : onResize(size3), [size3]);
  (0, import_react38.useEffect)(() => {
    var _wrapperRef$current;
    (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 || _wrapperRef$current.style.setProperty(WIDTH_PROP, px(size3));
    moveRef.current = size3;
    if (autoSaveId) {
      storage.setItem(autoSaveId, px(size3));
    }
  }, [autoSaveId, onResize, size3, storage]);
  (0, import_react38.useEffect)(() => {
    const wrapper = wrapperRef.current;
    const resizeHandle = getResizeHandle(id);
    const primaryPane = getPrimaryPane(id);
    if (!wrapper || !resizeHandle || !primaryPane) {
      return;
    }
    let collapseRequested = false;
    let collapseAllowed = typeof isCollapsed === "boolean";
    const onMove = (e6) => {
      e6.preventDefault();
      let delta = getPosition(e6) - offsetRef.current;
      if (isReversed)
        delta = delta * -1;
      let nextWidth = size3 + delta;
      if (Math.abs(nextWidth - defaultSize) < SNAP_REGION_PX / 2) {
        nextWidth = defaultSize;
      }
      if (collapseAllowed) {
        collapseRequested = nextWidth <= minSize / 2;
      }
      if (collapseRequested) {
        primaryPane.style.setProperty("width", "0px");
        moveRef.current = size3;
      } else {
        moveRef.current = nextWidth;
        primaryPane.style.removeProperty("width");
      }
      wrapper.style.setProperty(WIDTH_PROP, px(moveRef.current));
      let cursorStyle = "horizontal";
      if (moveRef.current < minSize) {
        cursorStyle = "horizontal-min";
      }
      if (moveRef.current > maxSize) {
        cursorStyle = "horizontal-max";
      }
      setGlobalCursorStyle(cursorStyle, isReversed);
    };
    const stopDragging = () => {
      resizeHandle.blur();
      setDragging(false);
      resetGlobalCursorStyle();
      if (collapseRequested) {
        onCollapseChange === null || onCollapseChange === void 0 || onCollapseChange(!isCollapsed);
        primaryPane.style.removeProperty("width");
      } else {
        setSize($9446cca9a3875146$export$7d15b64cf5a3a4c4(moveRef.current, minSize, maxSize));
      }
      collapseRequested = false;
      document.body.removeEventListener("mousemove", onMove);
      document.body.removeEventListener("touchmove", onMove);
      window.removeEventListener("mouseup", stopDragging);
      window.removeEventListener("touchend", stopDragging);
    };
    const startDragging = (e6) => {
      if ("button" in e6 && e6.button !== 0) {
        return;
      }
      if ("touches" in e6 && e6.touches.length !== 1) {
        return;
      }
      setDragging(true);
      offsetRef.current = getPosition(e6);
      document.body.addEventListener("mousemove", onMove);
      document.body.addEventListener("touchmove", onMove);
      window.addEventListener("mouseup", stopDragging);
      window.addEventListener("touchend", stopDragging);
    };
    const onKeyDown = (e6) => {
      if (e6.defaultPrevented) {
        return;
      }
      let step = Math.round((maxSize - minSize) / KEYBOARD_ARROW_STEPS);
      let increment2 = () => setSize((size4) => Math.min(size4 + step, maxSize));
      let decrement = () => setSize((size4) => Math.max(size4 - step, minSize));
      switch (e6.key) {
        case "Enter":
          if (collapseAllowed) {
            e6.preventDefault();
            onCollapseChange === null || onCollapseChange === void 0 || onCollapseChange(!isCollapsed);
          }
          break;
        case "Home":
          e6.preventDefault();
          setSize(minSize);
          break;
        case "End":
          e6.preventDefault();
          setSize(maxSize);
          break;
        case "ArrowLeft":
          e6.preventDefault();
          if (isReversed) {
            increment2();
          } else {
            decrement();
          }
          break;
        case "ArrowRight":
          e6.preventDefault();
          if (isReversed) {
            decrement();
          } else {
            increment2();
          }
      }
    };
    let options = {
      passive: true
    };
    let onDoubleClick = (e6) => {
      if (e6.clientX === offsetRef.current) {
        setSize(defaultSize);
      }
    };
    resizeHandle.addEventListener("contextmenu", stopDragging);
    resizeHandle.addEventListener("dblclick", onDoubleClick);
    resizeHandle.addEventListener("keydown", onKeyDown);
    resizeHandle.addEventListener("mousedown", startDragging, options);
    resizeHandle.addEventListener("touchstart", startDragging, options);
    return () => {
      resizeHandle.removeEventListener("contextmenu", stopDragging);
      resizeHandle.removeEventListener("dblclick", onDoubleClick);
      resizeHandle.removeEventListener("keydown", onKeyDown);
      resizeHandle.removeEventListener("mousedown", startDragging);
      resizeHandle.removeEventListener("touchstart", startDragging);
    };
  }, [maxSize, minSize, defaultSize, id, isReversed, size3, onCollapseChange, isCollapsed]);
  return (0, import_jsx_runtime19.jsx)(SplitViewProvider, {
    value: {
      id,
      isCollapsed,
      activity: !getIsMounted() ? "initializing" : isDragging ? "pointer" : handleIsFocused ? "keyboard" : void 0
    },
    children: (0, import_jsx_runtime19.jsxs)("div", {
      ...styleProps,
      ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
      ref: wrapperRef,
      className: classNames(css({
        display: "flex",
        height: "100%",
        width: "100%",
        overflow: "hidden",
        [MIN_WIDTH_PROP]: px(minSize),
        [MAX_WIDTH_PROP]: px(maxSize),
        [WIDTH_PROP]: px(defaultSize)
      }), styleProps.className),
      children: [startPane, (0, import_jsx_runtime19.jsx)(SplitViewResizeHandle, {
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": getPercentage(size3, minSize, maxSize),
        onBlur: () => setHandleFocus(false),
        onFocus: () => setHandleFocus(true)
      }), endPane]
    })
  });
}
var SplitPanePrimary = (0, import_react38.forwardRef)(function SplitPanePrimary2(props, forwardedRef) {
  let {
    activity,
    id,
    isCollapsed
  } = useSplitView();
  let styleProps = useStyleProps(props);
  return (0, import_jsx_runtime19.jsx)("div", {
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ref: forwardedRef,
    id: getPrimaryPaneId(id),
    "data-split-pane": "primary",
    "data-split-view-activity": activity,
    "data-split-view-collapsed": isCollapsed || void 0,
    className: classNames(css({
      containerType: "inline-size",
      overflow: "hidden",
      width: `clamp(${MIN_WIDTH_VAR},${WIDTH_VAR},${MAX_WIDTH_VAR})`,
      // prevent the secondary pane from collapsing completely, regardless of
      // consumer preference. losing the drag handle is a bad experience.
      maxWidth: `calc(100% - 100px)`,
      // hide when collapsed
      "&[data-split-view-collapsed]": {
        visibility: "hidden",
        width: 0
      },
      // support transition when not dragging
      "&:not([data-split-view-activity])": {
        transition: transition("width")
      },
      // disable interactive elements during drag
      "&[data-split-view-activity=pointer]": {
        pointerEvents: "none"
      }
    }), styleProps.className),
    children: props.children
  });
});
var SplitPaneSecondary = (0, import_react38.forwardRef)(function SplitPaneSecondary2(props, forwardedRef) {
  let {
    id,
    activity
  } = useSplitView();
  let styleProps = useStyleProps(props);
  return (0, import_jsx_runtime19.jsx)("div", {
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ref: forwardedRef,
    id: getSecondaryPaneId(id),
    "data-split-pane": "secondary",
    "data-split-view-activity": activity,
    className: classNames(css({
      containerType: "inline-size",
      flex: `1 1 0`,
      // prevent the secondary pane from collapsing completely, regardless of
      // consumer preference. losing the drag handle is a bad experience.
      minWidth: `100px`,
      overflow: "hidden",
      // disable interactive elements during drag
      "&[data-split-view-activity=pointer]": {
        pointerEvents: "none"
      }
    }), styleProps.className),
    children: props.children
  });
});
var SplitViewResizeHandle = (0, import_react38.forwardRef)(function SplitViewResizeHandle2(props, forwardedRef) {
  let {
    activity,
    id,
    isCollapsed
  } = useSplitView();
  return (0, import_jsx_runtime19.jsx)("div", {
    ...props,
    ref: forwardedRef,
    "aria-controls": getPrimaryPaneId(id),
    "aria-label": "Resize",
    "aria-orientation": "vertical",
    id: getResizeHandleId(id),
    role: "separator",
    tabIndex: 0,
    "data-split-view-resize-handle": true,
    "data-split-view-activity": activity,
    "data-split-view-collapsed": isCollapsed || void 0,
    className: css({
      backgroundColor: tokenSchema.color.border.muted,
      boxSizing: "border-box",
      cursor: "ew-resize",
      flexShrink: 0,
      outline: 0,
      position: "relative",
      touchAction: "none",
      transition: transition("background-color"),
      userSelect: "none",
      width: tokenSchema.size.border.regular,
      zIndex: 1,
      // hide visually when collapsed. still allow keyboard focus
      "&[data-split-view-collapsed]:not([data-split-view-activity])": visuallyHiddenStyles,
      // increase hit area
      "&::before": {
        content: '""',
        position: "absolute",
        inset: `calc(${tokenSchema.size.space.small} * -1)`
      },
      // drag indicator
      "&::after": {
        backgroundColor: tokenSchema.color.alias.backgroundHovered,
        content: '""',
        insetBlock: 0,
        insetInline: `calc(${tokenSchema.size.border.medium} * -1)`,
        opacity: 0,
        position: "absolute",
        transition: transition("opacity")
      },
      // delay transition to avoid unexpected flicker, the user may just be
      // mousing between panes; this way we ensure intent
      "&:hover": {
        backgroundColor: tokenSchema.color.border.neutral,
        transitionDelay: tokenSchema.animation.duration.regular,
        "&::after": {
          opacity: 1,
          transitionDelay: tokenSchema.animation.duration.regular
        }
      },
      "&[data-split-view-activity=pointer]::after, &[data-split-view-activity=keyboard]::after": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        insetInline: `calc(${tokenSchema.size.border.regular} * -1)`,
        opacity: 1
      }
    })
  });
});
var visuallyHiddenStyles = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/dialog/dist/keystar-ui-dialog.esm.js
var import_react40 = __toESM(require_react());

// node_modules/.pnpm/@react-aria+dialog@3.5.8_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/dialog/dist/import.mjs
var import_react39 = __toESM(require_react(), 1);
function $40df3f8667284809$export$d55e7ee900f34e93(props, ref) {
  let { role = "dialog" } = props;
  let titleId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  titleId = props["aria-label"] ? void 0 : titleId;
  let isRefocusing = (0, import_react39.useRef)(false);
  (0, import_react39.useEffect)(() => {
    if (ref.current && !ref.current.contains(document.activeElement)) {
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
      let timeout2 = setTimeout(() => {
        if (document.activeElement === ref.current) {
          isRefocusing.current = true;
          ref.current.blur();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
          isRefocusing.current = false;
        }
      }, 500);
      return () => {
        clearTimeout(timeout2);
      };
    }
  }, [
    ref
  ]);
  (0, $337b884510726a0d$export$14c98a7594375490)();
  return {
    dialogProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
        labelable: true
      }),
      role,
      tabIndex: -1,
      "aria-labelledby": props["aria-labelledby"] || titleId,
      // Prevent blur events from reaching useOverlay, which may cause
      // popovers to close. Since focus is contained within the dialog,
      // we don't want this to occur due to the above useEffect.
      onBlur: (e6) => {
        if (isRefocusing.current)
          e6.stopPropagation();
      }
    },
    titleProps: {
      id: titleId
    }
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/dialog/dist/keystar-ui-dialog.esm.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var DialogContext = import_react40.default.createContext(null);
var localizedMessages3 = {
  "ar-AE": {
    alert: "تنبيه",
    dismiss: "تجاهل"
  },
  "bg-BG": {
    alert: "Сигнал",
    dismiss: "Отхвърляне"
  },
  "cs-CZ": {
    alert: "Výstraha",
    dismiss: "Odstranit"
  },
  "da-DK": {
    alert: "Advarsel",
    dismiss: "Luk"
  },
  "de-DE": {
    alert: "Warnhinweis",
    dismiss: "Schließen"
  },
  "el-GR": {
    alert: "Ειδοποίηση",
    dismiss: "Απόρριψη"
  },
  "en-US": {
    alert: "Alert",
    dismiss: "Dismiss"
  },
  "es-ES": {
    alert: "Alerta",
    dismiss: "Descartar"
  },
  "et-EE": {
    alert: "Teade",
    dismiss: "Lõpeta"
  },
  "fi-FI": {
    alert: "Hälytys",
    dismiss: "Hylkää"
  },
  "fr-FR": {
    alert: "Alerte",
    dismiss: "Rejeter"
  },
  "he-IL": {
    alert: "התראה",
    dismiss: "התעלם"
  },
  "hr-HR": {
    alert: "Upozorenje",
    dismiss: "Odbaci"
  },
  "hu-HU": {
    alert: "Figyelmeztetés",
    dismiss: "Elutasítás"
  },
  "it-IT": {
    alert: "Avviso",
    dismiss: "Ignora"
  },
  "ja-JP": {
    alert: "アラート",
    dismiss: "閉じる"
  },
  "ko-KR": {
    alert: "경고",
    dismiss: "무시"
  },
  "lt-LT": {
    alert: "Įspėjimas",
    dismiss: "Atmesti"
  },
  "lv-LV": {
    alert: "Brīdinājums",
    dismiss: "Nerādīt"
  },
  "nb-NO": {
    alert: "Varsel",
    dismiss: "Lukk"
  },
  "nl-NL": {
    alert: "Melding",
    dismiss: "Negeren"
  },
  "pl-PL": {
    alert: "Ostrzeżenie",
    dismiss: "Zignoruj"
  },
  "pt-BR": {
    alert: "Alerta",
    dismiss: "Descartar"
  },
  "pt-PT": {
    alert: "Alerta",
    dismiss: "Dispensar"
  },
  "ro-RO": {
    alert: "Alertă",
    dismiss: "Revocare"
  },
  "ru-RU": {
    alert: "Предупреждение",
    dismiss: "Пропустить"
  },
  "sk-SK": {
    alert: "Upozornenie",
    dismiss: "Zrušiť"
  },
  "sl-SI": {
    alert: "Opozorilo",
    dismiss: "Opusti"
  },
  "sr-SP": {
    alert: "Upozorenje",
    dismiss: "Odbaci"
  },
  "sv-SE": {
    alert: "Varning",
    dismiss: "Avvisa"
  },
  "tr-TR": {
    alert: "Uyarı",
    dismiss: "Kapat"
  },
  "uk-UA": {
    alert: "Сигнал тривоги",
    dismiss: "Скасувати"
  },
  "zh-CN": {
    alert: "警报",
    dismiss: "取消"
  },
  "zh-T": {
    alert: "警示",
    dismiss: "關閉"
  }
};
var dialogClassList = new ClassList("Dialog", ["root", "grid", "heading", "header", "footer", "button-group"]);
var Dialog = (0, import_react40.forwardRef)(function Dialog2(props, forwardedRef) {
  let {
    type: type2 = "modal",
    ...contextProps
  } = (0, import_react40.useContext)(DialogContext) || {};
  let {
    children,
    isDismissable = contextProps.isDismissable,
    onDismiss = contextProps.onClose,
    size: size3
  } = props;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages3);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let gridRef = (0, import_react40.useRef)(null);
  let {
    dialogProps,
    titleProps
  } = $40df3f8667284809$export$d55e7ee900f34e93($3ef42575df84b30b$export$9d1611c77c2fe928(contextProps, props), domRef);
  const headingSize = "regular";
  let hasHeading = useHasChild(dialogClassList.selector("heading"), gridRef);
  let hasHeader = useHasChild(dialogClassList.selector("header"), gridRef);
  let hasFooter = useHasChild(dialogClassList.selector("footer"), gridRef);
  let hasButtonGroup = useHasChild(dialogClassList.selector("button-group"), gridRef);
  let slots = (0, import_react40.useMemo)(() => ({
    heading: {
      ...toDataAttributes({
        hasHeader
      }),
      UNSAFE_className: classNames(dialogClassList.element("heading"), getHeadingStyles()),
      elementType: "h2",
      size: headingSize,
      // FIXME: declared as const—shouldn't need this weirdness.
      ...titleProps
    },
    header: {
      // ...toDataAttributes({ hasHeading }),
      UNSAFE_className: classNames(dialogClassList.element("header"), getHeaderStyles())
    },
    content: {
      ...toDataAttributes({
        hasHeader: hasHeader || hasHeading || void 0,
        hasFooter: hasFooter || hasButtonGroup && type2 !== "fullscreen" || void 0
      }),
      UNSAFE_className: getContentStyles()
    },
    footer: {
      UNSAFE_className: classNames(dialogClassList.element("footer"), getFooterStyles())
    },
    buttonGroup: {
      ...toDataAttributes({
        hasFooter
      }),
      UNSAFE_className: classNames(dialogClassList.element("button-group"), getButtonGroupStyles()),
      align: "end"
    }
  }), [hasButtonGroup, hasFooter, hasHeader, hasHeading, headingSize, titleProps, type2]);
  const sizeVariant = getSizeVariant(type2, size3);
  const dialogStyleProps = useDialogStyleProps(props, sizeVariant);
  const gridStyleProps2 = useGridStyleProps2({
    isDismissable,
    size: sizeVariant
  });
  return (0, import_jsx_runtime20.jsx)("section", {
    ...dialogStyleProps,
    ...dialogProps,
    ref: domRef,
    children: (0, import_jsx_runtime20.jsxs)(Grid, {
      ref: gridRef,
      ...gridStyleProps2,
      children: [(0, import_jsx_runtime20.jsx)(SlotProvider, {
        slots,
        children
      }), isDismissable && (0, import_jsx_runtime20.jsx)(ActionButton, {
        prominence: "low",
        "aria-label": stringFormatter.format("dismiss"),
        onPress: onDismiss,
        gridArea: "closeButton",
        UNSAFE_className: css({
          placeSelf: "flex-start end",
          paddingInline: 0,
          marginBlock: `calc((${tokenSchema.size.element.regular} - ${tokenSchema.typography.heading[headingSize].capheight}) / 2 * -1)`,
          marginInlineEnd: `calc(${tokenSchema.size.space.medium} * -1)`,
          marginInlineStart: tokenSchema.size.space.regular
        }),
        children: (0, import_jsx_runtime20.jsx)(Icon, {
          src: xIcon,
          size: "medium"
        })
      })]
    })
  });
});
function getSizeVariant(type2, size3) {
  if (type2 === "fullscreen") {
    return "fullscreen";
  }
  if (type2 === "popover") {
    return size3 || "xsmall";
  }
  return size3 || "medium";
}
function useDialogStyleProps(props, sizeVariant) {
  let styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      size: sizeVariant
    }),
    ...styleProps,
    className: classNames(dialogClassList.element("root"), css({
      display: "flex",
      maxHeight: "inherit",
      maxWidth: "100%",
      outline: 0,
      width: "var(--dialog-width)",
      "--dialog-width": "fit-content",
      '&[data-size="xsmall"]': {
        "--dialog-width": tokenSchema.size.dialog.xsmall
      },
      '&[data-size="small"]': {
        "--dialog-width": tokenSchema.size.dialog.small
      },
      '&[data-size="medium"]': {
        "--dialog-width": tokenSchema.size.dialog.medium
      },
      '&[data-size="large"]': {
        "--dialog-width": tokenSchema.size.dialog.large
      },
      '&[data-size="fullscreen"]': {
        maxHeight: "none",
        maxWidth: "none",
        height: "100%",
        "--dialog-width": "100%"
      }
    }), styleProps.className)
  };
}
function useGridStyleProps2({
  isDismissable,
  size: size3
}) {
  let gridStyles = css({
    display: "grid",
    padding: tokenSchema.size.space.xxlarge,
    gridTemplateColumns: "auto 1fr auto",
    gridTemplateRows: "auto 1fr auto",
    gridTemplateAreas: `"heading header header"
      "content content content"
      "footer footer buttonGroup"`,
    width: "100%",
    "&[data-dismissable]": {
      gridTemplateColumns: "auto 1fr auto minmax(0, auto)",
      gridTemplateAreas: `"heading header header closeButton"
        "content content content content"
        "footer footer footer footer"`,
      // slot styles
      [dialogClassList.selector("button-group")]: {
        display: "none"
      }
    },
    // MOBILE SPECIFIC
    [breakpointQueries$1.below.tablet]: {
      padding: tokenSchema.size.space.xlarge,
      gridTemplateRows: "auto auto 1fr auto",
      gridTemplateAreas: `"heading heading heading"
      "header header header"
        "content content content"
        "footer footer buttonGroup"`,
      "&[data-dismissable]": {
        gridTemplateAreas: `"heading heading closeButton"
          "header header header"
            "content content content"
            "footer footer buttonGroup"`
      }
    },
    // TABLET & ABOVE
    [breakpointQueries$1.above.mobile]: {
      '&[data-size="fullscreen"]': {
        gridTemplateAreas: `"heading header buttonGroup"
          "content content content"
          "footer footer footer"`
      }
    }
  });
  return {
    ...toDataAttributes({
      dismissable: isDismissable || void 0,
      size: size3
    }),
    UNSAFE_className: classNames(dialogClassList.element("grid"), gridStyles)
  };
}
function getHeadingStyles() {
  return css({
    alignSelf: "center",
    gridArea: "heading",
    paddingBottom: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingBottom: tokenSchema.size.space.xlarge
    },
    "&[data-has-header=false]": {
      gridArea: "heading-start / heading-start / header-end / header-end"
    }
  });
}
function getHeaderStyles() {
  return css({
    alignItems: "center",
    boxSizing: "border-box",
    display: "flex",
    gridArea: "header",
    minWidth: "fit-content",
    outline: 0,
    paddingBottom: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      justifyContent: "flex-end",
      paddingBottom: tokenSchema.size.space.xlarge
    }
  });
}
function getContentStyles() {
  return css({
    gridArea: "content",
    overflowX: "hidden",
    overflowY: "auto",
    WebkitOverflowScrolling: "touch",
    // fixes two issues:
    // - focus rings get clipped by overflow: auto
    // - trimmed text (capsize) creates unwanted scrollbars
    padding: tokenSchema.size.space.regular,
    margin: `calc(${tokenSchema.size.space.regular} * -1)`
  });
}
function getButtonGroupStyles() {
  return css({
    gridArea: "buttonGroup",
    minWidth: 0,
    marginInlineStart: tokenSchema.size.space.regular,
    paddingTop: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingTop: tokenSchema.size.space.xlarge
    },
    [`${dialogClassList.selector("root")}:not([data-size=fullscreen]) &[data-has-footer=false]`]: {
      gridArea: "footer-start / footer-start / buttonGroup-end / buttonGroup-end"
    },
    // correct consumer error; hide the button group when the dialog is dismissable
    [`${dialogClassList.selector("root")}[data-dismissable] &`]: {
      display: "none"
    }
  });
}
function getFooterStyles() {
  return css({
    alignItems: "center",
    display: "flex",
    flexWrap: "wrap",
    gridArea: "footer",
    minWidth: 0,
    paddingTop: tokenSchema.size.space.large,
    [breakpointQueries$1.above.mobile]: {
      paddingTop: tokenSchema.size.space.xlarge
    }
  });
}
var AlertDialog = (0, import_react40.forwardRef)(function AlertDialog2(props, forwardedRef) {
  let {
    onClose = () => {
    }
  } = (0, import_react40.useContext)(DialogContext) || {};
  let {
    autoFocusButton,
    cancelLabel,
    children,
    isPrimaryActionDisabled,
    isSecondaryActionDisabled,
    onCancel = () => {
    },
    onPrimaryAction = () => {
    },
    onSecondaryAction = () => {
    },
    primaryActionLabel,
    secondaryActionLabel,
    title,
    tone,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime20.jsxs)(Dialog, {
    role: "alertdialog",
    ref: forwardedRef,
    size: "small",
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    children: [(0, import_jsx_runtime20.jsx)(Heading, {
      children: title
    }), (0, import_jsx_runtime20.jsx)(Content, {
      children: isReactText(children) ? (0, import_jsx_runtime20.jsx)(Text, {
        children
      }) : children
    }), (0, import_jsx_runtime20.jsxs)(ButtonGroup, {
      align: "end",
      children: [cancelLabel && (0, import_jsx_runtime20.jsx)(Button, {
        onPress: () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onCancel()),
        autoFocus: autoFocusButton === "cancel",
        prominence: secondaryActionLabel ? "low" : void 0,
        children: cancelLabel
      }), secondaryActionLabel && (0, import_jsx_runtime20.jsx)(Button, {
        onPress: () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onSecondaryAction()),
        autoFocus: autoFocusButton === "secondary",
        isDisabled: isSecondaryActionDisabled,
        children: secondaryActionLabel
      }), (0, import_jsx_runtime20.jsx)(Button, {
        prominence: "high",
        tone,
        onPress: () => $ff5963eb1fccf552$export$e08e3b67e392101e(onClose(), onPrimaryAction()),
        isDisabled: isPrimaryActionDisabled,
        autoFocus: autoFocusButton === "primary",
        children: primaryActionLabel
      })]
    })]
  });
});
function DialogContainer(props) {
  let {
    children,
    type: type2 = "modal",
    onDismiss,
    isDismissable,
    isKeyboardDismissDisabled
  } = props;
  let childArray = import_react40.default.Children.toArray(children);
  if (childArray.length > 1) {
    throw new Error("Only a single child can be passed to DialogContainer.");
  }
  let lastChild = (0, import_react40.useRef)(null);
  let child = import_react40.default.isValidElement(childArray[0]) ? childArray[0] : null;
  if (child) {
    lastChild.current = child;
  }
  let context = {
    type: type2,
    onClose: onDismiss,
    isDismissable
  };
  let state = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: !!child,
    onOpenChange: (isOpen) => {
      if (!isOpen) {
        onDismiss();
      }
    }
  });
  return (0, import_jsx_runtime20.jsx)(Modal, {
    state,
    type: type2,
    isDismissable,
    isKeyboardDismissDisabled,
    children: (0, import_jsx_runtime20.jsx)(DialogContext.Provider, {
      value: context,
      children: lastChild.current
    })
  });
}
function useDialogContainer() {
  const context = (0, import_react40.useContext)(DialogContext);
  assert(!!context, "Cannot call `useDialogContext` outside of `<DialogTrigger>` or `<DialogContainer>`.");
  return {
    type: context.type,
    dismiss() {
      context.onClose();
    }
  };
}
function DialogTrigger(props) {
  let {
    children,
    type: type2 = "modal",
    mobileType = type2 === "popover" ? "modal" : type2,
    hideArrow,
    targetRef,
    isDismissable,
    isKeyboardDismissDisabled,
    ...positionProps
  } = props;
  if (!Array.isArray(children) || children.length > 2) {
    throw new Error("DialogTrigger must have exactly 2 children");
  }
  let [trigger2, content] = children;
  let isMobile = useMediaQuery(breakpointQueries$1.below.tablet);
  if (isMobile) {
    if (type2 !== "modal" && mobileType === "modal") {
      isDismissable = true;
    }
    type2 = mobileType;
  }
  let state = $fc909762b330b746$export$61c6a8c84e605fb6(props);
  let wasOpen = (0, import_react40.useRef)(false);
  wasOpen.current = state.isOpen;
  let isExiting = (0, import_react40.useRef)(false);
  let onExiting = () => isExiting.current = true;
  let onExited = () => isExiting.current = false;
  (0, import_react40.useEffect)(() => {
    return () => {
      if ((wasOpen.current || isExiting.current) && type2 !== "popover" && type2 !== "tray") {
        console.warn("A DialogTrigger unmounted while open. This is likely due to being placed within a trigger that unmounts or inside a conditional. Consider using a DialogContainer instead.");
      }
    };
  }, []);
  if (type2 === "popover") {
    return (0, import_jsx_runtime20.jsx)(PopoverTrigger, {
      ...positionProps,
      state,
      targetRef,
      trigger: trigger2,
      content,
      isKeyboardDismissDisabled,
      hideArrow
    });
  }
  let renderOverlay = () => {
    switch (type2) {
      case "fullscreen":
      case "modal":
        return (0, import_jsx_runtime20.jsx)(Modal, {
          state,
          isDismissable: type2 === "modal" ? isDismissable : false,
          type: type2,
          isKeyboardDismissDisabled,
          onExiting,
          onExited,
          children: typeof content === "function" ? content(state.close) : content
        });
      case "tray":
        return (0, import_jsx_runtime20.jsx)(Tray, {
          state,
          isKeyboardDismissDisabled,
          children: typeof content === "function" ? content(state.close) : content
        });
    }
    assertNever(type2);
  };
  return (0, import_jsx_runtime20.jsx)(DialogTriggerBase, {
    type: type2,
    state,
    isDismissable,
    trigger: trigger2,
    overlay: renderOverlay()
  });
}
DialogTrigger.getCollectionNode = function* (props) {
  let [trigger2] = import_react40.Children.toArray(props.children);
  let [, content] = props.children;
  yield {
    element: trigger2,
    wrapper: (element2) => (0, import_jsx_runtime20.jsxs)(DialogTrigger, {
      ...props,
      children: [element2, content]
    }, element2.key)
  };
};
var _DialogTrigger = DialogTrigger;
function PopoverTrigger({
  state,
  targetRef,
  trigger: trigger2,
  content,
  hideArrow,
  ...props
}) {
  let triggerRef = (0, import_react40.useRef)(null);
  let {
    triggerProps,
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d({
    type: "dialog"
  }, state, triggerRef);
  let triggerPropsWithRef = {
    ...triggerProps,
    ref: targetRef ? void 0 : triggerRef
  };
  let overlay = (0, import_jsx_runtime20.jsx)(Popover, {
    ...props,
    hideArrow,
    triggerRef: targetRef || triggerRef,
    state,
    children: typeof content === "function" ? content(state.close) : content
  });
  return (0, import_jsx_runtime20.jsx)(DialogTriggerBase, {
    type: "popover",
    state,
    triggerProps: triggerPropsWithRef,
    dialogProps: overlayProps,
    trigger: trigger2,
    overlay
  });
}
function DialogTriggerBase({
  type: type2,
  state,
  isDismissable,
  dialogProps = {},
  triggerProps = {},
  overlay,
  trigger: trigger2
}) {
  let context = {
    type: type2,
    onClose: state.close,
    isDismissable,
    ...dialogProps
  };
  return (0, import_jsx_runtime20.jsxs)(import_react40.Fragment, {
    children: [(0, import_jsx_runtime20.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(triggerProps, {
        onPress: state.open
      }),
      isPressed: state.isOpen && type2 !== "modal" && type2 !== "fullscreen",
      children: trigger2
    }), (0, import_jsx_runtime20.jsx)(DialogContext.Provider, {
      value: context,
      children: overlay
    })]
  });
}

// node_modules/.pnpm/@react-aria+dnd@3.5.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/dnd/dist/import.mjs
var import_react41 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+live-announcer@3.3.1/node_modules/@react-aria/live-announcer/dist/import.mjs
var $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY = 7e3;
var $319e236875307eab$var$liveAnnouncer = null;
function $319e236875307eab$export$a9b970dcc4ae71a9(message, assertiveness = "assertive", timeout2 = $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY) {
  if (!$319e236875307eab$var$liveAnnouncer)
    $319e236875307eab$var$liveAnnouncer = new $319e236875307eab$var$LiveAnnouncer();
  $319e236875307eab$var$liveAnnouncer.announce(message, assertiveness, timeout2);
}
function $319e236875307eab$export$d10ae4f68404609a(assertiveness) {
  if ($319e236875307eab$var$liveAnnouncer)
    $319e236875307eab$var$liveAnnouncer.clear(assertiveness);
}
var $319e236875307eab$var$LiveAnnouncer = class {
  createLog(ariaLive) {
    let node3 = document.createElement("div");
    node3.setAttribute("role", "log");
    node3.setAttribute("aria-live", ariaLive);
    node3.setAttribute("aria-relevant", "additions");
    return node3;
  }
  destroy() {
    if (!this.node)
      return;
    document.body.removeChild(this.node);
    this.node = null;
  }
  announce(message, assertiveness = "assertive", timeout2 = $319e236875307eab$var$LIVEREGION_TIMEOUT_DELAY) {
    if (!this.node)
      return;
    let node3 = document.createElement("div");
    node3.textContent = message;
    if (assertiveness === "assertive")
      this.assertiveLog.appendChild(node3);
    else
      this.politeLog.appendChild(node3);
    if (message !== "")
      setTimeout(() => {
        node3.remove();
      }, timeout2);
  }
  clear(assertiveness) {
    if (!this.node)
      return;
    if (!assertiveness || assertiveness === "assertive")
      this.assertiveLog.innerHTML = "";
    if (!assertiveness || assertiveness === "polite")
      this.politeLog.innerHTML = "";
  }
  constructor() {
    this.node = document.createElement("div");
    this.node.dataset.liveAnnouncer = "true";
    Object.assign(this.node.style, {
      border: 0,
      clip: "rect(0 0 0 0)",
      clipPath: "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap"
    });
    this.assertiveLog = this.createLog("assertive");
    this.node.appendChild(this.assertiveLog);
    this.politeLog = this.createLog("polite");
    this.node.appendChild(this.politeLog);
    document.body.prepend(this.node);
  }
};

// node_modules/.pnpm/@react-aria+dnd@3.5.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/dnd/dist/import.mjs
var import_react_dom3 = __toESM(require_react_dom(), 1);
function $parcel$interopDefault2(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $103790afe9474d1c$export$60b7b4bcf3903d8e;
(function(DROP_OPERATION) {
  DROP_OPERATION[DROP_OPERATION["none"] = 0] = "none";
  DROP_OPERATION[DROP_OPERATION["cancel"] = 0] = "cancel";
  DROP_OPERATION[DROP_OPERATION["move"] = 1] = "move";
  DROP_OPERATION[DROP_OPERATION["copy"] = 2] = "copy";
  DROP_OPERATION[DROP_OPERATION["link"] = 4] = "link";
  DROP_OPERATION[DROP_OPERATION["all"] = 7] = "all";
})($103790afe9474d1c$export$60b7b4bcf3903d8e || ($103790afe9474d1c$export$60b7b4bcf3903d8e = {}));
var $103790afe9474d1c$export$9bbdfc78cf083e16 = {
  ...$103790afe9474d1c$export$60b7b4bcf3903d8e,
  copyMove: 3,
  copyLink: 6,
  linkMove: 5,
  all: 7,
  uninitialized: 7
};
var $103790afe9474d1c$export$dd0165308d8bff45 = $103790afe9474d1c$var$invert($103790afe9474d1c$export$9bbdfc78cf083e16);
$103790afe9474d1c$export$dd0165308d8bff45[7] = "all";
var $103790afe9474d1c$export$d7ebf00f36b7a95e = $103790afe9474d1c$var$invert($103790afe9474d1c$export$60b7b4bcf3903d8e);
var $103790afe9474d1c$export$608ecc6f1b23c35d = {
  none: "cancel",
  link: "link",
  copy: "copy",
  move: "move"
};
var $103790afe9474d1c$export$5eacb0769d26d3b2 = $103790afe9474d1c$var$invert($103790afe9474d1c$export$608ecc6f1b23c35d);
function $103790afe9474d1c$var$invert(object2) {
  let res = {};
  for (let key in object2)
    res[object2[key]] = key;
  return res;
}
var $103790afe9474d1c$export$4a7729b856e9a690 = /* @__PURE__ */ new Set([
  "text/plain",
  "text/uri-list",
  "text/html"
]);
var $103790afe9474d1c$export$fd9f9fc120c5402d = "application/vnd.react-aria.items+json";
var $103790afe9474d1c$export$f8fc6581787339b3 = "application/octet-stream";
var $7252cd45fc48c07c$export$dfdf5deeaf27473f = /* @__PURE__ */ new WeakMap();
var $7252cd45fc48c07c$export$990fced5dfac2637 = Symbol();
function $7252cd45fc48c07c$export$3093291712f09a77(state) {
  let { id } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);
  if (!id)
    throw new Error("Droppable item outside a droppable collection");
  return id;
}
function $7252cd45fc48c07c$export$7e397efd01d3db27(state) {
  let { ref } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);
  if (!ref)
    throw new Error("Droppable item outside a droppable collection");
  return ref;
}
function $7252cd45fc48c07c$export$e1d41611756c6326(items) {
  let types = /* @__PURE__ */ new Set();
  for (let item2 of items)
    for (let type2 of Object.keys(item2))
      types.add(type2);
  return types;
}
function $7252cd45fc48c07c$var$mapModality(modality) {
  if (!modality)
    modality = "virtual";
  if (modality === "pointer")
    modality = "virtual";
  if (modality === "virtual" && typeof window !== "undefined" && "ontouchstart" in window)
    modality = "touch";
  return modality;
}
function $7252cd45fc48c07c$export$49bac5d6d4b352ea() {
  return $7252cd45fc48c07c$var$mapModality((0, $507fabe10e71c6fb$export$98e20ec92f614cfe)());
}
function $7252cd45fc48c07c$export$1fb2158d224b542c() {
  return $7252cd45fc48c07c$var$mapModality((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)());
}
function $7252cd45fc48c07c$export$f9c1490890ddd063(dataTransfer, items) {
  let groupedByType = /* @__PURE__ */ new Map();
  let needsCustomData = false;
  let customData = [];
  for (let item2 of items) {
    let types = Object.keys(item2);
    if (types.length > 1)
      needsCustomData = true;
    let dataByType = {};
    for (let type2 of types) {
      let typeItems = groupedByType.get(type2);
      if (!typeItems) {
        typeItems = [];
        groupedByType.set(type2, typeItems);
      } else
        needsCustomData = true;
      let data = item2[type2];
      dataByType[type2] = data;
      typeItems.push(data);
    }
    customData.push(dataByType);
  }
  for (let [type2, items2] of groupedByType)
    if ((0, $103790afe9474d1c$export$4a7729b856e9a690).has(type2)) {
      let data = items2.join("\n");
      dataTransfer.items.add(data, type2);
    } else
      dataTransfer.items.add(items2[0], type2);
  if (needsCustomData) {
    let data = JSON.stringify(customData);
    dataTransfer.items.add(data, (0, $103790afe9474d1c$export$fd9f9fc120c5402d));
  }
}
var $7252cd45fc48c07c$export$7f04ce188c91447c = class {
  has(type2) {
    if (this.includesUnknownTypes || type2 === $7252cd45fc48c07c$export$990fced5dfac2637 && this.types.has((0, $103790afe9474d1c$export$f8fc6581787339b3)))
      return true;
    return typeof type2 === "string" && this.types.has(type2);
  }
  constructor(dataTransfer) {
    this.types = /* @__PURE__ */ new Set();
    let hasFiles = false;
    for (let item2 of dataTransfer.items)
      if (item2.type !== (0, $103790afe9474d1c$export$fd9f9fc120c5402d)) {
        if (item2.kind === "file")
          hasFiles = true;
        if (item2.type)
          this.types.add(item2.type);
        else
          this.types.add((0, $103790afe9474d1c$export$f8fc6581787339b3));
      }
    this.includesUnknownTypes = !hasFiles && dataTransfer.types.includes("Files");
  }
};
function $7252cd45fc48c07c$export$d9e760437831f8b3(dataTransfer) {
  let items = [];
  let hasCustomType = false;
  if (dataTransfer.types.includes((0, $103790afe9474d1c$export$fd9f9fc120c5402d)))
    try {
      let data = dataTransfer.getData((0, $103790afe9474d1c$export$fd9f9fc120c5402d));
      let parsed = JSON.parse(data);
      for (let item2 of parsed)
        items.push({
          kind: "text",
          types: new Set(Object.keys(item2)),
          getText: (type2) => Promise.resolve(item2[type2])
        });
      hasCustomType = true;
    } catch (e6) {
    }
  if (!hasCustomType) {
    let stringItems = /* @__PURE__ */ new Map();
    for (let item2 of dataTransfer.items) {
      if (item2.kind === "string")
        stringItems.set(item2.type || (0, $103790afe9474d1c$export$f8fc6581787339b3), dataTransfer.getData(item2.type));
      else if (item2.kind === "file") {
        if (typeof item2.webkitGetAsEntry === "function") {
          let entry = item2.webkitGetAsEntry();
          if (!entry)
            continue;
          if (entry.isFile)
            items.push($7252cd45fc48c07c$var$createFileItem(item2.getAsFile()));
          else if (entry.isDirectory)
            items.push($7252cd45fc48c07c$var$createDirectoryItem(entry));
        } else
          items.push($7252cd45fc48c07c$var$createFileItem(item2.getAsFile()));
      }
    }
    if (stringItems.size > 0)
      items.push({
        kind: "text",
        types: new Set(stringItems.keys()),
        getText: (type2) => Promise.resolve(stringItems.get(type2))
      });
  }
  return items;
}
function $7252cd45fc48c07c$var$blobToString(blob) {
  if (typeof blob.text === "function")
    return blob.text();
  return new Promise((resolve3, reject) => {
    let reader = new FileReader();
    reader.onload = () => {
      resolve3(reader.result);
    };
    reader.onerror = reject;
    reader.readAsText(blob);
  });
}
function $7252cd45fc48c07c$var$createFileItem(file) {
  return {
    kind: "file",
    type: file.type || (0, $103790afe9474d1c$export$f8fc6581787339b3),
    name: file.name,
    getText: () => $7252cd45fc48c07c$var$blobToString(file),
    getFile: () => Promise.resolve(file)
  };
}
function $7252cd45fc48c07c$var$createDirectoryItem(entry) {
  return {
    kind: "directory",
    name: entry.name,
    getEntries: () => $7252cd45fc48c07c$var$getEntries(entry)
  };
}
async function* $7252cd45fc48c07c$var$getEntries(item2) {
  let reader = item2.createReader();
  let entries;
  do {
    entries = await new Promise((resolve3, reject) => {
      reader.readEntries(resolve3, reject);
    });
    for (let entry of entries) {
      if (entry.isFile) {
        let file = await $7252cd45fc48c07c$var$getEntryFile(entry);
        yield $7252cd45fc48c07c$var$createFileItem(file);
      } else if (entry.isDirectory)
        yield $7252cd45fc48c07c$var$createDirectoryItem(entry);
    }
  } while (entries.length > 0);
}
function $7252cd45fc48c07c$var$getEntryFile(entry) {
  return new Promise((resolve3, reject) => entry.file(resolve3, reject));
}
var $7252cd45fc48c07c$export$6ca6700462636d0b = {
  draggingKeys: /* @__PURE__ */ new Set()
};
function $7252cd45fc48c07c$export$f2be18a910c0caa6(ref) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.draggingCollectionRef = ref;
}
function $7252cd45fc48c07c$export$72cb63bdda528276(keys) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.draggingKeys = keys;
}
function $7252cd45fc48c07c$export$dac8db29d42db9a1(ref) {
  $7252cd45fc48c07c$export$6ca6700462636d0b.dropCollectionRef = ref;
}
function $7252cd45fc48c07c$export$70936501603e6c57() {
  $7252cd45fc48c07c$export$6ca6700462636d0b = {
    draggingKeys: /* @__PURE__ */ new Set()
  };
}
function $7252cd45fc48c07c$export$6c10d32b362bfa5f(state) {
  $7252cd45fc48c07c$export$6ca6700462636d0b = state;
}
function $7252cd45fc48c07c$export$78bf638634500fa5(ref) {
  let { draggingCollectionRef, dropCollectionRef } = $7252cd45fc48c07c$export$6ca6700462636d0b;
  return (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) != null && draggingCollectionRef.current === ((ref === null || ref === void 0 ? void 0 : ref.current) || (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current));
}
var $7252cd45fc48c07c$export$8e6636520ac15722;
function $7252cd45fc48c07c$export$64f52ed7349ddb84(dropEffect) {
  $7252cd45fc48c07c$export$8e6636520ac15722 = dropEffect;
}
var $7252cd45fc48c07c$export$f0130eb70b6347b8 = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
function $7252cd45fc48c07c$export$6539bc8c3a0a2d67(o5) {
  $7252cd45fc48c07c$export$f0130eb70b6347b8 = o5;
}
var $67560de7c78cb232$var$dropTargets = /* @__PURE__ */ new Map();
var $67560de7c78cb232$var$dropItems = /* @__PURE__ */ new Map();
var $67560de7c78cb232$var$dragSession = null;
var $67560de7c78cb232$var$subscriptions = /* @__PURE__ */ new Set();
function $67560de7c78cb232$export$c28d9fb4a54e471a(target) {
  $67560de7c78cb232$var$dropTargets.set(target.element, target);
  $67560de7c78cb232$var$dragSession === null || $67560de7c78cb232$var$dragSession === void 0 ? void 0 : $67560de7c78cb232$var$dragSession.updateValidDropTargets();
  return () => {
    $67560de7c78cb232$var$dropTargets.delete(target.element);
    $67560de7c78cb232$var$dragSession === null || $67560de7c78cb232$var$dragSession === void 0 ? void 0 : $67560de7c78cb232$var$dragSession.updateValidDropTargets();
  };
}
function $67560de7c78cb232$export$aef80212ac99c003(item2) {
  $67560de7c78cb232$var$dropItems.set(item2.element, item2);
  return () => {
    $67560de7c78cb232$var$dropItems.delete(item2.element);
  };
}
function $67560de7c78cb232$export$549dbcf8649bf3b2(target, stringFormatter) {
  if ($67560de7c78cb232$var$dragSession)
    throw new Error("Cannot begin dragging while already dragging");
  $67560de7c78cb232$var$dragSession = new $67560de7c78cb232$var$DragSession(target, stringFormatter);
  requestAnimationFrame(() => {
    $67560de7c78cb232$var$dragSession.setup();
    if ((0, $7252cd45fc48c07c$export$1fb2158d224b542c)() === "keyboard")
      $67560de7c78cb232$var$dragSession.next();
  });
  for (let cb of $67560de7c78cb232$var$subscriptions)
    cb();
}
function $67560de7c78cb232$export$418e185dd3f1b968() {
  let [session, setSession] = (0, import_react41.useState)($67560de7c78cb232$var$dragSession);
  (0, import_react41.useEffect)(() => {
    let cb = () => setSession($67560de7c78cb232$var$dragSession);
    $67560de7c78cb232$var$subscriptions.add(cb);
    return () => {
      $67560de7c78cb232$var$subscriptions.delete(cb);
    };
  }, []);
  return session;
}
function $67560de7c78cb232$export$403bc76cbf68cf60() {
  return !!$67560de7c78cb232$var$dragSession;
}
function $67560de7c78cb232$var$endDragging() {
  $67560de7c78cb232$var$dragSession = null;
  for (let cb of $67560de7c78cb232$var$subscriptions)
    cb();
}
var $67560de7c78cb232$var$CANCELED_EVENTS = [
  "pointerdown",
  "pointermove",
  "pointerenter",
  "pointerleave",
  "pointerover",
  "pointerout",
  "pointerup",
  "mousedown",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "mouseup",
  "touchstart",
  "touchmove",
  "touchend",
  "focusin",
  "focusout"
];
var $67560de7c78cb232$var$CLICK_EVENTS = [
  "pointerup",
  "mouseup",
  "touchend"
];
var $67560de7c78cb232$var$MESSAGES = {
  keyboard: "dragStartedKeyboard",
  touch: "dragStartedTouch",
  virtual: "dragStartedVirtual"
};
var $67560de7c78cb232$var$DragSession = class {
  setup() {
    document.addEventListener("keydown", this.onKeyDown, true);
    document.addEventListener("keyup", this.onKeyUp, true);
    window.addEventListener("focus", this.onFocus, true);
    window.addEventListener("blur", this.onBlur, true);
    document.addEventListener("click", this.onClick, true);
    document.addEventListener("pointerdown", this.onPointerDown, true);
    for (let event of $67560de7c78cb232$var$CANCELED_EVENTS)
      document.addEventListener(event, this.cancelEvent, true);
    this.mutationObserver = new MutationObserver(() => this.updateValidDropTargets());
    this.updateValidDropTargets();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format($67560de7c78cb232$var$MESSAGES[(0, $7252cd45fc48c07c$export$1fb2158d224b542c)()]));
  }
  teardown() {
    document.removeEventListener("keydown", this.onKeyDown, true);
    document.removeEventListener("keyup", this.onKeyUp, true);
    window.removeEventListener("focus", this.onFocus, true);
    window.removeEventListener("blur", this.onBlur, true);
    document.removeEventListener("click", this.onClick, true);
    document.removeEventListener("pointerdown", this.onPointerDown, true);
    for (let event of $67560de7c78cb232$var$CANCELED_EVENTS)
      document.removeEventListener(event, this.cancelEvent, true);
    this.mutationObserver.disconnect();
    this.restoreAriaHidden();
  }
  onKeyDown(e6) {
    var _this_currentDropTarget;
    this.cancelEvent(e6);
    if (e6.key === "Escape") {
      this.cancel();
      return;
    }
    if (e6.key === "Tab" && !(e6.metaKey || e6.altKey || e6.ctrlKey)) {
      if (e6.shiftKey)
        this.previous();
      else
        this.next();
    }
    if (typeof ((_this_currentDropTarget = this.currentDropTarget) === null || _this_currentDropTarget === void 0 ? void 0 : _this_currentDropTarget.onKeyDown) === "function")
      this.currentDropTarget.onKeyDown(e6, this.dragTarget);
  }
  onKeyUp(e6) {
    this.cancelEvent(e6);
    if (e6.key === "Enter") {
      if (e6.altKey)
        this.activate();
      else
        this.drop();
    }
  }
  onFocus(e6) {
    if (e6.target !== this.dragTarget.element)
      this.cancelEvent(e6);
    if (!(e6.target instanceof HTMLElement) || e6.target === this.dragTarget.element)
      return;
    let dropTarget = this.validDropTargets.find((target) => target.element === e6.target) || this.validDropTargets.find((target) => target.element.contains(e6.target));
    if (!dropTarget) {
      if (this.currentDropTarget)
        this.currentDropTarget.element.focus();
      else
        this.dragTarget.element.focus();
      return;
    }
    let item2 = $67560de7c78cb232$var$dropItems.get(e6.target);
    this.setCurrentDropTarget(dropTarget, item2);
  }
  onBlur(e6) {
    if (e6.target !== this.dragTarget.element)
      this.cancelEvent(e6);
    if (!e6.relatedTarget || !(e6.relatedTarget instanceof HTMLElement)) {
      if (this.currentDropTarget)
        this.currentDropTarget.element.focus();
      else
        this.dragTarget.element.focus();
    }
  }
  onClick(e6) {
    this.cancelEvent(e6);
    if ((0, $6a7db85432448f7f$export$60278871457622de)(e6) || this.isVirtualClick) {
      if (e6.target === this.dragTarget.element) {
        this.cancel();
        return;
      }
      let dropTarget = this.validDropTargets.find((target) => target.element.contains(e6.target));
      if (dropTarget) {
        let item2 = $67560de7c78cb232$var$dropItems.get(e6.target);
        this.setCurrentDropTarget(dropTarget, item2);
        this.drop(item2);
      }
    }
  }
  onPointerDown(e6) {
    this.cancelEvent(e6);
    this.isVirtualClick = (0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e6);
  }
  cancelEvent(e6) {
    var _this_dragTarget;
    if ((e6.type === "focusin" || e6.type === "focusout") && e6.target === ((_this_dragTarget = this.dragTarget) === null || _this_dragTarget === void 0 ? void 0 : _this_dragTarget.element))
      return;
    if (!$67560de7c78cb232$var$CLICK_EVENTS.includes(e6.type))
      e6.preventDefault();
    e6.stopPropagation();
    e6.stopImmediatePropagation();
  }
  updateValidDropTargets() {
    if (!this.mutationObserver)
      return;
    this.mutationObserver.disconnect();
    if (this.restoreAriaHidden)
      this.restoreAriaHidden();
    this.validDropTargets = $67560de7c78cb232$var$findValidDropTargets(this.dragTarget);
    if (this.validDropTargets.length > 0) {
      let nearestIndex = this.findNearestDropTarget();
      this.validDropTargets = [
        ...this.validDropTargets.slice(nearestIndex),
        ...this.validDropTargets.slice(0, nearestIndex)
      ];
    }
    if (this.currentDropTarget && !this.validDropTargets.includes(this.currentDropTarget))
      this.setCurrentDropTarget(this.validDropTargets[0]);
    let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
    let validDropItems = [
      ...$67560de7c78cb232$var$dropItems.values()
    ].filter((item2) => {
      if (typeof item2.getDropOperation === "function")
        return item2.getDropOperation(types, this.dragTarget.allowedDropOperations) !== "cancel";
      return true;
    });
    let visibleDropTargets = this.validDropTargets.filter((target) => !validDropItems.some((item2) => target.element.contains(item2.element)));
    this.restoreAriaHidden = (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
      this.dragTarget.element,
      ...validDropItems.map((item2) => item2.element),
      ...visibleDropTargets.map((target) => target.element)
    ]);
    this.mutationObserver.observe(document.body, {
      subtree: true,
      attributes: true,
      attributeFilter: [
        "aria-hidden"
      ]
    });
  }
  next() {
    if (!this.currentDropTarget) {
      this.setCurrentDropTarget(this.validDropTargets[0]);
      return;
    }
    let index2 = this.validDropTargets.indexOf(this.currentDropTarget);
    if (index2 < 0) {
      this.setCurrentDropTarget(this.validDropTargets[0]);
      return;
    }
    if (index2 === this.validDropTargets.length - 1) {
      if (!this.dragTarget.element.closest('[aria-hidden="true"]')) {
        this.setCurrentDropTarget(null);
        this.dragTarget.element.focus();
      } else
        this.setCurrentDropTarget(this.validDropTargets[0]);
    } else
      this.setCurrentDropTarget(this.validDropTargets[index2 + 1]);
  }
  previous() {
    if (!this.currentDropTarget) {
      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
      return;
    }
    let index2 = this.validDropTargets.indexOf(this.currentDropTarget);
    if (index2 < 0) {
      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
      return;
    }
    if (index2 === 0) {
      if (!this.dragTarget.element.closest('[aria-hidden="true"]')) {
        this.setCurrentDropTarget(null);
        this.dragTarget.element.focus();
      } else
        this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
    } else
      this.setCurrentDropTarget(this.validDropTargets[index2 - 1]);
  }
  findNearestDropTarget() {
    let dragTargetRect = this.dragTarget.element.getBoundingClientRect();
    let minDistance = Infinity;
    let nearest = -1;
    for (let i6 = 0; i6 < this.validDropTargets.length; i6++) {
      let dropTarget = this.validDropTargets[i6];
      let rect = dropTarget.element.getBoundingClientRect();
      let dx = rect.left - dragTargetRect.left;
      let dy = rect.top - dragTargetRect.top;
      let dist = dx * dx + dy * dy;
      if (dist < minDistance) {
        minDistance = dist;
        nearest = i6;
      }
    }
    return nearest;
  }
  setCurrentDropTarget(dropTarget, item2) {
    if (dropTarget !== this.currentDropTarget) {
      if (this.currentDropTarget && typeof this.currentDropTarget.onDropExit === "function") {
        let rect = this.currentDropTarget.element.getBoundingClientRect();
        this.currentDropTarget.onDropExit({
          type: "dropexit",
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        });
      }
      this.currentDropTarget = dropTarget;
      if (dropTarget) {
        if (typeof dropTarget.onDropEnter === "function") {
          let rect = dropTarget.element.getBoundingClientRect();
          dropTarget.onDropEnter({
            type: "dropenter",
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          }, this.dragTarget);
        }
        if (!item2)
          dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.element.focus();
      }
    }
    if (item2 !== this.currentDropItem) {
      if (item2 && typeof this.currentDropTarget.onDropTargetEnter === "function")
        this.currentDropTarget.onDropTargetEnter(item2 === null || item2 === void 0 ? void 0 : item2.target);
      item2 === null || item2 === void 0 ? void 0 : item2.element.focus();
      this.currentDropItem = item2;
      if (!this.initialFocused) {
        (0, $319e236875307eab$export$a9b970dcc4ae71a9)(item2 === null || item2 === void 0 ? void 0 : item2.element.getAttribute("aria-label"), "polite");
        this.initialFocused = true;
      }
    }
  }
  end() {
    this.teardown();
    $67560de7c78cb232$var$endDragging();
    if (typeof this.dragTarget.onDragEnd === "function") {
      let target = this.currentDropTarget && this.dropOperation !== "cancel" ? this.currentDropTarget : this.dragTarget;
      let rect = target.element.getBoundingClientRect();
      this.dragTarget.onDragEnd({
        type: "dragend",
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2,
        dropOperation: this.dropOperation || "cancel"
      });
    }
    if (this.currentDropTarget) {
      if (!this.dragTarget.element.contains(this.currentDropTarget.element)) {
        this.dragTarget.element.dispatchEvent(new FocusEvent("blur"));
        this.dragTarget.element.dispatchEvent(new FocusEvent("focusout", {
          bubbles: true
        }));
      }
      (0, import_react_dom3.flushSync)(() => {
        this.currentDropTarget.element.blur();
      });
      this.currentDropTarget.element.focus();
    }
    this.setCurrentDropTarget(null);
  }
  cancel() {
    this.setCurrentDropTarget(null);
    this.end();
    if (!this.dragTarget.element.closest('[aria-hidden="true"]'))
      this.dragTarget.element.focus();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format("dropCanceled"));
  }
  drop(item2) {
    if (!this.currentDropTarget) {
      this.cancel();
      return;
    }
    if (typeof (item2 === null || item2 === void 0 ? void 0 : item2.getDropOperation) === "function") {
      let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
      this.dropOperation = item2.getDropOperation(types, this.dragTarget.allowedDropOperations);
    } else if (typeof this.currentDropTarget.getDropOperation === "function") {
      let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
      this.dropOperation = this.currentDropTarget.getDropOperation(types, this.dragTarget.allowedDropOperations);
    } else
      this.dropOperation = this.dragTarget.allowedDropOperations[0];
    if (typeof this.currentDropTarget.onDrop === "function") {
      let items = this.dragTarget.items.map((item3) => ({
        kind: "text",
        types: new Set(Object.keys(item3)),
        getText: (type2) => Promise.resolve(item3[type2])
      }));
      let rect = this.currentDropTarget.element.getBoundingClientRect();
      this.currentDropTarget.onDrop({
        type: "drop",
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2,
        items,
        dropOperation: this.dropOperation
      }, item2 === null || item2 === void 0 ? void 0 : item2.target);
    }
    this.end();
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(this.stringFormatter.format("dropComplete"));
  }
  activate() {
    if (this.currentDropTarget && typeof this.currentDropTarget.onDropActivate === "function") {
      let rect = this.currentDropTarget.element.getBoundingClientRect();
      this.currentDropTarget.onDropActivate({
        type: "dropactivate",
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      });
    }
  }
  constructor(target, stringFormatter) {
    this.dragTarget = target;
    this.stringFormatter = stringFormatter;
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.onClick = this.onClick.bind(this);
    this.onPointerDown = this.onPointerDown.bind(this);
    this.cancelEvent = this.cancelEvent.bind(this);
    this.initialFocused = false;
  }
};
function $67560de7c78cb232$var$findValidDropTargets(options) {
  let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(options.items);
  return [
    ...$67560de7c78cb232$var$dropTargets.values()
  ].filter((target) => {
    if (target.element.closest('[aria-hidden="true"]'))
      return false;
    if (typeof target.getDropOperation === "function")
      return target.getDropOperation(types, options.allowedDropOperations) !== "cancel";
    return true;
  });
}
var $865c2eb7c00a83f1$exports = {};
var $7dfcac1a0c98c789$exports = {};
$7dfcac1a0c98c789$exports = {
  "dragDescriptionKeyboard": `اضغط Enter لبدء السحب.`,
  "dragDescriptionKeyboardAlt": `اضغط على Alt + Enter لبدء السحب.`,
  "dragDescriptionLongPress": `اضغط باستمرار لبدء السحب.`,
  "dragDescriptionTouch": `اضغط مرتين لبدء السحب.`,
  "dragDescriptionVirtual": `انقر لبدء السحب.`,
  "dragItem": (args) => `اسحب ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `اسحب ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} عنصر محدد`,
    other: () => `${formatter.number(args.count)} عناصر محددة`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `اضغط على Enter للسحب ${formatter.plural(args.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `اضغط على مفتاحي Alt + Enter للسحب ${formatter.plural(args.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `اضغط باستمرار للسحب ${formatter.plural(args.count, {
    one: `عدد العناصر المختارة`,
    other: `عدد العناصر المختارة`
  })}.`,
  "dragStartedKeyboard": `بدأ السحب. اضغط Tab للانتقال إلى موضع الإفلات، ثم اضغط Enter للإفلات، أو اضغط Escape للإلغاء.`,
  "dragStartedTouch": `بدأ السحب. انتقل إلى موضع الإفلات، ثم اضغط مرتين للإفلات.`,
  "dragStartedVirtual": `بدأ السحب. انتقل إلى مكان الإفلات، ثم انقر أو اضغط Enter للإفلات.`,
  "dropCanceled": `تم إلغاء الإفلات.`,
  "dropComplete": `اكتمل الإفلات.`,
  "dropDescriptionKeyboard": `اضغط Enter للإفلات. اضغط Escape لإلغاء السحب.`,
  "dropDescriptionTouch": `اضغط مرتين للإفلات.`,
  "dropDescriptionVirtual": `انقر للإفلات.`,
  "dropIndicator": `مؤشر الإفلات`,
  "dropOnItem": (args) => `إفلات ${args.itemText}`,
  "dropOnRoot": `الإفلات`,
  "endDragKeyboard": `السحب. اضغط Enter لإلغاء السحب.`,
  "endDragTouch": `السحب. اضغط مرتين لإلغاء السحب.`,
  "endDragVirtual": `السحب. انقر لإلغاء السحب.`,
  "insertAfter": (args) => `أدخل بعد ${args.itemText}`,
  "insertBefore": (args) => `أدخل قبل ${args.itemText}`,
  "insertBetween": (args) => `أدخل بين ${args.beforeItemText} و ${args.afterItemText}`
};
var $f311c26671219eca$exports = {};
$f311c26671219eca$exports = {
  "dragDescriptionKeyboard": `Натиснете „Enter“, за да започнете да плъзгате.`,
  "dragDescriptionKeyboardAlt": `Натиснете Alt + Enter, за да започнете да плъзгате.`,
  "dragDescriptionLongPress": `Натиснете продължително, за да започнете да плъзгате.`,
  "dragDescriptionTouch": `Натиснете двукратно, за да започнете да плъзгате.`,
  "dragDescriptionVirtual": `Щракнете, за да започнете да плъзгате.`,
  "dragItem": (args) => `Плъзни ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Плъзни ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} избран елемент`,
    other: () => `${formatter.number(args.count)} избрани елемента`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Натиснете Enter, за да плъзнете ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} избран елемент`,
    other: () => `${formatter.number(args.count)} избрани елементи`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Натиснете Alt и Enter, за да плъзнете ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} избран елемент`,
    other: () => `${formatter.number(args.count)} избрани елементи`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Натиснете продължително, за да плъзнете ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} избран елемент`,
    other: () => `${formatter.number(args.count)} избрани елементи`
  })}.`,
  "dragStartedKeyboard": `Започна плъзгане. Натиснете „Tab“, за да се придвижите до целта, след което натиснете „Enter“ за пускане или натиснете „Escape“ за отмяна.`,
  "dragStartedTouch": `Започна плъзгане. Придвижете се до целта, след което натиснете двукратно, за да пуснете.`,
  "dragStartedVirtual": `Започна плъзгане. Придвижете се до целта, след което щракнете или натиснете „Enter“ за пускане.`,
  "dropCanceled": `Пускането е отменено.`,
  "dropComplete": `Пускането е завършено.`,
  "dropDescriptionKeyboard": `Натиснете „Enter“ за пускане. Натиснете „Escape“ за отмяна на плъзгането.`,
  "dropDescriptionTouch": `Натиснете двукратно за пускане.`,
  "dropDescriptionVirtual": `Щракнете за пускане.`,
  "dropIndicator": `индикатор за пускане`,
  "dropOnItem": (args) => `Пусни върху ${args.itemText}`,
  "dropOnRoot": `Пусни върху`,
  "endDragKeyboard": `Плъзгане. Натиснете „Enter“ за отмяна на плъзгането.`,
  "endDragTouch": `Плъзгане. Натиснете двукратно за отмяна на плъзгането.`,
  "endDragVirtual": `Плъзгане. Щракнете за отмяна.`,
  "insertAfter": (args) => `Вмъкни след ${args.itemText}`,
  "insertBefore": (args) => `Вмъкни преди ${args.itemText}`,
  "insertBetween": (args) => `Вмъкни между ${args.beforeItemText} и ${args.afterItemText}`
};
var $1aa4ade186550f72$exports = {};
$1aa4ade186550f72$exports = {
  "dragDescriptionKeyboard": `Stisknutím klávesy Enter začnete s přetahováním.`,
  "dragDescriptionKeyboardAlt": `Stisknutím Alt + Enter zahájíte přetahování.`,
  "dragDescriptionLongPress": `Dlouhým stisknutím zahájíte přetahování.`,
  "dragDescriptionTouch": `Poklepáním začnete s přetahováním.`,
  "dragDescriptionVirtual": `Kliknutím začnete s přetahováním.`,
  "dragItem": (args) => `Přetáhnout ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Přetáhnout ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} vybranou položku`,
    few: () => `${formatter.number(args.count)} vybrané položky`,
    other: () => `${formatter.number(args.count)} vybraných položek`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Stisknutím klávesy Enter přetáhněte ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} vybranou položku`,
    other: () => `${formatter.number(args.count)} vybrané položky`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Stisknutím Alt + Enter přetáhněte ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} vybranou položku`,
    other: () => `${formatter.number(args.count)} vybrané položky`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Dlouhým stisknutím přetáhnete ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} vybranou položku`,
    other: () => `${formatter.number(args.count)} vybrané položky`
  })}.`,
  "dragStartedKeyboard": `Začněte s přetahováním. Po stisknutí klávesy Tab najděte požadovaný cíl a stisknutím klávesy Enter přetažení dokončete nebo stisknutím klávesy Esc akci zrušte.`,
  "dragStartedTouch": `Začněte s přetahováním. Najděte požadovaný cíl a poklepáním přetažení dokončete.`,
  "dragStartedVirtual": `Začněte s přetahováním. Najděte požadovaný cíl a kliknutím nebo stisknutím klávesy Enter přetažení dokončete.`,
  "dropCanceled": `Přetažení bylo zrušeno.`,
  "dropComplete": `Přetažení bylo dokončeno.`,
  "dropDescriptionKeyboard": `Stisknutím klávesy Enter přetažení dokončete nebo stisknutím klávesy Esc akci zrušte.`,
  "dropDescriptionTouch": `Poklepáním přetažení dokončete.`,
  "dropDescriptionVirtual": `Kliknutím objekt přetáhněte.`,
  "dropIndicator": `indikátor přetažení`,
  "dropOnItem": (args) => `Přetáhnout na ${args.itemText}`,
  "dropOnRoot": `Přetáhnout na`,
  "endDragKeyboard": `Probíhá přetahování. Stisknutím klávesy Enter přetažení zrušíte.`,
  "endDragTouch": `Probíhá přetahování. Poklepáním přetažení zrušíte.`,
  "endDragVirtual": `Probíhá přetahování. Kliknutím přetažení zrušíte.`,
  "insertAfter": (args) => `Vložit za ${args.itemText}`,
  "insertBefore": (args) => `Vložit před ${args.itemText}`,
  "insertBetween": (args) => `Vložit mezi ${args.beforeItemText} a ${args.afterItemText}`
};
var $b6b0ea1b94a7633c$exports = {};
$b6b0ea1b94a7633c$exports = {
  "dragDescriptionKeyboard": `Tryk på Enter for at starte med at trække.`,
  "dragDescriptionKeyboardAlt": `Tryk på Alt + Enter for at starte med at trække.`,
  "dragDescriptionLongPress": `Tryk længe for at starte med at trække.`,
  "dragDescriptionTouch": `Dobbelttryk for at starte med at trække.`,
  "dragDescriptionVirtual": `Klik for at starte med at trække.`,
  "dragItem": (args) => `Træk ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Træk ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valgt element`,
    other: () => `${formatter.number(args.count)} valgte elementer`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Tryk på Enter for at trække ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valgte element`,
    other: () => `${formatter.number(args.count)} valgte elementer`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Tryk på Alt + Enter for at trække ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valgte element`,
    other: () => `${formatter.number(args.count)} valgte elementer`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Tryk længe for at trække ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valgte element`,
    other: () => `${formatter.number(args.count)} valgte elementer`
  })}.`,
  "dragStartedKeyboard": `Startet med at trække. Tryk på Tab for at gå til et slip-mål, tryk derefter på Enter for at slippe, eller tryk på Escape for at annullere.`,
  "dragStartedTouch": `Startet med at trække. Gå til et slip-mål, og dobbelttryk derefter for at slippe.`,
  "dragStartedVirtual": `Startet med at trække. Gå til et slip-mål, og klik eller tryk derefter på enter for at slippe.`,
  "dropCanceled": `Slip annulleret.`,
  "dropComplete": `Slip fuldført.`,
  "dropDescriptionKeyboard": `Tryk på Enter for at slippe. Tryk på Escape for at annullere trækning.`,
  "dropDescriptionTouch": `Dobbelttryk for at slippe.`,
  "dropDescriptionVirtual": `Klik for at slippe.`,
  "dropIndicator": `slip-indikator`,
  "dropOnItem": (args) => `Slip på ${args.itemText}`,
  "dropOnRoot": `Slip på`,
  "endDragKeyboard": `Trækning. Tryk på enter for at annullere træk.`,
  "endDragTouch": `Trækning. Dobbelttryk for at annullere træk.`,
  "endDragVirtual": `Trækning. Klik for at annullere trækning.`,
  "insertAfter": (args) => `Indsæt efter ${args.itemText}`,
  "insertBefore": (args) => `Indsæt før ${args.itemText}`,
  "insertBetween": (args) => `Indsæt mellem ${args.beforeItemText} og ${args.afterItemText}`
};
var $d10e4f47c744ad52$exports = {};
$d10e4f47c744ad52$exports = {
  "dragDescriptionKeyboard": `Drücken Sie die Eingabetaste, um den Ziehvorgang zu starten.`,
  "dragDescriptionKeyboardAlt": `Alt + Eingabe drücken, um den Ziehvorgang zu starten.`,
  "dragDescriptionLongPress": `Lang drücken, um mit dem Ziehen zu beginnen.`,
  "dragDescriptionTouch": `Tippen Sie doppelt, um den Ziehvorgang zu starten.`,
  "dragDescriptionVirtual": `Zum Starten des Ziehvorgangs klicken.`,
  "dragItem": (args) => `${args.itemText} ziehen`,
  "dragSelectedItems": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} ausgewähltes Objekt`,
    other: () => `${formatter.number(args.count)} ausgewählte Objekte`
  })} ziehen`,
  "dragSelectedKeyboard": (args, formatter) => `Eingabetaste drücken, um ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Alt + Eingabetaste drücken, um ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragSelectedLongPress": (args, formatter) => `Lang drücken, um ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} ausgewähltes Element`,
    other: () => `${formatter.number(args.count)} ausgewählte Elemente`
  })} zu ziehen.`,
  "dragStartedKeyboard": `Ziehvorgang gestartet. Drücken Sie die Tabulatortaste, um zu einem Ablegeziel zu navigieren und drücken Sie dann die Eingabetaste, um das Objekt abzulegen, oder Escape, um den Vorgang abzubrechen.`,
  "dragStartedTouch": `Ziehvorgang gestartet. Navigieren Sie zu einem Ablegeziel und tippen Sie doppelt, um das Objekt abzulegen.`,
  "dragStartedVirtual": `Ziehvorgang gestartet. Navigieren Sie zu einem Ablegeziel und klicken Sie oder drücken Sie die Eingabetaste, um das Objekt abzulegen.`,
  "dropCanceled": `Ablegen abgebrochen.`,
  "dropComplete": `Ablegen abgeschlossen.`,
  "dropDescriptionKeyboard": `Drücken Sie die Eingabetaste, um das Objekt abzulegen. Drücken Sie Escape, um den Vorgang abzubrechen.`,
  "dropDescriptionTouch": `Tippen Sie doppelt, um das Objekt abzulegen.`,
  "dropDescriptionVirtual": `Zum Ablegen klicken.`,
  "dropIndicator": `Ablegeanzeiger`,
  "dropOnItem": (args) => `Auf ${args.itemText} ablegen`,
  "dropOnRoot": `Ablegen auf`,
  "endDragKeyboard": `Ziehvorgang läuft. Drücken Sie die Eingabetaste, um den Vorgang abzubrechen.`,
  "endDragTouch": `Ziehvorgang läuft. Tippen Sie doppelt, um den Vorgang abzubrechen.`,
  "endDragVirtual": `Ziehvorgang läuft. Klicken Sie, um den Vorgang abzubrechen.`,
  "insertAfter": (args) => `Nach ${args.itemText} einfügen`,
  "insertBefore": (args) => `Vor ${args.itemText} einfügen`,
  "insertBetween": (args) => `Zwischen ${args.beforeItemText} und ${args.afterItemText} einfügen`
};
var $b3d2bb9abce688ab$exports = {};
$b3d2bb9abce688ab$exports = {
  "dragDescriptionKeyboard": `Πατήστε Enter για έναρξη της μεταφοράς.`,
  "dragDescriptionKeyboardAlt": `Πατήστε Alt + Enter για έναρξη της μεταφοράς.`,
  "dragDescriptionLongPress": `Πατήστε παρατεταμένα για να ξεκινήσετε τη μεταφορά.`,
  "dragDescriptionTouch": `Πατήστε δύο φορές για έναρξη της μεταφοράς.`,
  "dragDescriptionVirtual": `Κάντε κλικ για να ξεκινήσετε τη μεταφορά.`,
  "dragItem": (args) => `Μεταφορά ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Μεταφορά σε ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args.count)} επιλεγμένα στοιχεία`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Πατήστε Enter για να σύρετε ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Πατήστε Alt + Enter για να σύρετε ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Πατήστε παρατεταμένα για να σύρετε ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} επιλεγμένο στοιχείο`,
    other: () => `${formatter.number(args.count)} επιλεγμένα στοιχεία`
  })}.`,
  "dragStartedKeyboard": `Η μεταφορά ξεκίνησε. Πατήστε το πλήκτρο Tab για να μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, πατήστε Enter για απόθεση ή πατήστε Escape για ακύρωση.`,
  "dragStartedTouch": `Η μεταφορά ξεκίνησε. Μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, πατήστε δύο φορές για απόθεση.`,
  "dragStartedVirtual": `Η μεταφορά ξεκίνησε. Μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, κάντε κλικ ή πατήστε Enter για απόθεση.`,
  "dropCanceled": `Η απόθεση ακυρώθηκε.`,
  "dropComplete": `Η απόθεση ολοκληρώθηκε.`,
  "dropDescriptionKeyboard": `Πατήστε Enter για απόθεση. Πατήστε Escape για ακύρωση της μεταφοράς.`,
  "dropDescriptionTouch": `Πατήστε δύο φορές για απόθεση.`,
  "dropDescriptionVirtual": `Κάντε κλικ για απόθεση.`,
  "dropIndicator": `δείκτης απόθεσης`,
  "dropOnItem": (args) => `Απόθεση σε ${args.itemText}`,
  "dropOnRoot": `Απόθεση σε`,
  "endDragKeyboard": `Μεταφορά σε εξέλιξη. Πατήστε Enter για ακύρωση της μεταφοράς.`,
  "endDragTouch": `Μεταφορά σε εξέλιξη. Πατήστε δύο φορές για ακύρωση της μεταφοράς.`,
  "endDragVirtual": `Μεταφορά σε εξέλιξη. Κάντε κλικ για ακύρωση της μεταφοράς.`,
  "insertAfter": (args) => `Εισαγωγή μετά από ${args.itemText}`,
  "insertBefore": (args) => `Εισαγωγή πριν από ${args.itemText}`,
  "insertBetween": (args) => `Εισαγωγή μεταξύ ${args.beforeItemText} και ${args.afterItemText}`
};
var $f9b46437e610cca1$exports = {};
$f9b46437e610cca1$exports = {
  "dragItem": (args) => `Drag ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Drag ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} selected item`,
    other: () => `${formatter.number(args.count)} selected items`
  })}`,
  "dragDescriptionKeyboard": `Press Enter to start dragging.`,
  "dragDescriptionKeyboardAlt": `Press Alt + Enter to start dragging.`,
  "dragDescriptionTouch": `Double tap to start dragging.`,
  "dragDescriptionVirtual": `Click to start dragging.`,
  "dragDescriptionLongPress": `Long press to start dragging.`,
  "dragSelectedKeyboard": (args, formatter) => `Press Enter to drag ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} selected item`,
    other: () => `${formatter.number(args.count)} selected items`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Press Alt + Enter to drag ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} selected item`,
    other: () => `${formatter.number(args.count)} selected items`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Long press to drag ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} selected item`,
    other: () => `${formatter.number(args.count)} selected items`
  })}.`,
  "dragStartedKeyboard": `Started dragging. Press Tab to navigate to a drop target, then press Enter to drop, or press Escape to cancel.`,
  "dragStartedTouch": `Started dragging. Navigate to a drop target, then double tap to drop.`,
  "dragStartedVirtual": `Started dragging. Navigate to a drop target, then click or press Enter to drop.`,
  "endDragKeyboard": `Dragging. Press Enter to cancel drag.`,
  "endDragTouch": `Dragging. Double tap to cancel drag.`,
  "endDragVirtual": `Dragging. Click to cancel drag.`,
  "dropDescriptionKeyboard": `Press Enter to drop. Press Escape to cancel drag.`,
  "dropDescriptionTouch": `Double tap to drop.`,
  "dropDescriptionVirtual": `Click to drop.`,
  "dropCanceled": `Drop canceled.`,
  "dropComplete": `Drop complete.`,
  "dropIndicator": `drop indicator`,
  "dropOnRoot": `Drop on`,
  "dropOnItem": (args) => `Drop on ${args.itemText}`,
  "insertBefore": (args) => `Insert before ${args.itemText}`,
  "insertBetween": (args) => `Insert between ${args.beforeItemText} and ${args.afterItemText}`,
  "insertAfter": (args) => `Insert after ${args.itemText}`
};
var $204b5c01bd3acf26$exports = {};
$204b5c01bd3acf26$exports = {
  "dragDescriptionKeyboard": `Pulse Intro para empezar a arrastrar.`,
  "dragDescriptionKeyboardAlt": `Pulse Intro para empezar a arrastrar.`,
  "dragDescriptionLongPress": `Mantenga pulsado para comenzar a arrastrar.`,
  "dragDescriptionTouch": `Pulse dos veces para iniciar el arrastre.`,
  "dragDescriptionVirtual": `Haga clic para iniciar el arrastre.`,
  "dragItem": (args) => `Arrastrar ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Arrastrar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} elemento seleccionado`,
    other: () => `${formatter.number(args.count)} elementos seleccionados`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Pulse Intro para arrastrar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} elemento seleccionado`,
    other: () => `${formatter.number(args.count)} elementos seleccionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Pulse Alt + Intro para arrastrar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} elemento seleccionado`,
    other: () => `${formatter.number(args.count)} elementos seleccionados`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Mantenga pulsado para arrastrar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} elemento seleccionado`,
    other: () => `${formatter.number(args.count)} elementos seleccionados`
  })}.`,
  "dragStartedKeyboard": `Se ha empezado a arrastrar. Pulse el tabulador para ir al público destinatario donde se vaya a colocar y, a continuación, pulse Intro para soltar, o pulse Escape para cancelar.`,
  "dragStartedTouch": `Se ha empezado a arrastrar. Vaya al público destinatario donde se vaya a colocar y, a continuación, pulse dos veces para soltar.`,
  "dragStartedVirtual": `Se ha empezado a arrastrar. Vaya al público destinatario donde se vaya a colocar y, a continuación, haga clic o pulse Intro para soltar.`,
  "dropCanceled": `Se ha cancelado la colocación.`,
  "dropComplete": `Colocación finalizada.`,
  "dropDescriptionKeyboard": `Pulse Intro para soltar. Pulse Escape para cancelar el arrastre.`,
  "dropDescriptionTouch": `Pulse dos veces para soltar.`,
  "dropDescriptionVirtual": `Haga clic para soltar.`,
  "dropIndicator": `indicador de colocación`,
  "dropOnItem": (args) => `Soltar en ${args.itemText}`,
  "dropOnRoot": `Soltar en`,
  "endDragKeyboard": `Arrastrando. Pulse Intro para cancelar el arrastre.`,
  "endDragTouch": `Arrastrando. Pulse dos veces para cancelar el arrastre.`,
  "endDragVirtual": `Arrastrando. Haga clic para cancelar el arrastre.`,
  "insertAfter": (args) => `Insertar después de ${args.itemText}`,
  "insertBefore": (args) => `Insertar antes de ${args.itemText}`,
  "insertBetween": (args) => `Insertar entre ${args.beforeItemText} y ${args.afterItemText}`
};
var $110bdd83348ecbc0$exports = {};
$110bdd83348ecbc0$exports = {
  "dragDescriptionKeyboard": `Lohistamise alustamiseks vajutage klahvi Enter.`,
  "dragDescriptionKeyboardAlt": `Lohistamise alustamiseks vajutage klahvikombinatsiooni Alt + Enter.`,
  "dragDescriptionLongPress": `Vajutage pikalt lohistamise alustamiseks.`,
  "dragDescriptionTouch": `Topeltpuudutage lohistamise alustamiseks.`,
  "dragDescriptionVirtual": `Klõpsake lohistamise alustamiseks.`,
  "dragItem": (args) => `Lohista ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Lohista ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valitud üksust`,
    other: () => `${formatter.number(args.count)} valitud üksust`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valitud üksuse`,
    other: () => `${formatter.number(args.count)} valitud üksuse`
  })} lohistamiseks vajutage sisestusklahvi Enter.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Lohistamiseks vajutage klahvikombinatsiooni Alt + Enter ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valitud üksuse`,
    other: () => `${formatter.number(args.count)} valitud üksuse`
  })} jaoks.`,
  "dragSelectedLongPress": (args, formatter) => `Pikk vajutus ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valitud üksuse`,
    other: () => `${formatter.number(args.count)} valitud üksuse`
  })} lohistamiseks.`,
  "dragStartedKeyboard": `Alustati lohistamist. Kukutamise sihtmärgi juurde navigeerimiseks vajutage klahvi Tab, seejärel vajutage kukutamiseks klahvi Enter või loobumiseks klahvi Escape.`,
  "dragStartedTouch": `Alustati lohistamist. Navigeerige kukutamise sihtmärgi juurde ja topeltpuudutage kukutamiseks.`,
  "dragStartedVirtual": `Alustati lohistamist. Navigeerige kukutamise sihtmärgi juurde ja kukutamiseks klõpsake või vajutage klahvi Enter.`,
  "dropCanceled": `Lohistamisest loobuti.`,
  "dropComplete": `Lohistamine on tehtud.`,
  "dropDescriptionKeyboard": `Kukutamiseks vajutage klahvi Enter. Lohistamisest loobumiseks vajutage klahvi Escape.`,
  "dropDescriptionTouch": `Kukutamiseks topeltpuudutage.`,
  "dropDescriptionVirtual": `Kukutamiseks klõpsake.`,
  "dropIndicator": `lohistamise indikaator`,
  "dropOnItem": (args) => `Kukuta asukohta ${args.itemText}`,
  "dropOnRoot": `Kukuta asukohta`,
  "endDragKeyboard": `Lohistamine. Lohistamisest loobumiseks vajutage klahvi Enter.`,
  "endDragTouch": `Lohistamine. Lohistamisest loobumiseks topeltpuudutage.`,
  "endDragVirtual": `Lohistamine. Lohistamisest loobumiseks klõpsake.`,
  "insertAfter": (args) => `Sisesta ${args.itemText} järele`,
  "insertBefore": (args) => `Sisesta ${args.itemText} ette`,
  "insertBetween": (args) => `Sisesta ${args.beforeItemText} ja ${args.afterItemText} vahele`
};
var $87d3ccd5e347c7cc$exports = {};
$87d3ccd5e347c7cc$exports = {
  "dragDescriptionKeyboard": `Aloita vetäminen painamalla Enter-näppäintä.`,
  "dragDescriptionKeyboardAlt": `Aloita vetäminen painamalla Alt + Enter -näppäinyhdistelmää.`,
  "dragDescriptionLongPress": `Aloita vetäminen pitämällä painettuna.`,
  "dragDescriptionTouch": `Aloita vetäminen kaksoisnapauttamalla.`,
  "dragDescriptionVirtual": `Aloita vetäminen napsauttamalla.`,
  "dragItem": (args) => `Vedä kohdetta ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Vedä ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valittua kohdetta`,
    other: () => `${formatter.number(args.count)} valittua kohdetta`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Vedä painamalla Enter ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valittu kohde`,
    other: () => `${formatter.number(args.count)} valittua kohdetta`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Vedä painamalla Alt + Enter ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valittu kohde`,
    other: () => `${formatter.number(args.count)} valittua kohdetta`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Vedä pitämällä painettuna ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valittu kohde`,
    other: () => `${formatter.number(args.count)} valittua kohdetta`
  })}.`,
  "dragStartedKeyboard": `Vetäminen aloitettu. Siirry pudotuskohteeseen painamalla sarkainnäppäintä ja sitten pudota painamalla Enter-näppäintä tai peruuta painamalla Escape-näppäintä.`,
  "dragStartedTouch": `Vetäminen aloitettu. Siirry pudotuskohteeseen ja pudota kaksoisnapauttamalla.`,
  "dragStartedVirtual": `Vetäminen aloitettu. Siirry pudotuskohteeseen ja pudota napsauttamalla tai painamalla Enter-näppäintä.`,
  "dropCanceled": `Pudotus peruutettu.`,
  "dropComplete": `Pudotus suoritettu.`,
  "dropDescriptionKeyboard": `Pudota painamalla Enter-näppäintä. Peruuta vetäminen painamalla Escape-näppäintä.`,
  "dropDescriptionTouch": `Pudota kaksoisnapauttamalla.`,
  "dropDescriptionVirtual": `Pudota napsauttamalla.`,
  "dropIndicator": `pudotuksen ilmaisin`,
  "dropOnItem": (args) => `Pudota kohteeseen ${args.itemText}`,
  "dropOnRoot": `Pudota kohteeseen`,
  "endDragKeyboard": `Vedetään. Peruuta vetäminen painamalla Enter-näppäintä.`,
  "endDragTouch": `Vedetään. Peruuta vetäminen kaksoisnapauttamalla.`,
  "endDragVirtual": `Vedetään. Peruuta vetäminen napsauttamalla.`,
  "insertAfter": (args) => `Lisää kohteen ${args.itemText} jälkeen`,
  "insertBefore": (args) => `Lisää ennen kohdetta ${args.itemText}`,
  "insertBetween": (args) => `Lisää kohteiden ${args.beforeItemText} ja ${args.afterItemText} väliin`
};
var $a5de891427686596$exports = {};
$a5de891427686596$exports = {
  "dragDescriptionKeyboard": `Appuyez sur Entrée pour commencer le déplacement.`,
  "dragDescriptionKeyboardAlt": `Appuyez sur Alt + Entrée pour commencer à faire glisser.`,
  "dragDescriptionLongPress": `Appuyez de manière prolongée pour commencer à faire glisser.`,
  "dragDescriptionTouch": `Touchez deux fois pour commencer le déplacement.`,
  "dragDescriptionVirtual": `Cliquez pour commencer le déplacement.`,
  "dragItem": (args) => `Déplacer ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Déplacer ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} élément sélectionné`,
    other: () => `${formatter.number(args.count)} éléments sélectionnés`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Appuyez sur Entrée pour faire glisser ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} élément sélectionné`,
    other: () => `${formatter.number(args.count)} éléments sélectionnés`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Appuyez sur Alt + Entrée pour faire glisser ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} élément sélectionné`,
    other: () => `${formatter.number(args.count)} éléments sélectionnés`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Appuyez de manière prolongée pour faire glisser ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} élément sélectionné`,
    other: () => `${formatter.number(args.count)} éléments sélectionnés`
  })}.`,
  "dragStartedKeyboard": `Déplacement commencé. Appuyez sur Tabulation pour accéder à une cible de dépôt, puis appuyez sur Entrée pour déposer, ou appuyez sur Échap pour annuler.`,
  "dragStartedTouch": `Déplacement commencé. Accédez à une cible de dépôt, puis touchez deux fois pour déposer.`,
  "dragStartedVirtual": `Déplacement commencé. Accédez à une cible de dépôt, puis cliquez ou appuyez sur Entrée pour déposer.`,
  "dropCanceled": `Dépôt annulé.`,
  "dropComplete": `Dépôt terminé.`,
  "dropDescriptionKeyboard": `Appuyez sur Entrée pour déposer. Appuyez sur Échap pour annuler le déplacement.`,
  "dropDescriptionTouch": `Touchez deux fois pour déposer.`,
  "dropDescriptionVirtual": `Cliquez pour déposer.`,
  "dropIndicator": `indicateur de dépôt`,
  "dropOnItem": (args) => `Déposer sur ${args.itemText}`,
  "dropOnRoot": `Déposer sur`,
  "endDragKeyboard": `Déplacement. Appuyez sur Entrée pour annuler le déplacement.`,
  "endDragTouch": `Déplacement. Touchez deux fois pour annuler le déplacement.`,
  "endDragVirtual": `Déplacement. Cliquez pour annuler le déplacement.`,
  "insertAfter": (args) => `Insérer après ${args.itemText}`,
  "insertBefore": (args) => `Insérer avant ${args.itemText}`,
  "insertBetween": (args) => `Insérer entre ${args.beforeItemText} et ${args.afterItemText}`
};
var $ad7f4c66d85b4494$exports = {};
$ad7f4c66d85b4494$exports = {
  "dragDescriptionKeyboard": `הקש על Enter כדי להתחיל לגרור.`,
  "dragDescriptionKeyboardAlt": `הקש Alt + Enter כדי להתחיל לגרור.`,
  "dragDescriptionLongPress": `לחץ לחיצה ארוכה כדי להתחיל לגרור.`,
  "dragDescriptionTouch": `הקש פעמיים כדי להתחיל בגרירה.`,
  "dragDescriptionVirtual": `לחץ כדי להתחיל לגרור.`,
  "dragItem": (args) => `גרור את ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `גרור ${formatter.plural(args.count, {
    one: () => `פריט נבחר ${formatter.number(args.count)}`,
    other: () => `${formatter.number(args.count)} פריטים שנבחרו`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `הקש על Enter כדי לגרור ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} פריט שנבחר`,
    other: () => `${formatter.number(args.count)} פריטים שנבחרו`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `הקש Alt + Enter כדי לגרור ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} פריט שנבחר`,
    other: () => `${formatter.number(args.count)} פריטים שנבחרו`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `לחץ לחיצה ארוכה כדי לגרור ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} פריט שנבחר`,
    other: () => `${formatter.number(args.count)} פריטים שנבחרו`
  })}.`,
  "dragStartedKeyboard": `התחלת לגרור. הקש על Tab כדי לנווט לנקודת הגרירה ולאחר מכן הקש על Enter כדי לשחרר או על Escape כדי לבטל.`,
  "dragStartedTouch": `התחלת לגרור. נווט לנקודת השחרור ולאחר מכן הקש פעמיים כדי לשחרר.`,
  "dragStartedVirtual": `התחלת לגרור. נווט לנקודת השחרור ולאחר מכן לחץ או הקש על Enter כדי לשחרר.`,
  "dropCanceled": `השחרור בוטל.`,
  "dropComplete": `השחרור הושלם.`,
  "dropDescriptionKeyboard": `הקש על Enter כדי לשחרר. הקש על Escape כדי לבטל את הגרירה.`,
  "dropDescriptionTouch": `הקש פעמיים כדי לשחרר.`,
  "dropDescriptionVirtual": `לחץ כדי לשחרר.`,
  "dropIndicator": `מחוון שחרור`,
  "dropOnItem": (args) => `שחרר על ${args.itemText}`,
  "dropOnRoot": `שחרר על`,
  "endDragKeyboard": `גורר. הקש על Enter כדי לבטל את הגרירה.`,
  "endDragTouch": `גורר. הקש פעמיים כדי לבטל את הגרירה.`,
  "endDragVirtual": `גורר. לחץ כדי לבטל את הגרירה.`,
  "insertAfter": (args) => `הוסף אחרי ${args.itemText}`,
  "insertBefore": (args) => `הוסף לפני ${args.itemText}`,
  "insertBetween": (args) => `הוסף בין ${args.beforeItemText} לבין ${args.afterItemText}`
};
var $4aa59f3c6a796cae$exports = {};
$4aa59f3c6a796cae$exports = {
  "dragDescriptionKeyboard": `Pritisnite Enter da biste počeli povlačiti.`,
  "dragDescriptionKeyboardAlt": `Pritisnite Alt + Enter za početak povlačenja.`,
  "dragDescriptionLongPress": `Dugo pritisnite za početak povlačenja.`,
  "dragDescriptionTouch": `Dvaput dodirnite da biste počeli povlačiti.`,
  "dragDescriptionVirtual": `Kliknite da biste počeli povlačiti.`,
  "dragItem": (args) => `Povucite stavku ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Povucite ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} odabranu stavku`,
    other: () => `ovoliko odabranih stavki: ${formatter.number(args.count)}`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Pritisnite Enter za povlačenje ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} odabrana stavka`,
    other: () => `${formatter.number(args.count)} odabrane stavke`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Pritisnite Alt + Enter za povlačenje ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} odabrana stavka`,
    other: () => `${formatter.number(args.count)} odabrane stavke`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Dugo pritisnite za povlačenje ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} odabrana stavka`,
    other: () => `${formatter.number(args.count)} odabrane stavke`
  })}.`,
  "dragStartedKeyboard": `Počeli ste povlačiti. Pritisnite tipku tabulatora da biste došli do cilja ispuštanja, a zatim Enter da biste ispustili stavku ili Escape da biste prekinuli povlačenje.`,
  "dragStartedTouch": `Počeli ste povlačiti. Dođite do cilja ispuštanja, a zatim dvaput dodirnite da biste ispustili stavku.`,
  "dragStartedVirtual": `Počeli ste povlačiti. Dođite do cilja ispuštanja, a zatim kliknite ili pritisnite Enter da biste ispustili stavku.`,
  "dropCanceled": `Povlačenje je prekinuto.`,
  "dropComplete": `Ispuštanje je dovršeno.`,
  "dropDescriptionKeyboard": `Pritisnite Enter da biste ispustili stavku. Pritisnite Escape da biste prekinuli povlačenje.`,
  "dropDescriptionTouch": `Dvaput dodirnite da biste ispustili stavku.`,
  "dropDescriptionVirtual": `Kliknite da biste ispustili stavku.`,
  "dropIndicator": `pokazatelj ispuštanja`,
  "dropOnItem": (args) => `Ispustite na stavku ${args.itemText}`,
  "dropOnRoot": `Ispustite na`,
  "endDragKeyboard": `Povlačenje. Pritisnite Enter da biste prekinuli povlačenje.`,
  "endDragTouch": `Povlačenje. Dvaput dodirnite da biste prekinuli povlačenje.`,
  "endDragVirtual": `Povlačenje. Kliknite da biste prekinuli povlačenje.`,
  "insertAfter": (args) => `Umetnite iza stavke ${args.itemText}`,
  "insertBefore": (args) => `Ispustite ispred stavke ${args.itemText}`,
  "insertBetween": (args) => `Umetnite između stavki ${args.beforeItemText} i ${args.afterItemText}`
};
var $d8d3646556c40586$exports = {};
$d8d3646556c40586$exports = {
  "dragDescriptionKeyboard": `Nyomja le az Enter billentyűt a húzás megkezdéséhez.`,
  "dragDescriptionKeyboardAlt": `Nyomja le az Alt + Enter billentyűket a húzás megkezdéséhez.`,
  "dragDescriptionLongPress": `Hosszan nyomja meg a húzás elindításához.`,
  "dragDescriptionTouch": `Koppintson duplán a húzás megkezdéséhez.`,
  "dragDescriptionVirtual": `Kattintson a húzás megkezdéséhez.`,
  "dragItem": (args) => `${args.itemText} húzása`,
  "dragSelectedItems": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} kijelölt elem`,
    other: () => `${formatter.number(args.count)} kijelölt elem`
  })} húzása`,
  "dragSelectedKeyboard": (args, formatter) => `Nyomja meg az Entert ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} kijelölt elem`,
    other: () => `${formatter.number(args.count)} kijelölt elem`
  })} húzásához.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Nyomja meg az Alt + Enter billentyűket ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} kijelölt elem`,
    other: () => `${formatter.number(args.count)} kijelölt elem`
  })} húzásához.`,
  "dragSelectedLongPress": (args, formatter) => `Tartsa lenyomva hosszan ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} kijelölt elem`,
    other: () => `${formatter.number(args.count)} kijelölt elem`
  })} húzásához.`,
  "dragStartedKeyboard": `Húzás megkezdve. Nyomja le a Tab billentyűt az elengedési célhoz navigálásához, majd nyomja le az Enter billentyűt az elengedéshez, vagy nyomja le az Escape billentyűt a megszakításhoz.`,
  "dragStartedTouch": `Húzás megkezdve. Navigáljon egy elengedési célhoz, majd koppintson duplán az elengedéshez.`,
  "dragStartedVirtual": `Húzás megkezdve. Navigáljon egy elengedési célhoz, majd kattintson vagy nyomja le az Enter billentyűt az elengedéshez.`,
  "dropCanceled": `Elengedés megszakítva.`,
  "dropComplete": `Elengedés teljesítve.`,
  "dropDescriptionKeyboard": `Nyomja le az Enter billentyűt az elengedéshez. Nyomja le az Escape billentyűt a húzás megszakításához.`,
  "dropDescriptionTouch": `Koppintson duplán az elengedéshez.`,
  "dropDescriptionVirtual": `Kattintson az elengedéshez.`,
  "dropIndicator": `elengedésjelző`,
  "dropOnItem": (args) => `Elengedés erre: ${args.itemText}`,
  "dropOnRoot": `Elengedés erre:`,
  "endDragKeyboard": `Húzás folyamatban. Nyomja le az Enter billentyűt a húzás megszakításához.`,
  "endDragTouch": `Húzás folyamatban. Koppintson duplán a húzás megszakításához.`,
  "endDragVirtual": `Húzás folyamatban. Kattintson a húzás megszakításához.`,
  "insertAfter": (args) => `Beszúrás ${args.itemText} után`,
  "insertBefore": (args) => `Beszúrás ${args.itemText} elé`,
  "insertBetween": (args) => `Beszúrás ${args.beforeItemText} és ${args.afterItemText} közé`
};
var $982d558b45395246$exports = {};
$982d558b45395246$exports = {
  "dragDescriptionKeyboard": `Premi Invio per iniziare a trascinare.`,
  "dragDescriptionKeyboardAlt": `Premi Alt + Invio per iniziare a trascinare.`,
  "dragDescriptionLongPress": `Premi a lungo per iniziare a trascinare.`,
  "dragDescriptionTouch": `Tocca due volte per iniziare a trascinare.`,
  "dragDescriptionVirtual": `Fai clic per iniziare a trascinare.`,
  "dragItem": (args) => `Trascina ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Trascina ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} altro elemento selezionato`,
    other: () => `${formatter.number(args.count)} altri elementi selezionati`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Premi Invio per trascinare ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} elemento selezionato`,
    other: () => `${formatter.number(args.count)} elementi selezionati`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Premi Alt + Invio per trascinare ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} elemento selezionato`,
    other: () => `${formatter.number(args.count)} elementi selezionati`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Premi a lungo per trascinare ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} elemento selezionato`,
    other: () => `${formatter.number(args.count)} elementi selezionati`
  })}.`,
  "dragStartedKeyboard": `Hai iniziato a trascinare. Premi Tab per arrivare sull’area di destinazione, quindi premi Invio per rilasciare o Esc per annullare.`,
  "dragStartedTouch": `Hai iniziato a trascinare. Arriva sull’area di destinazione, quindi tocca due volte per rilasciare.`,
  "dragStartedVirtual": `Hai iniziato a trascinare. Arriva sull’area di destinazione, quindi fai clic o premi Invio per rilasciare.`,
  "dropCanceled": `Rilascio annullato.`,
  "dropComplete": `Rilascio completato.`,
  "dropDescriptionKeyboard": `Premi Invio per rilasciare. Premi Esc per annullare.`,
  "dropDescriptionTouch": `Tocca due volte per rilasciare.`,
  "dropDescriptionVirtual": `Fai clic per rilasciare.`,
  "dropIndicator": `indicatore di rilascio`,
  "dropOnItem": (args) => `Rilascia su ${args.itemText}`,
  "dropOnRoot": `Rilascia su`,
  "endDragKeyboard": `Trascinamento. Premi Invio per annullare.`,
  "endDragTouch": `Trascinamento. Tocca due volte per annullare.`,
  "endDragVirtual": `Trascinamento. Fai clic per annullare.`,
  "insertAfter": (args) => `Inserisci dopo ${args.itemText}`,
  "insertBefore": (args) => `Inserisci prima di ${args.itemText}`,
  "insertBetween": (args) => `Inserisci tra ${args.beforeItemText} e ${args.afterItemText}`
};
var $6a0cf387b9de036c$exports = {};
$6a0cf387b9de036c$exports = {
  "dragDescriptionKeyboard": `Enter キーを押してドラッグを開始してください。`,
  "dragDescriptionKeyboardAlt": `Alt+Enter キーを押してドラッグを開始します。`,
  "dragDescriptionLongPress": `長押ししてドラッグを開始します。`,
  "dragDescriptionTouch": `ダブルタップしてドラッグを開始します。`,
  "dragDescriptionVirtual": `クリックしてドラッグを開始します。`,
  "dragItem": (args) => `${args.itemText} をドラッグ`,
  "dragSelectedItems": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 個の選択項目`,
    other: () => `${formatter.number(args.count)} 個の選択項目`
  })} をドラッグ`,
  "dragSelectedKeyboard": (args, formatter) => `Enter キーを押して、${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 選択した項目`,
    other: () => `${formatter.number(args.count)} 選択した項目`
  })}をドラッグします。`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Alt+Enter キーを押して、${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 選択した項目`,
    other: () => `${formatter.number(args.count)} 選択した項目`
  })}をドラッグします。`,
  "dragSelectedLongPress": (args, formatter) => `長押しして、${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 選択した項目`,
    other: () => `${formatter.number(args.count)} 選択した項目`
  })}をドラッグします。`,
  "dragStartedKeyboard": `ドラッグを開始します。Tab キーを押してドロップターゲットにいどうし、Enter キーを押してドロップするか、Esc キーを押してキャンセルします。`,
  "dragStartedTouch": `ドラッグを開始しました。ドロップのターゲットに移動し、ダブルタップしてドロップします。`,
  "dragStartedVirtual": `ドラッグを開始しました。ドロップのターゲットに移動し、クリックまたは Enter キーを押してドロップします。`,
  "dropCanceled": `ドロップがキャンセルされました。`,
  "dropComplete": `ドロップが完了しました。`,
  "dropDescriptionKeyboard": `Enter キーを押してドロップします。Esc キーを押してドラッグをキャンセルします。`,
  "dropDescriptionTouch": `ダブルタップしてドロップします。`,
  "dropDescriptionVirtual": `クリックしてドロップします。`,
  "dropIndicator": `ドロップインジケーター`,
  "dropOnItem": (args) => `${args.itemText} にドロップ`,
  "dropOnRoot": `ドロップ場所`,
  "endDragKeyboard": `ドラッグしています。Enter キーを押してドラッグをキャンセルします。`,
  "endDragTouch": `ドラッグしています。ダブルタップしてドラッグをキャンセルします。`,
  "endDragVirtual": `ドラッグしています。クリックしてドラッグをキャンセルします。`,
  "insertAfter": (args) => `${args.itemText} の後に挿入`,
  "insertBefore": (args) => `${args.itemText} の前に挿入`,
  "insertBetween": (args) => `${args.beforeItemText} と ${args.afterItemText} の間に挿入`
};
var $a97fefa2956f4bcb$exports = {};
$a97fefa2956f4bcb$exports = {
  "dragDescriptionKeyboard": `드래그를 시작하려면 Enter를 누르세요.`,
  "dragDescriptionKeyboardAlt": `드래그를 시작하려면 Alt + Enter를 누르십시오.`,
  "dragDescriptionLongPress": `드래그를 시작하려면 길게 누르십시오.`,
  "dragDescriptionTouch": `드래그를 시작하려면 더블 탭하세요.`,
  "dragDescriptionVirtual": `드래그를 시작하려면 클릭하세요.`,
  "dragItem": (args) => `${args.itemText} 드래그`,
  "dragSelectedItems": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)}개 선택 항목`,
    other: () => `${formatter.number(args.count)}개 선택 항목`
  })} 드래그`,
  "dragSelectedKeyboard": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)}개 선택 항목`,
    other: () => `${formatter.number(args.count)}개 선택 항목`
  })}을 드래그하려면 Enter를 누르십시오.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)}개 선택 항목`,
    other: () => `${formatter.number(args.count)}개 선택 항목`
  })}을 드래그하려면 Alt + Enter를 누르십시오.`,
  "dragSelectedLongPress": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)}개 선택 항목`,
    other: () => `${formatter.number(args.count)}개 선택 항목`
  })}을 드래그하려면 길게 누르십시오.`,
  "dragStartedKeyboard": `드래그가 시작되었습니다. Tab을 눌러 드롭 대상으로 이동한 다음 Enter를 눌러 드롭하거나 Esc를 눌러 취소하세요.`,
  "dragStartedTouch": `드래그가 시작되었습니다. 드롭 대상으로 이동한 다음 더블 탭하여 드롭하세요.`,
  "dragStartedVirtual": `드래그가 시작되었습니다. 드롭 대상으로 이동한 다음 클릭하거나 Enter를 눌러 드롭하세요.`,
  "dropCanceled": `드롭이 취소되었습니다.`,
  "dropComplete": `드롭이 완료되었습니다.`,
  "dropDescriptionKeyboard": `드롭하려면 Enter를 누르세요. 드래그를 취소하려면 Esc를 누르세요.`,
  "dropDescriptionTouch": `더블 탭하여 드롭하세요.`,
  "dropDescriptionVirtual": `드롭하려면 클릭하세요.`,
  "dropIndicator": `드롭 표시기`,
  "dropOnItem": (args) => `${args.itemText}에 드롭`,
  "dropOnRoot": `드롭 대상`,
  "endDragKeyboard": `드래그 중입니다. 드래그를 취소하려면 Enter를 누르세요.`,
  "endDragTouch": `드래그 중입니다. 드래그를 취소하려면 더블 탭하세요.`,
  "endDragVirtual": `드래그 중입니다. 드래그를 취소하려면 클릭하세요.`,
  "insertAfter": (args) => `${args.itemText} 이후에 삽입`,
  "insertBefore": (args) => `${args.itemText} 이전에 삽입`,
  "insertBetween": (args) => `${args.beforeItemText} 및 ${args.afterItemText} 사이에 삽입`
};
var $5fb5837f94e1c150$exports = {};
$5fb5837f94e1c150$exports = {
  "dragDescriptionKeyboard": `Paspauskite „Enter“, kad pradėtumėte vilkti.`,
  "dragDescriptionKeyboardAlt": `Paspauskite „Alt + Enter“, kad pradėtumėte vilkti.`,
  "dragDescriptionLongPress": `Palaikykite nuspaudę, kad pradėtumėte vilkti.`,
  "dragDescriptionTouch": `Palieskite dukart, kad pradėtumėte vilkti.`,
  "dragDescriptionVirtual": `Spustelėkite, kad pradėtumėte vilkti.`,
  "dragItem": (args) => `Vilkti ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Vilkti ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args.count)} pasirinktus elementus`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Paspauskite „Enter“, jei norite nuvilkti ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args.count)} pasirinktus elementus`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Paspauskite „Alt + Enter“, kad nuvilktumėte ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args.count)} pasirinktus elementus`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Nuspaudę palaikykite, kad nuvilktumėte ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} pasirinktą elementą`,
    other: () => `${formatter.number(args.count)} pasirinktus elementus`
  })}.`,
  "dragStartedKeyboard": `Pradėta vilkti. Paspauskite „Tab“, kad pereitumėte į tiesioginę paskirties vietą, tada paspauskite „Enter“, kad numestumėte, arba „Escape“, kad atšauktumėte.`,
  "dragStartedTouch": `Pradėta vilkti. Eikite į tiesioginę paskirties vietą, tada palieskite dukart, kad numestumėte.`,
  "dragStartedVirtual": `Pradėta vilkti. Eikite į tiesioginę paskirties vietą ir spustelėkite arba paspauskite „Enter“, kad numestumėte.`,
  "dropCanceled": `Numetimas atšauktas.`,
  "dropComplete": `Numesta.`,
  "dropDescriptionKeyboard": `Paspauskite „Enter“, kad numestumėte. Paspauskite „Escape“, kad atšauktumėte vilkimą.`,
  "dropDescriptionTouch": `Palieskite dukart, kad numestumėte.`,
  "dropDescriptionVirtual": `Spustelėkite, kad numestumėte.`,
  "dropIndicator": `numetimo indikatorius`,
  "dropOnItem": (args) => `Numesti ant ${args.itemText}`,
  "dropOnRoot": `Numesti ant`,
  "endDragKeyboard": `Velkama. Paspauskite „Enter“, kad atšauktumėte vilkimą.`,
  "endDragTouch": `Velkama. Spustelėkite dukart, kad atšauktumėte vilkimą.`,
  "endDragVirtual": `Velkama. Spustelėkite, kad atšauktumėte vilkimą.`,
  "insertAfter": (args) => `Įterpti po ${args.itemText}`,
  "insertBefore": (args) => `Įterpti prieš ${args.itemText}`,
  "insertBetween": (args) => `Įterpti tarp ${args.beforeItemText} ir ${args.afterItemText}`
};
var $5b2e5709864cc922$exports = {};
$5b2e5709864cc922$exports = {
  "dragDescriptionKeyboard": `Nospiediet Enter, lai sāktu vilkšanu.`,
  "dragDescriptionKeyboardAlt": `Nospiediet taustiņu kombināciju Alt+Enter, lai sāktu vilkšanu.`,
  "dragDescriptionLongPress": `Turiet nospiestu, lai sāktu vilkšanu.`,
  "dragDescriptionTouch": `Veiciet dubultskārienu, lai sāktu vilkšanu.`,
  "dragDescriptionVirtual": `Noklikšķiniet, lai sāktu vilkšanu.`,
  "dragItem": (args) => `Velciet ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Velciet ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args.count)} atlasītos vienumus`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Nospiediet taustiņu Enter, lai vilktu ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args.count)} atlasītos vienumus`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Nospiediet taustiņu kombināciju Alt+Enter, lai vilktu ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args.count)} atlasītos vienumus`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Turiet nospiestu, lai vilktu ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} atlasīto vienumu`,
    other: () => `${formatter.number(args.count)} atlasītos vienumus`
  })}.`,
  "dragStartedKeyboard": `Uzsākta vilkšana. Nospiediet taustiņu Tab, lai pārietu uz nomešanas mērķi, pēc tam nospiediet Enter, lai nomestu, vai nospiediet Escape, lai atceltu.`,
  "dragStartedTouch": `Uzsākta vilkšana. Pārejiet uz nomešanas mērķi, pēc tam veiciet dubultskārienu, lai nomestu.`,
  "dragStartedVirtual": `Uzsākta vilkšana. Pārejiet uz nomešanas mērķi, pēc tam nospiediet Enter, lai nomestu.`,
  "dropCanceled": `Nomešana atcelta.`,
  "dropComplete": `Nomešana pabeigta.`,
  "dropDescriptionKeyboard": `Nospiediet Enter, lai nomestu. Nospiediet Escape, lai atceltu vilkšanu.`,
  "dropDescriptionTouch": `Veiciet dubultskārienu, lai nomestu.`,
  "dropDescriptionVirtual": `Noklikšķiniet, lai nomestu.`,
  "dropIndicator": `nomešanas indikators`,
  "dropOnItem": (args) => `Nometiet uz ${args.itemText}`,
  "dropOnRoot": `Nometiet uz`,
  "endDragKeyboard": `Notiek vilkšana. Nospiediet Enter, lai atceltu vilkšanu.`,
  "endDragTouch": `Notiek vilkšana. Veiciet dubultskārienu, lai atceltu vilkšanu.`,
  "endDragVirtual": `Notiek vilkšana. Noklikšķiniet, lai atceltu vilkšanu.`,
  "insertAfter": (args) => `Ievietojiet pēc ${args.itemText}`,
  "insertBefore": (args) => `Ievietojiet pirms ${args.itemText}`,
  "insertBetween": (args) => `Ievietojiet starp ${args.beforeItemText} un ${args.afterItemText}`
};
var $ee15bb8efb18cc69$exports = {};
$ee15bb8efb18cc69$exports = {
  "dragDescriptionKeyboard": `Trykk på Enter for å begynne å dra.`,
  "dragDescriptionKeyboardAlt": `Trykk på Alt + Enter for å begynne å dra.`,
  "dragDescriptionLongPress": `Trykk lenge for å begynne å dra.`,
  "dragDescriptionTouch": `Dobbelttrykk for å begynne å dra.`,
  "dragDescriptionVirtual": `Klikk for å begynne å dra.`,
  "dragItem": (args) => `Dra ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Dra ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} merket element`,
    other: () => `${formatter.number(args.count)} merkede elementer`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Trykk Enter for å dra ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valgt element`,
    other: () => `${formatter.number(args.count)} valgte elementer`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Trykk på Alt + Enter for å dra ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valgt element`,
    other: () => `${formatter.number(args.count)} valgte elementer`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Trykk lenge for å dra ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valgt element`,
    other: () => `${formatter.number(args.count)} valgte elementer`
  })}.`,
  "dragStartedKeyboard": `Begynte å dra. Trykk på Tab for å navigere til et mål, og trykk deretter på Enter for å slippe eller på Esc for å avbryte.`,
  "dragStartedTouch": `Begynte å dra. Naviger til et mål, og dobbelttrykk for å slippe.`,
  "dragStartedVirtual": `Begynte å dra. Naviger til et mål, og klikk eller trykk på Enter for å slippe.`,
  "dropCanceled": `Avbrøt slipping.`,
  "dropComplete": `Slippingen er fullført.`,
  "dropDescriptionKeyboard": `Trykk på Enter for å slippe. Trykk på Esc hvis du vil avbryte draingen.`,
  "dropDescriptionTouch": `Dobbelttrykk for å slippe.`,
  "dropDescriptionVirtual": `Klikk for å slippe.`,
  "dropIndicator": `slippeindikator`,
  "dropOnItem": (args) => `Slipp på ${args.itemText}`,
  "dropOnRoot": `Slipp på`,
  "endDragKeyboard": `Drar. Trykk på Enter hvis du vil avbryte.`,
  "endDragTouch": `Drar. Dobbelttrykk hvis du vil avbryte.`,
  "endDragVirtual": `Drar. Klikk hvis du vil avbryte.`,
  "insertAfter": (args) => `Sett inn etter ${args.itemText}`,
  "insertBefore": (args) => `Sett inn før ${args.itemText}`,
  "insertBetween": (args) => `Sett inn mellom ${args.beforeItemText} og ${args.afterItemText}`
};
var $1daf2d4602e26ac4$exports = {};
$1daf2d4602e26ac4$exports = {
  "dragDescriptionKeyboard": `Druk op Enter om te slepen.`,
  "dragDescriptionKeyboardAlt": `Druk op Alt + Enter om te slepen.`,
  "dragDescriptionLongPress": `Houd lang ingedrukt om te slepen.`,
  "dragDescriptionTouch": `Dubbeltik om te slepen.`,
  "dragDescriptionVirtual": `Klik om met slepen te starten.`,
  "dragItem": (args) => `${args.itemText} slepen`,
  "dragSelectedItems": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} geselecteerd item`,
    other: () => `${formatter.number(args.count)} geselecteerde items`
  })} slepen`,
  "dragSelectedKeyboard": (args, formatter) => `Druk op Enter om ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} geselecteerd item`,
    other: () => `${formatter.number(args.count)} geselecteerde items`
  })} te slepen.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Druk op Alt + Enter om ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} geselecteerd item`,
    other: () => `${formatter.number(args.count)} geselecteerde items`
  })} te slepen.`,
  "dragSelectedLongPress": (args, formatter) => `Houd lang ingedrukt om ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} geselecteerd item`,
    other: () => `${formatter.number(args.count)} geselecteerde items`
  })} te slepen.`,
  "dragStartedKeyboard": `Begonnen met slepen. Druk op Tab om naar een locatie te gaan. Druk dan op Enter om neer te zetten, of op Esc om te annuleren.`,
  "dragStartedTouch": `Begonnen met slepen. Ga naar de gewenste locatie en dubbeltik om neer te zetten.`,
  "dragStartedVirtual": `Begonnen met slepen. Ga naar de gewenste locatie en klik of druk op Enter om neer te zetten.`,
  "dropCanceled": `Neerzetten geannuleerd.`,
  "dropComplete": `Neerzetten voltooid.`,
  "dropDescriptionKeyboard": `Druk op Enter om neer te zetten. Druk op Esc om het slepen te annuleren.`,
  "dropDescriptionTouch": `Dubbeltik om neer te zetten.`,
  "dropDescriptionVirtual": `Klik om neer te zetten.`,
  "dropIndicator": `aanwijzer voor neerzetten`,
  "dropOnItem": (args) => `Neerzetten op ${args.itemText}`,
  "dropOnRoot": `Neerzetten op`,
  "endDragKeyboard": `Bezig met slepen. Druk op Enter om te annuleren.`,
  "endDragTouch": `Bezig met slepen. Dubbeltik om te annuleren.`,
  "endDragVirtual": `Bezig met slepen. Klik om te annuleren.`,
  "insertAfter": (args) => `Plaatsen na ${args.itemText}`,
  "insertBefore": (args) => `Plaatsen vóór ${args.itemText}`,
  "insertBetween": (args) => `Plaatsen tussen ${args.beforeItemText} en ${args.afterItemText}`
};
var $7115429b0f60511f$exports = {};
$7115429b0f60511f$exports = {
  "dragDescriptionKeyboard": `Naciśnij Enter, aby rozpocząć przeciąganie.`,
  "dragDescriptionKeyboardAlt": `Naciśnij Alt + Enter, aby rozpocząć przeciąganie.`,
  "dragDescriptionLongPress": `Naciśnij i przytrzymaj, aby rozpocząć przeciąganie.`,
  "dragDescriptionTouch": `Dotknij dwukrotnie, aby rozpocząć przeciąganie.`,
  "dragDescriptionVirtual": `Kliknij, aby rozpocząć przeciąganie.`,
  "dragItem": (args) => `Przeciągnij ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Przeciągnij ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} wybrany element`,
    other: () => `${formatter.number(args.count)} wybranych elementów`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Naciśnij Enter, aby przeciągnąć ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} wybrany element`,
    other: () => `${formatter.number(args.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Naciśnij Alt + Enter, aby przeciągnąć ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} wybrany element`,
    other: () => `${formatter.number(args.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Naciśnij i przytrzymaj, aby przeciągnąć ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} wybrany element`,
    other: () => `${formatter.number(args.count)} wybrane(-ych) elementy(-ów)`
  })}.`,
  "dragStartedKeyboard": `Rozpoczęto przeciąganie. Naciśnij Tab, aby wybrać miejsce docelowe, a następnie naciśnij Enter, aby upuścić, lub Escape, aby anulować.`,
  "dragStartedTouch": `Rozpoczęto przeciąganie. Wybierz miejsce, w którym chcesz upuścić element, a następnie dotknij dwukrotnie, aby upuścić.F`,
  "dragStartedVirtual": `Rozpoczęto przeciąganie. Wybierz miejsce, w którym chcesz upuścić element, a następnie kliknij lub naciśnij Enter, aby upuścić.`,
  "dropCanceled": `Anulowano upuszczenie.`,
  "dropComplete": `Zakończono upuszczanie.`,
  "dropDescriptionKeyboard": `Naciśnij Enter, aby upuścić. Naciśnij Escape, aby anulować przeciągnięcie.`,
  "dropDescriptionTouch": `Dotknij dwukrotnie, aby upuścić.`,
  "dropDescriptionVirtual": `Kliknij, aby upuścić.`,
  "dropIndicator": `wskaźnik upuszczenia`,
  "dropOnItem": (args) => `Upuść na ${args.itemText}`,
  "dropOnRoot": `Upuść`,
  "endDragKeyboard": `Przeciąganie. Naciśnij Enter, aby anulować przeciągnięcie.`,
  "endDragTouch": `Przeciąganie. Kliknij dwukrotnie, aby anulować przeciągnięcie.`,
  "endDragVirtual": `Przeciąganie. Kliknij, aby anulować przeciąganie.`,
  "insertAfter": (args) => `Umieść za ${args.itemText}`,
  "insertBefore": (args) => `Umieść przed ${args.itemText}`,
  "insertBetween": (args) => `Umieść między ${args.beforeItemText} i ${args.afterItemText}`
};
var $5edd453ae5d4a8bc$exports = {};
$5edd453ae5d4a8bc$exports = {
  "dragDescriptionKeyboard": `Pressione Enter para começar a arrastar.`,
  "dragDescriptionKeyboardAlt": `Pressione Alt + Enter para começar a arrastar.`,
  "dragDescriptionLongPress": `Pressione e segure para começar a arrastar.`,
  "dragDescriptionTouch": `Toque duas vezes para começar a arrastar.`,
  "dragDescriptionVirtual": `Clique para começar a arrastar.`,
  "dragItem": (args) => `Arrastar ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Arrastar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} item selecionado`,
    other: () => `${formatter.number(args.count)} itens selecionados`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Pressione Enter para arrastar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} o item selecionado`,
    other: () => `${formatter.number(args.count)} os itens selecionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Pressione Alt + Enter para arrastar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} o item selecionado`,
    other: () => `${formatter.number(args.count)} os itens selecionados`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Pressione e segure para arrastar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} o item selecionado`,
    other: () => `${formatter.number(args.count)} os itens selecionados`
  })}.`,
  "dragStartedKeyboard": `Comece a arrastar. Pressione Tab para navegar até um alvo e, em seguida, pressione Enter para soltar ou pressione Escape para cancelar.`,
  "dragStartedTouch": `Comece a arrastar. Navegue até um alvo e toque duas vezes para soltar.`,
  "dragStartedVirtual": `Comece a arrastar. Navegue até um alvo e clique ou pressione Enter para soltar.`,
  "dropCanceled": `Liberação cancelada.`,
  "dropComplete": `Liberação concluída.`,
  "dropDescriptionKeyboard": `Pressione Enter para soltar. Pressione Escape para cancelar.`,
  "dropDescriptionTouch": `Toque duas vezes para soltar.`,
  "dropDescriptionVirtual": `Clique para soltar.`,
  "dropIndicator": `indicador de liberação`,
  "dropOnItem": (args) => `Soltar em ${args.itemText}`,
  "dropOnRoot": `Soltar`,
  "endDragKeyboard": `Arrastando. Pressione Enter para cancelar.`,
  "endDragTouch": `Arrastando. Toque duas vezes para cancelar.`,
  "endDragVirtual": `Arrastando. Clique para cancelar.`,
  "insertAfter": (args) => `Inserir após ${args.itemText}`,
  "insertBefore": (args) => `Inserir antes de ${args.itemText}`,
  "insertBetween": (args) => `Inserir entre ${args.beforeItemText} e ${args.afterItemText}`
};
var $5f431994f708535e$exports = {};
$5f431994f708535e$exports = {
  "dragDescriptionKeyboard": `Prima Enter para iniciar o arrasto.`,
  "dragDescriptionKeyboardAlt": `Prima Alt + Enter para iniciar o arrasto.`,
  "dragDescriptionLongPress": `Prima longamente para começar a arrastar.`,
  "dragDescriptionTouch": `Faça duplo toque para começar a arrastar.`,
  "dragDescriptionVirtual": `Clique para iniciar o arrasto.`,
  "dragItem": (args) => `Arrastar ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Arrastar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} item selecionado`,
    other: () => `${formatter.number(args.count)} itens selecionados`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Prima Enter para arrastar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} o item selecionado`,
    other: () => `${formatter.number(args.count)} os itens selecionados`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Prima Alt + Enter para arrastar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} o item selecionado`,
    other: () => `${formatter.number(args.count)} os itens selecionados`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Prima longamente para arrastar ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} o item selecionado`,
    other: () => `${formatter.number(args.count)} os itens selecionados`
  })}.`,
  "dragStartedKeyboard": `Arrasto iniciado. Prima a tecla de tabulação para navegar para um destino para largar, e em seguida prima Enter para largar ou prima Escape para cancelar.`,
  "dragStartedTouch": `Arrasto iniciado. Navegue para um destino para largar, e em seguida faça duplo toque para largar.`,
  "dragStartedVirtual": `Arrasto iniciado. Navegue para um destino para largar, e em seguida clique ou prima Enter para largar.`,
  "dropCanceled": `Largar cancelado.`,
  "dropComplete": `Largar completo.`,
  "dropDescriptionKeyboard": `Prima Enter para largar. Prima Escape para cancelar o arrasto.`,
  "dropDescriptionTouch": `Faça duplo toque para largar.`,
  "dropDescriptionVirtual": `Clique para largar.`,
  "dropIndicator": `Indicador de largar`,
  "dropOnItem": (args) => `Largar em ${args.itemText}`,
  "dropOnRoot": `Largar em`,
  "endDragKeyboard": `A arrastar. Prima Enter para cancelar o arrasto.`,
  "endDragTouch": `A arrastar. Faça duplo toque para cancelar o arrasto.`,
  "endDragVirtual": `A arrastar. Clique para cancelar o arrasto.`,
  "insertAfter": (args) => `Inserir depois de ${args.itemText}`,
  "insertBefore": (args) => `Inserir antes de ${args.itemText}`,
  "insertBetween": (args) => `Inserir entre ${args.beforeItemText} e ${args.afterItemText}`
};
var $107b5e2e45e971f1$exports = {};
$107b5e2e45e971f1$exports = {
  "dragDescriptionKeyboard": `Apăsați pe Enter pentru a începe glisarea.`,
  "dragDescriptionKeyboardAlt": `Apăsați pe Alt + Enter pentru a începe glisarea.`,
  "dragDescriptionLongPress": `Apăsați lung pentru a începe glisarea.`,
  "dragDescriptionTouch": `Atingeți de două ori pentru a începe să glisați.`,
  "dragDescriptionVirtual": `Faceți clic pentru a începe glisarea.`,
  "dragItem": (args) => `Glisați ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Glisați ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} element selectat`,
    other: () => `${formatter.number(args.count)} elemente selectate`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Apăsați pe Enter pentru a glisa ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} element selectat`,
    other: () => `${formatter.number(args.count)} elemente selectate`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Apăsați pe Alt + Enter pentru a glisa ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} element selectat`,
    other: () => `${formatter.number(args.count)} elemente selectate`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Apăsați lung pentru a glisa ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} element selectat`,
    other: () => `${formatter.number(args.count)} elemente selectate`
  })}.`,
  "dragStartedKeyboard": `A început glisarea. Apăsați pe Tab pentru a naviga la o țintă de fixare, apoi apăsați pe Enter pentru a fixa sau apăsați pe Escape pentru a anula glisarea.`,
  "dragStartedTouch": `A început glisarea. Navigați la o țintă de fixare, apoi atingeți de două ori pentru a fixa.`,
  "dragStartedVirtual": `A început glisarea. Navigați la o țintă de fixare, apoi faceți clic sau apăsați pe Enter pentru a fixa.`,
  "dropCanceled": `Fixare anulată.`,
  "dropComplete": `Fixare finalizată.`,
  "dropDescriptionKeyboard": `Apăsați pe Enter pentru a fixa. Apăsați pe Escape pentru a anula glisarea.`,
  "dropDescriptionTouch": `Atingeți de două ori pentru a fixa.`,
  "dropDescriptionVirtual": `Faceți clic pentru a fixa.`,
  "dropIndicator": `indicator de fixare`,
  "dropOnItem": (args) => `Fixați pe ${args.itemText}`,
  "dropOnRoot": `Fixare pe`,
  "endDragKeyboard": `Se glisează. Apăsați pe Enter pentru a anula glisarea.`,
  "endDragTouch": `Se glisează. Atingeți de două ori pentru a anula glisarea.`,
  "endDragVirtual": `Se glisează. Faceți clic pentru a anula glisarea.`,
  "insertAfter": (args) => `Inserați după ${args.itemText}`,
  "insertBefore": (args) => `Inserați înainte de ${args.itemText}`,
  "insertBetween": (args) => `Inserați între ${args.beforeItemText} și ${args.afterItemText}`
};
var $d4b9c2f01c1892f7$exports = {};
$d4b9c2f01c1892f7$exports = {
  "dragDescriptionKeyboard": `Нажмите клавишу Enter для начала перетаскивания.`,
  "dragDescriptionKeyboardAlt": `Нажмите Alt + Enter, чтобы начать перетаскивать.`,
  "dragDescriptionLongPress": `Нажмите и удерживайте, чтобы начать перетаскивать.`,
  "dragDescriptionTouch": `Дважды нажмите для начала перетаскивания.`,
  "dragDescriptionVirtual": `Щелкните для начала перетаскивания.`,
  "dragItem": (args) => `Перетащить ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Перетащить ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} выбранный элемент`,
    other: () => `${formatter.number(args.count)} выбранных элем`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Нажмите Enter для перетаскивания ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} выбранного элемента`,
    other: () => `${formatter.number(args.count)} выбранных элементов`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Нажмите Alt + Enter для перетаскивания ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} выбранного элемента`,
    other: () => `${formatter.number(args.count)} выбранных элементов`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Нажмите и удерживайте для перетаскивания ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} выбранного элемента`,
    other: () => `${formatter.number(args.count)} выбранных элементов`
  })}.`,
  "dragStartedKeyboard": `Начато перетаскивание. Нажмите клавишу Tab для выбора цели, затем нажмите клавишу Enter, чтобы применить перетаскивание, или клавишу Escape для отмены действия.`,
  "dragStartedTouch": `Начато перетаскивание. Выберите цель, затем дважды нажмите, чтобы применить перетаскивание.`,
  "dragStartedVirtual": `Начато перетаскивание. Нажмите клавишу Tab для выбора цели, затем нажмите клавишу Enter, чтобы применить перетаскивание.`,
  "dropCanceled": `Перетаскивание отменено.`,
  "dropComplete": `Перетаскивание завершено.`,
  "dropDescriptionKeyboard": `Нажмите клавишу Enter, чтобы применить перетаскивание. Нажмите клавишу Escape для отмены.`,
  "dropDescriptionTouch": `Дважды нажмите, чтобы применить перетаскивание.`,
  "dropDescriptionVirtual": `Щелкните, чтобы применить перетаскивание.`,
  "dropIndicator": `индикатор перетаскивания`,
  "dropOnItem": (args) => `Перетащить на ${args.itemText}`,
  "dropOnRoot": `Перетащить на`,
  "endDragKeyboard": `Перетаскивание. Нажмите клавишу Enter для отмены.`,
  "endDragTouch": `Перетаскивание. Дважды нажмите для отмены.`,
  "endDragVirtual": `Перетаскивание. Щелкните для отмены.`,
  "insertAfter": (args) => `Вставить после ${args.itemText}`,
  "insertBefore": (args) => `Вставить перед ${args.itemText}`,
  "insertBetween": (args) => `Вставить между ${args.beforeItemText} и ${args.afterItemText}`
};
var $dbdc1942894e83e4$exports = {};
$dbdc1942894e83e4$exports = {
  "dragDescriptionKeyboard": `Stlačením klávesu Enter začnete presúvanie.`,
  "dragDescriptionKeyboardAlt": `Stlačením klávesov Alt + Enter začnete presúvanie.`,
  "dragDescriptionLongPress": `Dlhým stlačením začnete presúvanie.`,
  "dragDescriptionTouch": `Dvojitým kliknutím začnete presúvanie.`,
  "dragDescriptionVirtual": `Kliknutím začnete presúvanie.`,
  "dragItem": (args) => `Presunúť položku ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Presunúť ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} vybratú položku`,
    other: () => `${formatter.number(args.count)} vybraté položky`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Stlačením klávesu Enter presuniete ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} vybratú položku`,
    other: () => `${formatter.number(args.count)} vybratých položiek`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Stlačením klávesov Alt + Enter presuniete ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} vybratú položku`,
    other: () => `${formatter.number(args.count)} vybratých položiek`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Dlhým stlačením presuniete ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} vybratú položku`,
    other: () => `${formatter.number(args.count)} vybratých položiek`
  })}.`,
  "dragStartedKeyboard": `Presúvanie sa začalo. Do cieľového umiestnenia prejdete stlačením klávesu Tab. Ak chcete položku umiestniť, stlačte kláves Enter alebo stlačte kláves Esc, ak chcete presúvanie zrušiť.`,
  "dragStartedTouch": `Presúvanie sa začalo. Prejdite na cieľové umiestnenie a dvojitým kliknutím umiestnite položku.`,
  "dragStartedVirtual": `Presúvanie sa začalo. Prejdite na cieľové umiestnenie a kliknutím alebo stlačením klávesu Enter umiestnite položku.`,
  "dropCanceled": `Umiestnenie zrušené.`,
  "dropComplete": `Umiestnenie dokončené.`,
  "dropDescriptionKeyboard": `Stlačením klávesu Enter umiestnite položku. Stlačením klávesu Esc zrušíte presúvanie.`,
  "dropDescriptionTouch": `Dvojitým kliknutím umiestnite položku.`,
  "dropDescriptionVirtual": `Kliknutím umiestnite položku.`,
  "dropIndicator": `indikátor umiestnenia`,
  "dropOnItem": (args) => `Umiestniť na položku ${args.itemText}`,
  "dropOnRoot": `Umiestniť na`,
  "endDragKeyboard": `Prebieha presúvanie. Ak ho chcete zrušiť, stlačte kláves Enter.`,
  "endDragTouch": `Prebieha presúvanie. Dvojitým kliknutím ho môžete zrušiť.`,
  "endDragVirtual": `Prebieha presúvanie.`,
  "insertAfter": (args) => `Vložiť za položku ${args.itemText}`,
  "insertBefore": (args) => `Vložiť pred položku ${args.itemText}`,
  "insertBetween": (args) => `Vložiť medzi položky ${args.beforeItemText} a ${args.afterItemText}`
};
var $fbaaaaebd547d998$exports = {};
$fbaaaaebd547d998$exports = {
  "dragDescriptionKeyboard": `Pritisnite tipko Enter za začetek vlečenja.`,
  "dragDescriptionKeyboardAlt": `Pritisnite tipki Alt + Enter za začetek vlečenja.`,
  "dragDescriptionLongPress": `Pritisnite in zadržite za začetek vlečenja.`,
  "dragDescriptionTouch": `Dvotapnite za začetek vlečenja.`,
  "dragDescriptionVirtual": `Kliknite za začetek vlečenja.`,
  "dragItem": (args) => `Povleci ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Povlecite ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} izbran element`,
    other: () => `izbrane elemente (${formatter.number(args.count)})`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Pritisnite tipko Enter, da povlečete ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} izbrani element`,
    other: () => `${formatter.number(args.count)} izbranih elementov`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Pritisnite tipki Alt + Enter, da povlečete ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} izbrani element`,
    other: () => `${formatter.number(args.count)} izbranih elementov`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Pritisnite in zadržite, da povlečete ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} izbrani element`,
    other: () => `${formatter.number(args.count)} izbranih elementov`
  })}.`,
  "dragStartedKeyboard": `Vlečenje se je začelo. Pritisnite tipko Tab za pomik na mesto, kamor želite spustiti elemente, in pritisnite tipko Enter, da jih spustite, ali tipko Escape, da prekličete postopek.`,
  "dragStartedTouch": `Vlečenje se je začelo. Pomaknite se na mesto, kamor želite spustiti elemente, in dvotapnite, da jih spustite.`,
  "dragStartedVirtual": `Vlečenje se je začelo. Pomaknite se na mesto, kamor želite spustiti elemente, in kliknite ali pritisnite tipko Enter, da jih spustite.`,
  "dropCanceled": `Spust je preklican.`,
  "dropComplete": `Spust je končan.`,
  "dropDescriptionKeyboard": `Pritisnite tipko Enter, da spustite. Pritisnite tipko Escape, da prekličete vlečenje.`,
  "dropDescriptionTouch": `Dvotapnite, da spustite.`,
  "dropDescriptionVirtual": `Kliknite, da spustite.`,
  "dropIndicator": `indikator spusta`,
  "dropOnItem": (args) => `Spusti na mesto ${args.itemText}`,
  "dropOnRoot": `Spusti na mesto`,
  "endDragKeyboard": `Vlečenje. Pritisnite tipko Enter za preklic vlečenja.`,
  "endDragTouch": `Vlečenje. Dvotapnite za preklic vlečenja.`,
  "endDragVirtual": `Vlečenje. Kliknite, da prekličete vlečenje.`,
  "insertAfter": (args) => `Vstavi za ${args.itemText}`,
  "insertBefore": (args) => `Vstavi pred ${args.itemText}`,
  "insertBetween": (args) => `Vstavi med ${args.beforeItemText} in ${args.afterItemText}`
};
var $a0caa33f1e264489$exports = {};
$a0caa33f1e264489$exports = {
  "dragDescriptionKeyboard": `Pritisnite Enter da biste započeli prevlačenje.`,
  "dragDescriptionKeyboardAlt": `Pritisnite Alt + Enter da biste započeli prevlačenje.`,
  "dragDescriptionLongPress": `Pritisnite dugo da biste započeli prevlačenje.`,
  "dragDescriptionTouch": `Dvaput dodirnite da biste započeli prevlačenje.`,
  "dragDescriptionVirtual": `Kliknite da biste započeli prevlačenje.`,
  "dragItem": (args) => `Prevucite ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Prevucite ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} izabranu stavku`,
    other: () => `${formatter.number(args.count)} izabrane stavke`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Pritisnite Enter da biste prevukli ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} izabranu stavku`,
    other: () => `${formatter.number(args.count)} izabranih stavki`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Pritisnite Alt + Enter da biste prevukli ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} izabranu stavku`,
    other: () => `${formatter.number(args.count)} izabranih stavki`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Pritisnite dugo da biste prevukli ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} izabranu stavku`,
    other: () => `${formatter.number(args.count)} izabranih stavki`
  })}.`,
  "dragStartedKeyboard": `Prevlačenje je započeto. Pritisnite Tab da biste otišli do cilja za otpuštanje, zatim pritisnite Enter za ispuštanje ili pritisnite Escape za otkazivanje.`,
  "dragStartedTouch": `Prevlačenje je započeto. Idite do cilja za otpuštanje, a zatim dvaput dodirnite za otpuštanje.`,
  "dragStartedVirtual": `Prevlačenje je započeto. Idite do cilja za otpuštanje, a zatim kliknite ili pritinite Enter za otpuštanje.`,
  "dropCanceled": `Otpuštanje je otkazano.`,
  "dropComplete": `Prevlačenje je završeno.`,
  "dropDescriptionKeyboard": `Pritisnite Enter da biste otpustili. Pritisnite Escape da biste otkazali prevlačenje.`,
  "dropDescriptionTouch": `Dvaput dodirnite za otpuštanje.`,
  "dropDescriptionVirtual": `Kliknite za otpuštanje.`,
  "dropIndicator": `Indikator otpuštanja`,
  "dropOnItem": (args) => `Otpusti na ${args.itemText}`,
  "dropOnRoot": `Otpusti na`,
  "endDragKeyboard": `Prevlačenje u toku. Pritisnite Enter da biste otkazali prevlačenje.`,
  "endDragTouch": `Prevlačenje u toku. Dvaput dodirnite da biste otkazali prevlačenje.`,
  "endDragVirtual": `Prevlačenje u toku. Kliknite da biste otkazali prevlačenje.`,
  "insertAfter": (args) => `Umetnite posle ${args.itemText}`,
  "insertBefore": (args) => `Umetnite ispred ${args.itemText}`,
  "insertBetween": (args) => `Umetnite između ${args.beforeItemText} i ${args.afterItemText}`
};
var $d576b66176f5c0ff$exports = {};
$d576b66176f5c0ff$exports = {
  "dragDescriptionKeyboard": `Tryck på enter för att börja dra.`,
  "dragDescriptionKeyboardAlt": `Tryck på Alt + Retur för att börja dra.`,
  "dragDescriptionLongPress": `Tryck länge för att börja dra.`,
  "dragDescriptionTouch": `Dubbeltryck för att börja dra.`,
  "dragDescriptionVirtual": `Klicka för att börja dra.`,
  "dragItem": (args) => `Dra ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Dra ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} valt objekt`,
    other: () => `${formatter.number(args.count)} valda objekt`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Tryck på Retur för att dra ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} markerat objekt`,
    other: () => `${formatter.number(args.count)} markerade objekt`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Tryck på Alt + Retur för att dra ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} markerat objekt`,
    other: () => `${formatter.number(args.count)} markerade objekt`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Tryck länge för att dra ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} markerat objekt`,
    other: () => `${formatter.number(args.count)} markerade objekt`
  })}.`,
  "dragStartedKeyboard": `Börja dra. Tryck på tabb för att navigera till målet, tryck på enter för att släppa eller på escape för att avbryta.`,
  "dragStartedTouch": `Börja dra. Navigera till ett mål och dubbeltryck för att släppa.`,
  "dragStartedVirtual": `Börja dra. Navigera till ett mål och klicka eller tryck på enter för att släppa.`,
  "dropCanceled": `Släppåtgärd avbröts.`,
  "dropComplete": `Släppåtgärd klar.`,
  "dropDescriptionKeyboard": `Tryck på enter för att släppa. Tryck på escape för att avbryta dragåtgärd.`,
  "dropDescriptionTouch": `Dubbeltryck för att släppa.`,
  "dropDescriptionVirtual": `Klicka för att släppa.`,
  "dropIndicator": `släppindikator`,
  "dropOnItem": (args) => `Släpp på ${args.itemText}`,
  "dropOnRoot": `Släpp på`,
  "endDragKeyboard": `Drar. Tryck på enter för att avbryta dragåtgärd.`,
  "endDragTouch": `Drar. Dubbeltryck för att avbryta dragåtgärd.`,
  "endDragVirtual": `Drar. Klicka för att avbryta dragåtgärd.`,
  "insertAfter": (args) => `Infoga efter ${args.itemText}`,
  "insertBefore": (args) => `Infoga före ${args.itemText}`,
  "insertBetween": (args) => `Infoga mellan ${args.beforeItemText} och ${args.afterItemText}`
};
var $0681f168c13d8f2a$exports = {};
$0681f168c13d8f2a$exports = {
  "dragDescriptionKeyboard": `Sürüklemeyi başlatmak için Enter'a basın.`,
  "dragDescriptionKeyboardAlt": `Sürüklemeyi başlatmak için Alt + Enter'a basın.`,
  "dragDescriptionLongPress": `Sürüklemeye başlamak için uzun basın.`,
  "dragDescriptionTouch": `Sürüklemeyi başlatmak için çift tıklayın.`,
  "dragDescriptionVirtual": `Sürüklemeyi başlatmak için tıklayın.`,
  "dragItem": (args) => `${args.itemText}’i sürükle`,
  "dragSelectedItems": (args, formatter) => `Sürükle ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} seçili öge`,
    other: () => `${formatter.number(args.count)} seçili öge`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args.count)} seçilmiş öğe`
  })} öğesini sürüklemek için Enter'a basın.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args.count)} seçilmiş öğe`
  })} öğesini sürüklemek için Alt + Enter tuşuna basın.`,
  "dragSelectedLongPress": (args, formatter) => `${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} seçilmiş öğe`,
    other: () => `${formatter.number(args.count)} seçilmiş öğe`
  })} öğesini sürüklemek için uzun basın.`,
  "dragStartedKeyboard": `Sürükleme başlatıldı. Bir bırakma hedefine gitmek için Tab’a basın, ardından bırakmak için Enter’a basın veya iptal etmek için Escape’e basın.`,
  "dragStartedTouch": `Sürükleme başlatıldı. Bir bırakma hedefine gidin, ardından bırakmak için çift tıklayın.`,
  "dragStartedVirtual": `Sürükleme başlatıldı. Bir bırakma hedefine gidin, ardından bırakmak için Enter’a tıklayın veya basın.`,
  "dropCanceled": `Bırakma iptal edildi.`,
  "dropComplete": `Bırakma tamamlandı.`,
  "dropDescriptionKeyboard": `Bırakmak için Enter'a basın. Sürüklemeyi iptal etmek için Escape'e basın.`,
  "dropDescriptionTouch": `Bırakmak için çift tıklayın.`,
  "dropDescriptionVirtual": `Bırakmak için tıklayın.`,
  "dropIndicator": `bırakma göstergesi`,
  "dropOnItem": (args) => `${args.itemText} üzerine bırak`,
  "dropOnRoot": `Bırakın`,
  "endDragKeyboard": `Sürükleme. Sürüklemeyi iptal etmek için Enter'a basın.`,
  "endDragTouch": `Sürükleme. Sürüklemeyi iptal etmek için çift tıklayın.`,
  "endDragVirtual": `Sürükleme. Sürüklemeyi iptal etmek için tıklayın.`,
  "insertAfter": (args) => `${args.itemText}’den sonra gir`,
  "insertBefore": (args) => `${args.itemText}’den önce gir`,
  "insertBetween": (args) => `${args.beforeItemText} ve ${args.afterItemText} arasına gir`
};
var $2bfbc1f42c1cf5a7$exports = {};
$2bfbc1f42c1cf5a7$exports = {
  "dragDescriptionKeyboard": `Натисніть Enter, щоб почати перетягування.`,
  "dragDescriptionKeyboardAlt": `Натисніть Alt + Enter, щоб почати перетягування.`,
  "dragDescriptionLongPress": `Натисніть і утримуйте, щоб почати перетягування.`,
  "dragDescriptionTouch": `Натисніть двічі, щоб почати перетягування.`,
  "dragDescriptionVirtual": `Натисніть, щоб почати перетягування.`,
  "dragItem": (args) => `Перетягнути ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `Перетягніть ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} вибраний елемент`,
    other: () => `${formatter.number(args.count)} вибраних елем`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `Натисніть Enter, щоб перетягнути ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} вибраний елемент`,
    other: () => `${formatter.number(args.count)} вибраних елементи(-ів)`
  })}.`,
  "dragSelectedKeyboardAlt": (args, formatter) => `Натисніть Alt + Enter, щоб перетягнути ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} вибраний елемент`,
    other: () => `${formatter.number(args.count)} вибраних елементи(-ів)`
  })}.`,
  "dragSelectedLongPress": (args, formatter) => `Утримуйте, щоб перетягнути ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} вибраний елемент`,
    other: () => `${formatter.number(args.count)} вибраних елементи(-ів)`
  })}.`,
  "dragStartedKeyboard": `Перетягування почалося. Натисніть Tab, щоб перейти до цілі перетягування, потім натисніть Enter, щоб перетягнути, або Escape, щоб скасувати.`,
  "dragStartedTouch": `Перетягування почалося. Перейдіть до цілі перетягування, потім натисніть двічі, щоб перетягнути.`,
  "dragStartedVirtual": `Перетягування почалося. Перейдіть до цілі перетягування, потім натисніть Enter, щоб перетягнути.`,
  "dropCanceled": `Перетягування скасовано.`,
  "dropComplete": `Перетягування завершено.`,
  "dropDescriptionKeyboard": `Натисніть Enter, щоб перетягнути. Натисніть Escape, щоб скасувати перетягування.`,
  "dropDescriptionTouch": `Натисніть двічі, щоб перетягнути.`,
  "dropDescriptionVirtual": `Натисніть, щоб перетягнути.`,
  "dropIndicator": `індикатор перетягування`,
  "dropOnItem": (args) => `Перетягнути на ${args.itemText}`,
  "dropOnRoot": `Перетягнути на`,
  "endDragKeyboard": `Триває перетягування. Натисніть Enter, щоб скасувати перетягування.`,
  "endDragTouch": `Триває перетягування. Натисніть двічі, щоб скасувати перетягування.`,
  "endDragVirtual": `Триває перетягування. Натисніть, щоб скасувати перетягування.`,
  "insertAfter": (args) => `Вставити після ${args.itemText}`,
  "insertBefore": (args) => `Вставити перед ${args.itemText}`,
  "insertBetween": (args) => `Вставити між ${args.beforeItemText} і ${args.afterItemText}`
};
var $d0f488d433b55b8a$exports = {};
$d0f488d433b55b8a$exports = {
  "dragDescriptionKeyboard": `按 Enter 开始拖动。`,
  "dragDescriptionKeyboardAlt": `按 Alt + Enter 开始拖动。`,
  "dragDescriptionLongPress": `长按以开始拖动。`,
  "dragDescriptionTouch": `双击开始拖动。`,
  "dragDescriptionVirtual": `单击开始拖动。`,
  "dragItem": (args) => `拖动 ${args.itemText}`,
  "dragSelectedItems": (args, formatter) => `拖动 ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 选中项目`,
    other: () => `${formatter.number(args.count)} 选中项目`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `按 Enter 以拖动 ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 个选定项`,
    other: () => `${formatter.number(args.count)} 个选定项`
  })}。`,
  "dragSelectedKeyboardAlt": (args, formatter) => `按 Alt + Enter 以拖动 ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 个选定项`,
    other: () => `${formatter.number(args.count)} 个选定项`
  })}。`,
  "dragSelectedLongPress": (args, formatter) => `长按以拖动 ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 个选定项`,
    other: () => `${formatter.number(args.count)} 个选定项`
  })}。`,
  "dragStartedKeyboard": `已开始拖动。按 Tab 导航到放置目标，然后按 Enter 放置或按 Escape 取消。`,
  "dragStartedTouch": `已开始拖动。导航到放置目标，然后双击放置。`,
  "dragStartedVirtual": `已开始拖动。导航到放置目标，然后单击或按 Enter 放置。`,
  "dropCanceled": `放置已取消。`,
  "dropComplete": `放置已完成。`,
  "dropDescriptionKeyboard": `按 Enter 放置。按 Escape 取消拖动。`,
  "dropDescriptionTouch": `双击放置。`,
  "dropDescriptionVirtual": `单击放置。`,
  "dropIndicator": `放置标记`,
  "dropOnItem": (args) => `放置于 ${args.itemText}`,
  "dropOnRoot": `放置于`,
  "endDragKeyboard": `正在拖动。按 Enter 取消拖动。`,
  "endDragTouch": `正在拖动。双击取消拖动。`,
  "endDragVirtual": `正在拖动。单击取消拖动。`,
  "insertAfter": (args) => `插入到 ${args.itemText} 之后`,
  "insertBefore": (args) => `插入到 ${args.itemText} 之前`,
  "insertBetween": (args) => `插入到 ${args.beforeItemText} 和 ${args.afterItemText} 之间`
};
var $46168b0dce85301e$exports = {};
$46168b0dce85301e$exports = {
  "dragDescriptionKeyboard": `按 Enter 鍵以開始拖曳。`,
  "dragDescriptionKeyboardAlt": `按 Alt+Enter 鍵以開始拖曳。`,
  "dragDescriptionLongPress": `長按以開始拖曳。`,
  "dragDescriptionTouch": `輕點兩下以開始拖曳。`,
  "dragDescriptionVirtual": `按一下滑鼠以開始拖曳。`,
  "dragItem": (args) => `拖曳「${args.itemText}」`,
  "dragSelectedItems": (args, formatter) => `拖曳 ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 個選定項目`,
    other: () => `${formatter.number(args.count)} 個選定項目`
  })}`,
  "dragSelectedKeyboard": (args, formatter) => `按 Enter 鍵以拖曳 ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 個選定項目`,
    other: () => `${formatter.number(args.count)} 個選定項目`
  })}。`,
  "dragSelectedKeyboardAlt": (args, formatter) => `按 Alt+Enter 鍵以拖曳 ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 個選定項目`,
    other: () => `${formatter.number(args.count)} 個選定項目`
  })}。`,
  "dragSelectedLongPress": (args, formatter) => `長按以拖曳 ${formatter.plural(args.count, {
    one: () => `${formatter.number(args.count)} 個選定項目`,
    other: () => `${formatter.number(args.count)} 個選定項目`
  })}。`,
  "dragStartedKeyboard": `已開始拖曳。按 Tab 鍵以瀏覽至放置目標，然後按 Enter 鍵以放置，或按 Escape 鍵以取消。`,
  "dragStartedTouch": `已開始拖曳。瀏覽至放置目標，然後輕點兩下以放置。`,
  "dragStartedVirtual": `已開始拖曳。瀏覽至放置目標，然後按一下滑鼠或按 Enter 鍵以放置。`,
  "dropCanceled": `放置已取消。`,
  "dropComplete": `放置已完成。`,
  "dropDescriptionKeyboard": `按 Enter 鍵以放置。按 Escape 鍵以取消拖曳。`,
  "dropDescriptionTouch": `輕點兩下以放置。`,
  "dropDescriptionVirtual": `按一下滑鼠以放置。`,
  "dropIndicator": `放置指示器`,
  "dropOnItem": (args) => `放置在「${args.itemText}」上`,
  "dropOnRoot": `放置在`,
  "endDragKeyboard": `拖曳中。按 Enter 鍵以取消拖曳。`,
  "endDragTouch": `拖曳中。輕點兩下以取消拖曳。`,
  "endDragVirtual": `拖曳中。按一下滑鼠以取消拖曳。`,
  "insertAfter": (args) => `插入至「${args.itemText}」之後`,
  "insertBefore": (args) => `插入至「${args.itemText}」之前`,
  "insertBetween": (args) => `插入至「${args.beforeItemText}」和「${args.afterItemText}」之間`
};
$865c2eb7c00a83f1$exports = {
  "ar-AE": $7dfcac1a0c98c789$exports,
  "bg-BG": $f311c26671219eca$exports,
  "cs-CZ": $1aa4ade186550f72$exports,
  "da-DK": $b6b0ea1b94a7633c$exports,
  "de-DE": $d10e4f47c744ad52$exports,
  "el-GR": $b3d2bb9abce688ab$exports,
  "en-US": $f9b46437e610cca1$exports,
  "es-ES": $204b5c01bd3acf26$exports,
  "et-EE": $110bdd83348ecbc0$exports,
  "fi-FI": $87d3ccd5e347c7cc$exports,
  "fr-FR": $a5de891427686596$exports,
  "he-IL": $ad7f4c66d85b4494$exports,
  "hr-HR": $4aa59f3c6a796cae$exports,
  "hu-HU": $d8d3646556c40586$exports,
  "it-IT": $982d558b45395246$exports,
  "ja-JP": $6a0cf387b9de036c$exports,
  "ko-KR": $a97fefa2956f4bcb$exports,
  "lt-LT": $5fb5837f94e1c150$exports,
  "lv-LV": $5b2e5709864cc922$exports,
  "nb-NO": $ee15bb8efb18cc69$exports,
  "nl-NL": $1daf2d4602e26ac4$exports,
  "pl-PL": $7115429b0f60511f$exports,
  "pt-BR": $5edd453ae5d4a8bc$exports,
  "pt-PT": $5f431994f708535e$exports,
  "ro-RO": $107b5e2e45e971f1$exports,
  "ru-RU": $d4b9c2f01c1892f7$exports,
  "sk-SK": $dbdc1942894e83e4$exports,
  "sl-SI": $fbaaaaebd547d998$exports,
  "sr-SP": $a0caa33f1e264489$exports,
  "sv-SE": $d576b66176f5c0ff$exports,
  "tr-TR": $0681f168c13d8f2a$exports,
  "uk-UA": $2bfbc1f42c1cf5a7$exports,
  "zh-CN": $d0f488d433b55b8a$exports,
  "zh-TW": $46168b0dce85301e$exports
};
var $8253ed7ece74b463$var$MESSAGES = {
  keyboard: {
    start: "dragDescriptionKeyboard",
    end: "endDragKeyboard"
  },
  touch: {
    start: "dragDescriptionTouch",
    end: "endDragTouch"
  },
  virtual: {
    start: "dragDescriptionVirtual",
    end: "endDragVirtual"
  }
};
function $8253ed7ece74b463$export$7941f8aafa4b6021(options) {
  let { hasDragButton } = options;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)));
  let state = (0, import_react41.useRef)({
    options,
    x: 0,
    y: 0
  }).current;
  state.options = options;
  let isDraggingRef = (0, import_react41.useRef)(false);
  let [isDragging, setDraggingState] = (0, import_react41.useState)(false);
  let setDragging = (isDragging2) => {
    isDraggingRef.current = isDragging2;
    setDraggingState(isDragging2);
  };
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  let modalityOnPointerDown = (0, import_react41.useRef)(null);
  let onDragStart = (e6) => {
    var _options_preview;
    if (e6.defaultPrevented)
      return;
    e6.stopPropagation();
    if (modalityOnPointerDown.current === "virtual") {
      e6.preventDefault();
      startDragging(e6.target);
      modalityOnPointerDown.current = null;
      return;
    }
    if (typeof options.onDragStart === "function")
      options.onDragStart({
        type: "dragstart",
        x: e6.clientX,
        y: e6.clientY
      });
    let items = options.getItems();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e6.dataTransfer, items);
    let allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all;
    if (typeof options.getAllowedDropOperations === "function") {
      let allowedOperations = options.getAllowedDropOperations();
      allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
      for (let operation of allowedOperations)
        allowed |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation] || (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
    }
    (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)(allowed);
    e6.dataTransfer.effectAllowed = (0, $103790afe9474d1c$export$dd0165308d8bff45)[allowed] || "none";
    if (typeof ((_options_preview = options.preview) === null || _options_preview === void 0 ? void 0 : _options_preview.current) === "function")
      options.preview.current(items, (node3) => {
        let size3 = node3.getBoundingClientRect();
        let rect = e6.currentTarget.getBoundingClientRect();
        let x3 = e6.clientX - rect.x;
        let y4 = e6.clientY - rect.y;
        if (x3 > size3.width || y4 > size3.height) {
          x3 = size3.width / 2;
          y4 = size3.height / 2;
        }
        let height = 2 * Math.round(size3.height / 2);
        node3.style.height = `${height}px`;
        e6.dataTransfer.setDragImage(node3, x3, y4);
      });
    addGlobalListener(window, "drop", (e7) => {
      e7.preventDefault();
      e7.stopPropagation();
      console.warn("Drags initiated from the React Aria useDrag hook may only be dropped on a target created with useDrop. This ensures that a keyboard and screen reader accessible alternative is available.");
    }, {
      once: true
    });
    state.x = e6.clientX;
    state.y = e6.clientY;
    requestAnimationFrame(() => {
      setDragging(true);
    });
  };
  let onDrag = (e6) => {
    e6.stopPropagation();
    if (e6.clientX === state.x && e6.clientY === state.y)
      return;
    if (typeof options.onDragMove === "function")
      options.onDragMove({
        type: "dragmove",
        x: e6.clientX,
        y: e6.clientY
      });
    state.x = e6.clientX;
    state.y = e6.clientY;
  };
  let onDragEnd = (e6) => {
    e6.stopPropagation();
    if (typeof options.onDragEnd === "function") {
      let event = {
        type: "dragend",
        x: e6.clientX,
        y: e6.clientY,
        dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[e6.dataTransfer.dropEffect]
      };
      if (0, $7252cd45fc48c07c$export$8e6636520ac15722)
        event.dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[0, $7252cd45fc48c07c$export$8e6636520ac15722];
      options.onDragEnd(event);
    }
    setDragging(false);
    removeAllGlobalListeners();
    (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);
    (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
  };
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => {
      if (isDraggingRef.current) {
        if (typeof state.options.onDragEnd === "function") {
          let event = {
            type: "dragend",
            x: 0,
            y: 0,
            dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[(0, $7252cd45fc48c07c$export$8e6636520ac15722) || "none"]
          };
          state.options.onDragEnd(event);
        }
        setDragging(false);
        (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);
        (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
      }
    };
  }, [
    state
  ]);
  let onPress = (e6) => {
    if (e6.pointerType !== "keyboard" && e6.pointerType !== "virtual")
      return;
    startDragging(e6.target);
  };
  let startDragging = (target) => {
    if (typeof state.options.onDragStart === "function") {
      let rect = target.getBoundingClientRect();
      state.options.onDragStart({
        type: "dragstart",
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
      });
    }
    $67560de7c78cb232$export$549dbcf8649bf3b2({
      element: target,
      items: state.options.getItems(),
      allowedDropOperations: typeof state.options.getAllowedDropOperations === "function" ? state.options.getAllowedDropOperations() : [
        "move",
        "copy",
        "link"
      ],
      onDragEnd(e6) {
        setDragging(false);
        if (typeof state.options.onDragEnd === "function")
          state.options.onDragEnd(e6);
      }
    }, stringFormatter);
    setDragging(true);
  };
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  let message = !isDragging ? $8253ed7ece74b463$var$MESSAGES[modality].start : $8253ed7ece74b463$var$MESSAGES[modality].end;
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(stringFormatter.format(message));
  let interactions;
  if (!hasDragButton)
    interactions = {
      ...descriptionProps,
      onPointerDown(e6) {
        modalityOnPointerDown.current = (0, $6a7db85432448f7f$export$29bf1b5f2c56cf63)(e6.nativeEvent) ? "virtual" : e6.pointerType;
        if (e6.width < 1 && e6.height < 1)
          modalityOnPointerDown.current = "virtual";
        else {
          let rect = e6.currentTarget.getBoundingClientRect();
          let offsetX = e6.clientX - rect.x;
          let offsetY = e6.clientY - rect.y;
          let centerX = rect.width / 2;
          let centerY = rect.height / 2;
          if (Math.abs(offsetX - centerX) <= 0.5 && Math.abs(offsetY - centerY) <= 0.5)
            modalityOnPointerDown.current = "virtual";
          else
            modalityOnPointerDown.current = e6.pointerType;
        }
      },
      onKeyDownCapture(e6) {
        if (e6.target === e6.currentTarget && e6.key === "Enter") {
          e6.preventDefault();
          e6.stopPropagation();
        }
      },
      onKeyUpCapture(e6) {
        if (e6.target === e6.currentTarget && e6.key === "Enter") {
          e6.preventDefault();
          e6.stopPropagation();
          startDragging(e6.target);
        }
      },
      onClick(e6) {
        if ((0, $6a7db85432448f7f$export$60278871457622de)(e6.nativeEvent) || modalityOnPointerDown.current === "virtual") {
          e6.preventDefault();
          e6.stopPropagation();
          startDragging(e6.target);
        }
      }
    };
  return {
    dragProps: {
      ...interactions,
      draggable: "true",
      onDragStart,
      onDrag,
      onDragEnd
    },
    dragButtonProps: {
      ...descriptionProps,
      onPress
    },
    isDragging
  };
}
var $224594fe3e57ff1e$var$MESSAGES = {
  keyboard: "dropDescriptionKeyboard",
  touch: "dropDescriptionTouch",
  virtual: "dropDescriptionVirtual"
};
function $224594fe3e57ff1e$export$62447ad3d2ec7da6() {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)));
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(dragSession ? stringFormatter.format($224594fe3e57ff1e$var$MESSAGES[modality]) : "");
  return {
    dropProps: {
      ...descriptionProps,
      // Mobile Safari does not properly bubble click events on elements except links or inputs
      // unless there is an onclick handler bound directly to the element itself. By adding this
      // handler, React will take care of adding that for us, and we are able to handle document
      // level click events in the DragManager.
      // See https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
      onClick: () => {
      }
    }
  };
}
var $5c06e4929e123553$var$DROP_ACTIVATE_TIMEOUT = 800;
function $5c06e4929e123553$export$ccdee5eaf73cf661(options) {
  let { hasDropButton } = options;
  let [isDropTarget, setDropTarget] = (0, import_react41.useState)(false);
  let state = (0, import_react41.useRef)({
    x: 0,
    y: 0,
    dragOverElements: /* @__PURE__ */ new Set(),
    dropEffect: "none",
    allowedOperations: (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all,
    dropActivateTimer: null
  }).current;
  let fireDropEnter = (e6) => {
    setDropTarget(true);
    if (typeof options.onDropEnter === "function") {
      let rect = e6.currentTarget.getBoundingClientRect();
      options.onDropEnter({
        type: "dropenter",
        x: e6.clientX - rect.x,
        y: e6.clientY - rect.y
      });
    }
  };
  let fireDropExit = (e6) => {
    setDropTarget(false);
    if (typeof options.onDropExit === "function") {
      let rect = e6.currentTarget.getBoundingClientRect();
      options.onDropExit({
        type: "dropexit",
        x: e6.clientX - rect.x,
        y: e6.clientY - rect.y
      });
    }
  };
  let onDragOver = (e6) => {
    e6.preventDefault();
    e6.stopPropagation();
    let allowedOperations = $5c06e4929e123553$var$getAllowedOperations(e6);
    if (e6.clientX === state.x && e6.clientY === state.y && allowedOperations === state.allowedOperations) {
      e6.dataTransfer.dropEffect = state.dropEffect;
      return;
    }
    state.x = e6.clientX;
    state.y = e6.clientY;
    let prevDropEffect = state.dropEffect;
    if (allowedOperations !== state.allowedOperations) {
      let allowedOps = $5c06e4929e123553$var$allowedOperationsToArray(allowedOperations);
      let dropOperation = allowedOps[0];
      if (typeof options.getDropOperation === "function") {
        let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e6.dataTransfer);
        dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperations, options.getDropOperation(types, allowedOps));
      }
      state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    }
    if (typeof options.getDropOperationForPoint === "function") {
      let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e6.dataTransfer);
      let rect = e6.currentTarget.getBoundingClientRect();
      let dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperations, options.getDropOperationForPoint(types, $5c06e4929e123553$var$allowedOperationsToArray(allowedOperations), state.x - rect.x, state.y - rect.y));
      state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    }
    state.allowedOperations = allowedOperations;
    e6.dataTransfer.dropEffect = state.dropEffect;
    if (state.dropEffect === "none" && prevDropEffect !== "none")
      fireDropExit(e6);
    else if (state.dropEffect !== "none" && prevDropEffect === "none")
      fireDropEnter(e6);
    if (typeof options.onDropMove === "function" && state.dropEffect !== "none") {
      let rect = e6.currentTarget.getBoundingClientRect();
      options.onDropMove({
        type: "dropmove",
        x: state.x - rect.x,
        y: state.y - rect.y
      });
    }
    clearTimeout(state.dropActivateTimer);
    if (typeof options.onDropActivate === "function" && state.dropEffect !== "none") {
      let rect = e6.currentTarget.getBoundingClientRect();
      state.dropActivateTimer = setTimeout(() => {
        options.onDropActivate({
          type: "dropactivate",
          x: state.x - rect.x,
          y: state.y - rect.y
        });
      }, $5c06e4929e123553$var$DROP_ACTIVATE_TIMEOUT);
    }
  };
  let onDragEnter = (e6) => {
    e6.preventDefault();
    e6.stopPropagation();
    state.dragOverElements.add(e6.target);
    if (state.dragOverElements.size > 1)
      return;
    let allowedOperationsBits = $5c06e4929e123553$var$getAllowedOperations(e6);
    let allowedOperations = $5c06e4929e123553$var$allowedOperationsToArray(allowedOperationsBits);
    let dropOperation = allowedOperations[0];
    if (typeof options.getDropOperation === "function") {
      let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e6.dataTransfer);
      dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperationsBits, options.getDropOperation(types, allowedOperations));
    }
    if (typeof options.getDropOperationForPoint === "function") {
      let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e6.dataTransfer);
      let rect = e6.currentTarget.getBoundingClientRect();
      dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperationsBits, options.getDropOperationForPoint(types, allowedOperations, e6.clientX - rect.x, e6.clientY - rect.y));
    }
    state.x = e6.clientX;
    state.y = e6.clientY;
    state.allowedOperations = allowedOperationsBits;
    state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
    e6.dataTransfer.dropEffect = state.dropEffect;
    if (dropOperation !== "cancel")
      fireDropEnter(e6);
  };
  let onDragLeave = (e6) => {
    e6.preventDefault();
    e6.stopPropagation();
    state.dragOverElements.delete(e6.target);
    for (let element2 of state.dragOverElements)
      if (!e6.currentTarget.contains(element2))
        state.dragOverElements.delete(element2);
    if (state.dragOverElements.size > 0)
      return;
    if (state.dropEffect !== "none")
      fireDropExit(e6);
    clearTimeout(state.dropActivateTimer);
  };
  let onDrop = (e6) => {
    e6.preventDefault();
    e6.stopPropagation();
    (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(state.dropEffect);
    if (typeof options.onDrop === "function") {
      let dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[state.dropEffect];
      let items = (0, $7252cd45fc48c07c$export$d9e760437831f8b3)(e6.dataTransfer);
      let rect = e6.currentTarget.getBoundingClientRect();
      let event = {
        type: "drop",
        x: e6.clientX - rect.x,
        y: e6.clientY - rect.y,
        items,
        dropOperation
      };
      options.onDrop(event);
    }
    let dndStateSnapshot = {
      ...(0, $7252cd45fc48c07c$export$6ca6700462636d0b)
    };
    state.dragOverElements.clear();
    fireDropExit(e6);
    clearTimeout(state.dropActivateTimer);
    if (dndStateSnapshot.draggingCollectionRef == null)
      (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(void 0);
    else
      (0, $7252cd45fc48c07c$export$6c10d32b362bfa5f)(dndStateSnapshot);
  };
  let onDropEnter = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (typeof options.onDropEnter === "function")
      options.onDropEnter(e6);
  });
  let onDropExit = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (typeof options.onDropExit === "function")
      options.onDropExit(e6);
  });
  let onDropActivate = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (typeof options.onDropActivate === "function")
      options.onDropActivate(e6);
  });
  let onKeyboardDrop = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (typeof options.onDrop === "function")
      options.onDrop(e6);
  });
  let getDropOperationKeyboard = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((types, allowedOperations) => {
    if (options.getDropOperation)
      return options.getDropOperation(types, allowedOperations);
    return allowedOperations[0];
  });
  let { ref } = options;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => $67560de7c78cb232$export$c28d9fb4a54e471a({
    element: ref.current,
    getDropOperation: getDropOperationKeyboard,
    onDropEnter(e6) {
      setDropTarget(true);
      onDropEnter(e6);
    },
    onDropExit(e6) {
      setDropTarget(false);
      onDropExit(e6);
    },
    onDrop: onKeyboardDrop,
    onDropActivate
  }), [
    ref,
    getDropOperationKeyboard,
    onDropEnter,
    onDropExit,
    onKeyboardDrop,
    onDropActivate
  ]);
  let { dropProps } = (0, $224594fe3e57ff1e$export$62447ad3d2ec7da6)();
  return {
    dropProps: {
      ...!hasDropButton && dropProps,
      onDragEnter,
      onDragOver,
      onDragLeave,
      onDrop
    },
    dropButtonProps: {
      ...hasDropButton && dropProps
    },
    isDropTarget
  };
}
function $5c06e4929e123553$var$getAllowedOperations(e6) {
  let allowedOperations = (0, $103790afe9474d1c$export$9bbdfc78cf083e16)[e6.dataTransfer.effectAllowed];
  if (0, $7252cd45fc48c07c$export$f0130eb70b6347b8)
    allowedOperations &= (0, $7252cd45fc48c07c$export$f0130eb70b6347b8);
  let allowedModifiers = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
  if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) {
    if (e6.altKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy;
    if (e6.ctrlKey && !(0, $c87311424ea30a05$export$7bef049ce92e4224)())
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link;
    if (e6.metaKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move;
  } else {
    if (e6.altKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link;
    if (e6.shiftKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move;
    if (e6.ctrlKey)
      allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy;
  }
  if (allowedModifiers)
    return allowedOperations & allowedModifiers;
  return allowedOperations;
}
function $5c06e4929e123553$var$allowedOperationsToArray(allowedOperationsBits) {
  let allowedOperations = [];
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move)
    allowedOperations.push("move");
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy)
    allowedOperations.push("copy");
  if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link)
    allowedOperations.push("link");
  return allowedOperations;
}
function $5c06e4929e123553$var$getDropOperation(allowedOperations, operation) {
  let op = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation];
  return allowedOperations & op ? operation : "cancel";
}
var $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE = 20;
function $80d9daea3067eff3$export$6323452ca4533ed8(ref) {
  let scrollableRef = (0, import_react41.useRef)(null);
  (0, import_react41.useEffect)(() => {
    if (ref.current)
      scrollableRef.current = (0, $62d8ded9296f3872$export$2bb74740c4e19def)(ref.current) ? ref.current : (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current);
  }, [
    ref
  ]);
  let state = (0, import_react41.useRef)({
    timer: null,
    dx: 0,
    dy: 0
  }).current;
  (0, import_react41.useEffect)(() => {
    return () => {
      if (state.timer) {
        cancelAnimationFrame(state.timer);
        state.timer = null;
      }
    };
  }, [
    state
  ]);
  let scroll = (0, import_react41.useCallback)(() => {
    scrollableRef.current.scrollLeft += state.dx;
    scrollableRef.current.scrollTop += state.dy;
    if (state.timer)
      state.timer = requestAnimationFrame(scroll);
  }, [
    scrollableRef,
    state
  ]);
  return {
    move(x3, y4) {
      if (!(0, $c87311424ea30a05$export$78551043582a6a98)() || (0, $c87311424ea30a05$export$fedb369cb70207f1)() || !scrollableRef.current)
        return;
      let box = scrollableRef.current.getBoundingClientRect();
      let left = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let top = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let bottom = box.height - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      let right = box.width - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
      if (x3 < left || x3 > right || y4 < top || y4 > bottom) {
        if (x3 < left)
          state.dx = x3 - left;
        else if (x3 > right)
          state.dx = x3 - right;
        if (y4 < top)
          state.dy = y4 - top;
        else if (y4 > bottom)
          state.dy = y4 - bottom;
        if (!state.timer)
          state.timer = requestAnimationFrame(scroll);
      } else
        this.stop();
    },
    stop() {
      if (state.timer) {
        cancelAnimationFrame(state.timer);
        state.timer = null;
      }
    }
  };
}
var $4b52e4eff84e5217$var$DROP_POSITIONS = [
  "before",
  "on",
  "after"
];
var $4b52e4eff84e5217$var$DROP_POSITIONS_RTL = [
  "after",
  "on",
  "before"
];
function $4b52e4eff84e5217$export$f4e2f423c21f7b04(props, state, ref) {
  let localState = (0, import_react41.useRef)({
    props,
    state,
    nextTarget: null,
    dropOperation: null
  }).current;
  localState.props = props;
  localState.state = state;
  let defaultOnDrop = (0, import_react41.useCallback)(async (e6) => {
    let { onInsert, onRootDrop, onItemDrop, onReorder, acceptedDragTypes = "all", shouldAcceptItemDrop } = localState.props;
    let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
    let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
    let { target, dropOperation, items } = e6;
    let filteredItems = items;
    if (acceptedDragTypes !== "all" || shouldAcceptItemDrop)
      filteredItems = items.filter((item2) => {
        let itemTypes;
        if (item2.kind === "directory")
          itemTypes = /* @__PURE__ */ new Set([
            (0, $7252cd45fc48c07c$export$990fced5dfac2637)
          ]);
        else
          itemTypes = item2.kind === "file" ? /* @__PURE__ */ new Set([
            item2.type
          ]) : item2.types;
        if (acceptedDragTypes === "all" || acceptedDragTypes.some((type2) => itemTypes.has(type2))) {
          if (target.type === "item" && target.dropPosition === "on" && shouldAcceptItemDrop)
            return shouldAcceptItemDrop(target, itemTypes);
          return true;
        }
        return false;
      });
    if (filteredItems.length > 0) {
      if (target.type === "root" && onRootDrop)
        await onRootDrop({
          items: filteredItems,
          dropOperation
        });
      if (target.type === "item") {
        if (target.dropPosition === "on" && onItemDrop)
          await onItemDrop({
            items: filteredItems,
            dropOperation,
            isInternal,
            target
          });
        if (target.dropPosition !== "on") {
          if (!isInternal && onInsert)
            await onInsert({
              items: filteredItems,
              dropOperation,
              target
            });
          if (isInternal && onReorder)
            await onReorder({
              keys: draggingKeys,
              dropOperation,
              target
            });
        }
      }
    }
  }, [
    localState,
    ref
  ]);
  let autoScroll = (0, $80d9daea3067eff3$export$6323452ca4533ed8)(ref);
  let { dropProps } = (0, $5c06e4929e123553$export$ccdee5eaf73cf661)({
    ref,
    onDropEnter() {
      state.setTarget(localState.nextTarget);
    },
    onDropMove(e6) {
      state.setTarget(localState.nextTarget);
      autoScroll.move(e6.x, e6.y);
    },
    getDropOperationForPoint(types, allowedOperations, x3, y4) {
      let { draggingKeys, dropCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
      let isValidDropTarget = (target2) => state.getDropOperation({
        target: target2,
        types,
        allowedOperations,
        isInternal,
        draggingKeys
      }) !== "cancel";
      let target = props.dropTargetDelegate.getDropTargetFromPoint(x3, y4, isValidDropTarget);
      if (!target) {
        localState.dropOperation = "cancel";
        localState.nextTarget = null;
        return "cancel";
      }
      localState.dropOperation = state.getDropOperation({
        target,
        types,
        allowedOperations,
        isInternal,
        draggingKeys
      });
      if (localState.dropOperation === "cancel") {
        let rootTarget = {
          type: "root"
        };
        let dropOperation = state.getDropOperation({
          target: rootTarget,
          types,
          allowedOperations,
          isInternal,
          draggingKeys
        });
        if (dropOperation !== "cancel") {
          target = rootTarget;
          localState.dropOperation = dropOperation;
        }
      }
      if (target && localState.dropOperation !== "cancel" && (ref === null || ref === void 0 ? void 0 : ref.current) !== (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current))
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
      localState.nextTarget = localState.dropOperation === "cancel" ? null : target;
      return localState.dropOperation;
    },
    onDropExit() {
      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(void 0);
      state.setTarget(null);
      autoScroll.stop();
    },
    onDropActivate(e6) {
      var _state_target, _state_target1;
      if (((_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.type) === "item" && ((_state_target1 = state.target) === null || _state_target1 === void 0 ? void 0 : _state_target1.dropPosition) === "on" && typeof props.onDropActivate === "function")
        props.onDropActivate({
          type: "dropactivate",
          x: e6.x,
          y: e6.y,
          target: state.target
        });
    },
    onDrop(e6) {
      (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
      if (state.target)
        onDrop(e6, state.target);
      let { draggingCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      if (draggingCollectionRef == null)
        (0, $7252cd45fc48c07c$export$70936501603e6c57)();
    }
  });
  let droppingState = (0, import_react41.useRef)(null);
  let onDrop = (0, import_react41.useCallback)((e6, target) => {
    var _state_collection_getItem;
    let { state: state2 } = localState;
    state2.selectionManager.setFocused(true);
    let focusedKey = state2.selectionManager.focusedKey;
    if ((0, $7252cd45fc48c07c$export$6ca6700462636d0b).draggingKeys.has((_state_collection_getItem = state2.collection.getItem(focusedKey)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.parentKey)) {
      focusedKey = state2.collection.getItem(focusedKey).parentKey;
      state2.selectionManager.setFocusedKey(focusedKey);
    }
    droppingState.current = {
      timeout: null,
      focusedKey,
      collection: state2.collection,
      selectedKeys: state2.selectionManager.selectedKeys
    };
    let onDropFn = localState.props.onDrop || defaultOnDrop;
    onDropFn({
      type: "drop",
      x: e6.x,
      y: e6.y,
      target,
      items: e6.items,
      dropOperation: e6.dropOperation
    });
    droppingState.current.timeout = setTimeout(() => {
      let { state: state3 } = localState;
      if (target.type === "item" && target.dropPosition === "on" && state3.collection.getItem(target.key) != null) {
        state3.selectionManager.setFocusedKey(target.key);
        state3.selectionManager.setFocused(true);
        (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      } else if (!state3.selectionManager.isSelected(focusedKey))
        (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      droppingState.current = null;
    }, 50);
  }, [
    localState,
    defaultOnDrop
  ]);
  (0, import_react41.useEffect)(() => {
    return () => {
      if (droppingState.current)
        clearTimeout(droppingState.current.timeout);
    };
  }, []);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (droppingState.current && state.selectionManager.isFocused && state.collection.size > droppingState.current.collection.size && state.selectionManager.isSelectionEqual(droppingState.current.selectedKeys)) {
      let newKeys = /* @__PURE__ */ new Set();
      for (let key of state.collection.getKeys())
        if (!droppingState.current.collection.getItem(key))
          newKeys.add(key);
      state.selectionManager.setSelectedKeys(newKeys);
      if (state.selectionManager.focusedKey === droppingState.current.focusedKey) {
        let first = newKeys.keys().next().value;
        let item2 = state.collection.getItem(first);
        if ((item2 === null || item2 === void 0 ? void 0 : item2.type) === "cell")
          first = item2.parentKey;
        state.selectionManager.setFocusedKey(first);
        if (state.selectionManager.selectionMode === "none")
          (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
      }
      droppingState.current = null;
    }
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  (0, import_react41.useEffect)(() => {
    let getNextTarget = (target, wrap2 = true, horizontal = false) => {
      if (!target)
        return {
          type: "root"
        };
      let { keyboardDelegate } = localState.props;
      let nextKey;
      if ((target === null || target === void 0 ? void 0 : target.type) === "item")
        nextKey = horizontal ? keyboardDelegate.getKeyRightOf(target.key) : keyboardDelegate.getKeyBelow(target.key);
      else
        nextKey = horizontal && direction === "rtl" ? keyboardDelegate.getLastKey() : keyboardDelegate.getFirstKey();
      let dropPositions = horizontal && direction === "rtl" ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;
      let dropPosition = dropPositions[0];
      if (target.type === "item") {
        let nextCollectionKey = horizontal && direction === "rtl" ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);
        if (nextKey == null || nextKey === nextCollectionKey) {
          let positionIndex = dropPositions.indexOf(target.dropPosition);
          let nextDropPosition = dropPositions[positionIndex + 1];
          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null))
            return {
              type: "item",
              key: target.key,
              dropPosition: nextDropPosition
            };
          if (target.dropPosition === dropPositions[2])
            dropPosition = "on";
        } else
          dropPosition = target.dropPosition;
      }
      if (nextKey == null) {
        if (wrap2)
          return {
            type: "root"
          };
        return null;
      }
      return {
        type: "item",
        key: nextKey,
        dropPosition
      };
    };
    let getPreviousTarget = (target, wrap2 = true, horizontal = false) => {
      let { keyboardDelegate } = localState.props;
      let nextKey;
      if ((target === null || target === void 0 ? void 0 : target.type) === "item")
        nextKey = horizontal ? keyboardDelegate.getKeyLeftOf(target.key) : keyboardDelegate.getKeyAbove(target.key);
      else
        nextKey = horizontal && direction === "rtl" ? keyboardDelegate.getFirstKey() : keyboardDelegate.getLastKey();
      let dropPositions = horizontal && direction === "rtl" ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;
      let dropPosition = !target || target.type === "root" ? dropPositions[2] : "on";
      if ((target === null || target === void 0 ? void 0 : target.type) === "item") {
        let prevCollectionKey = horizontal && direction === "rtl" ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);
        if (nextKey == null || nextKey === prevCollectionKey) {
          let positionIndex = dropPositions.indexOf(target.dropPosition);
          let nextDropPosition = dropPositions[positionIndex - 1];
          if (positionIndex > 0 && nextDropPosition !== dropPositions[2])
            return {
              type: "item",
              key: target.key,
              dropPosition: nextDropPosition
            };
          if (target.dropPosition === dropPositions[0])
            dropPosition = "on";
        } else
          dropPosition = target.dropPosition;
      }
      if (nextKey == null) {
        if (wrap2)
          return {
            type: "root"
          };
        return null;
      }
      return {
        type: "item",
        key: nextKey,
        dropPosition
      };
    };
    let nextValidTarget = (target, types, allowedDropOperations, getNextTarget2, wrap2 = true) => {
      let seenRoot = 0;
      let operation;
      let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
      let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
      do {
        let nextTarget = getNextTarget2(target, wrap2);
        if (!nextTarget)
          return null;
        target = nextTarget;
        operation = localState.state.getDropOperation({
          target: nextTarget,
          types,
          allowedOperations: allowedDropOperations,
          isInternal,
          draggingKeys
        });
        if (target.type === "root")
          seenRoot++;
      } while (operation === "cancel" && !localState.state.isDropTarget(target) && seenRoot < 2);
      if (operation === "cancel")
        return null;
      return target;
    };
    return $67560de7c78cb232$export$c28d9fb4a54e471a({
      element: ref.current,
      getDropOperation(types, allowedOperations) {
        if (localState.state.target) {
          let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
          return localState.state.getDropOperation({
            target: localState.state.target,
            types,
            allowedOperations,
            isInternal,
            draggingKeys
          });
        }
        let target = nextValidTarget(null, types, allowedOperations, getNextTarget);
        return target ? "move" : "cancel";
      },
      onDropEnter(e6, drag) {
        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);
        let selectionManager = localState.state.selectionManager;
        let target;
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
        let key = selectionManager.focusedKey;
        let dropPosition = "after";
        let item2 = localState.state.collection.getItem(key);
        if ((item2 === null || item2 === void 0 ? void 0 : item2.type) === "cell")
          key = item2.parentKey;
        if (selectionManager.isSelected(key)) {
          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key)
            dropPosition = "before";
          else
            key = selectionManager.lastSelectedKey;
        }
        if (key != null) {
          target = {
            type: "item",
            key,
            dropPosition
          };
          let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
          let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
          var _nextValidTarget;
          if (localState.state.getDropOperation({
            target,
            types,
            allowedOperations: drag.allowedDropOperations,
            isInternal,
            draggingKeys
          }) === "cancel")
            target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);
        }
        if (!target)
          target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
        localState.state.setTarget(target);
      },
      onDropExit() {
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(void 0);
        localState.state.setTarget(null);
      },
      onDropTargetEnter(target) {
        localState.state.setTarget(target);
      },
      onDropActivate(e6) {
        var _localState_state_target, _localState_state_target1;
        if (((_localState_state_target = localState.state.target) === null || _localState_state_target === void 0 ? void 0 : _localState_state_target.type) === "item" && ((_localState_state_target1 = localState.state.target) === null || _localState_state_target1 === void 0 ? void 0 : _localState_state_target1.dropPosition) === "on" && typeof localState.props.onDropActivate === "function")
          localState.props.onDropActivate({
            type: "dropactivate",
            x: e6.x,
            y: e6.y,
            target: localState.state.target
          });
      },
      onDrop(e6, target) {
        (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
        if (localState.state.target)
          onDrop(e6, target || localState.state.target);
      },
      onKeyDown(e6, drag) {
        let { keyboardDelegate } = localState.props;
        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);
        switch (e6.key) {
          case "ArrowDown":
            if (keyboardDelegate.getKeyBelow) {
              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);
              localState.state.setTarget(target);
            }
            break;
          case "ArrowUp":
            if (keyboardDelegate.getKeyAbove) {
              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);
              localState.state.setTarget(target);
            }
            break;
          case "ArrowLeft":
            if (keyboardDelegate.getKeyLeftOf) {
              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target2, wrap2) => getPreviousTarget(target2, wrap2, true));
              localState.state.setTarget(target);
            }
            break;
          case "ArrowRight":
            if (keyboardDelegate.getKeyRightOf) {
              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target2, wrap2) => getNextTarget(target2, wrap2, true));
              localState.state.setTarget(target);
            }
            break;
          case "Home":
            if (keyboardDelegate.getFirstKey) {
              let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
              localState.state.setTarget(target);
            }
            break;
          case "End":
            if (keyboardDelegate.getLastKey) {
              let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);
              localState.state.setTarget(target);
            }
            break;
          case "PageDown":
            if (keyboardDelegate.getKeyPageBelow) {
              let target = localState.state.target;
              if (!target)
                target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
              else {
                let nextKey = keyboardDelegate.getKeyPageBelow(target.type === "item" ? target.key : keyboardDelegate.getFirstKey());
                let dropPosition = target.type === "item" ? target.dropPosition : "after";
                if (nextKey == null || target.type === "item" && target.key === keyboardDelegate.getLastKey()) {
                  nextKey = keyboardDelegate.getLastKey();
                  dropPosition = "after";
                }
                target = {
                  type: "item",
                  key: nextKey,
                  dropPosition
                };
                let { draggingCollectionRef, draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
                let isInternal = (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) === (ref === null || ref === void 0 ? void 0 : ref.current);
                let operation = localState.state.getDropOperation({
                  target,
                  types,
                  allowedOperations: drag.allowedDropOperations,
                  isInternal,
                  draggingKeys
                });
                var _nextValidTarget;
                if (operation === "cancel")
                  target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);
              }
              localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);
            }
            break;
          case "PageUp": {
            if (!keyboardDelegate.getKeyPageAbove)
              break;
            let target = localState.state.target;
            if (!target)
              target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);
            else if (target.type === "item") {
              if (target.key === keyboardDelegate.getFirstKey())
                target = {
                  type: "root"
                };
              else {
                let nextKey = keyboardDelegate.getKeyPageAbove(target.key);
                let dropPosition = target.dropPosition;
                if (nextKey == null) {
                  nextKey = keyboardDelegate.getFirstKey();
                  dropPosition = "before";
                }
                target = {
                  type: "item",
                  key: nextKey,
                  dropPosition
                };
              }
              let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
              let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
              let operation = localState.state.getDropOperation({
                target,
                types,
                allowedOperations: drag.allowedDropOperations,
                isInternal,
                draggingKeys
              });
              var _nextValidTarget1;
              if (operation === "cancel")
                target = (_nextValidTarget1 = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)) !== null && _nextValidTarget1 !== void 0 ? _nextValidTarget1 : nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);
            }
            localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);
            break;
          }
        }
      }
    });
  }, [
    localState,
    ref,
    onDrop,
    direction
  ]);
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)();
  (0, $7252cd45fc48c07c$export$dfdf5deeaf27473f).set(state, {
    id,
    ref
  });
  return {
    collectionProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(dropProps, {
      id,
      // Remove description from collection element. If dropping on the entire collection,
      // there should be a drop indicator that has this description, so no need to double announce.
      "aria-describedby": null
    })
  };
}
function $bfaab576ce1c580e$export$f7b0c5d28b66b6a5(options, state, ref) {
  let { dropProps } = (0, $224594fe3e57ff1e$export$62447ad3d2ec7da6)();
  let droppableCollectionRef = (0, $7252cd45fc48c07c$export$7e397efd01d3db27)(state);
  (0, import_react41.useEffect)(() => {
    if (ref.current)
      return $67560de7c78cb232$export$aef80212ac99c003({
        element: ref.current,
        target: options.target,
        getDropOperation(types, allowedOperations) {
          let { draggingKeys: draggingKeys2 } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
          let isInternal2 = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(droppableCollectionRef);
          return state.getDropOperation({
            target: options.target,
            types,
            allowedOperations,
            isInternal: isInternal2,
            draggingKeys: draggingKeys2
          });
        }
      });
  }, [
    ref,
    options.target,
    state,
    droppableCollectionRef
  ]);
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let { draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
  let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(droppableCollectionRef);
  let isValidDropTarget = dragSession && state.getDropOperation({
    target: options.target,
    types: (0, $7252cd45fc48c07c$export$e1d41611756c6326)(dragSession.dragTarget.items),
    allowedOperations: dragSession.dragTarget.allowedDropOperations,
    isInternal,
    draggingKeys
  }) !== "cancel";
  let isDropTarget = state.isDropTarget(options.target);
  (0, import_react41.useEffect)(() => {
    if (dragSession && isDropTarget && ref.current)
      ref.current.focus();
  }, [
    isDropTarget,
    dragSession,
    ref
  ]);
  return {
    dropProps: {
      ...dropProps,
      "aria-hidden": !dragSession || isValidDropTarget ? void 0 : "true"
    },
    isDropTarget
  };
}
function $ddf25448c71fc93a$export$8d0e41d2815afac5(props, state, ref) {
  let { target } = props;
  let { collection: collection2 } = state;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)));
  let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
  let { dropProps } = (0, $bfaab576ce1c580e$export$f7b0c5d28b66b6a5)(props, state, ref);
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let getText = (key) => {
    var _collection_getTextValue, _collection_getItem;
    var _collection_getTextValue1;
    return (_collection_getTextValue1 = (_collection_getTextValue = collection2.getTextValue) === null || _collection_getTextValue === void 0 ? void 0 : _collection_getTextValue.call(collection2, key)) !== null && _collection_getTextValue1 !== void 0 ? _collection_getTextValue1 : (_collection_getItem = collection2.getItem(key)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue;
  };
  let label = "";
  let labelledBy;
  if (target.type === "root") {
    label = stringFormatter.format("dropOnRoot");
    labelledBy = `${id} ${(0, $7252cd45fc48c07c$export$3093291712f09a77)(state)}`;
  } else if (target.dropPosition === "on")
    label = stringFormatter.format("dropOnItem", {
      itemText: getText(target.key)
    });
  else {
    let before;
    let after;
    if (collection2.getFirstKey() === target.key && target.dropPosition === "before")
      before = null;
    else
      before = target.dropPosition === "before" ? collection2.getKeyBefore(target.key) : target.key;
    if (collection2.getLastKey() === target.key && target.dropPosition === "after")
      after = null;
    else
      after = target.dropPosition === "after" ? collection2.getKeyAfter(target.key) : target.key;
    if (before && after)
      label = stringFormatter.format("insertBetween", {
        beforeItemText: getText(before),
        afterItemText: getText(after)
      });
    else if (before)
      label = stringFormatter.format("insertAfter", {
        itemText: getText(before)
      });
    else if (after)
      label = stringFormatter.format("insertBefore", {
        itemText: getText(after)
      });
  }
  let isDropTarget = state.isDropTarget(target);
  let ariaHidden = !dragSession ? "true" : dropProps["aria-hidden"];
  return {
    dropIndicatorProps: {
      ...dropProps,
      id,
      "aria-roledescription": stringFormatter.format("dropIndicator"),
      "aria-label": label,
      "aria-labelledby": labelledBy,
      "aria-hidden": ariaHidden,
      tabIndex: -1
    },
    isDropTarget,
    // If aria-hidden, we are either not in a drag session or the drop target is invalid.
    // In that case, there's no need to render anything at all unless we need to show the indicator visually.
    // This can happen when dragging using the native DnD API as opposed to keyboard dragging.
    isHidden: !isDropTarget && !!ariaHidden
  };
}
var $fd98cf7cbf233429$var$MESSAGES = {
  keyboard: {
    selected: "dragSelectedKeyboard",
    notSelected: "dragDescriptionKeyboard"
  },
  touch: {
    selected: "dragSelectedLongPress",
    notSelected: "dragDescriptionLongPress"
  },
  virtual: {
    selected: "dragDescriptionVirtual",
    notSelected: "dragDescriptionVirtual"
  }
};
function $fd98cf7cbf233429$export$b35afafff42da2d9(props, state) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($865c2eb7c00a83f1$exports)));
  let isDisabled = state.selectionManager.isDisabled(props.key);
  let { dragProps, dragButtonProps } = (0, $8253ed7ece74b463$export$7941f8aafa4b6021)({
    getItems() {
      return state.getItems(props.key);
    },
    preview: state.preview,
    getAllowedDropOperations: state.getAllowedDropOperations,
    hasDragButton: props.hasDragButton,
    onDragStart(e6) {
      state.startDrag(props.key, e6);
      (0, $7252cd45fc48c07c$export$72cb63bdda528276)(state.draggingKeys);
    },
    onDragMove(e6) {
      state.moveDrag(e6);
    },
    onDragEnd(e6) {
      let { dropOperation } = e6;
      let isInternal = dropOperation === "cancel" ? false : (0, $7252cd45fc48c07c$export$78bf638634500fa5)();
      state.endDrag({
        ...e6,
        keys: state.draggingKeys,
        isInternal
      });
      (0, $7252cd45fc48c07c$export$70936501603e6c57)();
    }
  });
  let item2 = state.collection.getItem(props.key);
  let numKeysForDrag = state.getKeysForDrag(props.key).size;
  let isSelected = numKeysForDrag > 1 && state.selectionManager.isSelected(props.key);
  let dragButtonLabel;
  let description;
  let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
  if (!props.hasDragButton && state.selectionManager.selectionMode !== "none") {
    let msg2 = $fd98cf7cbf233429$var$MESSAGES[modality][isSelected ? "selected" : "notSelected"];
    if (props.hasAction && modality === "keyboard")
      msg2 += "Alt";
    if (isSelected)
      description = stringFormatter.format(msg2, {
        count: numKeysForDrag
      });
    else
      description = stringFormatter.format(msg2);
    delete dragProps.onClick;
  } else if (isSelected)
    dragButtonLabel = stringFormatter.format("dragSelectedItems", {
      count: numKeysForDrag
    });
  else {
    var _state_collection_getTextValue, _state_collection;
    var _state_collection_getTextValue1, _ref;
    let itemText = (_ref = (_state_collection_getTextValue1 = (_state_collection_getTextValue = (_state_collection = state.collection).getTextValue) === null || _state_collection_getTextValue === void 0 ? void 0 : _state_collection_getTextValue.call(_state_collection, props.key)) !== null && _state_collection_getTextValue1 !== void 0 ? _state_collection_getTextValue1 : item2 === null || item2 === void 0 ? void 0 : item2.textValue) !== null && _ref !== void 0 ? _ref : "";
    dragButtonLabel = stringFormatter.format("dragItem", {
      itemText
    });
  }
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(description);
  if (description)
    Object.assign(dragProps, descriptionProps);
  if (!props.hasDragButton && props.hasAction) {
    let { onKeyDownCapture, onKeyUpCapture } = dragProps;
    if (modality === "touch")
      delete dragProps["aria-describedby"];
    dragProps.onKeyDownCapture = (e6) => {
      if (e6.altKey)
        onKeyDownCapture(e6);
    };
    dragProps.onKeyUpCapture = (e6) => {
      if (e6.altKey)
        onKeyUpCapture(e6);
    };
  }
  return {
    dragProps: isDisabled ? {} : dragProps,
    dragButtonProps: {
      ...dragButtonProps,
      isDisabled,
      "aria-label": dragButtonLabel
    }
  };
}
function $4ac1fdc3a0fcd564$export$2962a7984b2f0a80(props, state, ref) {
  let { draggingCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
  if (state.draggingKeys.size > 0 && (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) !== ref.current)
    (0, $7252cd45fc48c07c$export$f2be18a910c0caa6)(ref);
}
var $9fcc7f0d70d084ee$var$globalEvents = /* @__PURE__ */ new Map();
function $9fcc7f0d70d084ee$var$addGlobalEventListener(event, fn2) {
  let eventData = $9fcc7f0d70d084ee$var$globalEvents.get(event);
  if (!eventData) {
    let handlers = /* @__PURE__ */ new Set();
    let listener = (e6) => {
      for (let handler of handlers)
        handler(e6);
    };
    eventData = {
      listener,
      handlers
    };
    $9fcc7f0d70d084ee$var$globalEvents.set(event, eventData);
    document.addEventListener(event, listener);
  }
  eventData.handlers.add(fn2);
  return () => {
    eventData.handlers.delete(fn2);
    if (eventData.handlers.size === 0) {
      document.removeEventListener(event, eventData.listener);
      $9fcc7f0d70d084ee$var$globalEvents.delete(event);
    }
  };
}
function $9fcc7f0d70d084ee$export$2314ca2a3e892862(options) {
  let isFocusedRef = (0, import_react41.useRef)(false);
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    onFocusChange: (isFocused) => {
      isFocusedRef.current = isFocused;
    }
  });
  let onBeforeCopy = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (isFocusedRef.current && options.getItems)
      e6.preventDefault();
  });
  let onCopy = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    var _options_onCopy;
    if (!isFocusedRef.current || !options.getItems)
      return;
    e6.preventDefault();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e6.clipboardData, options.getItems());
    (_options_onCopy = options.onCopy) === null || _options_onCopy === void 0 ? void 0 : _options_onCopy.call(options);
  });
  let onBeforeCut = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (isFocusedRef.current && options.onCut && options.getItems)
      e6.preventDefault();
  });
  let onCut = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (!isFocusedRef.current || !options.onCut || !options.getItems)
      return;
    e6.preventDefault();
    (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e6.clipboardData, options.getItems());
    options.onCut();
  });
  let onBeforePaste = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (isFocusedRef.current && options.onPaste)
      e6.preventDefault();
  });
  let onPaste = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e6) => {
    if (!isFocusedRef.current || !options.onPaste)
      return;
    e6.preventDefault();
    let items = (0, $7252cd45fc48c07c$export$d9e760437831f8b3)(e6.clipboardData);
    options.onPaste(items);
  });
  (0, import_react41.useEffect)(() => {
    return (0, $ff5963eb1fccf552$export$e08e3b67e392101e)($9fcc7f0d70d084ee$var$addGlobalEventListener("beforecopy", onBeforeCopy), $9fcc7f0d70d084ee$var$addGlobalEventListener("copy", onCopy), $9fcc7f0d70d084ee$var$addGlobalEventListener("beforecut", onBeforeCut), $9fcc7f0d70d084ee$var$addGlobalEventListener("cut", onCut), $9fcc7f0d70d084ee$var$addGlobalEventListener("beforepaste", onBeforePaste), $9fcc7f0d70d084ee$var$addGlobalEventListener("paste", onPaste));
  }, [
    onBeforeCopy,
    onCopy,
    onBeforeCut,
    onCut,
    onBeforePaste,
    onPaste
  ]);
  return {
    clipboardProps: focusProps
  };
}
function $ad0e3f3d9c50e4ba$var$DragPreview(props, ref) {
  let render3 = props.children;
  let [children, setChildren] = (0, import_react41.useState)(null);
  let domRef = (0, import_react41.useRef)(null);
  (0, import_react41.useImperativeHandle)(ref, () => (items, callback) => {
    (0, import_react_dom3.flushSync)(() => {
      setChildren(render3(items));
    });
    callback(domRef.current);
    requestAnimationFrame(() => {
      setChildren(null);
    });
  }, [
    render3
  ]);
  if (!children)
    return null;
  return (0, import_react41.default).createElement("div", {
    style: {
      zIndex: -100,
      position: "absolute",
      top: 0,
      left: -1e5
    },
    ref: domRef
  }, children);
}
var $ad0e3f3d9c50e4ba$export$905ab40ac2179daa = (0, import_react41.default).forwardRef($ad0e3f3d9c50e4ba$var$DragPreview);

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/dist/DropZone-db35e18a.esm.js
var import_react42 = __toESM(require_react());
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var localizedMessages4 = {
  "ar-AE": {
    dropzoneLabel: "DropZone"
  },
  "bg-BG": {
    dropzoneLabel: "DropZone"
  },
  "cs-CZ": {
    dropzoneLabel: "Místo pro přetažení"
  },
  "da-DK": {
    dropzoneLabel: "DropZone"
  },
  "de-DE": {
    dropzoneLabel: "Ablegebereich"
  },
  "el-GR": {
    dropzoneLabel: "DropZone"
  },
  "en-US": {
    dropzoneLabel: "DropZone"
  },
  "es-ES": {
    dropzoneLabel: "DropZone"
  },
  "et-EE": {
    dropzoneLabel: "DropZone"
  },
  "fi-FI": {
    dropzoneLabel: "DropZone"
  },
  "fr-FR": {
    dropzoneLabel: "DropZone"
  },
  "he-IL": {
    dropzoneLabel: "DropZone"
  },
  "hr-HR": {
    dropzoneLabel: "Zona spuštanja"
  },
  "hu-HU": {
    dropzoneLabel: "DropZone"
  },
  "it-IT": {
    dropzoneLabel: "Zona di rilascio"
  },
  "ja-JP": {
    dropzoneLabel: "ドロップゾーン"
  },
  "ko-KR": {
    dropzoneLabel: "드롭 영역"
  },
  "lt-LT": {
    dropzoneLabel: "„DropZone“"
  },
  "lv-LV": {
    dropzoneLabel: "DropZone"
  },
  "nb-NO": {
    dropzoneLabel: "Droppsone"
  },
  "nl-NL": {
    dropzoneLabel: "DropZone"
  },
  "pl-PL": {
    dropzoneLabel: "Strefa upuszczania"
  },
  "pt-BR": {
    dropzoneLabel: "DropZone"
  },
  "pt-PT": {
    dropzoneLabel: "DropZone"
  },
  "ro-RO": {
    dropzoneLabel: "Zonă de plasare"
  },
  "ru-RU": {
    dropzoneLabel: "DropZone"
  },
  "sk-SK": {
    dropzoneLabel: "DropZone"
  },
  "sl-SI": {
    dropzoneLabel: "DropZone"
  },
  "sr-SP": {
    dropzoneLabel: "DropZone"
  },
  "sv-SE": {
    dropzoneLabel: "DropZone"
  },
  "tr-TR": {
    dropzoneLabel: "DropZone"
  },
  "uk-UA": {
    dropzoneLabel: "DropZone"
  },
  "zh-CN": {
    dropzoneLabel: "放置区域"
  },
  "zh-TW": {
    dropzoneLabel: "放置區"
  }
};
var dropZoneClassList = new ClassList("DropZone");
var DropZone = forwardRefWithAs(function DropZone2(props, forwardedRef) {
  let dropzoneRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let buttonRef = (0, import_react42.useRef)(null);
  let {
    dropProps,
    dropButtonProps,
    isDropTarget
  } = $5c06e4929e123553$export$ccdee5eaf73cf661({
    ...props,
    ref: buttonRef,
    hasDropButton: true
  });
  let {
    clipboardProps
  } = $9fcc7f0d70d084ee$export$2314ca2a3e892862({
    onPaste: (items) => {
      var _props$onDrop;
      return (_props$onDrop = props.onDrop) === null || _props$onDrop === void 0 ? void 0 : _props$onDrop.call(props, {
        type: "drop",
        items,
        x: 0,
        y: 0,
        dropOperation: "copy"
      });
    }
  });
  let {
    focusProps,
    isFocused,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages4);
  let labelId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let dropzoneId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let ariaLabel = props["aria-label"] || stringFormatter.format("dropzoneLabel");
  let messageId = props["aria-labelledby"];
  let ariaLabelledby = [dropzoneId, labelId, messageId].filter(Boolean).join(" ");
  let labelProps = $313b98861ee5dd6c$export$d6875122194c7b44({
    "aria-labelledby": ariaLabelledby
  });
  let slots = {
    icon: {
      color: isDropTarget ? "accent" : "neutral"
    },
    label: {
      id: labelId,
      color: isDropTarget ? "accent" : void 0
    }
  };
  let children = useRenderProps(props, {
    isDropTarget
  });
  let styleProps = useStyleProps(props);
  let ElementType = props.elementType || "div";
  return (0, import_jsx_runtime21.jsxs)(ElementType, {
    ...dropProps,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    }),
    ...toDataAttributes({
      isDropTarget,
      isFocused,
      isFocusVisible
    }, {
      omitFalsyValues: true,
      trimBooleanKeys: true
    }),
    ref: dropzoneRef,
    className: classNames(dropZoneClassList.element("root"), css({
      border: `${tokenSchema.size.border.medium} dashed ${tokenSchema.color.border.neutral}`,
      borderRadius: tokenSchema.size.radius.regular,
      display: "flex",
      flexDirection: "column",
      gap: tokenSchema.size.space.medium,
      "&[data-drop-target]": {
        backgroundColor: tokenSchema.color.alias.backgroundSelected,
        borderColor: tokenSchema.color.alias.focusRing,
        borderStyle: "solid",
        cursor: "copy"
      },
      "&[data-focus-visible]": {
        borderColor: tokenSchema.color.alias.focusRing
      }
    }), styleProps.className),
    children: [(0, import_jsx_runtime21.jsxs)($5c3e21d68f1c4674$export$439d29a4e110a164, {
      children: [(0, import_jsx_runtime21.jsx)("div", {
        id: dropzoneId,
        "aria-hidden": "true",
        children: ariaLabel
      }), (0, import_jsx_runtime21.jsx)("button", {
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(dropButtonProps, focusProps, clipboardProps, labelProps),
        ref: buttonRef
      })]
    }), (0, import_jsx_runtime21.jsx)(SlotProvider, {
      slots,
      children
    })]
  });
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/drag-and-drop/dist/keystar-ui-drag-and-drop.esm.js
var import_react44 = __toESM(require_react());
var import_jsx_runtime22 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-stately+dnd@3.2.6_react@18.2.0/node_modules/@react-stately/dnd/dist/import.mjs
var import_react43 = __toESM(require_react(), 1);
function $b45bbbaf0c3785df$export$29efd034f1d79f81(props) {
  let { getItems, collection: collection2, selectionManager, onDragStart, onDragMove, onDragEnd, preview, getAllowedDropOperations } = props;
  let [, setDragging] = (0, import_react43.useState)(false);
  let draggingKeys = (0, import_react43.useRef)(/* @__PURE__ */ new Set());
  let draggedKey = (0, import_react43.useRef)(null);
  let getKeys = (key) => {
    let keys = new Set(selectionManager.isSelected(key) ? new Set([
      ...selectionManager.selectedKeys
    ].filter((key2) => !!collection2.getItem(key2))) : []);
    keys.add(key);
    return keys;
  };
  return {
    collection: collection2,
    selectionManager,
    get draggedKey() {
      return draggedKey.current;
    },
    get draggingKeys() {
      return draggingKeys.current;
    },
    isDragging(key) {
      return draggingKeys.current.has(key);
    },
    getKeysForDrag: getKeys,
    getItems(key) {
      return getItems(getKeys(key));
    },
    preview,
    getAllowedDropOperations,
    startDrag(key, event) {
      let keys = getKeys(key);
      draggingKeys.current = keys;
      draggedKey.current = key;
      selectionManager.setFocused(false);
      setDragging(true);
      if (typeof onDragStart === "function")
        onDragStart({
          ...event,
          keys
        });
    },
    moveDrag(event) {
      if (typeof onDragMove === "function")
        onDragMove({
          ...event,
          keys: draggingKeys.current
        });
    },
    endDrag(event) {
      let { isInternal } = event;
      if (typeof onDragEnd === "function")
        onDragEnd({
          ...event,
          keys: draggingKeys.current,
          isInternal
        });
      draggingKeys.current = /* @__PURE__ */ new Set();
      draggedKey.current = null;
      setDragging(false);
    }
  };
}
function $e672e8bc247525d1$export$926850f6ecef79d0(props) {
  let { acceptedDragTypes = "all", onInsert, onRootDrop, onItemDrop, onReorder, shouldAcceptItemDrop, collection: collection2, selectionManager, onDropEnter, getDropOperation, onDrop } = props;
  let [target, setTarget] = (0, import_react43.useState)(null);
  let targetRef = (0, import_react43.useRef)(null);
  let getOppositeTarget = (target2) => {
    if (target2.dropPosition === "before") {
      let key = collection2.getKeyBefore(target2.key);
      return key != null ? {
        type: "item",
        key,
        dropPosition: "after"
      } : null;
    } else if (target2.dropPosition === "after") {
      let key = collection2.getKeyAfter(target2.key);
      return key != null ? {
        type: "item",
        key,
        dropPosition: "before"
      } : null;
    }
  };
  let defaultGetDropOperation = (0, import_react43.useCallback)((e6) => {
    let { target: target2, types, allowedOperations, isInternal, draggingKeys } = e6;
    if (acceptedDragTypes === "all" || acceptedDragTypes.some((type2) => types.has(type2))) {
      let isValidInsert = onInsert && target2.type === "item" && !isInternal && (target2.dropPosition === "before" || target2.dropPosition === "after");
      let isValidReorder = onReorder && target2.type === "item" && isInternal && (target2.dropPosition === "before" || target2.dropPosition === "after");
      let isValidRootDrop = onRootDrop && target2.type === "root" && !isInternal;
      let isValidOnItemDrop = onItemDrop && target2.type === "item" && target2.dropPosition === "on" && !(isInternal && draggingKeys.has(target2.key)) && (!shouldAcceptItemDrop || shouldAcceptItemDrop(target2, types));
      if (onDrop || isValidInsert || isValidReorder || isValidRootDrop || isValidOnItemDrop) {
        if (getDropOperation)
          return getDropOperation(target2, types, allowedOperations);
        else
          return allowedOperations[0];
      }
    }
    return "cancel";
  }, [
    acceptedDragTypes,
    getDropOperation,
    onInsert,
    onRootDrop,
    onItemDrop,
    shouldAcceptItemDrop,
    onReorder,
    onDrop
  ]);
  return {
    collection: collection2,
    selectionManager,
    target,
    setTarget(newTarget) {
      if (this.isDropTarget(newTarget))
        return;
      let target2 = targetRef.current;
      if (target2 && typeof props.onDropExit === "function")
        props.onDropExit({
          type: "dropexit",
          x: 0,
          y: 0,
          target: target2
        });
      if (newTarget && typeof onDropEnter === "function")
        onDropEnter({
          type: "dropenter",
          x: 0,
          y: 0,
          target: newTarget
        });
      targetRef.current = newTarget;
      setTarget(newTarget);
    },
    isDropTarget(dropTarget) {
      let target2 = targetRef.current;
      if ($e672e8bc247525d1$var$isEqualDropTarget(dropTarget, target2))
        return true;
      if ((dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.type) === "item" && (target2 === null || target2 === void 0 ? void 0 : target2.type) === "item" && dropTarget.key !== target2.key && dropTarget.dropPosition !== target2.dropPosition && dropTarget.dropPosition !== "on" && target2.dropPosition !== "on")
        return $e672e8bc247525d1$var$isEqualDropTarget(getOppositeTarget(dropTarget), target2) || $e672e8bc247525d1$var$isEqualDropTarget(dropTarget, getOppositeTarget(target2));
      return false;
    },
    getDropOperation(e6) {
      return defaultGetDropOperation(e6);
    }
  };
}
function $e672e8bc247525d1$var$isEqualDropTarget(a3, b2) {
  if (!a3)
    return !b2;
  switch (a3.type) {
    case "root":
      return (b2 === null || b2 === void 0 ? void 0 : b2.type) === "root";
    case "item":
      return (b2 === null || b2 === void 0 ? void 0 : b2.type) === "item" && (b2 === null || b2 === void 0 ? void 0 : b2.key) === a3.key && (b2 === null || b2 === void 0 ? void 0 : b2.dropPosition) === a3.dropPosition;
  }
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/drag-and-drop/dist/keystar-ui-drag-and-drop.esm.js
function FileTrigger(props, ref) {
  let {
    acceptedFileTypes,
    allowsMultiple,
    children,
    defaultCamera,
    onSelect,
    ...rest
  } = props;
  let inputRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(rest);
  return (0, import_jsx_runtime22.jsxs)(import_jsx_runtime22.Fragment, {
    children: [(0, import_jsx_runtime22.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      onPress: () => {
        var _inputRef$current;
        if (inputRef.current.value) {
          inputRef.current.value = "";
        }
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.click();
      },
      children
    }), (0, import_jsx_runtime22.jsx)("input", {
      ...domProps,
      accept: acceptedFileTypes === null || acceptedFileTypes === void 0 ? void 0 : acceptedFileTypes.toString(),
      capture: defaultCamera,
      multiple: allowsMultiple,
      onChange: (e6) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(e6.target.files),
      ref: inputRef,
      style: {
        display: "none"
      },
      type: "file"
    })]
  });
}
var _FileTrigger = (0, import_react44.forwardRef)(FileTrigger);
function useDragAndDrop(options) {
  let dragAndDropHooks = (0, import_react44.useMemo)(() => {
    let {
      onDrop,
      onInsert,
      onItemDrop,
      onReorder,
      onRootDrop,
      getItems
    } = options;
    let isDraggable = !!getItems;
    let isDroppable = !!(onDrop || onInsert || onItemDrop || onReorder || onRootDrop);
    let hooks = {};
    if (isDraggable) {
      hooks.useDraggableCollectionState = function useDraggableCollectionStateOverride(props) {
        return $b45bbbaf0c3785df$export$29efd034f1d79f81({
          ...props,
          ...options
        });
      };
      hooks.useDraggableCollection = $4ac1fdc3a0fcd564$export$2962a7984b2f0a80;
      hooks.useDraggableItem = $fd98cf7cbf233429$export$b35afafff42da2d9;
      hooks.DragPreview = $ad0e3f3d9c50e4ba$export$905ab40ac2179daa;
    }
    if (isDroppable) {
      hooks.useDroppableCollectionState = function useDroppableCollectionStateOverride(props) {
        return $e672e8bc247525d1$export$926850f6ecef79d0({
          ...props,
          ...options
        });
      }, hooks.useDroppableItem = $bfaab576ce1c580e$export$f7b0c5d28b66b6a5;
      hooks.useDroppableCollection = function useDroppableCollectionOverride(props, state, ref) {
        return $4b52e4eff84e5217$export$f4e2f423c21f7b04({
          ...props,
          ...options
        }, state, ref);
      };
      hooks.useDropIndicator = $ddf25448c71fc93a$export$8d0e41d2815afac5;
    }
    if (isDraggable || isDroppable) {
      hooks.isVirtualDragging = $67560de7c78cb232$export$403bc76cbf68cf60;
    }
    return hooks;
  }, [options]);
  return {
    dragAndDropHooks
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/trash2Icon/dist/keystar-ui-icon-icons-trash2Icon.esm.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var trash2Icon = (0, import_jsx_runtime23.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime23.jsx)("path", {
    d: "M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M10 11v6M14 11v6"
  })
});

// node_modules/.pnpm/@react-stately+selection@3.14.1_react@18.2.0/node_modules/@react-stately/selection/dist/import.mjs
var import_react45 = __toESM(require_react(), 1);
var $e40ea825a81a3709$export$52baac22726c72bf = class _$e40ea825a81a3709$export$52baac22726c72bf extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    if (keys instanceof _$e40ea825a81a3709$export$52baac22726c72bf) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
};
function $7af3f5b51489e0b5$var$equalSets(setA, setB) {
  if (setA.size !== setB.size)
    return false;
  for (let item2 of setA) {
    if (!setB.has(item2))
      return false;
  }
  return true;
}
function $7af3f5b51489e0b5$export$253fe78d46329472(props) {
  let { selectionMode = "none", disallowEmptySelection, allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = "toggle", disabledBehavior = "all" } = props;
  let isFocusedRef = (0, import_react45.useRef)(false);
  let [, setFocused] = (0, import_react45.useState)(false);
  let focusedKeyRef = (0, import_react45.useRef)(null);
  let childFocusStrategyRef = (0, import_react45.useRef)(null);
  let [, setFocusedKey] = (0, import_react45.useState)(null);
  let selectedKeysProp = (0, import_react45.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [
    props.selectedKeys
  ]);
  let defaultSelectedKeys = (0, import_react45.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [
    props.defaultSelectedKeys
  ]);
  let [selectedKeys, setSelectedKeys] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);
  let disabledKeysProp = (0, import_react45.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let [selectionBehavior, setSelectionBehavior] = (0, import_react45.useState)(selectionBehaviorProp);
  if (selectionBehaviorProp === "replace" && selectionBehavior === "toggle" && typeof selectedKeys === "object" && selectedKeys.size === 0)
    setSelectionBehavior("replace");
  let lastSelectionBehavior = (0, import_react45.useRef)(selectionBehaviorProp);
  (0, import_react45.useEffect)(() => {
    if (selectionBehaviorProp !== lastSelectionBehavior.current) {
      setSelectionBehavior(selectionBehaviorProp);
      lastSelectionBehavior.current = selectionBehaviorProp;
    }
  }, [
    selectionBehaviorProp
  ]);
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    get isFocused() {
      return isFocusedRef.current;
    },
    setFocused(f5) {
      isFocusedRef.current = f5;
      setFocused(f5);
    },
    get focusedKey() {
      return focusedKeyRef.current;
    },
    get childFocusStrategy() {
      return childFocusStrategyRef.current;
    },
    setFocusedKey(k2, childFocusStrategy = "first") {
      focusedKeyRef.current = k2;
      childFocusStrategyRef.current = childFocusStrategy;
      setFocusedKey(k2);
    },
    selectedKeys,
    setSelectedKeys(keys) {
      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys))
        setSelectedKeys(keys);
    },
    disabledKeys: disabledKeysProp,
    disabledBehavior
  };
}
function $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {
  if (!selection)
    return defaultValue;
  return selection === "all" ? "all" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);
}
var $d496c0a20b6e58ec$export$6c8a5aaad13c9852 = class {
  /**
  * The type of selection that is allowed in the collection.
  */
  get selectionMode() {
    return this.state.selectionMode;
  }
  /**
  * Whether the collection allows empty selection.
  */
  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  /**
  * The selection behavior for the collection.
  */
  get selectionBehavior() {
    return this.state.selectionBehavior;
  }
  /**
  * Sets the selection behavior for the collection.
  */
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }
  /**
  * Whether the collection is currently focused.
  */
  get isFocused() {
    return this.state.isFocused;
  }
  /**
  * Sets whether the collection is focused.
  */
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  /**
  * The current focused key in the collection.
  */
  get focusedKey() {
    return this.state.focusedKey;
  }
  /** Whether the first or last child of the focused key should receive focus. */
  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  /**
  * Sets the focused key.
  */
  setFocusedKey(key, childFocusStrategy) {
    if (key == null || this.collection.getItem(key))
      this.state.setFocusedKey(key, childFocusStrategy);
  }
  /**
  * The currently selected keys in the collection.
  */
  get selectedKeys() {
    return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  /**
  * The raw selection value for the collection.
  * Either 'all' for select all, or a set of keys.
  */
  get rawSelection() {
    return this.state.selectedKeys;
  }
  /**
  * Returns whether a key is selected.
  */
  isSelected(key) {
    if (this.state.selectionMode === "none")
      return false;
    key = this.getKey(key);
    return this.state.selectedKeys === "all" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);
  }
  /**
  * Whether the selection is empty.
  */
  get isEmpty() {
    return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
  }
  /**
  * Whether all items in the collection are selected.
  */
  get isSelectAll() {
    if (this.isEmpty)
      return false;
    if (this.state.selectedKeys === "all")
      return true;
    if (this._isSelectAll != null)
      return this._isSelectAll;
    let allKeys = this.getSelectAllKeys();
    let selectedKeys = this.state.selectedKeys;
    this._isSelectAll = allKeys.every((k2) => selectedKeys.has(k2));
    return this._isSelectAll;
  }
  get firstSelectedKey() {
    let first = null;
    for (let key of this.state.selectedKeys) {
      let item2 = this.collection.getItem(key);
      if (!first || item2 && (0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, item2, first) < 0)
        first = item2;
    }
    return first === null || first === void 0 ? void 0 : first.key;
  }
  get lastSelectedKey() {
    let last = null;
    for (let key of this.state.selectedKeys) {
      let item2 = this.collection.getItem(key);
      if (!last || item2 && (0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, item2, last) > 0)
        last = item2;
    }
    return last === null || last === void 0 ? void 0 : last.key;
  }
  get disabledKeys() {
    return this.state.disabledKeys;
  }
  get disabledBehavior() {
    return this.state.disabledBehavior;
  }
  /**
  * Extends the selection to the given key.
  */
  extendSelection(toKey) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single") {
      this.replaceSelection(toKey);
      return;
    }
    toKey = this.getKey(toKey);
    let selection;
    if (this.state.selectedKeys === "all")
      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([
        toKey
      ], toKey, toKey);
    else {
      let selectedKeys = this.state.selectedKeys;
      let anchorKey = selectedKeys.anchorKey || toKey;
      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);
      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey))
        selection.delete(key);
      for (let key of this.getKeyRange(toKey, anchorKey))
        if (this.canSelectItem(key))
          selection.add(key);
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from2, to) {
    let fromItem = this.collection.getItem(from2);
    let toItem = this.collection.getItem(to);
    if (fromItem && toItem) {
      if ((0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, fromItem, toItem) <= 0)
        return this.getKeyRangeInternal(from2, to);
      return this.getKeyRangeInternal(to, from2);
    }
    return [];
  }
  getKeyRangeInternal(from2, to) {
    let keys = [];
    let key = from2;
    while (key) {
      let item2 = this.collection.getItem(key);
      if (item2 && item2.type === "item" || item2.type === "cell" && this.allowsCellSelection)
        keys.push(key);
      if (key === to)
        return keys;
      key = this.collection.getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    let item2 = this.collection.getItem(key);
    if (!item2)
      return key;
    if (item2.type === "cell" && this.allowsCellSelection)
      return key;
    while (item2.type !== "item" && item2.parentKey != null)
      item2 = this.collection.getItem(item2.parentKey);
    if (!item2 || item2.type !== "item")
      return null;
    return item2.key;
  }
  /**
  * Toggles whether the given key is selected.
  */
  toggleSelection(key) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    key = this.getKey(key);
    if (key == null)
      return;
    let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
    if (keys.has(key))
      keys.delete(key);
    else if (this.canSelectItem(key)) {
      keys.add(key);
      keys.anchorKey = key;
      keys.currentKey = key;
    }
    if (this.disallowEmptySelection && keys.size === 0)
      return;
    this.state.setSelectedKeys(keys);
  }
  /**
  * Replaces the selection with only the given key.
  */
  replaceSelection(key) {
    if (this.selectionMode === "none")
      return;
    key = this.getKey(key);
    if (key == null)
      return;
    let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([
      key
    ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();
    this.state.setSelectedKeys(selection);
  }
  /**
  * Replaces the selection with the given keys.
  */
  setSelectedKeys(keys) {
    if (this.selectionMode === "none")
      return;
    let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();
    for (let key of keys) {
      key = this.getKey(key);
      if (key != null) {
        selection.add(key);
        if (this.selectionMode === "single")
          break;
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getSelectAllKeys() {
    let keys = [];
    let addKeys = (key) => {
      while (key) {
        if (this.canSelectItem(key)) {
          let item2 = this.collection.getItem(key);
          if (item2.type === "item")
            keys.push(key);
          if (item2.hasChildNodes && (this.allowsCellSelection || item2.type !== "item"))
            addKeys((0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection)).key);
        }
        key = this.collection.getKeyAfter(key);
      }
    };
    addKeys(this.collection.getFirstKey());
    return keys;
  }
  /**
  * Selects all items in the collection.
  */
  selectAll() {
    if (!this.isSelectAll && this.selectionMode === "multiple")
      this.state.setSelectedKeys("all");
  }
  /**
  * Removes all keys from the selection.
  */
  clearSelection() {
    if (!this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0))
      this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());
  }
  /**
  * Toggles between select all and an empty selection.
  */
  toggleSelectAll() {
    if (this.isSelectAll)
      this.clearSelection();
    else
      this.selectAll();
  }
  select(key, e6) {
    if (this.selectionMode === "none")
      return;
    if (this.selectionMode === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection)
        this.toggleSelection(key);
      else
        this.replaceSelection(key);
    } else if (this.selectionBehavior === "toggle" || e6 && (e6.pointerType === "touch" || e6.pointerType === "virtual"))
      this.toggleSelection(key);
    else
      this.replaceSelection(key);
  }
  /**
  * Returns whether the current selection is equal to the given selection.
  */
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys)
      return true;
    let selectedKeys = this.selectedKeys;
    if (selection.size !== selectedKeys.size)
      return false;
    for (let key of selection) {
      if (!selectedKeys.has(key))
        return false;
    }
    for (let key of selectedKeys) {
      if (!selection.has(key))
        return false;
    }
    return true;
  }
  canSelectItem(key) {
    if (this.state.selectionMode === "none" || this.state.disabledKeys.has(key))
      return false;
    let item2 = this.collection.getItem(key);
    if (!item2 || item2.type === "cell" && !this.allowsCellSelection)
      return false;
    return true;
  }
  isDisabled(key) {
    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === "all";
  }
  isLink(key) {
    var _this_collection_getItem_props, _this_collection_getItem;
    return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);
  }
  constructor(collection2, state, options) {
    this.collection = collection2;
    this.state = state;
    var _options_allowsCellSelection;
    this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;
    this._isSelectAll = null;
  }
};

// node_modules/.pnpm/@react-stately+list@3.10.1_react@18.2.0/node_modules/@react-stately/list/dist/import.mjs
var import_react46 = __toESM(require_react(), 1);
var $a02d57049d202695$export$d085fb9e920b5ca7 = class {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node3 = this.keyMap.get(key);
    return node3 ? node3.prevKey : null;
  }
  getKeyAfter(key) {
    let node3 = this.keyMap.get(key);
    return node3 ? node3.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  getChildren(key) {
    let node3 = this.keyMap.get(key);
    return (node3 === null || node3 === void 0 ? void 0 : node3.childNodes) || [];
  }
  constructor(nodes) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.iterable = nodes;
    let visit2 = (node3) => {
      this.keyMap.set(node3.key, node3);
      if (node3.childNodes && node3.type === "section")
        for (let child of node3.childNodes)
          visit2(child);
    };
    for (let node3 of nodes)
      visit2(node3);
    let last;
    let index2 = 0;
    for (let [key, node3] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node3.prevKey = last.key;
      } else {
        this.firstKey = key;
        node3.prevKey = void 0;
      }
      if (node3.type === "item")
        node3.index = index2++;
      last = node3;
      last.nextKey = void 0;
    }
    this.lastKey = last === null || last === void 0 ? void 0 : last.key;
  }
};
function $e72dd72e1c76a225$export$2f645645f7bca764(props) {
  let { filter: filter3 } = props;
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react46.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let factory = (0, import_react46.useCallback)((nodes) => filter3 ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter3(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes), [
    filter3
  ]);
  let context = (0, import_react46.useMemo)(() => ({
    suppressTextValueWarning: props.suppressTextValueWarning
  }), [
    props.suppressTextValueWarning
  ]);
  let collection2 = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, factory, context);
  let selectionManager = (0, import_react46.useMemo)(() => new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(collection2, selectionState), [
    collection2,
    selectionState
  ]);
  const cachedCollection = (0, import_react46.useRef)(null);
  (0, import_react46.useEffect)(() => {
    if (selectionState.focusedKey != null && !collection2.getItem(selectionState.focusedKey)) {
      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);
      const cachedItemNodes = [
        ...cachedCollection.current.getKeys()
      ].map((key) => {
        const itemNode = cachedCollection.current.getItem(key);
        return itemNode.type === "item" ? itemNode : null;
      }).filter((node3) => node3 !== null);
      const itemNodes = [
        ...collection2.getKeys()
      ].map((key) => {
        const itemNode = collection2.getItem(key);
        return itemNode.type === "item" ? itemNode : null;
      }).filter((node3) => node3 !== null);
      const diff = cachedItemNodes.length - itemNodes.length;
      let index2 = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);
      let newNode;
      while (index2 >= 0) {
        if (!selectionManager.isDisabled(itemNodes[index2].key)) {
          newNode = itemNodes[index2];
          break;
        }
        if (index2 < itemNodes.length - 1)
          index2++;
        else {
          if (index2 > startItem.index)
            index2 = startItem.index;
          index2--;
        }
      }
      selectionState.setFocusedKey(newNode ? newNode.key : null);
    }
    cachedCollection.current = collection2;
  }, [
    collection2,
    selectionManager,
    selectionState,
    selectionState.focusedKey
  ]);
  return {
    collection: collection2,
    disabledKeys,
    selectionManager
  };
}
function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {
  var _props_defaultSelectedKey;
  let [selectedKey, setSelectedKey] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);
  let selectedKeys = (0, import_react46.useMemo)(() => selectedKey != null ? [
    selectedKey
  ] : [], [
    selectedKey
  ]);
  let { collection: collection2, disabledKeys, selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({
    ...props,
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: (keys) => {
      var _keys_values_next_value;
      let key = (_keys_values_next_value = keys.values().next().value) !== null && _keys_values_next_value !== void 0 ? _keys_values_next_value : null;
      if (key === selectedKey && props.onSelectionChange)
        props.onSelectionChange(key);
      setSelectedKey(key);
    }
  });
  let selectedItem = selectedKey != null ? collection2.getItem(selectedKey) : null;
  return {
    collection: collection2,
    disabledKeys,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

// node_modules/.pnpm/@react-stately+virtualizer@3.6.5_react@18.2.0/node_modules/@react-stately/virtualizer/dist/import.mjs
var import_react47 = __toESM(require_react(), 1);
var $c74cda7d31af1253$export$c84671f46d6a1ca = class {
  /**
  * Returns whether the layout should invalidate in response to
  * visible rectangle changes. By default, it only invalidates
  * when the collection view's size changes. Return true always
  * to make the layout invalidate while scrolling (e.g. sticky headers).
  */
  shouldInvalidate(newRect, oldRect) {
    return newRect.width !== oldRect.width || newRect.height !== oldRect.height;
  }
  /**
  * This method allows the layout to perform any pre-computation
  * it needs to in order to prepare {@link LayoutInfo}s for retrieval.
  * Called by the collection view before {@link getVisibleLayoutInfos}
  * or {@link getLayoutInfo} are called.
  */
  validate(invalidationContext) {
  }
  /**
  * Returns a {@link DragTarget} describing a view at the given point to be dragged.
  * Return `null` to cancel the drag. The default implementation returns the view at the given point.
  * @param point The point at which the drag occurred.
  */
  // getDragTarget(point: Point): DragTarget | null {
  //   let target = this.virtualizer.keyAtPoint(point);
  //   if (!target) {
  //     return null;
  //   }
  //   return {
  //     type: 'item',
  //     key: target
  //   };
  // }
  /**
  * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`
  * to reject the drop. The dropped items will be inserted before the resulting target.
  * @param point The point at which the drop occurred.
  */
  // getDropTarget(point: Point): DropTarget | null {
  //   return null;
  // }
  /**
  * Returns the starting attributes for an animated insertion.
  * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.
  * The default implementation just returns its input.
  *
  * @param layoutInfo The proposed LayoutInfo for this view.
  */
  getInitialLayoutInfo(layoutInfo) {
    return layoutInfo;
  }
  /**
  * Returns the ending attributes for an animated removal.
  * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}
  * to the one returned by this method. The default implementation returns its input.
  *
  * @param layoutInfo The original LayoutInfo for this view.
  */
  getFinalLayoutInfo(layoutInfo) {
    return layoutInfo;
  }
};
var $d7fd61009c21d0bb$export$7e0eeb9da702a085 = class _$d7fd61009c21d0bb$export$7e0eeb9da702a085 {
  /**
  * Returns a copy of the LayoutInfo.
  */
  copy() {
    let res = new _$d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());
    res.estimatedSize = this.estimatedSize;
    res.opacity = this.opacity;
    res.transform = this.transform;
    res.parentKey = this.parentKey;
    res.isSticky = this.isSticky;
    res.zIndex = this.zIndex;
    res.allowOverflow = this.allowOverflow;
    return res;
  }
  /**
  * @param type A string representing the view type. Should be `'item'` for item views.
                           Other types are used by supplementary views.
  * @param key The unique key for this view.
  * @param rect The rectangle describing the size and position of this view.
  */
  constructor(type2, key, rect) {
    this.type = type2;
    this.key = key;
    this.parentKey = null;
    this.rect = rect;
    this.estimatedSize = false;
    this.isSticky = false;
    this.opacity = 1;
    this.transform = null;
    this.zIndex = 0;
    this.allowOverflow = false;
  }
};
var $3041db3296945e6e$export$baf26146a414f24a = class _$3041db3296945e6e$export$baf26146a414f24a {
  /**
  * Returns a copy of this point.
  */
  copy() {
    return new _$3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);
  }
  /**
  * Checks if two points are equal.
  */
  equals(point) {
    return this.x === point.x && this.y === point.y;
  }
  /**
  * Returns true if this point is the origin.
  */
  isOrigin() {
    return this.x === 0 && this.y === 0;
  }
  constructor(x3 = 0, y4 = 0) {
    this.x = x3;
    this.y = y4;
  }
};
var $60423f92c7f9ad87$export$c79fc6492f3af13d = class _$60423f92c7f9ad87$export$c79fc6492f3af13d {
  /**
  * The maximum x-coordinate in the rectangle.
  */
  get maxX() {
    return this.x + this.width;
  }
  /**
  * The maximum y-coordinate in the rectangle.
  */
  get maxY() {
    return this.y + this.height;
  }
  /**
  * The area of the rectangle.
  */
  get area() {
    return this.width * this.height;
  }
  /**
  * The top left corner of the rectangle.
  */
  get topLeft() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);
  }
  /**
  * The top right corner of the rectangle.
  */
  get topRight() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);
  }
  /**
  * The bottom left corner of the rectangle.
  */
  get bottomLeft() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);
  }
  /**
  * The bottom right corner of the rectangle.
  */
  get bottomRight() {
    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);
  }
  /**
  * Returns whether this rectangle intersects another rectangle.
  * @param rect - The rectangle to check.
  */
  intersects(rect) {
    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;
  }
  /**
  * Returns whether this rectangle fully contains another rectangle.
  * @param rect - The rectangle to check.
  */
  containsRect(rect) {
    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;
  }
  /**
  * Returns whether the rectangle contains the given point.
  * @param point - The point to check.
  */
  containsPoint(point) {
    return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;
  }
  /**
  * Returns the first corner of this rectangle (from top to bottom, left to right)
  * that is contained in the given rectangle, or null of the rectangles do not intersect.
  * @param rect - The rectangle to check.
  */
  getCornerInRect(rect) {
    for (let key of [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]) {
      if (rect.containsPoint(this[key]))
        return key;
    }
    return null;
  }
  equals(rect) {
    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
  }
  pointEquals(point) {
    return this.x === point.x && this.y === point.y;
  }
  sizeEquals(size3) {
    return this.width === size3.width && this.height === size3.height;
  }
  /**
  * Returns the union of this Rect and another.
  */
  union(other) {
    let x3 = Math.min(this.x, other.x);
    let y4 = Math.min(this.y, other.y);
    let width = Math.max(this.maxX, other.maxX) - x3;
    let height = Math.max(this.maxY, other.maxY) - y4;
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(x3, y4, width, height);
  }
  /**
  * Returns the intersection of this Rect with another.
  * If the rectangles do not intersect, an all zero Rect is returned.
  */
  intersection(other) {
    if (!this.intersects(other))
      return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);
    let x3 = Math.max(this.x, other.x);
    let y4 = Math.max(this.y, other.y);
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(x3, y4, Math.min(this.maxX, other.maxX) - x3, Math.min(this.maxY, other.maxY) - y4);
  }
  /**
  * Returns a copy of this rectangle.
  */
  copy() {
    return new _$60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);
  }
  constructor(x3 = 0, y4 = 0, width = 0, height = 0) {
    this.x = x3;
    this.y = y4;
    this.width = width;
    this.height = height;
  }
};
var $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec = class _$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {
  /**
  * Returns a copy of this size.
  */
  copy() {
    return new _$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);
  }
  /**
  * Returns whether this size is equal to another one.
  */
  equals(other) {
    return this.width === other.width && this.height === other.height;
  }
  /**
  * The total area of the Size.
  */
  get area() {
    return this.width * this.height;
  }
  constructor(width = 0, height = 0) {
    this.width = width;
    this.height = height;
  }
};
var $ad1d98aa8f0c31b4$var$KEY = 0;
var $ad1d98aa8f0c31b4$export$1a5223887c560441 = class {
  /**
  * Prepares the view for reuse. Called just before the view is removed from the DOM.
  */
  prepareForReuse() {
    this.content = null;
    this.rendered = null;
    this.layoutInfo = null;
  }
  constructor(virtualizer) {
    this.virtualizer = virtualizer;
    this.key = ++$ad1d98aa8f0c31b4$var$KEY;
  }
};
var $3eb131dcf37ad5f8$var$perf = typeof window !== "undefined" ? window.performance : null;
var $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);
var $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
};
var $3eb131dcf37ad5f8$var$fixTs;
function $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn2) {
  let canceled = false;
  let raf_id;
  let promise = new Promise((resolve3) => {
    let start2 = $3eb131dcf37ad5f8$var$getTime();
    let diffX = end.x - begin.x;
    let diffY = end.y - begin.y;
    raf_id = requestAnimationFrame(function run(t5) {
      if ($3eb131dcf37ad5f8$var$fixTs == null)
        $3eb131dcf37ad5f8$var$fixTs = t5 > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;
      if ($3eb131dcf37ad5f8$var$fixTs)
        t5 = $3eb131dcf37ad5f8$var$getTime();
      let delta = t5 - start2;
      if (delta > duration) {
        fn2(end);
        resolve3();
      } else {
        let proceed = fn2(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));
        if (proceed !== false && !canceled)
          raf_id = requestAnimationFrame(run);
      }
    });
  });
  promise.cancel = function() {
    canceled = true;
    cancelAnimationFrame(raf_id);
  };
  return promise;
}
function $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t5) {
  return Math.sin(t5 * Math.PI / 2);
}
function $fc36f9a046a9ce79$export$37a26b283fd7740e(a3, b2) {
  let res = /* @__PURE__ */ new Set();
  for (let key of a3.keys())
    if (!b2.has(key))
      res.add(key);
  return res;
}
function $fc36f9a046a9ce79$export$acaf96a27438246b(a3, b2) {
  let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a3, b2);
  let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b2, a3);
  let toUpdate = /* @__PURE__ */ new Set();
  for (let key of a3.keys())
    if (b2.has(key))
      toUpdate.add(key);
  return {
    toRemove,
    toAdd,
    toUpdate
  };
}
function* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {
  for (let iterator of iterators)
    yield* iterator;
}
function $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a3, b2) {
  if (a3 === b2)
    return true;
  if (a3.size !== b2.size)
    return false;
  for (let key of a3) {
    if (!b2.has(key))
      return false;
  }
  return true;
}
var $364191b3decf3697$var$RollingAverage = class {
  addSample(sample) {
    this.count++;
    this.value += (sample - this.value) / this.count;
  }
  constructor() {
    this.count = 0;
    this.value = 0;
  }
};
var $364191b3decf3697$export$4455ee6afb38dcbb = class {
  setVisibleRect(rect) {
    let time2 = performance.now() - this.startTime;
    if (time2 < 500) {
      this.averageTime.addSample(time2);
      if (rect.x !== this.visibleRect.x && time2 > 0)
        this.velocity.x = (rect.x - this.visibleRect.x) / time2;
      if (rect.y !== this.visibleRect.y && time2 > 0)
        this.velocity.y = (rect.y - this.visibleRect.y) / time2;
    }
    this.startTime = performance.now();
    this.visibleRect = rect;
  }
  collectMetrics() {
    let time2 = performance.now() - this.startTime;
    if (time2 < 500)
      this.averagePerf.addSample(time2);
    if (this.visibleRect.height > 0) {
      let o5 = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));
      this.overscanY.addSample(o5);
    }
    if (this.visibleRect.width > 0) {
      let o5 = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));
      this.overscanX.addSample(o5);
    }
  }
  getOverscannedRect() {
    let overscanned = this.visibleRect.copy();
    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;
    if (this.velocity.y > 0) {
      overscanned.y -= overscanY * 0.2;
      overscanned.height += overscanY + overscanY * 0.2;
    } else {
      overscanned.y -= overscanY;
      overscanned.height += overscanY + overscanY * 0.2;
    }
    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;
    if (this.velocity.x > 0) {
      overscanned.x -= overscanX * 0.2;
      overscanned.width += overscanX + overscanX * 0.2;
    } else {
      overscanned.x -= overscanX;
      overscanned.width += overscanX + overscanX * 0.2;
    }
    return overscanned;
  }
  constructor() {
    this.startTime = 0;
    this.averagePerf = new $364191b3decf3697$var$RollingAverage();
    this.averageTime = new $364191b3decf3697$var$RollingAverage();
    this.velocity = new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5);
    this.overscanX = new $364191b3decf3697$var$RollingAverage();
    this.overscanY = new $364191b3decf3697$var$RollingAverage();
    this.visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
  }
};
var $8e135e531d8dcb66$export$febc5573c75cefb0 = class {
  constructor() {
    this.level = 0;
    this.actions = [];
    this.animated = true;
    this.initialMap = /* @__PURE__ */ new Map();
    this.finalMap = /* @__PURE__ */ new Map();
    this.initialLayoutInfo = /* @__PURE__ */ new Map();
    this.finalLayoutInfo = /* @__PURE__ */ new Map();
    this.removed = /* @__PURE__ */ new Map();
    this.toRemove = /* @__PURE__ */ new Map();
  }
};
var $38b9490c1cca8fc4$export$89be5a243e59c4b2 = class {
  _setContentSize(size3) {
    this._contentSize = size3;
    this.delegate.setContentSize(size3);
  }
  _setContentOffset(offset) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);
    this.delegate.setVisibleRect(rect);
  }
  /**
  * Get the size of the scrollable content.
  */
  get contentSize() {
    return this._contentSize;
  }
  /**
  * Get the collection view's currently visible rectangle.
  */
  get visibleRect() {
    return this._visibleRect;
  }
  /**
  * Set the collection view's currently visible rectangle.
  */
  set visibleRect(rect) {
    this._setVisibleRect(rect);
  }
  _setVisibleRect(rect, forceUpdate = false) {
    let current = this._visibleRect;
    if (rect.equals(current))
      return;
    if (this.shouldOverscan)
      this._overscanManager.setVisibleRect(rect);
    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);
    this._resetAnimatedContentOffset();
    this._visibleRect = rect;
    if (shouldInvalidate)
      this.relayoutNow({
        offsetChanged: !rect.pointEquals(current),
        sizeChanged: !rect.sizeEquals(current)
      });
    else
      this.updateSubviews(forceUpdate);
  }
  get collection() {
    return this._collection;
  }
  set collection(data) {
    this._setData(data);
  }
  _setData(data) {
    if (data === this._collection)
      return;
    if (this._collection)
      this._runTransaction(() => {
        this._collection = data;
      }, this.transitionDuration > 0);
    else {
      this._collection = data;
      this.reloadData();
    }
  }
  /**
  * Reloads the data from the data source and relayouts the collection view.
  * Does not animate any changes. Equivalent to re-assigning the same data source
  * to the collection view.
  */
  reloadData() {
    this.relayout({
      contentChanged: true
    });
  }
  /**
  * Returns the item with the given key.
  */
  getItem(key) {
    return this._collection ? this._collection.getItem(key) : null;
  }
  /** The set of persisted keys are always present in the DOM, even if not currently in view. */
  get persistedKeys() {
    return this._persistedKeys;
  }
  /** The set of persisted keys are always present in the DOM, even if not currently in view. */
  set persistedKeys(persistedKeys) {
    if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {
      this._persistedKeys = persistedKeys;
      this.updateSubviews();
    }
  }
  /** Returns whether the given key, or an ancestor, is persisted. */
  isPersistedKey(key) {
    if (this._persistedKeys.has(key))
      return true;
    for (let k2 of this._persistedKeys)
      while (k2 != null) {
        let layoutInfo = this.layout.getLayoutInfo(k2);
        if (!layoutInfo)
          break;
        k2 = layoutInfo.parentKey;
        if (k2 === key)
          return true;
      }
    return false;
  }
  /**
  * Get the collection view's layout.
  */
  get layout() {
    return this._layout;
  }
  /**
  * Set the collection view's layout.
  */
  set layout(layout) {
    this.setLayout(layout);
  }
  /**
  * Sets the collection view's layout, optionally with an animated transition
  * from the current layout to the new layout.
  * @param layout The layout to switch to.
  * @param animated Whether to animate the layout change.
  */
  setLayout(layout, animated = false) {
    if (layout === this._layout)
      return;
    let applyLayout = () => {
      if (this._layout)
        this._layout.virtualizer = null;
      layout.virtualizer = this;
      this._layout = layout;
    };
    if (animated)
      this._runTransaction(applyLayout);
    else {
      applyLayout();
      this.relayout();
    }
  }
  _getReuseType(layoutInfo, content) {
    if (layoutInfo.type === "item" && content) {
      let type2 = this.delegate.getType ? this.delegate.getType(content) : "item";
      let reuseType = type2 === "item" ? "item" : layoutInfo.type + "_" + type2;
      return {
        type: type2,
        reuseType
      };
    }
    return {
      type: layoutInfo.type,
      reuseType: layoutInfo.type
    };
  }
  getReusableView(layoutInfo) {
    let content = this.getItem(layoutInfo.key);
    let { reuseType } = this._getReuseType(layoutInfo, content);
    if (!this._reusableViews[reuseType])
      this._reusableViews[reuseType] = [];
    let reusable = this._reusableViews[reuseType];
    let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);
    view.viewType = reuseType;
    if (!this._animatedContentOffset.isOrigin()) {
      layoutInfo = layoutInfo.copy();
      layoutInfo.rect.x += this._animatedContentOffset.x;
      layoutInfo.rect.y += this._animatedContentOffset.y;
    }
    view.layoutInfo = layoutInfo;
    this._renderView(view);
    return view;
  }
  _renderView(reusableView) {
    let { type: type2, key } = reusableView.layoutInfo;
    reusableView.content = this.getItem(key);
    reusableView.rendered = this._renderContent(type2, reusableView.content);
  }
  _renderContent(type2, content) {
    let cached = this._renderedContent.get(content);
    if (cached != null)
      return cached;
    let rendered = this.delegate.renderView(type2, content);
    if (content)
      this._renderedContent.set(content, rendered);
    return rendered;
  }
  /**
  * Returns an array of all currently visible views, including both
  * item views and supplementary views.
  */
  get visibleViews() {
    return Array.from(this._visibleViews.values());
  }
  /**
  * Gets the visible view for the given type and key. Returns null if
  * the view is not currently visible.
  *
  * @param key The key of the view to retrieve.
  */
  getView(key) {
    return this._visibleViews.get(key) || null;
  }
  /**
  * Returns an array of visible views matching the given type.
  * @param type The view type to find.
  */
  getViewsOfType(type2) {
    return this.visibleViews.filter((v5) => v5.layoutInfo && v5.layoutInfo.type === type2);
  }
  /**
  * Returns the key for the given view. Returns null
  * if the view is not currently visible.
  */
  keyForView(view) {
    if (view && view.layoutInfo)
      return view.layoutInfo.key;
    return null;
  }
  /**
  * Returns the key for the item view currently at the given point.
  */
  keyAtPoint(point) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);
    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
    for (let layoutInfo of layoutInfos) {
      if (layoutInfo.rect.intersects(rect))
        return layoutInfo.key;
    }
    return null;
  }
  /**
  * Cleanup for when the Virtualizer will be unmounted.
  */
  willUnmount() {
    cancelAnimationFrame(this._relayoutRaf);
  }
  /**
  * Triggers a layout invalidation, and updates the visible subviews.
  */
  relayout(context = {}) {
    if (this._scrollAnimation || typeof requestAnimationFrame === "undefined")
      return;
    if (this._invalidationContext) {
      Object.assign(this._invalidationContext, context);
      return;
    }
    this._invalidationContext = context;
  }
  /**
  * Performs a relayout immediately. Prefer {@link relayout} over this method
  * where possible, since it coalesces multiple layout passes in the same tick.
  */
  relayoutNow(context = this._invalidationContext || {}) {
    if (this._relayoutRaf) {
      cancelAnimationFrame(this._relayoutRaf);
      this._relayoutRaf = null;
      context = {
        ...this._invalidationContext,
        ...context
      };
    }
    this._invalidationContext = null;
    if (!this.layout || !this._collection || this._scrollAnimation)
      return;
    let scrollAnchor = this._getScrollAnchor();
    if (typeof context.beforeLayout === "function")
      context.beforeLayout();
    this.layout.validate(context);
    this._setContentSize(this.layout.getContentSize());
    if (typeof context.afterLayout === "function")
      context.afterLayout();
    let visibleRect = this.getVisibleRect();
    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);
    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;
    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;
    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));
    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));
    let hasLayoutUpdates = false;
    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {
      if (context.animated || !this._animatedContentOffset.isOrigin()) {
        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;
        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;
        hasLayoutUpdates = this.updateSubviews(context.contentChanged);
      } else
        this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));
    } else
      hasLayoutUpdates = this.updateSubviews(context.contentChanged);
    if (!(context.transaction && context.animated))
      this._applyLayoutInfos();
    if (context.animated && hasLayoutUpdates) {
      this._enableTransitions();
      let done = () => {
        this._disableTransitions();
        if (!this._animatedContentOffset.isOrigin()) {
          let { x: x3, y: y4 } = this.getVisibleRect();
          this._resetAnimatedContentOffset();
          this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x3, y4));
        }
        if (typeof context.afterAnimation === "function")
          context.afterAnimation();
      };
      setTimeout(done, this.transitionDuration + 100);
      return;
    } else if (typeof context.afterAnimation === "function")
      context.afterAnimation();
  }
  /**
  * Corrects DOM order of visible views to match item order of collection.
  */
  _correctItemOrder() {
    if (this._isScrolling || this._transaction)
      return;
    for (let key of this._visibleLayoutInfos.keys()) {
      let view = this._visibleViews.get(key);
      this._children.delete(view);
      this._children.add(view);
    }
  }
  _enableTransitions() {
    this.delegate.beginAnimations();
  }
  _disableTransitions() {
    this.delegate.endAnimations();
  }
  _getScrollAnchor() {
    if (!this.anchorScrollPosition)
      return null;
    let visibleRect = this.getVisibleRect();
    if (this.delegate.getScrollAnchor) {
      let key = this.delegate.getScrollAnchor(visibleRect);
      if (key != null) {
        let layoutInfo = this.layout.getLayoutInfo(key);
        let corner = layoutInfo.rect.getCornerInRect(visibleRect);
        if (corner) {
          let key2 = layoutInfo.key;
          let offset = layoutInfo.rect[corner].y - visibleRect.y;
          return {
            key: key2,
            layoutInfo,
            corner,
            offset
          };
        }
      }
    }
    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop)
      return null;
    let cornerAnchor = null;
    for (let [key, view] of this._visibleViews) {
      let layoutInfo = view.layoutInfo;
      if (layoutInfo && layoutInfo.rect.area > 0) {
        let corner = layoutInfo.rect.getCornerInRect(visibleRect);
        if (corner) {
          let offset = layoutInfo.rect[corner].y - visibleRect.y;
          if (!cornerAnchor || offset < cornerAnchor.offset)
            cornerAnchor = {
              key,
              layoutInfo,
              corner,
              offset
            };
        }
      }
    }
    return cornerAnchor;
  }
  _restoreScrollAnchor(scrollAnchor, context) {
    let contentOffset = this.getVisibleRect();
    if (scrollAnchor) {
      var _context_transaction;
      let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);
      if (finalAnchor) {
        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;
        contentOffset.y += adjustment;
      }
    }
    return contentOffset;
  }
  getVisibleRect() {
    let v5 = this.visibleRect;
    let x3 = v5.x - this._animatedContentOffset.x;
    let y4 = v5.y - this._animatedContentOffset.y;
    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x3, y4, v5.width, v5.height);
  }
  getVisibleLayoutInfos() {
    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();
    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);
    return this._visibleLayoutInfos;
  }
  _getLayoutInfoMap(rect, copy2 = false) {
    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);
    let map2 = /* @__PURE__ */ new Map();
    for (let layoutInfo of layoutInfos) {
      if (copy2)
        layoutInfo = layoutInfo.copy();
      map2.set(layoutInfo.key, layoutInfo);
    }
    return map2;
  }
  updateSubviews(forceUpdate = false) {
    if (!this._collection)
      return;
    let visibleLayoutInfos = this.getVisibleLayoutInfos();
    let currentlyVisible = this._visibleViews;
    let toAdd, toRemove, toUpdate;
    if (forceUpdate) {
      toAdd = visibleLayoutInfos;
      toRemove = currentlyVisible;
      toUpdate = /* @__PURE__ */ new Set();
    } else {
      ({ toAdd, toRemove, toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));
      for (let key of toUpdate) {
        let view = currentlyVisible.get(key);
        if (!view || !view.layoutInfo)
          continue;
        let item2 = this.getItem(visibleLayoutInfos.get(key).key);
        if (view.content === item2)
          toUpdate.delete(key);
        else {
          let { reuseType } = this._getReuseType(view.layoutInfo, item2);
          if (view.viewType !== reuseType) {
            toUpdate.delete(key);
            toAdd.add(key);
            toRemove.add(key);
          }
        }
      }
      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {
        if (this._transaction)
          this._applyLayoutInfos();
        return;
      }
    }
    let removed = /* @__PURE__ */ new Set();
    for (let key of toRemove.keys()) {
      let view = this._visibleViews.get(key);
      if (view) {
        removed.add(view);
        this._visibleViews.delete(key);
        if (this._transaction)
          this._transaction.toRemove.set(key, view);
        else
          this.reuseView(view);
      }
    }
    for (let key of toAdd.keys()) {
      let layoutInfo = visibleLayoutInfos.get(key);
      let view;
      if (this._transaction) {
        if (this._transaction.initialLayoutInfo.has(key))
          layoutInfo = this._transaction.initialLayoutInfo.get(key);
        view = this._transaction.toRemove.get(key);
        if (view) {
          this._transaction.toRemove.delete(key);
          this._applyLayoutInfo(view, layoutInfo);
        }
      }
      if (!view) {
        view = this.getReusableView(layoutInfo);
        if (!removed.has(view))
          this._children.add(view);
      }
      this._visibleViews.set(key, view);
      removed.delete(view);
    }
    for (let key of toUpdate) {
      let view = currentlyVisible.get(key);
      this._renderedContent.delete(key);
      this._renderView(view);
    }
    if (!this._transaction)
      this.removeViews(removed);
    this._correctItemOrder();
    this._flushVisibleViews();
    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());
    if (hasLayoutUpdates)
      requestAnimationFrame(() => {
        if (this._transaction)
          requestAnimationFrame(() => this._applyLayoutInfos());
      });
    return hasLayoutUpdates;
  }
  afterRender() {
    if (this._transactionQueue.length > 0)
      this._processTransactionQueue();
    else if (this._invalidationContext)
      this.relayoutNow();
    if (this.shouldOverscan)
      this._overscanManager.collectMetrics();
  }
  _flushVisibleViews() {
    let viewsByParentKey = /* @__PURE__ */ new Map([
      [
        null,
        []
      ]
    ]);
    for (let view of this._children) {
      var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;
      if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey))
        viewsByParentKey.set(view.layoutInfo.parentKey, []);
      (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);
      if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key))
        viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);
    }
    let buildTree = (parent, views) => views.map((view) => {
      let children2 = viewsByParentKey.get(view.layoutInfo.key);
      return this.delegate.renderWrapper(parent, view, children2, (childViews) => buildTree(view, childViews));
    });
    let children = buildTree(null, viewsByParentKey.get(null));
    this.delegate.setVisibleViews(children);
  }
  _applyLayoutInfo(view, layoutInfo) {
    if (view.layoutInfo === layoutInfo)
      return false;
    view.layoutInfo = layoutInfo;
    return true;
  }
  _applyLayoutInfos() {
    let updated = false;
    for (let view of this._visibleViews.values()) {
      let cur = view.layoutInfo;
      if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {
        let layoutInfo = this.layout.getLayoutInfo(cur.key);
        if (this._applyLayoutInfo(view, layoutInfo))
          updated = true;
      }
    }
    if (this._transaction) {
      for (let view of this._transaction.toRemove.values()) {
        let cur = view.layoutInfo;
        if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {
          let layoutInfo = this.layout.getLayoutInfo(cur.key);
          if (this._applyLayoutInfo(view, layoutInfo))
            updated = true;
        }
      }
      for (let view of this._transaction.removed.values()) {
        let cur = view.layoutInfo;
        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;
        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());
        if (this._applyLayoutInfo(view, layoutInfo))
          updated = true;
      }
    }
    if (updated)
      this._flushVisibleViews();
  }
  _hasLayoutUpdates() {
    if (!this._transaction)
      return false;
    for (let view of this._visibleViews.values()) {
      let cur = view.layoutInfo;
      if (!cur)
        return true;
      let layoutInfo = this.layout.getLayoutInfo(cur.key);
      if (
        // Uses equals rather than pointEquals so that width/height changes are taken into account
        !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform
      )
        return true;
    }
    return false;
  }
  reuseView(view) {
    view.prepareForReuse();
    this._reusableViews[view.viewType].push(view);
  }
  removeViews(toRemove) {
    for (let view of toRemove)
      this._children.delete(view);
  }
  updateItemSize(key, size3) {
    if (!this.layout.updateItemSize)
      return;
    if (this._scrollAnimation) {
      this._sizeUpdateQueue.set(key, size3);
      return;
    }
    let changed = this.layout.updateItemSize(key, size3);
    if (changed)
      this.relayout();
  }
  startScrolling() {
    this._isScrolling = true;
  }
  endScrolling() {
    this._isScrolling = false;
    this._correctItemOrder();
    this._flushVisibleViews();
  }
  _resetAnimatedContentOffset() {
    if (!this._animatedContentOffset.isOrigin()) {
      this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);
      this._applyLayoutInfos();
    }
  }
  /**
  * Scrolls the item with the given key into view, optionally with an animation.
  * @param key The key of the item to scroll into view.
  * @param duration The duration of the scroll animation.
  */
  scrollToItem(key, options) {
    if (key == null)
      return;
    let layoutInfo = this.layout.getLayoutInfo(key);
    if (!layoutInfo)
      return;
    let { duration = 300, shouldScrollX = true, shouldScrollY = true, offsetX = 0, offsetY = 0 } = options;
    let x3 = this.visibleRect.x;
    let y4 = this.visibleRect.y;
    let minX = layoutInfo.rect.x - offsetX;
    let minY = layoutInfo.rect.y - offsetY;
    let maxX = x3 + this.visibleRect.width;
    let maxY = y4 + this.visibleRect.height;
    if (shouldScrollX) {
      if (minX <= x3 || maxX === 0)
        x3 = minX;
      else if (layoutInfo.rect.maxX > maxX)
        x3 += layoutInfo.rect.maxX - maxX;
    }
    if (shouldScrollY) {
      if (minY <= y4 || maxY === 0)
        y4 = minY;
      else if (layoutInfo.rect.maxY > maxY)
        y4 += layoutInfo.rect.maxY - maxY;
    }
    return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x3, y4), duration);
  }
  /**
  * Performs an animated scroll to the given offset.
  * @param offset - The offset to scroll to.
  * @param duration The duration of the animation.
  * @returns A promise that resolves when the animation is complete.
  */
  scrollTo(offset, duration = 300) {
    if (this._scrollAnimation) {
      this._scrollAnimation.cancel();
      this._scrollAnimation = null;
    }
    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {
      this._setContentOffset(offset);
      return Promise.resolve();
    }
    this.startScrolling();
    this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset2) => {
      this._setContentOffset(offset2);
    });
    this._scrollAnimation.then(() => {
      this._scrollAnimation = null;
      for (let [key, size3] of this._sizeUpdateQueue)
        this.updateItemSize(key, size3);
      this._sizeUpdateQueue.clear();
      this.relayout();
      this._processTransactionQueue();
      this.endScrolling();
    });
    return this._scrollAnimation;
  }
  _runTransaction(action, animated) {
    this._startTransaction();
    if (this._nextTransaction)
      this._nextTransaction.actions.push(action);
    this._endTransaction(animated);
  }
  _startTransaction() {
    if (!this._nextTransaction)
      this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0)();
    this._nextTransaction.level++;
  }
  _endTransaction(animated) {
    if (!this._nextTransaction)
      return false;
    if (animated != null)
      this._nextTransaction.animated = animated;
    if (--this._nextTransaction.level > 0)
      return false;
    if (this._nextTransaction.actions.length === 0) {
      this._nextTransaction = null;
      return false;
    }
    if (this._nextTransaction.animated == null)
      this._nextTransaction.animated = true;
    this._transactionQueue.push(this._nextTransaction);
    this._nextTransaction = null;
    return true;
  }
  _processTransactionQueue() {
    if (this._transaction || this._scrollAnimation)
      return;
    let next2 = this._transactionQueue.shift();
    if (next2)
      this._performTransaction(next2);
  }
  _getContentRect() {
    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);
  }
  _performTransaction(transaction) {
    this._transaction = transaction;
    this.relayoutNow({
      transaction,
      animated: transaction.animated,
      beforeLayout: () => {
        if (transaction.animated)
          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);
        for (let action of transaction.actions)
          action();
      },
      afterLayout: () => {
        if (transaction.animated) {
          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());
          this._setupTransactionAnimations(transaction);
        } else
          this._transaction = null;
      },
      afterAnimation: () => {
        if (transaction.toRemove.size > 0 || transaction.removed.size > 0)
          for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())) {
            this._children.delete(view);
            this.reuseView(view);
          }
        this._transaction = null;
        this._correctItemOrder();
        this._flushVisibleViews();
        this._processTransactionQueue();
      }
    });
  }
  _setupTransactionAnimations(transaction) {
    let { initialMap, finalMap } = transaction;
    for (let [key, layoutInfo] of initialMap)
      if (finalMap.has(key))
        transaction.initialLayoutInfo.set(key, layoutInfo);
      else
        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);
    for (let [key, layoutInfo] of finalMap)
      if (!initialMap.has(key)) {
        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());
        transaction.initialLayoutInfo.set(key, initialLayoutInfo);
      }
    for (let [key, view] of this._visibleViews)
      if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {
        transaction.removed.set(key, view);
        this._visibleViews.delete(key);
        if (view.layoutInfo) {
          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key))
            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);
        }
      }
  }
  constructor(options = {}) {
    this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();
    this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this._reusableViews = {};
    this._visibleLayoutInfos = /* @__PURE__ */ new Map();
    this._visibleViews = /* @__PURE__ */ new Map();
    this._renderedContent = /* @__PURE__ */ new WeakMap();
    this._children = /* @__PURE__ */ new Set();
    this._invalidationContext = null;
    this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();
    this._persistedKeys = /* @__PURE__ */ new Set();
    this._scrollAnimation = null;
    this._isScrolling = false;
    this._sizeUpdateQueue = /* @__PURE__ */ new Map();
    this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);
    this._transaction = null;
    this._nextTransaction = null;
    this._transactionQueue = [];
    var _options_transitionDuration;
    this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;
    this.anchorScrollPosition = options.anchorScrollPosition || false;
    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;
    this.shouldOverscan = options.shouldOverscan !== false;
    for (let key of [
      "delegate",
      "size",
      "layout",
      "collection"
    ])
      if (options[key])
        this[key] = options[key];
  }
};
function $fc0b13b484ac1194$export$1505db82fe357e65(opts) {
  let [visibleViews, setVisibleViews] = (0, import_react47.useState)([]);
  let [contentSize, setContentSize] = (0, import_react47.useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());
  let [isAnimating, setAnimating] = (0, import_react47.useState)(false);
  let [isScrolling, setScrolling] = (0, import_react47.useState)(false);
  let virtualizer = (0, import_react47.useMemo)(() => new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);
  virtualizer.delegate = {
    setVisibleViews,
    setVisibleRect(rect) {
      virtualizer.visibleRect = rect;
      opts.onVisibleRectChange(rect);
    },
    setContentSize,
    renderView: opts.renderView,
    renderWrapper: opts.renderWrapper,
    beginAnimations: () => setAnimating(true),
    endAnimations: () => setAnimating(false),
    getScrollAnchor: opts.getScrollAnchor
  };
  virtualizer.layout = opts.layout;
  virtualizer.collection = opts.collection;
  virtualizer.transitionDuration = opts.transitionDuration;
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    virtualizer.afterRender();
  });
  (0, import_react47.useEffect)(() => {
    return () => virtualizer.willUnmount();
  }, []);
  let setVisibleRect = (0, import_react47.useCallback)((rect) => {
    virtualizer.visibleRect = rect;
  }, [
    virtualizer
  ]);
  let startScrolling = (0, import_react47.useCallback)(() => {
    virtualizer.startScrolling();
    setScrolling(true);
  }, [
    virtualizer
  ]);
  let endScrolling = (0, import_react47.useCallback)(() => {
    virtualizer.endScrolling();
    setScrolling(false);
  }, [
    virtualizer
  ]);
  let state = (0, import_react47.useMemo)(() => ({
    virtualizer,
    visibleViews,
    setVisibleRect,
    contentSize,
    isAnimating,
    isScrolling,
    startScrolling,
    endScrolling
  }), [
    virtualizer,
    visibleViews,
    setVisibleRect,
    contentSize,
    isAnimating,
    isScrolling,
    startScrolling,
    endScrolling
  ]);
  return state;
}

// node_modules/.pnpm/@react-aria+grid@3.8.5_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/grid/dist/import.mjs
var import_react49 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+selection@3.17.2_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/selection/dist/import.mjs
var import_react_dom4 = __toESM(require_react_dom(), 1);
var import_react48 = __toESM(require_react(), 1);
function $feb5ffebff200149$export$d3e3bd3e26688c04(e6) {
  return (0, $c87311424ea30a05$export$e1865c3bedcd822b)() ? e6.altKey : e6.ctrlKey;
}
function $feb5ffebff200149$export$16792effe837dba3(e6) {
  if ((0, $c87311424ea30a05$export$9ac100e40613ea10)())
    return e6.metaKey;
  return e6.ctrlKey;
}
var $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1e3;
function $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {
  let { keyboardDelegate, selectionManager, onTypeSelect } = options;
  let state = (0, import_react48.useRef)({
    search: "",
    timeout: null
  }).current;
  let onKeyDown = (e6) => {
    let character2 = $fb3050f43d946246$var$getStringForKey(e6.key);
    if (!character2 || e6.ctrlKey || e6.metaKey || !e6.currentTarget.contains(e6.target))
      return;
    if (character2 === " " && state.search.trim().length > 0) {
      e6.preventDefault();
      if (!("continuePropagation" in e6))
        e6.stopPropagation();
    }
    state.search += character2;
    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);
    if (key == null)
      key = keyboardDelegate.getKeyForSearch(state.search);
    if (key != null) {
      selectionManager.setFocusedKey(key);
      if (onTypeSelect)
        onTypeSelect(key);
    }
    clearTimeout(state.timeout);
    state.timeout = setTimeout(() => {
      state.search = "";
    }, $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);
  };
  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null
    }
  };
}
function $fb3050f43d946246$var$getStringForKey(key) {
  if (key.length === 1 || !/^[A-Z]/i.test(key))
    return key;
  return "";
}
function $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {
  let { selectionManager: manager, keyboardDelegate: delegate, ref, autoFocus = false, shouldFocusWrap = false, disallowEmptySelection = false, disallowSelectAll = false, selectOnFocus = manager.selectionBehavior === "replace", disallowTypeAhead = false, shouldUseVirtualFocus, allowsTabNavigation = false, isVirtualized, scrollRef = ref, linkBehavior = "action" } = options;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onKeyDown = (e6) => {
    if (e6.altKey && e6.key === "Tab")
      e6.preventDefault();
    if (!ref.current.contains(e6.target))
      return;
    const navigateToKey = (key, childFocus) => {
      if (key != null) {
        if (manager.isLink(key) && linkBehavior === "selection" && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e6)) {
          (0, import_react_dom4.flushSync)(() => {
            manager.setFocusedKey(key, childFocus);
          });
          let item2 = scrollRef.current.querySelector(`[data-key="${key}"]`);
          router.open(item2, e6);
          return;
        }
        manager.setFocusedKey(key, childFocus);
        if (manager.isLink(key) && linkBehavior === "override")
          return;
        if (e6.shiftKey && manager.selectionMode === "multiple")
          manager.extendSelection(key);
        else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e6))
          manager.replaceSelection(key);
      }
    };
    switch (e6.key) {
      case "ArrowDown":
        if (delegate.getKeyBelow) {
          var _delegate_getFirstKey, _delegate_getFirstKey1;
          e6.preventDefault();
          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);
          if (nextKey == null && shouldFocusWrap)
            nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "ArrowUp":
        if (delegate.getKeyAbove) {
          var _delegate_getLastKey, _delegate_getLastKey1;
          e6.preventDefault();
          let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);
          if (nextKey == null && shouldFocusWrap)
            nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "ArrowLeft":
        if (delegate.getKeyLeftOf) {
          var _delegate_getFirstKey2, _delegate_getLastKey2;
          e6.preventDefault();
          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);
          if (nextKey == null && shouldFocusWrap)
            nextKey = direction === "rtl" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);
          navigateToKey(nextKey, direction === "rtl" ? "first" : "last");
        }
        break;
      case "ArrowRight":
        if (delegate.getKeyRightOf) {
          var _delegate_getLastKey3, _delegate_getFirstKey3;
          e6.preventDefault();
          let nextKey = delegate.getKeyRightOf(manager.focusedKey);
          if (nextKey == null && shouldFocusWrap)
            nextKey = direction === "rtl" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);
          navigateToKey(nextKey, direction === "rtl" ? "last" : "first");
        }
        break;
      case "Home":
        if (delegate.getFirstKey) {
          e6.preventDefault();
          let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e6));
          manager.setFocusedKey(firstKey);
          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e6) && e6.shiftKey && manager.selectionMode === "multiple")
            manager.extendSelection(firstKey);
          else if (selectOnFocus)
            manager.replaceSelection(firstKey);
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e6.preventDefault();
          let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e6));
          manager.setFocusedKey(lastKey);
          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e6) && e6.shiftKey && manager.selectionMode === "multiple")
            manager.extendSelection(lastKey);
          else if (selectOnFocus)
            manager.replaceSelection(lastKey);
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow) {
          e6.preventDefault();
          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove) {
          e6.preventDefault();
          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e6) && manager.selectionMode === "multiple" && disallowSelectAll !== true) {
          e6.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        e6.preventDefault();
        if (!disallowEmptySelection)
          manager.clearSelection();
        break;
      case "Tab":
        if (!allowsTabNavigation) {
          if (e6.shiftKey)
            ref.current.focus();
          else {
            let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {
              tabbable: true
            });
            let next2;
            let last;
            do {
              last = walker.lastChild();
              if (last)
                next2 = last;
            } while (last);
            if (next2 && !next2.contains(document.activeElement))
              (0, $7215afc6de606d6b$export$de79e2c695e052f3)(next2);
          }
          break;
        }
    }
  };
  let scrollPos = (0, import_react48.useRef)({
    top: 0,
    left: 0
  });
  (0, $e9faafb641e167db$export$90fc3a17d93f704c)(scrollRef, "scroll", isVirtualized ? null : () => {
    scrollPos.current = {
      top: scrollRef.current.scrollTop,
      left: scrollRef.current.scrollLeft
    };
  });
  let onFocus = (e6) => {
    if (manager.isFocused) {
      if (!e6.currentTarget.contains(e6.target))
        manager.setFocused(false);
      return;
    }
    if (!e6.currentTarget.contains(e6.target))
      return;
    manager.setFocused(true);
    if (manager.focusedKey == null) {
      let navigateToFirstKey = (key) => {
        if (key != null) {
          manager.setFocusedKey(key);
          if (selectOnFocus)
            manager.replaceSelection(key);
        }
      };
      let relatedTarget = e6.relatedTarget;
      var _manager_lastSelectedKey, _manager_firstSelectedKey;
      if (relatedTarget && e6.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)
        navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());
      else
        navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());
    } else if (!isVirtualized) {
      scrollRef.current.scrollTop = scrollPos.current.top;
      scrollRef.current.scrollLeft = scrollPos.current.left;
    }
    if (!isVirtualized && manager.focusedKey != null) {
      let element2 = scrollRef.current.querySelector(`[data-key="${manager.focusedKey}"]`);
      if (element2) {
        if (!element2.contains(document.activeElement))
          (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element2);
        let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
        if (modality === "keyboard")
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(element2, {
            containingElement: ref.current
          });
      }
    }
  };
  let onBlur = (e6) => {
    if (!e6.currentTarget.contains(e6.relatedTarget))
      manager.setFocused(false);
  };
  const autoFocusRef = (0, import_react48.useRef)(autoFocus);
  (0, import_react48.useEffect)(() => {
    if (autoFocusRef.current) {
      let focusedKey = null;
      if (autoFocus === "first")
        focusedKey = delegate.getFirstKey();
      if (autoFocus === "last")
        focusedKey = delegate.getLastKey();
      let selectedKeys = manager.selectedKeys;
      if (selectedKeys.size)
        focusedKey = selectedKeys.values().next().value;
      manager.setFocused(true);
      manager.setFocusedKey(focusedKey);
      if (focusedKey == null && !shouldUseVirtualFocus)
        (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    }
    autoFocusRef.current = false;
  }, []);
  let lastFocusedKey = (0, import_react48.useRef)(manager.focusedKey);
  (0, import_react48.useEffect)(() => {
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {
      let element2 = scrollRef.current.querySelector(`[data-key="${manager.focusedKey}"]`);
      if (element2 && modality === "keyboard") {
        if (!isVirtualized)
          (0, $2f04cbc44ee30ce0$export$53a0910f038337bd)(scrollRef.current, element2);
        (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(element2, {
          containingElement: ref.current
        });
      }
    }
    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null)
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    lastFocusedKey.current = manager.focusedKey;
  }, [
    isVirtualized,
    scrollRef,
    manager.focusedKey,
    manager.isFocused,
    ref
  ]);
  let handlers = {
    onKeyDown,
    onFocus,
    onBlur,
    onMouseDown(e6) {
      if (scrollRef.current === e6.target)
        e6.preventDefault();
    }
  };
  let { typeSelectProps } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({
    keyboardDelegate: delegate,
    selectionManager: manager
  });
  if (!disallowTypeAhead)
    handlers = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(typeSelectProps, handlers);
  let tabIndex;
  if (!shouldUseVirtualFocus)
    tabIndex = manager.focusedKey == null ? 0 : -1;
  return {
    collectionProps: {
      ...handlers,
      tabIndex
    }
  };
}
function $880e95eb8b93ba9a$export$ecf600387e221c37(options) {
  let { selectionManager: manager, key, ref, shouldSelectOnPressUp, shouldUseVirtualFocus, focus, isDisabled, onAction, allowsDifferentPressOrigin, linkBehavior = "action" } = options;
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onSelect = (e6) => {
    if (e6.pointerType === "keyboard" && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e6))
      manager.toggleSelection(key);
    else {
      if (manager.selectionMode === "none")
        return;
      if (manager.isLink(key)) {
        if (linkBehavior === "selection") {
          router.open(ref.current, e6);
          manager.setSelectedKeys(manager.selectedKeys);
          return;
        } else if (linkBehavior === "override" || linkBehavior === "none")
          return;
      }
      if (manager.selectionMode === "single") {
        if (manager.isSelected(key) && !manager.disallowEmptySelection)
          manager.toggleSelection(key);
        else
          manager.replaceSelection(key);
      } else if (e6 && e6.shiftKey)
        manager.extendSelection(key);
      else if (manager.selectionBehavior === "toggle" || e6 && ((0, $feb5ffebff200149$export$16792effe837dba3)(e6) || e6.pointerType === "touch" || e6.pointerType === "virtual"))
        manager.toggleSelection(key);
      else
        manager.replaceSelection(key);
    }
  };
  (0, import_react48.useEffect)(() => {
    let isFocused = key === manager.focusedKey;
    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {
      if (focus)
        focus();
      else if (document.activeElement !== ref.current)
        (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    }
  }, [
    ref,
    key,
    manager.focusedKey,
    manager.childFocusStrategy,
    manager.isFocused,
    shouldUseVirtualFocus
  ]);
  isDisabled = isDisabled || manager.isDisabled(key);
  let itemProps = {};
  if (!shouldUseVirtualFocus && !isDisabled)
    itemProps = {
      tabIndex: key === manager.focusedKey ? 0 : -1,
      onFocus(e6) {
        if (e6.target === ref.current)
          manager.setFocusedKey(key);
      }
    };
  else if (isDisabled)
    itemProps.onMouseDown = (e6) => {
      e6.preventDefault();
    };
  let isLinkOverride = manager.isLink(key) && linkBehavior === "override";
  let hasLinkAction = manager.isLink(key) && linkBehavior !== "selection" && linkBehavior !== "none";
  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;
  let allowsActions = (onAction || hasLinkAction) && !isDisabled;
  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === "replace" ? !allowsSelection : !allowsSelection || manager.isEmpty);
  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === "replace";
  let hasAction = hasPrimaryAction || hasSecondaryAction;
  let modality = (0, import_react48.useRef)(null);
  let longPressEnabled = hasAction && allowsSelection;
  let longPressEnabledOnPressStart = (0, import_react48.useRef)(false);
  let hadPrimaryActionOnPressStart = (0, import_react48.useRef)(false);
  let performAction = (e6) => {
    if (onAction)
      onAction();
    if (hasLinkAction)
      router.open(ref.current, e6);
  };
  let itemPressProps = {};
  if (shouldSelectOnPressUp) {
    itemPressProps.onPressStart = (e6) => {
      modality.current = e6.pointerType;
      longPressEnabledOnPressStart.current = longPressEnabled;
      if (e6.pointerType === "keyboard" && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey()))
        onSelect(e6);
    };
    if (!allowsDifferentPressOrigin)
      itemPressProps.onPress = (e6) => {
        if (hasPrimaryAction || hasSecondaryAction && e6.pointerType !== "mouse") {
          if (e6.pointerType === "keyboard" && !$880e95eb8b93ba9a$var$isActionKey())
            return;
          performAction(e6);
        } else if (e6.pointerType !== "keyboard" && allowsSelection)
          onSelect(e6);
      };
    else {
      itemPressProps.onPressUp = hasPrimaryAction ? null : (e6) => {
        if (e6.pointerType !== "keyboard" && allowsSelection)
          onSelect(e6);
      };
      itemPressProps.onPress = hasPrimaryAction ? performAction : null;
    }
  } else {
    itemPressProps.onPressStart = (e6) => {
      modality.current = e6.pointerType;
      longPressEnabledOnPressStart.current = longPressEnabled;
      hadPrimaryActionOnPressStart.current = hasPrimaryAction;
      if (allowsSelection && (e6.pointerType === "mouse" && !hasPrimaryAction || e6.pointerType === "keyboard" && (!allowsActions || $880e95eb8b93ba9a$var$isSelectionKey())))
        onSelect(e6);
    };
    itemPressProps.onPress = (e6) => {
      if (e6.pointerType === "touch" || e6.pointerType === "pen" || e6.pointerType === "virtual" || e6.pointerType === "keyboard" && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e6.pointerType === "mouse" && hadPrimaryActionOnPressStart.current) {
        if (hasAction)
          performAction(e6);
        else if (allowsSelection)
          onSelect(e6);
      }
    };
  }
  itemProps["data-key"] = key;
  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)(itemPressProps);
  let onDoubleClick = hasSecondaryAction ? (e6) => {
    if (modality.current === "mouse") {
      e6.stopPropagation();
      e6.preventDefault();
      performAction(e6);
    }
  } : void 0;
  let { longPressProps } = (0, $8a26561d2877236e$export$c24ed0104d07eab9)({
    isDisabled: !longPressEnabled,
    onLongPress(e6) {
      if (e6.pointerType === "touch") {
        onSelect(e6);
        manager.setSelectionBehavior("toggle");
      }
    }
  });
  let onDragStartCapture = (e6) => {
    if (modality.current === "touch" && longPressEnabledOnPressStart.current)
      e6.preventDefault();
  };
  let onClick = manager.isLink(key) ? (e6) => {
    if (!(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7).isOpening)
      e6.preventDefault();
  } : void 0;
  return {
    itemProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {
      onDoubleClick,
      onDragStartCapture,
      onClick
    }),
    isPressed,
    isSelected: manager.isSelected(key),
    isFocused: manager.isFocused && manager.focusedKey === key,
    isDisabled,
    allowsSelection,
    hasAction
  };
}
function $880e95eb8b93ba9a$var$isActionKey() {
  let event = window.event;
  return (event === null || event === void 0 ? void 0 : event.key) === "Enter";
}
function $880e95eb8b93ba9a$var$isSelectionKey() {
  let event = window.event;
  return (event === null || event === void 0 ? void 0 : event.key) === " " || (event === null || event === void 0 ? void 0 : event.code) === "Space";
}
var $2a25aae57d74318e$export$a05409b8bb224a5a = class {
  getNextKey(key) {
    key = this.collection.getKeyAfter(key);
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (item2.type === "item" && !this.disabledKeys.has(key))
        return key;
      key = this.collection.getKeyAfter(key);
    }
    return null;
  }
  getPreviousKey(key) {
    key = this.collection.getKeyBefore(key);
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (item2.type === "item" && !this.disabledKeys.has(key))
        return key;
      key = this.collection.getKeyBefore(key);
    }
    return null;
  }
  findKey(key, nextKey, shouldSkip) {
    let item2 = this.getItem(key);
    if (!item2)
      return null;
    let prevRect = item2.getBoundingClientRect();
    do {
      key = nextKey(key);
      item2 = this.getItem(key);
    } while (item2 && shouldSkip(prevRect, item2.getBoundingClientRect()));
    return key;
  }
  isSameRow(prevRect, itemRect) {
    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;
  }
  isSameColumn(prevRect, itemRect) {
    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;
  }
  getKeyBelow(key) {
    if (this.layout === "grid" && this.orientation === "vertical")
      return this.findKey(key, (key2) => this.getNextKey(key2), this.isSameRow);
    else
      return this.getNextKey(key);
  }
  getKeyAbove(key) {
    if (this.layout === "grid" && this.orientation === "vertical")
      return this.findKey(key, (key2) => this.getPreviousKey(key2), this.isSameRow);
    else
      return this.getPreviousKey(key);
  }
  getNextColumn(key, right) {
    return right ? this.getPreviousKey(key) : this.getNextKey(key);
  }
  getKeyRightOf(key) {
    if (this.layout === "grid") {
      if (this.orientation === "vertical")
        return this.getNextColumn(key, this.direction === "rtl");
      else
        return this.findKey(key, (key2) => this.getNextColumn(key2, this.direction === "rtl"), this.isSameColumn);
    } else if (this.orientation === "horizontal")
      return this.getNextColumn(key, this.direction === "rtl");
    return null;
  }
  getKeyLeftOf(key) {
    if (this.layout === "grid") {
      if (this.orientation === "vertical")
        return this.getNextColumn(key, this.direction === "ltr");
      else
        return this.findKey(key, (key2) => this.getNextColumn(key2, this.direction === "ltr"), this.isSameColumn);
    } else if (this.orientation === "horizontal")
      return this.getNextColumn(key, this.direction === "ltr");
    return null;
  }
  getFirstKey() {
    let key = this.collection.getFirstKey();
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (item2.type === "item" && !this.disabledKeys.has(key))
        return key;
      key = this.collection.getKeyAfter(key);
    }
    return null;
  }
  getLastKey() {
    let key = this.collection.getLastKey();
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (item2.type === "item" && !this.disabledKeys.has(key))
        return key;
      key = this.collection.getKeyBefore(key);
    }
    return null;
  }
  getItem(key) {
    return this.ref.current.querySelector(`[data-key="${key}"]`);
  }
  getKeyPageAbove(key) {
    let menu = this.ref.current;
    let item2 = this.getItem(key);
    if (!item2)
      return null;
    if (!(0, $62d8ded9296f3872$export$2bb74740c4e19def)(menu))
      return this.getFirstKey();
    let containerRect = menu.getBoundingClientRect();
    let itemRect = item2.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let containerX = containerRect.x - menu.scrollLeft;
      let pageX = Math.max(0, itemRect.x - containerX + itemRect.width - containerRect.width);
      while (item2 && itemRect.x - containerX > pageX) {
        key = this.getKeyAbove(key);
        item2 = key == null ? null : this.getItem(key);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    } else {
      let containerY = containerRect.y - menu.scrollTop;
      let pageY = Math.max(0, itemRect.y - containerY + itemRect.height - containerRect.height);
      while (item2 && itemRect.y - containerY > pageY) {
        key = this.getKeyAbove(key);
        item2 = key == null ? null : this.getItem(key);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    }
    return key !== null && key !== void 0 ? key : this.getFirstKey();
  }
  getKeyPageBelow(key) {
    let menu = this.ref.current;
    let item2 = this.getItem(key);
    if (!item2)
      return null;
    if (!(0, $62d8ded9296f3872$export$2bb74740c4e19def)(menu))
      return this.getLastKey();
    let containerRect = menu.getBoundingClientRect();
    let itemRect = item2.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let containerX = containerRect.x - menu.scrollLeft;
      let pageX = Math.min(menu.scrollWidth, itemRect.x - containerX - itemRect.width + containerRect.width);
      while (item2 && itemRect.x - containerX < pageX) {
        key = this.getKeyBelow(key);
        item2 = key == null ? null : this.getItem(key);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    } else {
      let containerY = containerRect.y - menu.scrollTop;
      let pageY = Math.min(menu.scrollHeight, itemRect.y - containerY - itemRect.height + containerRect.height);
      while (item2 && itemRect.y - containerY < pageY) {
        key = this.getKeyBelow(key);
        item2 = key == null ? null : this.getItem(key);
        itemRect = item2 === null || item2 === void 0 ? void 0 : item2.getBoundingClientRect();
      }
    }
    return key !== null && key !== void 0 ? key : this.getLastKey();
  }
  getKeyForSearch(search, fromKey) {
    if (!this.collator)
      return null;
    let collection2 = this.collection;
    let key = fromKey || this.getFirstKey();
    while (key != null) {
      let item2 = collection2.getItem(key);
      let substring = item2.textValue.slice(0, search.length);
      if (item2.textValue && this.collator.compare(substring, search) === 0)
        return key;
      key = this.getKeyBelow(key);
    }
    return null;
  }
  constructor(...args) {
    if (args.length === 1) {
      let opts = args[0];
      this.collection = opts.collection;
      this.ref = opts.ref;
      this.collator = opts.collator;
      this.disabledKeys = opts.disabledKeys || /* @__PURE__ */ new Set();
      this.orientation = opts.orientation;
      this.direction = opts.direction;
      this.layout = opts.layout || "stack";
    } else {
      this.collection = args[0];
      this.disabledKeys = args[1];
      this.ref = args[2];
      this.collator = args[3];
      this.layout = "stack";
      this.orientation = "vertical";
    }
    if (this.layout === "stack" && this.orientation === "vertical") {
      this.getKeyLeftOf = void 0;
      this.getKeyRightOf = void 0;
    }
  }
};
function $982254629710d113$export$b95089534ab7c1fd(props) {
  let { selectionManager, collection: collection2, disabledKeys, ref, keyboardDelegate } = props;
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let disabledBehavior = selectionManager.disabledBehavior;
  let delegate = (0, import_react48.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(collection2, disabledBehavior === "selection" ? /* @__PURE__ */ new Set() : disabledKeys, ref, collator), [
    keyboardDelegate,
    collection2,
    disabledKeys,
    ref,
    collator,
    disabledBehavior
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    ...props,
    ref,
    selectionManager,
    keyboardDelegate: delegate
  });
  return {
    listProps: collectionProps
  };
}

// node_modules/.pnpm/@react-aria+grid@3.8.5_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/grid/dist/import.mjs
function $parcel$interopDefault3(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $d1c300d9c497e402$export$de9feff04fda126e = class {
  isCell(node3) {
    return node3.type === "cell";
  }
  isRow(node3) {
    return node3.type === "row" || node3.type === "item";
  }
  findPreviousKey(fromKey, pred) {
    let key = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (!this.disabledKeys.has(key) && (!pred || pred(item2)))
        return key;
      key = this.collection.getKeyBefore(key);
    }
  }
  findNextKey(fromKey, pred) {
    let key = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();
    while (key != null) {
      let item2 = this.collection.getItem(key);
      if (!this.disabledKeys.has(key) && (!pred || pred(item2)))
        return key;
      key = this.collection.getKeyAfter(key);
    }
  }
  getKeyBelow(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem)
      return;
    if (this.isCell(startItem))
      key = startItem.parentKey;
    key = this.findNextKey(key);
    if (key != null) {
      if (this.isCell(startItem)) {
        let item2 = this.collection.getItem(key);
        return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection), startItem.index).key;
      }
      if (this.focusMode === "row")
        return key;
    }
  }
  getKeyAbove(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem)
      return;
    if (this.isCell(startItem))
      key = startItem.parentKey;
    key = this.findPreviousKey(key);
    if (key != null) {
      if (this.isCell(startItem)) {
        let item2 = this.collection.getItem(key);
        return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection), startItem.index).key;
      }
      if (this.focusMode === "row")
        return key;
    }
  }
  getKeyRightOf(key) {
    let item2 = this.collection.getItem(key);
    if (!item2)
      return;
    if (this.isRow(item2)) {
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection);
      return this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key : (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(children).key;
    }
    if (this.isCell(item2)) {
      let parent = this.collection.getItem(item2.parentKey);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
      let next2 = this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index - 1) : (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index + 1);
      if (next2)
        return next2.key;
      if (this.focusMode === "row")
        return item2.parentKey;
      return this.direction === "rtl" ? this.getFirstKey(key) : this.getLastKey(key);
    }
  }
  getKeyLeftOf(key) {
    let item2 = this.collection.getItem(key);
    if (!item2)
      return;
    if (this.isRow(item2)) {
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection);
      return this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(children).key : (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
    }
    if (this.isCell(item2)) {
      let parent = this.collection.getItem(item2.parentKey);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
      let prev2 = this.direction === "rtl" ? (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index + 1) : (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)(children, item2.index - 1);
      if (prev2)
        return prev2.key;
      if (this.focusMode === "row")
        return item2.parentKey;
      return this.direction === "rtl" ? this.getLastKey(key) : this.getFirstKey(key);
    }
  }
  getFirstKey(key, global3) {
    let item2;
    if (key != null) {
      item2 = this.collection.getItem(key);
      if (!item2)
        return;
      if (this.isCell(item2) && !global3) {
        let parent = this.collection.getItem(item2.parentKey);
        return (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection)).key;
      }
    }
    key = this.findNextKey();
    if (key != null && item2 && this.isCell(item2) && global3 || this.focusMode === "cell") {
      let item3 = this.collection.getItem(key);
      key = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item3, this.collection)).key;
    }
    return key;
  }
  getLastKey(key, global3) {
    let item2;
    if (key != null) {
      item2 = this.collection.getItem(key);
      if (!item2)
        return;
      if (this.isCell(item2) && !global3) {
        let parent = this.collection.getItem(item2.parentKey);
        let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(parent, this.collection);
        return (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
      }
    }
    key = this.findPreviousKey();
    if (key != null && item2 && this.isCell(item2) && global3 || this.focusMode === "cell") {
      let item3 = this.collection.getItem(key);
      let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item3, this.collection);
      key = (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children).key;
    }
    return key;
  }
  getItem(key) {
    return this.ref.current.querySelector(`[data-key="${key}"]`);
  }
  getItemRect(key) {
    var _this_layout_getLayoutInfo;
    if (this.layout)
      return (_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect;
    let item2 = this.getItem(key);
    if (item2)
      return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(item2.offsetLeft, item2.offsetTop, item2.offsetWidth, item2.offsetHeight);
  }
  getPageHeight() {
    var _this_layout_virtualizer, _this_ref_current, _this_ref;
    if (this.layout)
      return (_this_layout_virtualizer = this.layout.virtualizer) === null || _this_layout_virtualizer === void 0 ? void 0 : _this_layout_virtualizer.visibleRect.height;
    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.offsetHeight;
  }
  getContentHeight() {
    var _this_ref_current, _this_ref;
    if (this.layout)
      return this.layout.getContentSize().height;
    return (_this_ref = this.ref) === null || _this_ref === void 0 ? void 0 : (_this_ref_current = _this_ref.current) === null || _this_ref_current === void 0 ? void 0 : _this_ref_current.scrollHeight;
  }
  getKeyPageAbove(key) {
    let itemRect = this.getItemRect(key);
    if (!itemRect)
      return null;
    let pageY = Math.max(0, itemRect.maxY - this.getPageHeight());
    while (itemRect && itemRect.y > pageY) {
      key = this.getKeyAbove(key);
      itemRect = this.getItemRect(key);
    }
    return key;
  }
  getKeyPageBelow(key) {
    let itemRect = this.getItemRect(key);
    if (!itemRect)
      return null;
    let pageHeight = this.getPageHeight();
    let pageY = Math.min(this.getContentHeight(), itemRect.y + pageHeight);
    while (itemRect && itemRect.maxY < pageY) {
      let nextKey = this.getKeyBelow(key);
      itemRect = this.getItemRect(nextKey);
      if (nextKey != null)
        key = nextKey;
    }
    return key;
  }
  getKeyForSearch(search, fromKey) {
    if (!this.collator)
      return null;
    let collection2 = this.collection;
    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
    let startItem = collection2.getItem(key);
    if (startItem.type === "cell")
      key = startItem.parentKey;
    let hasWrapped = false;
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.textValue) {
        let substring = item2.textValue.slice(0, search.length);
        if (this.collator.compare(substring, search) === 0) {
          if (this.isRow(item2) && this.focusMode === "cell")
            return (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item2, this.collection)).key;
          return item2.key;
        }
      }
      key = this.findNextKey(key);
      if (key == null && !hasWrapped) {
        key = this.getFirstKey();
        hasWrapped = true;
      }
    }
    return null;
  }
  constructor(options) {
    this.collection = options.collection;
    this.disabledKeys = options.disabledKeys;
    this.ref = options.ref;
    this.direction = options.direction;
    this.collator = options.collator;
    this.layout = options.layout;
    this.focusMode = options.focusMode || "row";
  }
};
var $1af922eb41e03c8f$export$e6235c0d09b995d0 = /* @__PURE__ */ new WeakMap();
var $835c96616a7cb4f9$exports = {};
var $682989befd4f478d$exports = {};
$682989befd4f478d$exports = {
  "deselectedItem": (args) => `${args.item} غير المحدد`,
  "longPressToSelect": `اضغط مطولًا للدخول إلى وضع التحديد.`,
  "select": `تحديد`,
  "selectedAll": `جميع العناصر المحددة.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `لم يتم تحديد عناصر`,
    one: () => `${formatter.number(args.count)} عنصر محدد`,
    other: () => `${formatter.number(args.count)} عنصر محدد`
  })}.`,
  "selectedItem": (args) => `${args.item} المحدد`
};
var $f7fca02019afd941$exports = {};
$f7fca02019afd941$exports = {
  "deselectedItem": (args) => `${args.item} не е избран.`,
  "longPressToSelect": `Натиснете и задръжте за да влезете в избирателен режим.`,
  "select": `Изберете`,
  "selectedAll": `Всички елементи са избрани.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Няма избрани елементи`,
    one: () => `${formatter.number(args.count)} избран елемент`,
    other: () => `${formatter.number(args.count)} избрани елементи`
  })}.`,
  "selectedItem": (args) => `${args.item} избран.`
};
var $8f86f40be75387f1$exports = {};
$8f86f40be75387f1$exports = {
  "deselectedItem": (args) => `Položka ${args.item} není vybrána.`,
  "longPressToSelect": `Dlouhým stisknutím přejdete do režimu výběru.`,
  "select": `Vybrat`,
  "selectedAll": `Vybrány všechny položky.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nevybrány žádné položky`,
    one: () => `Vybrána ${formatter.number(args.count)} položka`,
    other: () => `Vybráno ${formatter.number(args.count)} položek`
  })}.`,
  "selectedItem": (args) => `Vybrána položka ${args.item}.`
};
var $db24ba43c8d652ee$exports = {};
$db24ba43c8d652ee$exports = {
  "deselectedItem": (args) => `${args.item} ikke valgt.`,
  "longPressToSelect": `Lav et langt tryk for at aktivere valgtilstand.`,
  "select": `Vælg`,
  "selectedAll": `Alle elementer valgt.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Ingen elementer valgt`,
    one: () => `${formatter.number(args.count)} element valgt`,
    other: () => `${formatter.number(args.count)} elementer valgt`
  })}.`,
  "selectedItem": (args) => `${args.item} valgt.`
};
var $f8f1e72c8b5447d6$exports = {};
$f8f1e72c8b5447d6$exports = {
  "deselectedItem": (args) => `${args.item} nicht ausgewählt.`,
  "longPressToSelect": `Gedrückt halten, um Auswahlmodus zu öffnen.`,
  "select": `Auswählen`,
  "selectedAll": `Alle Elemente ausgewählt.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Keine Elemente ausgewählt`,
    one: () => `${formatter.number(args.count)} Element ausgewählt`,
    other: () => `${formatter.number(args.count)} Elemente ausgewählt`
  })}.`,
  "selectedItem": (args) => `${args.item} ausgewählt.`
};
var $9a73ed2983c3ab0b$exports = {};
$9a73ed2983c3ab0b$exports = {
  "deselectedItem": (args) => `Δεν επιλέχθηκε το στοιχείο ${args.item}.`,
  "longPressToSelect": `Πατήστε παρατεταμένα για να μπείτε σε λειτουργία επιλογής.`,
  "select": `Επιλογή`,
  "selectedAll": `Επιλέχθηκαν όλα τα στοιχεία.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Δεν επιλέχθηκαν στοιχεία`,
    one: () => `Επιλέχθηκε ${formatter.number(args.count)} στοιχείο`,
    other: () => `Επιλέχθηκαν ${formatter.number(args.count)} στοιχεία`
  })}.`,
  "selectedItem": (args) => `Επιλέχθηκε το στοιχείο ${args.item}.`
};
var $583de0b3587601b9$exports = {};
$583de0b3587601b9$exports = {
  "deselectedItem": (args) => `${args.item} not selected.`,
  "select": `Select`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `No items selected`,
    one: () => `${formatter.number(args.count)} item selected`,
    other: () => `${formatter.number(args.count)} items selected`
  })}.`,
  "selectedAll": `All items selected.`,
  "selectedItem": (args) => `${args.item} selected.`,
  "longPressToSelect": `Long press to enter selection mode.`
};
var $147159c978043442$exports = {};
$147159c978043442$exports = {
  "deselectedItem": (args) => `${args.item} no seleccionado.`,
  "longPressToSelect": `Mantenga pulsado para abrir el modo de selección.`,
  "select": `Seleccionar`,
  "selectedAll": `Todos los elementos seleccionados.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Ningún elemento seleccionado`,
    one: () => `${formatter.number(args.count)} elemento seleccionado`,
    other: () => `${formatter.number(args.count)} elementos seleccionados`
  })}.`,
  "selectedItem": (args) => `${args.item} seleccionado.`
};
var $5cbb62c8a19173ac$exports = {};
$5cbb62c8a19173ac$exports = {
  "deselectedItem": (args) => `${args.item} pole valitud.`,
  "longPressToSelect": `Valikurežiimi sisenemiseks vajutage pikalt.`,
  "select": `Vali`,
  "selectedAll": `Kõik üksused valitud.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Üksusi pole valitud`,
    one: () => `${formatter.number(args.count)} üksus valitud`,
    other: () => `${formatter.number(args.count)} üksust valitud`
  })}.`,
  "selectedItem": (args) => `${args.item} valitud.`
};
var $a33d71dc804cc59e$exports = {};
$a33d71dc804cc59e$exports = {
  "deselectedItem": (args) => `Kohdetta ${args.item} ei valittu.`,
  "longPressToSelect": `Siirry valintatilaan painamalla pitkään.`,
  "select": `Valitse`,
  "selectedAll": `Kaikki kohteet valittu.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Ei yhtään kohdetta valittu`,
    one: () => `${formatter.number(args.count)} kohde valittu`,
    other: () => `${formatter.number(args.count)} kohdetta valittu`
  })}.`,
  "selectedItem": (args) => `${args.item} valittu.`
};
var $92d800447793d084$exports = {};
$92d800447793d084$exports = {
  "deselectedItem": (args) => `${args.item} non sélectionné.`,
  "longPressToSelect": `Appuyez de manière prolongée pour passer en mode de sélection.`,
  "select": `Sélectionner`,
  "selectedAll": `Tous les éléments sélectionnés.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Aucun élément sélectionné`,
    one: () => `${formatter.number(args.count)} élément sélectionné`,
    other: () => `${formatter.number(args.count)} éléments sélectionnés`
  })}.`,
  "selectedItem": (args) => `${args.item} sélectionné.`
};
var $fe732cdb32124ea8$exports = {};
$fe732cdb32124ea8$exports = {
  "deselectedItem": (args) => `${args.item} לא נבחר.`,
  "longPressToSelect": `הקשה ארוכה לכניסה למצב בחירה.`,
  "select": `בחר`,
  "selectedAll": `כל הפריטים נבחרו.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `לא נבחרו פריטים`,
    one: () => `פריט ${formatter.number(args.count)} נבחר`,
    other: () => `${formatter.number(args.count)} פריטים נבחרו`
  })}.`,
  "selectedItem": (args) => `${args.item} נבחר.`
};
var $e41234e934efb4f5$exports = {};
$e41234e934efb4f5$exports = {
  "deselectedItem": (args) => `Stavka ${args.item} nije odabrana.`,
  "longPressToSelect": `Dugo pritisnite za ulazak u način odabira.`,
  "select": `Odaberite`,
  "selectedAll": `Odabrane su sve stavke.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nije odabrana nijedna stavka`,
    one: () => `Odabrana je ${formatter.number(args.count)} stavka`,
    other: () => `Odabrano je ${formatter.number(args.count)} stavki`
  })}.`,
  "selectedItem": (args) => `Stavka ${args.item} je odabrana.`
};
var $1b0393182473bf9e$exports = {};
$1b0393182473bf9e$exports = {
  "deselectedItem": (args) => `${args.item} nincs kijelölve.`,
  "longPressToSelect": `Nyomja hosszan a kijelöléshez.`,
  "select": `Kijelölés`,
  "selectedAll": `Az összes elem kijelölve.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Egy elem sincs kijelölve`,
    one: () => `${formatter.number(args.count)} elem kijelölve`,
    other: () => `${formatter.number(args.count)} elem kijelölve`
  })}.`,
  "selectedItem": (args) => `${args.item} kijelölve.`
};
var $2eed782c1c110ce7$exports = {};
$2eed782c1c110ce7$exports = {
  "deselectedItem": (args) => `${args.item} non selezionato.`,
  "longPressToSelect": `Premi a lungo per passare alla modalità di selezione.`,
  "select": `Seleziona`,
  "selectedAll": `Tutti gli elementi selezionati.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nessun elemento selezionato`,
    one: () => `${formatter.number(args.count)} elemento selezionato`,
    other: () => `${formatter.number(args.count)} elementi selezionati`
  })}.`,
  "selectedItem": (args) => `${args.item} selezionato.`
};
var $8b5d459f86e9b23c$exports = {};
$8b5d459f86e9b23c$exports = {
  "deselectedItem": (args) => `${args.item} が選択されていません。`,
  "longPressToSelect": `長押しして選択モードを開きます。`,
  "select": `選択`,
  "selectedAll": `すべての項目を選択しました。`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `項目が選択されていません`,
    one: () => `${formatter.number(args.count)} 項目を選択しました`,
    other: () => `${formatter.number(args.count)} 項目を選択しました`
  })}。`,
  "selectedItem": (args) => `${args.item} を選択しました。`
};
var $1949c3ad17295fd4$exports = {};
$1949c3ad17295fd4$exports = {
  "deselectedItem": (args) => `${args.item}이(가) 선택되지 않았습니다.`,
  "longPressToSelect": `선택 모드로 들어가려면 길게 누르십시오.`,
  "select": `선택`,
  "selectedAll": `모든 항목이 선택되었습니다.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `선택된 항목이 없습니다`,
    one: () => `${formatter.number(args.count)}개 항목이 선택되었습니다`,
    other: () => `${formatter.number(args.count)}개 항목이 선택되었습니다`
  })}.`,
  "selectedItem": (args) => `${args.item}이(가) 선택되었습니다.`
};
var $f5e3df4dc8aa7b54$exports = {};
$f5e3df4dc8aa7b54$exports = {
  "deselectedItem": (args) => `${args.item} nepasirinkta.`,
  "longPressToSelect": `Norėdami įjungti pasirinkimo režimą, paspauskite ir palaikykite.`,
  "select": `Pasirinkti`,
  "selectedAll": `Pasirinkti visi elementai.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nepasirinktas nė vienas elementas`,
    one: () => `Pasirinktas ${formatter.number(args.count)} elementas`,
    other: () => `Pasirinkta elementų: ${formatter.number(args.count)}`
  })}.`,
  "selectedItem": (args) => `Pasirinkta: ${args.item}.`
};
var $9dd86690a5c2b2c5$exports = {};
$9dd86690a5c2b2c5$exports = {
  "deselectedItem": (args) => `Vienums ${args.item} nav atlasīts.`,
  "longPressToSelect": `Ilgi turiet nospiestu. lai ieslēgtu atlases režīmu.`,
  "select": `Atlasīt`,
  "selectedAll": `Atlasīti visi vienumi.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nav atlasīts neviens vienums`,
    one: () => `Atlasīto vienumu skaits: ${formatter.number(args.count)}`,
    other: () => `Atlasīto vienumu skaits: ${formatter.number(args.count)}`
  })}.`,
  "selectedItem": (args) => `Atlasīts vienums ${args.item}.`
};
var $843964c3bf9a7d24$exports = {};
$843964c3bf9a7d24$exports = {
  "deselectedItem": (args) => `${args.item} er ikke valgt.`,
  "longPressToSelect": `Bruk et langt trykk for å gå inn i valgmodus.`,
  "select": `Velg`,
  "selectedAll": `Alle elementer er valgt.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Ingen elementer er valgt`,
    one: () => `${formatter.number(args.count)} element er valgt`,
    other: () => `${formatter.number(args.count)} elementer er valgt`
  })}.`,
  "selectedItem": (args) => `${args.item} er valgt.`
};
var $73f50e845f9ef3b4$exports = {};
$73f50e845f9ef3b4$exports = {
  "deselectedItem": (args) => `${args.item} niet geselecteerd.`,
  "longPressToSelect": `Druk lang om de selectiemodus te openen.`,
  "select": `Selecteren`,
  "selectedAll": `Alle items geselecteerd.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Geen items geselecteerd`,
    one: () => `${formatter.number(args.count)} item geselecteerd`,
    other: () => `${formatter.number(args.count)} items geselecteerd`
  })}.`,
  "selectedItem": (args) => `${args.item} geselecteerd.`
};
var $87f92a7e077514b2$exports = {};
$87f92a7e077514b2$exports = {
  "deselectedItem": (args) => `Nie zaznaczono ${args.item}.`,
  "longPressToSelect": `Naciśnij i przytrzymaj, aby wejść do trybu wyboru.`,
  "select": `Zaznacz`,
  "selectedAll": `Wszystkie zaznaczone elementy.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nie zaznaczono żadnych elementów`,
    one: () => `${formatter.number(args.count)} zaznaczony element`,
    other: () => `${formatter.number(args.count)} zaznaczonych elementów`
  })}.`,
  "selectedItem": (args) => `Zaznaczono ${args.item}.`
};
var $c28c98d58ee9ff6f$exports = {};
$c28c98d58ee9ff6f$exports = {
  "deselectedItem": (args) => `${args.item} não selecionado.`,
  "longPressToSelect": `Mantenha pressionado para entrar no modo de seleção.`,
  "select": `Selecionar`,
  "selectedAll": `Todos os itens selecionados.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nenhum item selecionado`,
    one: () => `${formatter.number(args.count)} item selecionado`,
    other: () => `${formatter.number(args.count)} itens selecionados`
  })}.`,
  "selectedItem": (args) => `${args.item} selecionado.`
};
var $b6b1503b17b2254d$exports = {};
$b6b1503b17b2254d$exports = {
  "deselectedItem": (args) => `${args.item} não selecionado.`,
  "longPressToSelect": `Prima continuamente para entrar no modo de seleção.`,
  "select": `Selecionar`,
  "selectedAll": `Todos os itens selecionados.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nenhum item selecionado`,
    one: () => `${formatter.number(args.count)} item selecionado`,
    other: () => `${formatter.number(args.count)} itens selecionados`
  })}.`,
  "selectedItem": (args) => `${args.item} selecionado.`
};
var $8bdaeb71e50c3e1a$exports = {};
$8bdaeb71e50c3e1a$exports = {
  "deselectedItem": (args) => `${args.item} neselectat.`,
  "longPressToSelect": `Apăsați lung pentru a intra în modul de selectare.`,
  "select": `Selectare`,
  "selectedAll": `Toate elementele selectate.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Niciun element selectat`,
    one: () => `${formatter.number(args.count)} element selectat`,
    other: () => `${formatter.number(args.count)} elemente selectate`
  })}.`,
  "selectedItem": (args) => `${args.item} selectat.`
};
var $ec2b852dd7c3d1f2$exports = {};
$ec2b852dd7c3d1f2$exports = {
  "deselectedItem": (args) => `${args.item} не выбрано.`,
  "longPressToSelect": `Нажмите и удерживайте для входа в режим выбора.`,
  "select": `Выбрать`,
  "selectedAll": `Выбраны все элементы.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Нет выбранных элементов`,
    one: () => `${formatter.number(args.count)} элемент выбран`,
    other: () => `${formatter.number(args.count)} элементов выбрано`
  })}.`,
  "selectedItem": (args) => `${args.item} выбрано.`
};
var $79e6d900d6a4f82d$exports = {};
$79e6d900d6a4f82d$exports = {
  "deselectedItem": (args) => `Nevybraté položky: ${args.item}.`,
  "longPressToSelect": `Dlhším stlačením prejdite do režimu výberu.`,
  "select": `Vybrať`,
  "selectedAll": `Všetky vybraté položky.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Žiadne vybraté položky`,
    one: () => `${formatter.number(args.count)} vybratá položka`,
    other: () => `Počet vybratých položiek:${formatter.number(args.count)}`
  })}.`,
  "selectedItem": (args) => `Vybraté položky: ${args.item}.`
};
var $f4c1f0d5d4d03d80$exports = {};
$f4c1f0d5d4d03d80$exports = {
  "deselectedItem": (args) => `Element ${args.item} ni izbran.`,
  "longPressToSelect": `Za izbirni način pritisnite in dlje časa držite.`,
  "select": `Izberite`,
  "selectedAll": `Vsi elementi so izbrani.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Noben element ni izbran`,
    one: () => `${formatter.number(args.count)} element je izbran`,
    other: () => `${formatter.number(args.count)} elementov je izbranih`
  })}.`,
  "selectedItem": (args) => `Element ${args.item} je izbran.`
};
var $46252cd87269b10b$exports = {};
$46252cd87269b10b$exports = {
  "deselectedItem": (args) => `${args.item} nije izabrano.`,
  "longPressToSelect": `Dugo pritisnite za ulazak u režim biranja.`,
  "select": `Izaberite`,
  "selectedAll": `Izabrane su sve stavke.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Nije izabrana nijedna stavka`,
    one: () => `Izabrana je ${formatter.number(args.count)} stavka`,
    other: () => `Izabrano je ${formatter.number(args.count)} stavki`
  })}.`,
  "selectedItem": (args) => `${args.item} je izabrano.`
};
var $d4d5d8dab362555c$exports = {};
$d4d5d8dab362555c$exports = {
  "deselectedItem": (args) => `${args.item} ej markerat.`,
  "longPressToSelect": `Tryck länge när du vill öppna väljarläge.`,
  "select": `Markera`,
  "selectedAll": `Alla markerade objekt.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Inga markerade objekt`,
    one: () => `${formatter.number(args.count)} markerat objekt`,
    other: () => `${formatter.number(args.count)} markerade objekt`
  })}.`,
  "selectedItem": (args) => `${args.item} markerat.`
};
var $3d55d1f97c377e83$exports = {};
$3d55d1f97c377e83$exports = {
  "deselectedItem": (args) => `${args.item} seçilmedi.`,
  "longPressToSelect": `Seçim moduna girmek için uzun basın.`,
  "select": `Seç`,
  "selectedAll": `Tüm ögeler seçildi.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Hiçbir öge seçilmedi`,
    one: () => `${formatter.number(args.count)} öge seçildi`,
    other: () => `${formatter.number(args.count)} öge seçildi`
  })}.`,
  "selectedItem": (args) => `${args.item} seçildi.`
};
var $5368512f1c703a3f$exports = {};
$5368512f1c703a3f$exports = {
  "deselectedItem": (args) => `${args.item} не вибрано.`,
  "longPressToSelect": `Виконайте довге натиснення, щоб перейти в режим вибору.`,
  "select": `Вибрати`,
  "selectedAll": `Усі елементи вибрано.`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `Жодних елементів не вибрано`,
    one: () => `${formatter.number(args.count)} елемент вибрано`,
    other: () => `Вибрано елементів: ${formatter.number(args.count)}`
  })}.`,
  "selectedItem": (args) => `${args.item} вибрано.`
};
var $f1316b1074463583$exports = {};
$f1316b1074463583$exports = {
  "deselectedItem": (args) => `未选择 ${args.item}。`,
  "longPressToSelect": `长按以进入选择模式。`,
  "select": `选择`,
  "selectedAll": `已选择所有项目。`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `未选择项目`,
    one: () => `已选择 ${formatter.number(args.count)} 个项目`,
    other: () => `已选择 ${formatter.number(args.count)} 个项目`
  })}。`,
  "selectedItem": (args) => `已选择 ${args.item}。`
};
var $7e60654723031b6f$exports = {};
$7e60654723031b6f$exports = {
  "deselectedItem": (args) => `未選取「${args.item}」。`,
  "longPressToSelect": `長按以進入選擇模式。`,
  "select": `選取`,
  "selectedAll": `已選取所有項目。`,
  "selectedCount": (args, formatter) => `${formatter.plural(args.count, {
    "=0": `未選取任何項目`,
    one: () => `已選取 ${formatter.number(args.count)} 個項目`,
    other: () => `已選取 ${formatter.number(args.count)} 個項目`
  })}。`,
  "selectedItem": (args) => `已選取「${args.item}」。`
};
$835c96616a7cb4f9$exports = {
  "ar-AE": $682989befd4f478d$exports,
  "bg-BG": $f7fca02019afd941$exports,
  "cs-CZ": $8f86f40be75387f1$exports,
  "da-DK": $db24ba43c8d652ee$exports,
  "de-DE": $f8f1e72c8b5447d6$exports,
  "el-GR": $9a73ed2983c3ab0b$exports,
  "en-US": $583de0b3587601b9$exports,
  "es-ES": $147159c978043442$exports,
  "et-EE": $5cbb62c8a19173ac$exports,
  "fi-FI": $a33d71dc804cc59e$exports,
  "fr-FR": $92d800447793d084$exports,
  "he-IL": $fe732cdb32124ea8$exports,
  "hr-HR": $e41234e934efb4f5$exports,
  "hu-HU": $1b0393182473bf9e$exports,
  "it-IT": $2eed782c1c110ce7$exports,
  "ja-JP": $8b5d459f86e9b23c$exports,
  "ko-KR": $1949c3ad17295fd4$exports,
  "lt-LT": $f5e3df4dc8aa7b54$exports,
  "lv-LV": $9dd86690a5c2b2c5$exports,
  "nb-NO": $843964c3bf9a7d24$exports,
  "nl-NL": $73f50e845f9ef3b4$exports,
  "pl-PL": $87f92a7e077514b2$exports,
  "pt-BR": $c28c98d58ee9ff6f$exports,
  "pt-PT": $b6b1503b17b2254d$exports,
  "ro-RO": $8bdaeb71e50c3e1a$exports,
  "ru-RU": $ec2b852dd7c3d1f2$exports,
  "sk-SK": $79e6d900d6a4f82d$exports,
  "sl-SI": $f4c1f0d5d4d03d80$exports,
  "sr-SP": $46252cd87269b10b$exports,
  "sv-SE": $d4d5d8dab362555c$exports,
  "tr-TR": $3d55d1f97c377e83$exports,
  "uk-UA": $5368512f1c703a3f$exports,
  "zh-CN": $f1316b1074463583$exports,
  "zh-TW": $7e60654723031b6f$exports
};
function $92599c3fd427b763$export$137e594ef3218a10(props, state) {
  let { getRowText = (key) => {
    var _state_collection_getTextValue, _state_collection, _state_collection_getItem;
    var _state_collection_getTextValue1;
    return (_state_collection_getTextValue1 = (_state_collection_getTextValue = (_state_collection = state.collection).getTextValue) === null || _state_collection_getTextValue === void 0 ? void 0 : _state_collection_getTextValue.call(_state_collection, key)) !== null && _state_collection_getTextValue1 !== void 0 ? _state_collection_getTextValue1 : (_state_collection_getItem = state.collection.getItem(key)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.textValue;
  } } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($835c96616a7cb4f9$exports)));
  let selection = state.selectionManager.rawSelection;
  let lastSelection = (0, import_react49.useRef)(selection);
  (0, $4f58c5f72bcf79f7$export$496315a1608d9602)(() => {
    var _lastSelection_current;
    if (!state.selectionManager.isFocused) {
      lastSelection.current = selection;
      return;
    }
    let addedKeys = $92599c3fd427b763$var$diffSelection(selection, lastSelection.current);
    let removedKeys = $92599c3fd427b763$var$diffSelection(lastSelection.current, selection);
    let isReplace = state.selectionManager.selectionBehavior === "replace";
    let messages = [];
    if (state.selectionManager.selectedKeys.size === 1 && isReplace) {
      if (state.collection.getItem(state.selectionManager.selectedKeys.keys().next().value)) {
        let currentSelectionText = getRowText(state.selectionManager.selectedKeys.keys().next().value);
        if (currentSelectionText)
          messages.push(stringFormatter.format("selectedItem", {
            item: currentSelectionText
          }));
      }
    } else if (addedKeys.size === 1 && removedKeys.size === 0) {
      let addedText = getRowText(addedKeys.keys().next().value);
      if (addedText)
        messages.push(stringFormatter.format("selectedItem", {
          item: addedText
        }));
    } else if (removedKeys.size === 1 && addedKeys.size === 0) {
      if (state.collection.getItem(removedKeys.keys().next().value)) {
        let removedText = getRowText(removedKeys.keys().next().value);
        if (removedText)
          messages.push(stringFormatter.format("deselectedItem", {
            item: removedText
          }));
      }
    }
    if (state.selectionManager.selectionMode === "multiple") {
      if (messages.length === 0 || selection === "all" || selection.size > 1 || lastSelection.current === "all" || ((_lastSelection_current = lastSelection.current) === null || _lastSelection_current === void 0 ? void 0 : _lastSelection_current.size) > 1)
        messages.push(selection === "all" ? stringFormatter.format("selectedAll") : stringFormatter.format("selectedCount", {
          count: selection.size
        }));
    }
    if (messages.length > 0)
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(messages.join(" "));
    lastSelection.current = selection;
  }, [
    selection
  ]);
}
function $92599c3fd427b763$var$diffSelection(a3, b2) {
  let res = /* @__PURE__ */ new Set();
  if (a3 === "all" || b2 === "all")
    return res;
  for (let key of a3.keys())
    if (!b2.has(key))
      res.add(key);
  return res;
}
function $5b9b5b5723db6ae1$export$be42ebdab07ae4c2(props) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($835c96616a7cb4f9$exports)));
  let modality = (0, $507fabe10e71c6fb$export$98e20ec92f614cfe)();
  let shouldLongPress = (modality === "pointer" || modality === "virtual" || modality == null) && typeof window !== "undefined" && "ontouchstart" in window;
  let interactionDescription = (0, import_react49.useMemo)(() => {
    let selectionMode = props.selectionManager.selectionMode;
    let selectionBehavior = props.selectionManager.selectionBehavior;
    let message = void 0;
    if (shouldLongPress)
      message = stringFormatter.format("longPressToSelect");
    return selectionBehavior === "replace" && selectionMode !== "none" && props.hasItemActions ? message : void 0;
  }, [
    props.selectionManager.selectionMode,
    props.selectionManager.selectionBehavior,
    props.hasItemActions,
    stringFormatter,
    shouldLongPress
  ]);
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(interactionDescription);
  return descriptionProps;
}
function $83c6e2eafa584c67$export$f6b86a04e5d66d90(props, state, ref) {
  let { isVirtualized, keyboardDelegate, focusMode, scrollRef, getRowText, onRowAction, onCellAction } = props;
  let { selectionManager: manager } = state;
  if (!props["aria-label"] && !props["aria-labelledby"])
    console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let disabledBehavior = state.selectionManager.disabledBehavior;
  let delegate = (0, import_react49.useMemo)(() => keyboardDelegate || new (0, $d1c300d9c497e402$export$de9feff04fda126e)({
    collection: state.collection,
    disabledKeys: disabledBehavior === "selection" ? /* @__PURE__ */ new Set() : state.disabledKeys,
    ref,
    direction,
    collator,
    focusMode
  }), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    disabledBehavior,
    ref,
    direction,
    collator,
    focusMode
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    ref,
    selectionManager: manager,
    keyboardDelegate: delegate,
    isVirtualized,
    scrollRef
  });
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).set(state, {
    keyboardDelegate: delegate,
    actions: {
      onRowAction,
      onCellAction
    }
  });
  let descriptionProps = (0, $5b9b5b5723db6ae1$export$be42ebdab07ae4c2)({
    selectionManager: manager,
    hasItemActions: !!(onRowAction || onCellAction)
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let onFocus = (0, import_react49.useCallback)((e6) => {
    if (manager.isFocused) {
      if (!e6.currentTarget.contains(e6.target))
        manager.setFocused(false);
      return;
    }
    if (!e6.currentTarget.contains(e6.target))
      return;
    manager.setFocused(true);
  }, [
    manager
  ]);
  let navDisabledHandlers = (0, import_react49.useMemo)(() => ({
    onBlur: collectionProps.onBlur,
    onFocus
  }), [
    onFocus,
    collectionProps.onBlur
  ]);
  let hasTabbableChild = (0, $83013635b024ae3d$export$eac1895992b9f3d6)(ref, {
    isDisabled: state.collection.size !== 0
  });
  let gridProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
    domProps,
    {
      role: "grid",
      id,
      "aria-multiselectable": manager.selectionMode === "multiple" ? "true" : void 0
    },
    state.isKeyboardNavigationDisabled ? navDisabledHandlers : collectionProps,
    // If collection is empty, make sure the grid is tabbable unless there is a child tabbable element.
    state.collection.size === 0 && {
      tabIndex: hasTabbableChild ? -1 : 0
    },
    descriptionProps
  );
  if (isVirtualized) {
    gridProps["aria-rowcount"] = state.collection.size;
    gridProps["aria-colcount"] = state.collection.columnCount;
  }
  (0, $92599c3fd427b763$export$137e594ef3218a10)({
    getRowText
  }, state);
  return {
    gridProps
  };
}
function $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf() {
  return {
    rowGroupProps: {
      role: "rowgroup"
    }
  };
}
function $4159a7a9cbb0cc18$export$96357d5a73f686fa(props, state, ref) {
  let { node: node3, isVirtualized, shouldSelectOnPressUp, onAction } = props;
  let { actions: { onRowAction } } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);
  let { itemProps, ...states } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key: node3.key,
    ref,
    isVirtualized,
    shouldSelectOnPressUp,
    onAction: onRowAction ? () => onRowAction(node3.key) : onAction,
    isDisabled: state.collection.size === 0
  });
  let isSelected = state.selectionManager.isSelected(node3.key);
  let rowProps = {
    role: "row",
    "aria-selected": state.selectionManager.selectionMode !== "none" ? isSelected : void 0,
    "aria-disabled": states.isDisabled || void 0,
    ...itemProps
  };
  if (isVirtualized)
    rowProps["aria-rowindex"] = node3.index + 1;
  return {
    rowProps,
    ...states
  };
}
function $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state, ref) {
  let { node: node3, isVirtualized, focusMode = "child", shouldSelectOnPressUp, onAction } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { keyboardDelegate, actions: { onCellAction } } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);
  let keyWhenFocused = (0, import_react49.useRef)(null);
  let focus = () => {
    let treeWalker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current);
    if (focusMode === "child") {
      if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement)
        return;
      let focusable = state.selectionManager.childFocusStrategy === "last" ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();
      if (focusable) {
        (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
        return;
      }
    }
    if (keyWhenFocused.current != null && node3.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement))
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
  };
  let { itemProps, isPressed } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key: node3.key,
    ref,
    isVirtualized,
    focus,
    shouldSelectOnPressUp,
    onAction: onCellAction ? () => onCellAction(node3.key) : onAction,
    isDisabled: state.collection.size === 0
  });
  let onKeyDownCapture = (e6) => {
    if (!e6.currentTarget.contains(e6.target) || state.isKeyboardNavigationDisabled)
      return;
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current);
    walker.currentNode = document.activeElement;
    switch (e6.key) {
      case "ArrowLeft": {
        let focusable = direction === "rtl" ? walker.nextNode() : walker.previousNode();
        if (focusMode === "child" && focusable === ref.current)
          focusable = null;
        if (focusable) {
          e6.preventDefault();
          e6.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
          });
        } else {
          let prev2 = keyboardDelegate.getKeyLeftOf(node3.key);
          if (prev2 !== node3.key)
            break;
          e6.preventDefault();
          e6.stopPropagation();
          if (focusMode === "cell" && direction === "rtl") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
            });
          } else {
            walker.currentNode = ref.current;
            focusable = direction === "rtl" ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);
            if (focusable) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowRight": {
        let focusable = direction === "rtl" ? walker.previousNode() : walker.nextNode();
        if (focusMode === "child" && focusable === ref.current)
          focusable = null;
        if (focusable) {
          e6.preventDefault();
          e6.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
          });
        } else {
          let next2 = keyboardDelegate.getKeyRightOf(node3.key);
          if (next2 !== node3.key)
            break;
          e6.preventDefault();
          e6.stopPropagation();
          if (focusMode === "cell" && direction === "ltr") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
            });
          } else {
            walker.currentNode = ref.current;
            focusable = direction === "rtl" ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();
            if (focusable) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
        if (!e6.altKey && ref.current.contains(e6.target)) {
          e6.stopPropagation();
          e6.preventDefault();
          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e6.nativeEvent.type, e6.nativeEvent));
        }
        break;
    }
  };
  let onFocus = (e6) => {
    keyWhenFocused.current = node3.key;
    if (e6.target !== ref.current) {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)())
        state.selectionManager.setFocusedKey(node3.key);
      return;
    }
    requestAnimationFrame(() => {
      if (focusMode === "child" && document.activeElement === ref.current)
        focus();
    });
  };
  let gridCellProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, {
    role: "gridcell",
    onKeyDownCapture,
    onFocus
  });
  var _node_colIndex;
  if (isVirtualized)
    gridCellProps["aria-colindex"] = ((_node_colIndex = node3.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node3.index) + 1;
  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null)
    gridCellProps.onPointerDown = (e6) => {
      let el = e6.currentTarget;
      let tabindex = el.getAttribute("tabindex");
      el.removeAttribute("tabindex");
      requestAnimationFrame(() => {
        el.setAttribute("tabindex", tabindex);
      });
    };
  return {
    gridCellProps,
    isPressed
  };
}
function $ab90dcbc1b5466d0$var$last(walker) {
  let next2;
  let last;
  do {
    last = walker.lastChild();
    if (last)
      next2 = last;
  } while (last);
  return next2;
}
function $7cb39d07f245a780$export$70e2eed1a92976ad(props, state) {
  let { key } = props;
  let manager = state.selectionManager;
  let checkboxId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let isDisabled = !state.selectionManager.canSelectItem(key);
  let isSelected = state.selectionManager.isSelected(key);
  let onChange = () => manager.select(key);
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($835c96616a7cb4f9$exports)));
  return {
    checkboxProps: {
      id: checkboxId,
      "aria-label": stringFormatter.format("select"),
      isSelected,
      isDisabled,
      onChange
    }
  };
}

// node_modules/.pnpm/@react-aria+gridlist@3.7.2_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/gridlist/dist/import.mjs
var import_react50 = __toESM(require_react(), 1);
var $ce9b18daab526bbd$export$5b9bb410392e3991 = /* @__PURE__ */ new WeakMap();
function $ce9b18daab526bbd$export$f45c25170b9a99c2(state, key) {
  let { id } = $ce9b18daab526bbd$export$5b9bb410392e3991.get(state);
  if (!id)
    throw new Error("Unknown list");
  return `${id}-${$ce9b18daab526bbd$export$e0c709538cb8ae18(key)}`;
}
function $ce9b18daab526bbd$export$e0c709538cb8ae18(key) {
  if (typeof key === "string")
    return key.replace(/\s*/g, "");
  return "" + key;
}
function $f47efb0c3a859cf2$export$664f9155035607eb(props, state, ref) {
  let { isVirtualized, keyboardDelegate, onAction, linkBehavior = "action" } = props;
  if (!props["aria-label"] && !props["aria-labelledby"])
    console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    ref,
    keyboardDelegate,
    isVirtualized,
    selectOnFocus: state.selectionManager.selectionBehavior === "replace",
    shouldFocusWrap: props.shouldFocusWrap,
    linkBehavior
  });
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $ce9b18daab526bbd$export$5b9bb410392e3991).set(state, {
    id,
    onAction,
    linkBehavior
  });
  let descriptionProps = (0, $5b9b5b5723db6ae1$export$be42ebdab07ae4c2)({
    selectionManager: state.selectionManager,
    hasItemActions: !!onAction
  });
  let hasTabbableChild = (0, $83013635b024ae3d$export$eac1895992b9f3d6)(ref, {
    isDisabled: state.collection.size !== 0
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let gridProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
    domProps,
    {
      role: "grid",
      id,
      "aria-multiselectable": state.selectionManager.selectionMode === "multiple" ? "true" : void 0
    },
    // If collection is empty, make sure the grid is tabbable unless there is a child tabbable element.
    state.collection.size === 0 ? {
      tabIndex: hasTabbableChild ? -1 : 0
    } : listProps,
    descriptionProps
  );
  if (isVirtualized) {
    gridProps["aria-rowcount"] = state.collection.size;
    gridProps["aria-colcount"] = 1;
  }
  (0, $92599c3fd427b763$export$137e594ef3218a10)({}, state);
  return {
    gridProps
  };
}
function $4e8b0456ef72939f$export$9610e69494fadfd2(props, state, ref) {
  let { node: node3, isVirtualized, shouldSelectOnPressUp } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { onAction, linkBehavior } = (0, $ce9b18daab526bbd$export$5b9bb410392e3991).get(state);
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let keyWhenFocused = (0, import_react50.useRef)(null);
  let focus = () => {
    if (keyWhenFocused.current != null && node3.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement))
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
  };
  let { itemProps, ...itemStates } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key: node3.key,
    ref,
    isVirtualized,
    shouldSelectOnPressUp,
    onAction: onAction ? () => onAction(node3.key) : void 0,
    focus,
    linkBehavior
  });
  let onKeyDown = (e6) => {
    if (!e6.currentTarget.contains(e6.target))
      return;
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current);
    walker.currentNode = document.activeElement;
    switch (e6.key) {
      case "ArrowLeft": {
        let focusable = direction === "rtl" ? walker.nextNode() : walker.previousNode();
        if (focusable) {
          e6.preventDefault();
          e6.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
          });
        } else {
          e6.preventDefault();
          e6.stopPropagation();
          if (direction === "rtl") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
            });
          } else {
            walker.currentNode = ref.current;
            let lastElement = $4e8b0456ef72939f$var$last(walker);
            if (lastElement) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(lastElement);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(lastElement, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowRight": {
        let focusable = direction === "rtl" ? walker.previousNode() : walker.nextNode();
        if (focusable) {
          e6.preventDefault();
          e6.stopPropagation();
          (0, $6a99195332edec8b$export$80f3e147d781571c)(focusable);
          (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(focusable, {
            containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
          });
        } else {
          e6.preventDefault();
          e6.stopPropagation();
          if (direction === "ltr") {
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
            (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(ref.current, {
              containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
            });
          } else {
            walker.currentNode = ref.current;
            let lastElement = $4e8b0456ef72939f$var$last(walker);
            if (lastElement) {
              (0, $6a99195332edec8b$export$80f3e147d781571c)(lastElement);
              (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(lastElement, {
                containingElement: (0, $62d8ded9296f3872$export$cfa2225e87938781)(ref.current)
              });
            }
          }
        }
        break;
      }
      case "ArrowUp":
      case "ArrowDown":
        if (!e6.altKey && ref.current.contains(e6.target)) {
          e6.stopPropagation();
          e6.preventDefault();
          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e6.nativeEvent.type, e6.nativeEvent));
        }
        break;
    }
  };
  let onFocus = (e6) => {
    keyWhenFocused.current = node3.key;
    if (e6.target !== ref.current) {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)())
        state.selectionManager.setFocusedKey(node3.key);
      return;
    }
  };
  let linkProps = itemStates.hasAction ? (0, $ea8dcbcb9ea1b556$export$51437d503373d223)(node3.props) : {};
  let rowProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, linkProps, {
    role: "row",
    onKeyDownCapture: onKeyDown,
    onFocus,
    "aria-label": node3.textValue || void 0,
    "aria-selected": state.selectionManager.canSelectItem(node3.key) ? state.selectionManager.isSelected(node3.key) : void 0,
    "aria-disabled": state.selectionManager.isDisabled(node3.key) || void 0,
    "aria-labelledby": descriptionId && node3.textValue ? `${(0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state, node3.key)} ${descriptionId}` : void 0,
    id: (0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state, node3.key)
  });
  if (isVirtualized)
    rowProps["aria-rowindex"] = node3.index + 1;
  let gridCellProps = {
    role: "gridcell",
    "aria-colindex": 1
  };
  return {
    rowProps,
    gridCellProps,
    descriptionProps: {
      id: descriptionId
    },
    ...itemStates
  };
}
function $4e8b0456ef72939f$var$last(walker) {
  let next2;
  let last;
  do {
    last = walker.lastChild();
    if (last)
      next2 = last;
  } while (last);
  return next2;
}
function $e52ffc04a4adbd52$export$e29f2573fabbf7b9(props, state) {
  let { key } = props;
  const { checkboxProps } = (0, $7cb39d07f245a780$export$70e2eed1a92976ad)(props, state);
  return {
    checkboxProps: {
      ...checkboxProps,
      "aria-labelledby": `${checkboxProps.id} ${(0, $ce9b18daab526bbd$export$f45c25170b9a99c2)(state, key)}`
    }
  };
}

// node_modules/.pnpm/@react-aria+virtualizer@3.9.7_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/virtualizer/dist/import.mjs
var import_react51 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);
var $ce415dc67314b753$var$cachedRTLResult = null;
function $ce415dc67314b753$export$faf7630257ad4304(recalculate = false) {
  if ($ce415dc67314b753$var$cachedRTLResult === null || recalculate) {
    const outerDiv = document.createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = document.createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0)
      $ce415dc67314b753$var$cachedRTLResult = "positive-descending";
    else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0)
        $ce415dc67314b753$var$cachedRTLResult = "negative";
      else
        $ce415dc67314b753$var$cachedRTLResult = "positive-ascending";
    }
    document.body.removeChild(outerDiv);
    return $ce415dc67314b753$var$cachedRTLResult;
  }
  return $ce415dc67314b753$var$cachedRTLResult;
}
function $ce415dc67314b753$export$1389d168952b34b5(node3, direction) {
  let { scrollLeft } = node3;
  if (direction === "rtl") {
    let { scrollWidth, clientWidth } = node3;
    switch ($ce415dc67314b753$export$faf7630257ad4304()) {
      case "negative":
        scrollLeft = -scrollLeft;
        break;
      case "positive-descending":
        scrollLeft = scrollWidth - clientWidth - scrollLeft;
        break;
    }
  }
  return scrollLeft;
}
function $ce415dc67314b753$export$ed5fd5ffe5ab0ac(node3, direction, scrollLeft) {
  if (direction === "rtl")
    switch ($ce415dc67314b753$export$faf7630257ad4304()) {
      case "negative":
        scrollLeft = -scrollLeft;
        break;
      case "positive-ascending":
        break;
      default: {
        const { clientWidth, scrollWidth } = node3;
        scrollLeft = scrollWidth - clientWidth - scrollLeft;
        break;
      }
    }
  node3.scrollLeft = scrollLeft;
}
function $44a6ee657928b002$var$ScrollView(props, ref) {
  let { contentSize, onVisibleRectChange, children, innerStyle, sizeToFit, onScrollStart, onScrollEnd, scrollDirection = "both", ...otherProps } = props;
  let defaultRef = (0, import_react51.useRef)();
  ref = ref || defaultRef;
  let state = (0, import_react51.useRef)({
    scrollTop: 0,
    scrollLeft: 0,
    scrollEndTime: 0,
    scrollTimeout: null,
    width: 0,
    height: 0,
    isScrolling: false
  }).current;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let [isScrolling, setScrolling] = (0, import_react51.useState)(false);
  let onScroll = (0, import_react51.useCallback)((e6) => {
    if (e6.target !== e6.currentTarget)
      return;
    if (props.onScroll)
      props.onScroll(e6);
    (0, import_react_dom5.flushSync)(() => {
      let scrollTop = e6.currentTarget.scrollTop;
      let scrollLeft = (0, $ce415dc67314b753$export$1389d168952b34b5)(e6.currentTarget, direction);
      state.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state.height));
      state.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state.width));
      onVisibleRectChange(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(state.scrollLeft, state.scrollTop, state.width, state.height));
      if (!state.isScrolling) {
        state.isScrolling = true;
        setScrolling(true);
        if (onScrollStart)
          onScrollStart();
      }
      let now = Date.now();
      if (state.scrollEndTime <= now + 50) {
        state.scrollEndTime = now + 300;
        clearTimeout(state.scrollTimeout);
        state.scrollTimeout = setTimeout(() => {
          state.isScrolling = false;
          setScrolling(false);
          state.scrollTimeout = null;
          if (onScrollEnd)
            onScrollEnd();
        }, 300);
      }
    });
  }, [
    props,
    direction,
    state,
    contentSize,
    onVisibleRectChange,
    onScrollStart,
    onScrollEnd
  ]);
  (0, import_react51.useEffect)(() => {
    return () => {
      clearTimeout(state.scrollTimeout);
    };
  }, []);
  let updateSize = (0, import_react51.useCallback)(() => {
    let dom = ref.current;
    if (!dom)
      return;
    let w2 = dom.clientWidth;
    let h3 = dom.clientHeight;
    if (sizeToFit && contentSize.width > 0 && contentSize.height > 0) {
      if (sizeToFit === "width")
        w2 = Math.min(w2, contentSize.width);
      else if (sizeToFit === "height")
        h3 = Math.min(h3, contentSize.height);
    }
    if (state.width !== w2 || state.height !== h3) {
      state.width = w2;
      state.height = h3;
      onVisibleRectChange(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(state.scrollLeft, state.scrollTop, w2, h3));
    }
  }, [
    onVisibleRectChange,
    ref,
    state,
    sizeToFit,
    contentSize
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    updateSize();
  }, [
    updateSize
  ]);
  (0, $9daab02d461809db$export$683480f191c0e3ea)({
    ref,
    onResize: updateSize
  });
  let style = {
    // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.
    padding: 0,
    ...otherProps.style
  };
  if (scrollDirection === "horizontal") {
    style.overflowX = "auto";
    style.overflowY = "hidden";
  } else if (scrollDirection === "vertical" || contentSize.width === state.width) {
    style.overflowY = "auto";
    style.overflowX = "hidden";
  } else
    style.overflow = "auto";
  innerStyle = {
    width: contentSize.width,
    height: contentSize.height,
    pointerEvents: isScrolling ? "none" : "auto",
    position: "relative",
    ...innerStyle
  };
  return (0, import_react51.default).createElement("div", {
    ...otherProps,
    style,
    ref,
    onScroll
  }, (0, import_react51.default).createElement("div", {
    role: "presentation",
    style: innerStyle
  }, children));
}
var $44a6ee657928b002$export$5665e3d6be6adea = (0, import_react51.default).forwardRef($44a6ee657928b002$var$ScrollView);
function $47736c1e63ba1c6d$export$1da781778207e0a2(options) {
  let { layoutInfo, virtualizer, ref } = options;
  let updateSize = (0, import_react51.useCallback)(() => {
    let size3 = $47736c1e63ba1c6d$var$getSize(ref.current);
    virtualizer.updateItemSize(layoutInfo.key, size3);
  }, [
    virtualizer,
    layoutInfo.key,
    ref
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (layoutInfo.estimatedSize)
      updateSize();
  });
  return {
    updateSize
  };
}
function $47736c1e63ba1c6d$var$getSize(node3) {
  let height = node3.style.height;
  node3.style.height = "";
  let size3 = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(node3.scrollWidth, node3.scrollHeight);
  node3.style.height = height;
  return size3;
}
function $ccf8a0a04e4175ae$export$6796df8ba7398521(props) {
  let { className, layoutInfo, virtualizer, parent, children } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let ref = (0, import_react51.useRef)();
  (0, $47736c1e63ba1c6d$export$1da781778207e0a2)({
    layoutInfo,
    virtualizer,
    ref
  });
  return (0, import_react51.default).createElement("div", {
    role: "presentation",
    ref,
    className,
    style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, direction, parent)
  }, children);
}
var $ccf8a0a04e4175ae$var$cache = /* @__PURE__ */ new WeakMap();
function $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, dir, parent) {
  let xProperty = dir === "rtl" ? "right" : "left";
  let cached = $ccf8a0a04e4175ae$var$cache.get(layoutInfo);
  if (cached && cached[xProperty] != null) {
    if (!parent)
      return cached;
    let top = layoutInfo.rect.y - parent.rect.y;
    let x3 = layoutInfo.rect.x - parent.rect.x;
    if (cached.top === top && cached[xProperty] === x3)
      return cached;
  }
  let style = {
    position: layoutInfo.isSticky ? "sticky" : "absolute",
    // Sticky elements are positioned in normal document flow. Display inline-block so that they don't push other sticky columns onto the following rows.
    display: layoutInfo.isSticky ? "inline-block" : void 0,
    overflow: layoutInfo.allowOverflow ? "visible" : "hidden",
    top: layoutInfo.rect.y - (parent ? parent.rect.y : 0),
    [xProperty]: layoutInfo.rect.x - (parent ? parent.rect.x : 0),
    transition: "all",
    WebkitTransition: "all",
    WebkitTransitionDuration: "inherit",
    transitionDuration: "inherit",
    width: layoutInfo.rect.width,
    height: layoutInfo.rect.height,
    opacity: layoutInfo.opacity,
    zIndex: layoutInfo.zIndex,
    transform: layoutInfo.transform,
    contain: "size layout style"
  };
  $ccf8a0a04e4175ae$var$cache.set(layoutInfo, style);
  return style;
}
function $6d0a5c394373ae64$var$Virtualizer(props, ref) {
  let { children: renderView, renderWrapper, layout, collection: collection2, sizeToFit, scrollDirection, transitionDuration, isLoading, onLoadMore, focusedKey, shouldUseVirtualFocus, scrollToItem, autoFocus, ...otherProps } = props;
  let fallbackRef = (0, import_react51.useRef)();
  ref = ref || fallbackRef;
  let state = (0, $fc0b13b484ac1194$export$1505db82fe357e65)({
    transitionDuration,
    layout,
    collection: collection2,
    renderView,
    renderWrapper: renderWrapper || $6d0a5c394373ae64$var$defaultRenderWrapper,
    onVisibleRectChange(rect) {
      ref.current.scrollLeft = rect.x;
      ref.current.scrollTop = rect.y;
    }
  });
  let { virtualizerProps, scrollViewProps } = $6d0a5c394373ae64$export$dd6d526d88b5a137(props, state, ref);
  return (0, import_react51.default).createElement((0, $44a6ee657928b002$export$5665e3d6be6adea), {
    ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(otherProps, virtualizerProps, scrollViewProps),
    ref,
    innerStyle: state.isAnimating ? {
      transition: `none ${state.virtualizer.transitionDuration}ms`
    } : void 0,
    contentSize: state.contentSize,
    onScrollStart: state.startScrolling,
    onScrollEnd: state.endScrolling,
    sizeToFit,
    scrollDirection
  }, state.visibleViews);
}
function $6d0a5c394373ae64$export$dd6d526d88b5a137(props, state, ref) {
  let { focusedKey, scrollToItem, shouldUseVirtualFocus, isLoading, onLoadMore } = props;
  let { virtualizer } = state;
  let lastFocusedKey = (0, import_react51.useRef)(null);
  let isFocusWithin = (0, import_react51.useRef)(false);
  let autoFocus = (0, import_react51.useRef)(props.autoFocus);
  (0, import_react51.useEffect)(() => {
    if (virtualizer.visibleRect.height === 0)
      return;
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (focusedKey !== lastFocusedKey.current && (modality !== "pointer" || autoFocus.current)) {
      autoFocus.current = false;
      if (scrollToItem)
        scrollToItem(focusedKey);
      else
        virtualizer.scrollToItem(focusedKey, {
          duration: 0
        });
    }
    lastFocusedKey.current = focusedKey;
  }, [
    focusedKey,
    virtualizer.visibleRect.height,
    virtualizer,
    lastFocusedKey,
    scrollToItem,
    ref
  ]);
  virtualizer.persistedKeys = (0, import_react51.useMemo)(() => focusedKey ? /* @__PURE__ */ new Set([
    focusedKey
  ]) : /* @__PURE__ */ new Set(), [
    focusedKey
  ]);
  let onFocus = (0, import_react51.useCallback)((e6) => {
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (!isFocusWithin.current && ref.current.contains(e6.target) && modality !== "pointer") {
      if (scrollToItem)
        scrollToItem(focusedKey);
      else
        virtualizer.scrollToItem(focusedKey, {
          duration: 0
        });
    }
    isFocusWithin.current = e6.target !== ref.current;
  }, [
    ref,
    virtualizer,
    focusedKey,
    scrollToItem
  ]);
  let onBlur = (0, import_react51.useCallback)((e6) => {
    isFocusWithin.current = ref.current.contains(e6.relatedTarget);
  }, [
    ref
  ]);
  let tabIndex;
  if (!shouldUseVirtualFocus) {
    tabIndex = focusedKey != null ? -1 : 0;
    if (virtualizer.collection.size === 0 && props.tabIndex != null)
      tabIndex = props.tabIndex;
  }
  let isLoadingRef = (0, import_react51.useRef)(isLoading);
  let prevProps = (0, import_react51.useRef)(props);
  let onVisibleRectChange = (0, import_react51.useCallback)((rect) => {
    state.setVisibleRect(rect);
    if (!isLoadingRef.current && onLoadMore) {
      let scrollOffset = state.virtualizer.contentSize.height - rect.height * 2;
      if (rect.y > scrollOffset) {
        isLoadingRef.current = true;
        onLoadMore();
      }
    }
  }, [
    onLoadMore,
    state
  ]);
  let lastContentSize = (0, import_react51.useRef)(0);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (state.isAnimating)
      return;
    let wasLoading = isLoadingRef.current;
    if (props !== prevProps.current) {
      isLoadingRef.current = isLoading;
      prevProps.current = props;
    }
    let shouldLoadMore = !isLoadingRef.current && onLoadMore && state.contentSize.height > 0 && state.contentSize.height <= state.virtualizer.visibleRect.height && (wasLoading || state.contentSize.height !== lastContentSize.current);
    if (shouldLoadMore) {
      isLoadingRef.current = true;
      onLoadMore();
    }
    lastContentSize.current = state.contentSize.height;
  }, [
    state.contentSize,
    state.isAnimating,
    state.virtualizer,
    isLoading,
    onLoadMore,
    props
  ]);
  return {
    virtualizerProps: {
      tabIndex,
      onFocus,
      onBlur
    },
    scrollViewProps: {
      onVisibleRectChange
    }
  };
}
var $6d0a5c394373ae64$export$89be5a243e59c4b2 = (0, import_react51.default).forwardRef($6d0a5c394373ae64$var$Virtualizer);
function $6d0a5c394373ae64$var$defaultRenderWrapper(parent, reusableView) {
  return (0, import_react51.default).createElement((0, $ccf8a0a04e4175ae$export$6796df8ba7398521), {
    key: reusableView.key,
    layoutInfo: reusableView.layoutInfo,
    virtualizer: reusableView.virtualizer,
    parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo
  }, reusableView.rendered);
}

// node_modules/.pnpm/@react-stately+layout@3.13.4_react@18.2.0/node_modules/@react-stately/layout/dist/import.mjs
var $61ef60fc9b1041f4$var$DEFAULT_HEIGHT = 48;
var $61ef60fc9b1041f4$export$cacbb3924155d68e = class extends (0, $c74cda7d31af1253$export$c84671f46d6a1ca) {
  getLayoutInfo(key) {
    let res = this.layoutInfos.get(key);
    if (!res && this.validRect.area < this.contentSize.area && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, Infinity, Infinity);
      this.rootNodes = this.buildCollection();
      this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);
      res = this.layoutInfos.get(key);
    }
    return res;
  }
  getVisibleLayoutInfos(rect) {
    if (!this.validRect.containsRect(rect) && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = this.validRect.union(rect);
      this.rootNodes = this.buildCollection();
    }
    let res = [];
    let addNodes = (nodes) => {
      for (let node3 of nodes)
        if (this.isVisible(node3, rect)) {
          res.push(node3.layoutInfo);
          if (node3.header)
            res.push(node3.header);
          if (node3.children)
            addNodes(node3.children);
        }
    };
    addNodes(this.rootNodes);
    return res;
  }
  isVisible(node3, rect) {
    return node3.layoutInfo.rect.intersects(rect) || node3.layoutInfo.isSticky || this.virtualizer.isPersistedKey(node3.layoutInfo.key);
  }
  shouldInvalidateEverything(invalidationContext) {
    return invalidationContext.sizeChanged;
  }
  validate(invalidationContext) {
    this.collection = this.virtualizer.collection;
    this.invalidateEverything = this.shouldInvalidateEverything(invalidationContext);
    if (this.invalidateEverything) {
      this.lastValidRect = this.validRect;
      this.validRect = this.virtualizer.getVisibleRect();
    }
    this.rootNodes = this.buildCollection();
    if (this.lastCollection && this.collection !== this.lastCollection) {
      for (let key of this.lastCollection.getKeys())
        if (!this.collection.getItem(key)) {
          let layoutNode = this.layoutNodes.get(key);
          if (layoutNode) {
            var _layoutNode_header;
            this.layoutInfos.delete(layoutNode.layoutInfo.key);
            this.layoutInfos.delete((_layoutNode_header = layoutNode.header) === null || _layoutNode_header === void 0 ? void 0 : _layoutNode_header.key);
            this.layoutNodes.delete(key);
          }
        }
    }
    this.lastWidth = this.virtualizer.visibleRect.width;
    this.lastCollection = this.collection;
    this.invalidateEverything = false;
  }
  buildCollection() {
    let y4 = this.padding;
    let skipped = 0;
    let nodes = [];
    for (let node3 of this.collection) {
      var _this_rowHeight;
      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;
      if (node3.type === "item" && y4 + rowHeight < this.validRect.y && !this.isValid(node3, y4)) {
        y4 += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(node3, 0, y4);
      y4 = layoutNode.layoutInfo.rect.maxY;
      nodes.push(layoutNode);
      if (node3.type === "item" && y4 > this.validRect.maxY) {
        y4 += (this.collection.size - (nodes.length + skipped)) * rowHeight;
        break;
      }
    }
    if (this.isLoading) {
      var _this_loaderHeight;
      let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, this.virtualizer.visibleRect.width, (_this_loaderHeight = this.loaderHeight) !== null && _this_loaderHeight !== void 0 ? _this_loaderHeight : this.virtualizer.visibleRect.height);
      let loader = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("loader", "loader", rect);
      this.layoutInfos.set("loader", loader);
      nodes.push({
        layoutInfo: loader
      });
      y4 = loader.rect.maxY;
    }
    if (nodes.length === 0) {
      var _this_placeholderHeight;
      let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, this.virtualizer.visibleRect.width, (_this_placeholderHeight = this.placeholderHeight) !== null && _this_placeholderHeight !== void 0 ? _this_placeholderHeight : this.virtualizer.visibleRect.height);
      let placeholder = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("placeholder", "placeholder", rect);
      this.layoutInfos.set("placeholder", placeholder);
      nodes.push({
        layoutInfo: placeholder
      });
      y4 = placeholder.rect.maxY;
    }
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(this.virtualizer.visibleRect.width, y4 + this.padding);
    return nodes;
  }
  isValid(node3, y4) {
    let cached = this.layoutNodes.get(node3.key);
    return !this.invalidateEverything && cached && cached.node === node3 && y4 === (cached.header || cached.layoutInfo).rect.y && cached.layoutInfo.rect.intersects(this.lastValidRect) && cached.validRect.containsRect(cached.layoutInfo.rect.intersection(this.validRect));
  }
  buildChild(node3, x3, y4) {
    if (this.isValid(node3, y4))
      return this.layoutNodes.get(node3.key);
    let layoutNode = this.buildNode(node3, x3, y4);
    layoutNode.node = node3;
    var _node_parentKey;
    layoutNode.layoutInfo.parentKey = (_node_parentKey = node3.parentKey) !== null && _node_parentKey !== void 0 ? _node_parentKey : null;
    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);
    if (layoutNode.header)
      this.layoutInfos.set(layoutNode.header.key, layoutNode.header);
    this.layoutNodes.set(node3.key, layoutNode);
    return layoutNode;
  }
  buildNode(node3, x3, y4) {
    switch (node3.type) {
      case "section":
        return this.buildSection(node3, x3, y4);
      case "item":
        return this.buildItem(node3, x3, y4);
    }
  }
  buildSection(node3, x3, y4) {
    let width = this.virtualizer.visibleRect.width;
    let rectHeight = this.headingHeight;
    let isEstimated = false;
    if (rectHeight == null) {
      let previousLayoutNode = this.layoutNodes.get(node3.key);
      if (previousLayoutNode && previousLayoutNode.header) {
        let curNode = this.collection.getItem(node3.key);
        let lastNode = this.lastCollection ? this.lastCollection.getItem(node3.key) : null;
        rectHeight = previousLayoutNode.header.rect.height;
        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;
      } else {
        rectHeight = node3.rendered ? this.estimatedHeadingHeight : 0;
        isEstimated = true;
      }
    }
    if (rectHeight == null)
      rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;
    let headerRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, width, rectHeight);
    let header = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("header", node3.key + ":header", headerRect);
    header.estimatedSize = isEstimated;
    header.parentKey = node3.key;
    y4 += header.rect.height;
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, width, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node3.type, node3.key, rect);
    let startY = y4;
    let skipped = 0;
    let children = [];
    for (let child of (0, $c5a24bc478652b5f$export$1005530eda016c13)(node3, this.collection)) {
      var _this_rowHeight;
      let rowHeight = (_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight;
      if (y4 + rowHeight < this.validRect.y && !this.isValid(node3, y4)) {
        y4 += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(child, x3, y4);
      y4 = layoutNode.layoutInfo.rect.maxY;
      children.push(layoutNode);
      if (y4 > this.validRect.maxY) {
        y4 += ([
          ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(node3, this.collection)
        ].length - (children.length + skipped)) * rowHeight;
        break;
      }
    }
    rect.height = y4 - startY;
    return {
      header,
      layoutInfo,
      children,
      validRect: layoutInfo.rect.intersection(this.validRect)
    };
  }
  buildItem(node3, x3, y4) {
    let width = this.virtualizer.visibleRect.width;
    let rectHeight = this.rowHeight;
    let isEstimated = false;
    if (rectHeight == null) {
      let previousLayoutNode = this.layoutNodes.get(node3.key);
      if (previousLayoutNode) {
        rectHeight = previousLayoutNode.layoutInfo.rect.height;
        isEstimated = width !== this.lastWidth || node3 !== previousLayoutNode.node || previousLayoutNode.layoutInfo.estimatedSize;
      } else {
        rectHeight = this.estimatedRowHeight;
        isEstimated = true;
      }
    }
    if (rectHeight == null)
      rectHeight = $61ef60fc9b1041f4$var$DEFAULT_HEIGHT;
    if (typeof this.indentationForItem === "function")
      x3 += this.indentationForItem(this.collection, node3.key) || 0;
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x3, y4, width - x3, rectHeight);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node3.type, node3.key, rect);
    layoutInfo.allowOverflow = true;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: layoutInfo.rect
    };
  }
  updateItemSize(key, size3) {
    let layoutInfo = this.layoutInfos.get(key);
    if (!layoutInfo)
      return false;
    layoutInfo.estimatedSize = false;
    if (layoutInfo.rect.height !== size3.height) {
      let newLayoutInfo = layoutInfo.copy();
      newLayoutInfo.rect.height = size3.height;
      this.layoutInfos.set(key, newLayoutInfo);
      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);
      let node3 = this.collection.getItem(layoutInfo.parentKey);
      while (node3) {
        this.updateLayoutNode(node3.key, layoutInfo, newLayoutInfo);
        node3 = this.collection.getItem(node3.parentKey);
      }
      return true;
    }
    return false;
  }
  updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {
    let n6 = this.layoutNodes.get(key);
    if (n6) {
      n6.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
      if (n6.header === oldLayoutInfo)
        n6.header = newLayoutInfo;
      else if (n6.layoutInfo === oldLayoutInfo)
        n6.layoutInfo = newLayoutInfo;
    }
  }
  getContentSize() {
    return this.contentSize;
  }
  getKeyAbove(key) {
    let collection2 = this.collection;
    key = collection2.getKeyBefore(key);
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key)))
        return key;
      key = collection2.getKeyBefore(key);
    }
  }
  getKeyBelow(key) {
    let collection2 = this.collection;
    key = collection2.getKeyAfter(key);
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key)))
        return key;
      key = collection2.getKeyAfter(key);
    }
  }
  getKeyPageAbove(key) {
    let layoutInfo = this.getLayoutInfo(key);
    if (layoutInfo) {
      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);
      while (layoutInfo && layoutInfo.rect.y > pageY) {
        let keyAbove = this.getKeyAbove(layoutInfo.key);
        layoutInfo = this.getLayoutInfo(keyAbove);
      }
      if (layoutInfo)
        return layoutInfo.key;
    }
    return this.getFirstKey();
  }
  getKeyPageBelow(key) {
    let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());
    if (layoutInfo) {
      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);
      while (layoutInfo && layoutInfo.rect.y < pageY) {
        let keyBelow = this.getKeyBelow(layoutInfo.key);
        layoutInfo = this.getLayoutInfo(keyBelow);
      }
      if (layoutInfo)
        return layoutInfo.key;
    }
    return this.getLastKey();
  }
  getFirstKey() {
    let collection2 = this.collection;
    let key = collection2.getFirstKey();
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key)))
        return key;
      key = collection2.getKeyAfter(key);
    }
  }
  getLastKey() {
    let collection2 = this.collection;
    let key = collection2.getLastKey();
    while (key != null) {
      let item2 = collection2.getItem(key);
      if (item2.type === "item" && (this.allowDisabledKeyFocus || !this.disabledKeys.has(item2.key)))
        return key;
      key = collection2.getKeyBefore(key);
    }
  }
  getKeyForSearch(search, fromKey) {
    if (!this.collator)
      return null;
    let collection2 = this.collection;
    let key = fromKey || this.getFirstKey();
    while (key != null) {
      let item2 = collection2.getItem(key);
      let substring = item2.textValue.slice(0, search.length);
      if (item2.textValue && this.collator.compare(substring, search) === 0)
        return key;
      key = this.getKeyBelow(key);
    }
    return null;
  }
  getInitialLayoutInfo(layoutInfo) {
    layoutInfo.opacity = 0;
    layoutInfo.transform = "scale3d(0.8, 0.8, 0.8)";
    return layoutInfo;
  }
  getFinalLayoutInfo(layoutInfo) {
    layoutInfo.opacity = 0;
    layoutInfo.transform = "scale3d(0.8, 0.8, 0.8)";
    return layoutInfo;
  }
  getDropTargetFromPoint(x3, y4, isValidDropTarget) {
    x3 += this.virtualizer.visibleRect.x;
    y4 += this.virtualizer.visibleRect.y;
    let key = this.virtualizer.keyAtPoint(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x3, y4));
    if (key == null || this.collection.size === 0)
      return {
        type: "root"
      };
    let layoutInfo = this.getLayoutInfo(key);
    let rect = layoutInfo.rect;
    let target = {
      type: "item",
      key: layoutInfo.key,
      dropPosition: "on"
    };
    if (!isValidDropTarget(target)) {
      if (y4 <= rect.y + rect.height / 2 && isValidDropTarget({
        ...target,
        dropPosition: "before"
      }))
        target.dropPosition = "before";
      else if (isValidDropTarget({
        ...target,
        dropPosition: "after"
      }))
        target.dropPosition = "after";
    } else if (y4 <= rect.y + 10 && isValidDropTarget({
      ...target,
      dropPosition: "before"
    }))
      target.dropPosition = "before";
    else if (y4 >= rect.maxY - 10 && isValidDropTarget({
      ...target,
      dropPosition: "after"
    }))
      target.dropPosition = "after";
    return target;
  }
  /**
  * Creates a new ListLayout with options. See the list of properties below for a description
  * of the options that can be provided.
  */
  constructor(options = {}) {
    super();
    this.disabledKeys = /* @__PURE__ */ new Set();
    this.allowDisabledKeyFocus = false;
    this.rowHeight = options.rowHeight;
    this.estimatedRowHeight = options.estimatedRowHeight;
    this.headingHeight = options.headingHeight;
    this.estimatedHeadingHeight = options.estimatedHeadingHeight;
    this.padding = options.padding || 0;
    this.indentationForItem = options.indentationForItem;
    this.collator = options.collator;
    this.loaderHeight = options.loaderHeight;
    this.placeholderHeight = options.placeholderHeight;
    this.layoutInfos = /* @__PURE__ */ new Map();
    this.layoutNodes = /* @__PURE__ */ new Map();
    this.rootNodes = [];
    this.lastWidth = 0;
    this.lastCollection = null;
    this.allowDisabledKeyFocus = options.allowDisabledKeyFocus;
    this.lastValidRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this.validRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();
  }
};
var $a152112e902709bf$export$62444c3c724b1b20 = class extends (0, $61ef60fc9b1041f4$export$cacbb3924155d68e) {
  shouldInvalidateEverything(invalidationContext) {
    return super.shouldInvalidateEverything(invalidationContext) || !this.lastCollection || this.collection.columns.length !== this.lastCollection.columns.length || this.collection.columns.some((c5, i6) => c5.key !== this.lastCollection.columns[i6].key || c5.props.width !== this.lastCollection.columns[i6].props.width || c5.props.minWidth !== this.lastCollection.columns[i6].props.minWidth || c5.props.maxWidth !== this.lastCollection.columns[i6].props.maxWidth);
  }
  getResizerPosition() {
    var _this_getLayoutInfo;
    return (_this_getLayoutInfo = this.getLayoutInfo(this.resizingColumn)) === null || _this_getLayoutInfo === void 0 ? void 0 : _this_getLayoutInfo.rect.maxX;
  }
  getColumnWidth(key) {
    var _this_columnLayout_getColumnWidth;
    return (_this_columnLayout_getColumnWidth = this.columnLayout.getColumnWidth(key)) !== null && _this_columnLayout_getColumnWidth !== void 0 ? _this_columnLayout_getColumnWidth : 0;
  }
  getColumnMinWidth(key) {
    let column2 = this.collection.columns.find((col) => col.key === key);
    if (!column2)
      return 0;
    return this.columnLayout.getColumnMinWidth(key);
  }
  getColumnMaxWidth(key) {
    let column2 = this.collection.columns.find((col) => col.key === key);
    if (!column2)
      return 0;
    return this.columnLayout.getColumnMaxWidth(key);
  }
  // outside, where this is called, should call props.onColumnResizeStart...
  startResize(key) {
    this.resizingColumn = key;
  }
  // only way to call props.onColumnResize with the new size outside of Layout is to send the result back
  updateResizedColumns(key, width) {
    let newControlled = new Map(Array.from(this.controlledColumns).map(([key2, entry]) => [
      key2,
      entry.props.width
    ]));
    let newSizes = this.columnLayout.resizeColumnWidth(this.virtualizer.visibleRect.width, this.collection, newControlled, this.uncontrolledWidths, key, width);
    let map2 = new Map(Array.from(this.uncontrolledColumns).map(([key2]) => [
      key2,
      newSizes.get(key2)
    ]));
    map2.set(key, width);
    this.uncontrolledWidths = map2;
    if (this.uncontrolledWidths.size > 0)
      this.virtualizer.relayoutNow({
        sizeChanged: true
      });
    return newSizes;
  }
  endResize() {
    this.resizingColumn = null;
  }
  buildCollection() {
    let loadingState = this.collection.body.props.loadingState;
    this.wasLoading = this.isLoading;
    this.isLoading = loadingState === "loading" || loadingState === "loadingMore";
    this.stickyColumnIndices = [];
    for (let column2 of this.collection.columns)
      if (column2.props.isDragButtonCell || column2.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column2.key))
        this.stickyColumnIndices.push(column2.index);
    let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);
    this.controlledColumns = controlledColumns;
    this.uncontrolledColumns = uncontrolledColumns;
    let colWidths = this.columnLayout.recombineColumns(this.collection.columns, this.uncontrolledWidths, uncontrolledColumns, controlledColumns);
    this.columnWidths = this.columnLayout.buildColumnWidths(this.virtualizer.visibleRect.width, this.collection, colWidths);
    let header = this.buildHeader();
    let body = this.buildBody(0);
    this.lastPersistedKeys = null;
    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);
    this.contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);
    return [
      header,
      body
    ];
  }
  buildHeader() {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("header", "header", rect);
    let y4 = 0;
    let width = 0;
    let children = [];
    for (let headerRow of this.collection.headerRows) {
      let layoutNode = this.buildChild(headerRow, 0, y4);
      layoutNode.layoutInfo.parentKey = "header";
      y4 = layoutNode.layoutInfo.rect.maxY;
      width = Math.max(width, layoutNode.layoutInfo.rect.width);
      layoutNode.index = children.length;
      children.push(layoutNode);
    }
    rect.width = width;
    rect.height = y4;
    this.layoutInfos.set("header", layoutInfo);
    return {
      layoutInfo,
      children,
      validRect: layoutInfo.rect
    };
  }
  buildHeaderRow(headerRow, x3, y4) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, 0, 0);
    let row = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("headerrow", headerRow.key, rect);
    let height = 0;
    let columns = [];
    for (let cell2 of (0, $c5a24bc478652b5f$export$1005530eda016c13)(headerRow, this.collection)) {
      let layoutNode = this.buildChild(cell2, x3, y4);
      layoutNode.layoutInfo.parentKey = row.key;
      x3 = layoutNode.layoutInfo.rect.maxX;
      height = Math.max(height, layoutNode.layoutInfo.rect.height);
      layoutNode.index = columns.length;
      columns.push(layoutNode);
    }
    for (let [i6, layout] of columns.entries())
      layout.layoutInfo.zIndex = columns.length - i6 + 1;
    this.setChildHeights(columns, height);
    rect.height = height;
    rect.width = x3;
    return {
      layoutInfo: row,
      children: columns,
      validRect: rect
    };
  }
  setChildHeights(children, height) {
    for (let child of children)
      if (child.layoutInfo.rect.height !== height) {
        child.layoutInfo = child.layoutInfo.copy();
        this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);
        child.layoutInfo.rect.height = height;
      }
  }
  // used to get the column widths when rendering to the DOM
  getRenderedColumnWidth(node3) {
    var _node_colspan;
    let colspan = (_node_colspan = node3.colspan) !== null && _node_colspan !== void 0 ? _node_colspan : 1;
    var _node_colIndex;
    let colIndex = (_node_colIndex = node3.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node3.index;
    let width = 0;
    for (let i6 = colIndex; i6 < colIndex + colspan; i6++) {
      let column2 = this.collection.columns[i6];
      if ((column2 === null || column2 === void 0 ? void 0 : column2.key) != null)
        width += this.columnWidths.get(column2.key);
    }
    return width;
  }
  getEstimatedHeight(node3, width, height, estimatedHeight) {
    let isEstimated = false;
    if (height == null) {
      let previousLayoutNode = this.layoutNodes.get(node3.key);
      if (previousLayoutNode) {
        height = previousLayoutNode.layoutInfo.rect.height;
        isEstimated = node3 !== previousLayoutNode.node || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;
      } else {
        height = estimatedHeight;
        isEstimated = true;
      }
    }
    return {
      height,
      isEstimated
    };
  }
  buildColumn(node3, x3, y4) {
    var _node_props, _node_props1;
    let width = this.getRenderedColumnWidth(node3);
    let { height, isEstimated } = this.getEstimatedHeight(node3, width, this.headingHeight, this.estimatedHeadingHeight);
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x3, y4, width, height);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node3.type, node3.key, rect);
    layoutInfo.isSticky = !this.disableSticky && (((_node_props = node3.props) === null || _node_props === void 0 ? void 0 : _node_props.isDragButtonCell) || ((_node_props1 = node3.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.isSelectionCell));
    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: layoutInfo.rect
    };
  }
  buildBody(y4) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, y4, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("rowgroup", "body", rect);
    let startY = y4;
    let skipped = 0;
    let width = 0;
    let children = [];
    for (let [i6, node3] of [
      ...this.collection
    ].entries()) {
      var _this_rowHeight;
      let rowHeight = ((_this_rowHeight = this.rowHeight) !== null && _this_rowHeight !== void 0 ? _this_rowHeight : this.estimatedRowHeight) + 1;
      if (y4 + rowHeight < this.validRect.y && !this.isValid(node3, y4)) {
        y4 += rowHeight;
        skipped++;
        continue;
      }
      let layoutNode = this.buildChild(node3, 0, y4);
      layoutNode.layoutInfo.parentKey = "body";
      layoutNode.index = i6;
      y4 = layoutNode.layoutInfo.rect.maxY;
      width = Math.max(width, layoutNode.layoutInfo.rect.width);
      children.push(layoutNode);
      if (y4 > this.validRect.maxY) {
        y4 += (this.collection.size - (skipped + children.length)) * rowHeight;
        break;
      }
    }
    if (this.isLoading) {
      let rect2 = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(40, Math.max(y4, 40), (width || this.virtualizer.visibleRect.width) - 80, children.length === 0 ? this.virtualizer.visibleRect.height - 80 : 60);
      let loader = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("loader", "loader", rect2);
      loader.parentKey = "body";
      loader.isSticky = !this.disableSticky && children.length === 0;
      this.layoutInfos.set("loader", loader);
      children.push({
        layoutInfo: loader,
        validRect: loader.rect
      });
      y4 = loader.rect.maxY;
      width = Math.max(width, rect2.width);
    } else if (children.length === 0) {
      let rect2 = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(40, Math.max(y4, 40), this.virtualizer.visibleRect.width - 80, this.virtualizer.visibleRect.height - 80);
      let empty2 = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("empty", "empty", rect2);
      empty2.parentKey = "body";
      empty2.isSticky = !this.disableSticky;
      this.layoutInfos.set("empty", empty2);
      children.push({
        layoutInfo: empty2,
        validRect: empty2.rect
      });
      y4 = empty2.rect.maxY;
      width = Math.max(width, rect2.width);
    }
    rect.width = width;
    rect.height = y4 - startY;
    this.layoutInfos.set("body", layoutInfo);
    return {
      layoutInfo,
      children,
      validRect: layoutInfo.rect.intersection(this.validRect)
    };
  }
  buildNode(node3, x3, y4) {
    switch (node3.type) {
      case "headerrow":
        return this.buildHeaderRow(node3, x3, y4);
      case "item":
        return this.buildRow(node3, x3, y4);
      case "column":
      case "placeholder":
        return this.buildColumn(node3, x3, y4);
      case "cell":
        return this.buildCell(node3, x3, y4);
      default:
        throw new Error("Unknown node type " + node3.type);
    }
  }
  buildRow(node3, x3, y4) {
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x3, y4, 0, 0);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)("row", node3.key, rect);
    let children = [];
    let height = 0;
    for (let [i6, child] of [
      ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(node3, this.collection)
    ].entries())
      if (child.type === "cell") {
        if (x3 > this.validRect.maxX) {
          let layoutNode = this.layoutNodes.get(child.key);
          if (layoutNode) {
            layoutNode.layoutInfo.rect.x = x3;
            x3 += layoutNode.layoutInfo.rect.width;
          }
        } else {
          let layoutNode = this.buildChild(child, x3, y4);
          x3 = layoutNode.layoutInfo.rect.maxX;
          height = Math.max(height, layoutNode.layoutInfo.rect.height);
          layoutNode.index = i6;
          children.push(layoutNode);
        }
      }
    this.setChildHeights(children, height);
    rect.width = this.layoutInfos.get("header").rect.width;
    rect.height = height + 1;
    return {
      layoutInfo,
      children,
      validRect: rect.intersection(this.validRect)
    };
  }
  buildCell(node3, x3, y4) {
    var _node_props, _node_props1;
    let width = this.getRenderedColumnWidth(node3);
    let { height, isEstimated } = this.getEstimatedHeight(node3, width, this.rowHeight, this.estimatedRowHeight);
    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x3, y4, width, height);
    let layoutInfo = new (0, $d7fd61009c21d0bb$export$7e0eeb9da702a085)(node3.type, node3.key, rect);
    layoutInfo.isSticky = !this.disableSticky && (((_node_props = node3.props) === null || _node_props === void 0 ? void 0 : _node_props.isDragButtonCell) || ((_node_props1 = node3.props) === null || _node_props1 === void 0 ? void 0 : _node_props1.isSelectionCell));
    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;
    layoutInfo.estimatedSize = isEstimated;
    return {
      layoutInfo,
      validRect: rect
    };
  }
  getVisibleLayoutInfos(rect) {
    if (!this.validRect.containsRect(rect) && this.lastCollection) {
      this.lastValidRect = this.validRect;
      this.validRect = this.validRect.union(rect);
      this.rootNodes = this.buildCollection();
    }
    let res = [];
    this.buildPersistedIndices();
    for (let node3 of this.rootNodes) {
      res.push(node3.layoutInfo);
      this.addVisibleLayoutInfos(res, node3, rect);
    }
    return res;
  }
  addVisibleLayoutInfos(res, node3, rect) {
    if (!node3.children || node3.children.length === 0)
      return;
    switch (node3.layoutInfo.type) {
      case "header":
        for (let child of node3.children) {
          res.push(child.layoutInfo);
          this.addVisibleLayoutInfos(res, child, rect);
        }
        break;
      case "rowgroup": {
        let firstVisibleRow = this.binarySearch(node3.children, rect.topLeft, "y");
        let lastVisibleRow = this.binarySearch(node3.children, rect.bottomRight, "y");
        let persistedRowIndices = this.persistedIndices.get(node3.layoutInfo.key);
        let persistIndex = 0;
        while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < firstVisibleRow) {
          let idx = persistedRowIndices[persistIndex];
          if (idx < node3.children.length) {
            res.push(node3.children[idx].layoutInfo);
            this.addVisibleLayoutInfos(res, node3.children[idx], rect);
          }
          persistIndex++;
        }
        for (let i6 = firstVisibleRow; i6 <= lastVisibleRow; i6++) {
          while (persistedRowIndices && persistIndex < persistedRowIndices.length && persistedRowIndices[persistIndex] < i6)
            persistIndex++;
          res.push(node3.children[i6].layoutInfo);
          this.addVisibleLayoutInfos(res, node3.children[i6], rect);
        }
        while (persistedRowIndices && persistIndex < persistedRowIndices.length) {
          let idx = persistedRowIndices[persistIndex++];
          if (idx < node3.children.length)
            res.push(node3.children[idx].layoutInfo);
        }
        break;
      }
      case "headerrow":
      case "row": {
        let firstVisibleCell = this.binarySearch(node3.children, rect.topLeft, "x");
        let lastVisibleCell = this.binarySearch(node3.children, rect.topRight, "x");
        let stickyIndex = 0;
        let persistedCellIndices = this.persistedIndices.get(node3.layoutInfo.key) || this.stickyColumnIndices;
        while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < firstVisibleCell) {
          let idx = persistedCellIndices[stickyIndex];
          if (idx < node3.children.length)
            res.push(node3.children[idx].layoutInfo);
          stickyIndex++;
        }
        for (let i6 = firstVisibleCell; i6 <= lastVisibleCell; i6++) {
          while (stickyIndex < persistedCellIndices.length && persistedCellIndices[stickyIndex] < i6)
            stickyIndex++;
          res.push(node3.children[i6].layoutInfo);
        }
        while (stickyIndex < persistedCellIndices.length) {
          let idx = persistedCellIndices[stickyIndex++];
          if (idx < node3.children.length)
            res.push(node3.children[idx].layoutInfo);
        }
        break;
      }
      default:
        throw new Error("Unknown node type " + node3.layoutInfo.type);
    }
  }
  binarySearch(items, point, axis) {
    let low = 0;
    let high = items.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      let item2 = items[mid];
      if (axis === "x" && item2.layoutInfo.rect.maxX < point.x || axis === "y" && item2.layoutInfo.rect.maxY < point.y)
        low = mid + 1;
      else if (axis === "x" && item2.layoutInfo.rect.x > point.x || axis === "y" && item2.layoutInfo.rect.y > point.y)
        high = mid - 1;
      else
        return mid;
    }
    return Math.max(0, Math.min(items.length - 1, low));
  }
  buildPersistedIndices() {
    if (this.virtualizer.persistedKeys === this.lastPersistedKeys)
      return;
    this.lastPersistedKeys = this.virtualizer.persistedKeys;
    this.persistedIndices.clear();
    for (let key of this.virtualizer.persistedKeys) {
      let layoutInfo = this.layoutInfos.get(key);
      while (layoutInfo && layoutInfo.parentKey) {
        let collectionNode = this.collection.getItem(layoutInfo.key);
        let indices = this.persistedIndices.get(layoutInfo.parentKey);
        if (!indices) {
          indices = collectionNode.type === "cell" || collectionNode.type === "column" ? [
            ...this.stickyColumnIndices
          ] : [];
          this.persistedIndices.set(layoutInfo.parentKey, indices);
        }
        let index2 = this.layoutNodes.get(layoutInfo.key).index;
        if (!indices.includes(index2))
          indices.push(index2);
        layoutInfo = this.layoutInfos.get(layoutInfo.parentKey);
      }
    }
    for (let indices of this.persistedIndices.values())
      indices.sort((a3, b2) => a3 - b2);
  }
  getInitialLayoutInfo(layoutInfo) {
    let res = super.getInitialLayoutInfo(layoutInfo);
    res.transform = null;
    return res;
  }
  getFinalLayoutInfo(layoutInfo) {
    let res = super.getFinalLayoutInfo(layoutInfo);
    res.transform = null;
    return res;
  }
  // Checks if Chrome version is 105 or greater
  checkChrome105() {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null)
      return false;
    let isChrome105;
    if (window.navigator["userAgentData"])
      isChrome105 = (_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((b2) => b2.brand === "Chromium" && Number(b2.version) === 105);
    else {
      let regex = /Chrome\/(\d+)/;
      let matches = regex.exec(window.navigator.userAgent);
      isChrome105 = matches && matches.length >= 2 && Number(matches[1]) === 105;
    }
    return isChrome105;
  }
  getDropTargetFromPoint(x3, y4, isValidDropTarget) {
    var _this_virtualizer_layout_getVisibleLayoutInfos_find;
    x3 += this.virtualizer.visibleRect.x;
    y4 += this.virtualizer.visibleRect.y;
    y4 -= (_this_virtualizer_layout_getVisibleLayoutInfos_find = this.virtualizer.layout.getVisibleLayoutInfos(new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x3, y4, 1, 1)).find((info) => info.type === "headerrow")) === null || _this_virtualizer_layout_getVisibleLayoutInfos_find === void 0 ? void 0 : _this_virtualizer_layout_getVisibleLayoutInfos_find.rect.height;
    let key;
    let point = new (0, $3041db3296945e6e$export$baf26146a414f24a)(x3, y4);
    let rectAtPoint = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);
    let layoutInfos = this.virtualizer.layout.getVisibleLayoutInfos(rectAtPoint).filter((info) => info.type === "row");
    for (let layoutInfo2 of layoutInfos)
      if (layoutInfo2.rect.intersects(rectAtPoint))
        key = layoutInfo2.key;
    if (key == null || this.collection.size === 0)
      return {
        type: "root"
      };
    let layoutInfo = this.getLayoutInfo(key);
    let rect = layoutInfo.rect;
    let target = {
      type: "item",
      key: layoutInfo.key,
      dropPosition: "on"
    };
    if (!isValidDropTarget(target)) {
      if (y4 <= rect.y + rect.height / 2 && isValidDropTarget({
        ...target,
        dropPosition: "before"
      }))
        target.dropPosition = "before";
      else if (isValidDropTarget({
        ...target,
        dropPosition: "after"
      }))
        target.dropPosition = "after";
    } else if (y4 <= rect.y + 10 && isValidDropTarget({
      ...target,
      dropPosition: "before"
    }))
      target.dropPosition = "before";
    else if (y4 >= rect.maxY - 10 && isValidDropTarget({
      ...target,
      dropPosition: "after"
    }))
      target.dropPosition = "after";
    return target;
  }
  constructor(options) {
    super(options);
    this.columnWidths = /* @__PURE__ */ new Map();
    this.wasLoading = false;
    this.isLoading = false;
    this.lastPersistedKeys = null;
    this.persistedIndices = /* @__PURE__ */ new Map();
    this.collection = options.initialCollection;
    this.stickyColumnIndices = [];
    this.disableSticky = this.checkChrome105();
    this.columnLayout = options.columnLayout;
    let [controlledColumns, uncontrolledColumns] = this.columnLayout.splitColumnsIntoControlledAndUncontrolled(this.collection.columns);
    this.controlledColumns = controlledColumns;
    this.uncontrolledColumns = uncontrolledColumns;
    this.uncontrolledWidths = this.columnLayout.getInitialUncontrolledWidths(uncontrolledColumns);
  }
};

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/list-view/dist/keystar-ui-list-view.esm.js
var import_react52 = __toESM(require_react());
var import_jsx_runtime27 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/chevronLeftIcon/dist/keystar-ui-icon-icons-chevronLeftIcon.esm.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var chevronLeftIcon = (0, import_jsx_runtime24.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime24.jsx)("path", {
    d: "m15 18-6-6 6-6"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/chevronRightIcon/dist/keystar-ui-icon-icons-chevronRightIcon.esm.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var chevronRightIcon = (0, import_jsx_runtime25.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime25.jsx)("path", {
    d: "m9 18 6-6-6-6"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/gripVerticalIcon/dist/keystar-ui-icon-icons-gripVerticalIcon.esm.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var gripVerticalIcon = (0, import_jsx_runtime26.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime26.jsx)("circle", {
    cx: 9,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime26.jsx)("circle", {
    cx: 9,
    cy: 5,
    r: 1
  }), (0, import_jsx_runtime26.jsx)("circle", {
    cx: 9,
    cy: 19,
    r: 1
  }), (0, import_jsx_runtime26.jsx)("circle", {
    cx: 15,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime26.jsx)("circle", {
    cx: 15,
    cy: 5,
    r: 1
  }), (0, import_jsx_runtime26.jsx)("circle", {
    cx: 15,
    cy: 19,
    r: 1
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/list-view/dist/keystar-ui-list-view.esm.js
var listViewClassList = new ClassList("ListView", ["centered-wrapper"]);
var listViewItemClassList = new ClassList("ListViewItem", ["actionmenu", "actions", "badge", "checkbox", "content", "description", "draghandle", "grid", "parent-indicator", "row", "thumbnail"]);
var ListViewContext = (
  // @ts-expect-error
  (0, import_react52.createContext)(null)
);
var ListViewProvider = ListViewContext.Provider;
function useListViewContext() {
  let context = (0, import_react52.useContext)(ListViewContext);
  if (!context) {
    throw new Error("Attempt to access `ListViewContext` outside of its provided.");
  }
  return context;
}
var localizedMessages5 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    loadingMore: "جارٍ تحميل المزيد..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    loadingMore: "Зареждане на още..."
  },
  "cs-CZ": {
    loading: "Načítání...",
    loadingMore: "Načítání dalších..."
  },
  "da-DK": {
    loading: "Indlæser...",
    loadingMore: "Indlæser flere..."
  },
  "de-DE": {
    loading: "Laden...",
    loadingMore: "Mehr laden ..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    loadingMore: "Φόρτωση περισσότερων..."
  },
  "en-US": {
    loading: "Loading…",
    loadingMore: "Loading more…"
  },
  "es-ES": {
    loading: "Cargando…",
    loadingMore: "Cargando más…"
  },
  "et-EE": {
    loading: "Laadimine...",
    loadingMore: "Laadi rohkem..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    loadingMore: "Ladataan lisää…"
  },
  "fr-FR": {
    loading: "Chargement...",
    loadingMore: "Chargement supplémentaire..."
  },
  "he-IL": {
    loading: "טוען...",
    loadingMore: "טוען עוד..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    loadingMore: "Továbbiak betöltése folyamatban…"
  },
  "it-IT": {
    loading: "Caricamento...",
    loadingMore: "Caricamento altri..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    loadingMore: "さらに読み込み中..."
  },
  "ko-KR": {
    loading: "로드 중…",
    loadingMore: "추가 로드 중…"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    loadingMore: "Įkeliama daugiau..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    loadingMore: "Tiek ielādēts vēl..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    loadingMore: "Laster inn flere ..."
  },
  "nl-NL": {
    loading: "Laden...",
    loadingMore: "Meer laden..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    loadingMore: "Wczytywanie większej liczby..."
  },
  "pt-BR": {
    loading: "Carregando...",
    loadingMore: "Carregando mais..."
  },
  "pt-PT": {
    loading: "A carregar...",
    loadingMore: "A carregar mais..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    loadingMore: "Se încarcă mai multe..."
  },
  "ru-RU": {
    loading: "Загрузка...",
    loadingMore: "Дополнительная загрузка..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    loadingMore: "Načítava sa viac..."
  },
  "sl-SI": {
    loading: "Nalaganje ...",
    loadingMore: "Nalaganje več vsebine ..."
  },
  "sr-SP": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "sv-SE": {
    loading: "Läser in...",
    loadingMore: "Läser in mer..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    loadingMore: "Daha fazla yükleniyor..."
  },
  "uk-UA": {
    loading: "Завантаження…",
    loadingMore: "Завантаження інших об’єктів..."
  },
  "zh-CN": {
    loading: "正在加载...",
    loadingMore: "正在加载更多..."
  },
  "zh-T": {
    loading: "載入中…",
    loadingMore: "正在載入更多…"
  }
};
function DragPreview(props) {
  let {
    item: item2,
    itemCount,
    itemHeight,
    density
  } = props;
  let isDraggingMultiple = itemCount > 1;
  return (0, import_jsx_runtime27.jsx)("div", {
    ...toDataAttributes({
      density,
      multi: isDraggingMultiple
    }),
    style: {
      height: itemHeight
    },
    className: classNames(css({
      display: "grid",
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderSelected}`,
      borderRadius: tokenSchema.size.radius.small,
      paddingInline: tokenSchema.size.space.medium,
      position: "relative",
      outline: 0,
      width: tokenSchema.size.alias.singleLineWidth,
      // Density
      minHeight: tokenSchema.size.element.medium,
      paddingBlock: tokenSchema.size.space.medium,
      '&[data-density="compact"]': {
        minHeight: tokenSchema.size.element.regular,
        paddingBlock: tokenSchema.size.space.regular
      },
      '&[data-density="spacious"]': {
        minHeight: tokenSchema.size.element.large,
        paddingBlock: tokenSchema.size.space.large
      },
      // indicate that multiple items are being dragged by implying a stack
      "&[data-multi=true]::after": {
        backgroundColor: "inherit",
        border: "inherit",
        borderRadius: "inherit",
        content: '" "',
        display: "block",
        height: "100%",
        insetInlineStart: 4,
        position: "absolute",
        top: 4,
        width: "100%",
        zIndex: -1
      }
    })),
    children: (0, import_jsx_runtime27.jsx)(Grid, {
      UNSAFE_className: listViewItemClassList.element("grid"),
      columns: "auto auto 1fr auto",
      rows: "1fr auto",
      areas: ["thumbnail content     . badge", "thumbnail description . badge"],
      alignItems: "center",
      children: (0, import_jsx_runtime27.jsxs)(SlotProvider, {
        slots: {
          text: {
            gridArea: "content",
            flexGrow: 1,
            truncate: true,
            weight: "medium",
            UNSAFE_className: listViewItemClassList.element("content")
          },
          description: {
            color: "neutralSecondary",
            size: "small",
            gridArea: "description",
            flexGrow: 1,
            marginTop: "small",
            truncate: true,
            UNSAFE_className: listViewItemClassList.element("description")
          },
          image: {
            borderRadius: "xsmall",
            gridArea: "thumbnail",
            marginEnd: "regular",
            overflow: "hidden",
            height: density === "compact" ? "element.small" : "element.regular",
            UNSAFE_className: listViewItemClassList.element("thumbnail")
          },
          button: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actions")
          },
          actionGroup: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actions")
          },
          actionMenu: {
            isHidden: true,
            UNSAFE_className: listViewItemClassList.element("actionmenu")
          }
        },
        children: [isReactText(item2.rendered) ? (0, import_jsx_runtime27.jsx)(Text, {
          children: item2.rendered
        }) : item2.rendered, isDraggingMultiple && (0, import_jsx_runtime27.jsx)(Flex, {
          alignItems: "center",
          backgroundColor: "accentEmphasis",
          borderRadius: "small",
          gridArea: "badge",
          minWidth: "element.small",
          padding: "small",
          UNSAFE_className: listViewItemClassList.element("badge"),
          children: (0, import_jsx_runtime27.jsx)(Text, {
            align: "center",
            color: "inverse",
            size: "small",
            weight: "medium",
            children: itemCount
          })
        })]
      })
    })
  });
}
function InsertionIndicator(props) {
  let {
    dropState,
    dragAndDropHooks
  } = useListViewContext();
  const {
    target,
    isPresentationOnly
  } = props;
  assert(!!dragAndDropHooks.useDropIndicator, "dragAndDropHooks.useDropIndicator is not defined.");
  let ref = (0, import_react52.useRef)(null);
  let {
    dropIndicatorProps
  } = dragAndDropHooks.useDropIndicator(props, dropState, ref);
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  let isDropTarget = dropState.isDropTarget(target);
  if (!isDropTarget && dropIndicatorProps["aria-hidden"]) {
    return null;
  }
  let maskColor = tokenSchema.color.background.canvas;
  let borderColor = tokenSchema.color.background.accentEmphasis;
  let borderSize = tokenSchema.size.border.medium;
  let circleSize = tokenSchema.size.space.regular;
  return (0, import_jsx_runtime27.jsx)("div", {
    role: "row",
    "aria-hidden": dropIndicatorProps["aria-hidden"],
    children: (0, import_jsx_runtime27.jsx)("div", {
      role: "gridcell",
      "aria-selected": "false",
      ...toDataAttributes({
        dropTarget: isDropTarget
      }),
      className: classNames(css({
        insetInlineStart: circleSize,
        outline: "none",
        position: "absolute",
        width: `calc(100% - (2 * ${circleSize}))`,
        "&[data-drop-target=true]": {
          borderBottom: `${borderSize} solid ${borderColor}`,
          "&::before": {
            left: `calc(${circleSize} * -1)`
          },
          "&::after": {
            right: `calc(${circleSize} * -1)`
          },
          "&::before, &::after": {
            backgroundColor: maskColor,
            border: `${borderSize} solid ${borderColor}`,
            borderRadius: "50%",
            content: '" "',
            height: circleSize,
            position: "absolute",
            top: `calc(${circleSize} / -2 - ${borderSize} / 2)`,
            width: circleSize,
            zIndex: 5
          }
        }
      })),
      children: !isPresentationOnly && (0, import_jsx_runtime27.jsx)("div", {
        ...visuallyHiddenProps,
        role: "button",
        ...dropIndicatorProps,
        ref
      })
    })
  });
}
function ListViewItem(props) {
  var _draggableItem, _draggableItem2, _dropIndicator, _dropIndicator2;
  let {
    item: item2
  } = props;
  let {
    density,
    dragAndDropHooks,
    dragState,
    dropState,
    isListDraggable,
    isListDroppable,
    layout,
    loadingState,
    overflowMode,
    state
  } = useListViewContext();
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let rowRef = (0, import_react52.useRef)(null);
  let {
    isFocusVisible: isFocusVisibleWithin,
    focusProps: focusWithinProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    within: true
  });
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let {
    rowProps,
    gridCellProps,
    isPressed,
    descriptionProps,
    isDisabled,
    allowsSelection,
    hasAction
  } = $4e8b0456ef72939f$export$9610e69494fadfd2({
    node: item2,
    isVirtualized: true,
    shouldSelectOnPressUp: isListDraggable
  }, state, rowRef);
  let isDroppable = isListDroppable && !isDisabled;
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled: !allowsSelection && !hasAction
  });
  let {
    checkboxProps
  } = $e52ffc04a4adbd52$export$e29f2573fabbf7b9({
    key: item2.key
  }, state);
  let draggableItem;
  if (isListDraggable) {
    assert(!!(dragAndDropHooks && dragAndDropHooks.useDraggableItem), "useDraggableItem is missing from dragAndDropHooks");
    draggableItem = dragAndDropHooks.useDraggableItem({
      key: item2.key,
      hasDragButton: true
    }, dragState);
    if (isDisabled) {
      draggableItem = null;
    }
  }
  let isDropTarget;
  let dropIndicator;
  let dropIndicatorRef = (0, import_react52.useRef)(null);
  if (isListDroppable) {
    let target = {
      type: "item",
      key: item2.key,
      dropPosition: "on"
    };
    isDropTarget = dropState.isDropTarget(target);
    assert(!!(dragAndDropHooks && dragAndDropHooks.useDropIndicator), "useDropIndicator is missing from dragAndDropHooks");
    dropIndicator = dragAndDropHooks.useDropIndicator({
      target
    }, dropState, dropIndicatorRef);
  }
  let dragButtonRef = (0, import_react52.useRef)(null);
  let {
    buttonProps
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    // @ts-expect-error
    ...(_draggableItem = draggableItem) === null || _draggableItem === void 0 ? void 0 : _draggableItem.dragButtonProps,
    elementType: "div"
  }, dragButtonRef);
  let chevron = (0, import_jsx_runtime27.jsx)(Icon, {
    ...toDataAttributes({
      disabled: !hasAction,
      visible: item2.props.hasChildItems
    }),
    color: "neutral",
    src: direction === "ltr" ? chevronRightIcon : chevronLeftIcon,
    "aria-hidden": "true",
    UNSAFE_className: classNames(listViewItemClassList.element("parent-indicator"), css({
      display: "none",
      gridArea: "chevron",
      marginInlineStart: tokenSchema.size.space.regular,
      [`${listViewItemClassList.selector("root")}[data-child-nodes=true] &`]: {
        display: "inline-block",
        visibility: "hidden"
      },
      "&[data-visible=true]": {
        visibility: "visible"
      },
      "&[data-disabled=true]": {
        stroke: tokenSchema.color.alias.foregroundDisabled
      }
    }))
  });
  let showCheckbox = state.selectionManager.selectionMode !== "none" && state.selectionManager.selectionBehavior === "toggle";
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  let dropProps = isDroppable ? (
    // @ts-expect-error
    void 0
  ) : (
    // @ts-expect-error
    {
      "aria-hidden": void 0
    }
  );
  const mergedProps = $3ef42575df84b30b$export$9d1611c77c2fe928(
    rowProps,
    // @ts-expect-error
    (_draggableItem2 = draggableItem) === null || _draggableItem2 === void 0 ? void 0 : _draggableItem2.dragProps,
    dropProps,
    hoverProps,
    focusWithinProps,
    focusProps,
    // Remove tab index from list row if performing a screenreader drag. This prevents TalkBack from focusing the row,
    // allowing for single swipe navigation between row drop indicator
    // @ts-expect-error
    (dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.isVirtualDragging()) && {
      tabIndex: null
    }
  );
  let isFirstRow = item2.prevKey == null;
  let isLastRow = item2.nextKey == null;
  let isFlushWithContainerBottom = false;
  if (isLastRow && loadingState !== "loadingMore") {
    var _layout$getContentSiz, _layout$virtualizer;
    if (((_layout$getContentSiz = layout.getContentSize()) === null || _layout$getContentSiz === void 0 ? void 0 : _layout$getContentSiz.height) >= ((_layout$virtualizer = layout.virtualizer) === null || _layout$virtualizer === void 0 ? void 0 : _layout$virtualizer.getVisibleRect().height)) {
      isFlushWithContainerBottom = true;
    }
  }
  let content = isReactText(item2.rendered) ? (0, import_jsx_runtime27.jsx)(Text, {
    children: item2.rendered
  }) : item2.rendered;
  if (isDisabled) {
    content = (0, import_jsx_runtime27.jsx)(KeystarProvider, {
      isDisabled: true,
      children: content
    });
  }
  return (0, import_jsx_runtime27.jsx)("div", {
    ...mergedProps,
    ...toDataAttributes({
      "flush-last": isFlushWithContainerBottom
    }),
    className: classNames(listViewItemClassList.element("row"), css({
      cursor: "default",
      outline: 0,
      position: "relative",
      /* box shadow for bottom border */
      "&:not([data-flush-last=true])::after": {
        boxShadow: `inset 0 -1px 0 0 ${tokenSchema.color.border.neutral}`,
        content: '" "',
        display: "block",
        insetBlockEnd: 0,
        insetBlockStart: 0,
        insetInlineEnd: 0,
        insetInlineStart: 0,
        pointerEvents: "none",
        position: "absolute",
        zIndex: 3
      }
    })),
    ref: rowRef,
    children: (0, import_jsx_runtime27.jsx)("div", {
      ...toDataAttributes({
        first: isFirstRow || void 0,
        last: isLastRow || void 0,
        // @ts-expect-error
        droppable: isDropTarget || void 0,
        draggable: isListDraggable || void 0,
        focus: isFocusVisible ? "visible" : isFocusVisibleWithin ? "within" : void 0,
        interaction: isPressed ? "press" : isHovered ? "hover" : void 0
      }),
      className: classNames(listViewItemClassList.element("root"), css({
        display: "grid",
        paddingInline: tokenSchema.size.space.medium,
        position: "relative",
        outline: 0,
        // density
        minHeight: tokenSchema.size.element.medium,
        paddingBlock: tokenSchema.size.space.medium,
        [`${listViewClassList.selector("root")}[data-density="compact"] &`]: {
          minHeight: tokenSchema.size.element.regular,
          paddingBlock: tokenSchema.size.space.regular
        },
        [`${listViewClassList.selector("root")}[data-density="spacious"] &`]: {
          minHeight: tokenSchema.size.element.large,
          paddingBlock: tokenSchema.size.space.large
        },
        // variants
        "&[data-draggable=true]": {
          paddingInlineStart: tokenSchema.size.space.small
        },
        // interactions
        '&[data-interaction="hover"]': {
          backgroundColor: tokenSchema.color.alias.backgroundHovered
        },
        '&[data-interaction="press"]': {
          backgroundColor: tokenSchema.color.alias.backgroundPressed
        },
        // focus indicator
        '&[data-focus="visible"]': {
          "&::before": {
            backgroundColor: tokenSchema.color.background.accentEmphasis,
            borderRadius: tokenSchema.size.space.small,
            content: '""',
            insetBlock: 0,
            insetInlineStart: tokenSchema.size.space.xsmall,
            marginBlock: tokenSchema.size.space.xsmall,
            marginInlineEnd: `calc(${tokenSchema.size.space.small} * -1)`,
            position: "absolute",
            width: tokenSchema.size.space.small
          }
        },
        // selected
        [`${listViewItemClassList.selector("row")}[aria-selected="true"] &`]: {
          backgroundColor: tokenSchema.color.alias.backgroundSelected,
          // boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.alias.focusRing}`,
          '&[data-interaction="hover"], &[data-focus="visible"]': {
            backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
          }
        }
      })),
      ...gridCellProps,
      children: (0, import_jsx_runtime27.jsxs)(Grid, {
        UNSAFE_className: listViewItemClassList.element("grid"),
        columns: "auto auto auto 1fr minmax(0px, auto) auto auto",
        rows: "1fr auto",
        areas: ["draghandle checkbox thumbnail content actions actionmenu chevron", "draghandle checkbox thumbnail description actions actionmenu chevron"],
        alignItems: "center",
        children: [isListDraggable && (0, import_jsx_runtime27.jsx)("div", {
          className: classNames(css({
            gridArea: "draghandle",
            display: "flex",
            justifyContent: "center",
            width: tokenSchema.size.element.small
          })),
          children: !isDisabled && (0, import_jsx_runtime27.jsx)(FocusRing, {
            children: (0, import_jsx_runtime27.jsx)("div", {
              ...buttonProps,
              className: classNames(listViewItemClassList.element("draghandle"), css({
                outline: 0,
                position: "relative",
                // focus ring
                "::after": {
                  borderRadius: tokenSchema.size.radius.small,
                  content: '""',
                  inset: 0,
                  margin: 0,
                  position: "absolute",
                  transition: transition(["box-shadow", "margin"], {
                    easing: "easeOut"
                  })
                },
                "&[data-focus=visible]::after": {
                  boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
                  margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
                }
              })),
              ref: dragButtonRef,
              draggable: "true",
              children: (0, import_jsx_runtime27.jsx)(Icon, {
                src: gripVerticalIcon,
                color: "neutral"
              })
            })
          })
        }), isListDroppable && !((_dropIndicator = dropIndicator) !== null && _dropIndicator !== void 0 && _dropIndicator.isHidden) && (0, import_jsx_runtime27.jsx)("div", {
          role: "button",
          ...visuallyHiddenProps,
          ...(_dropIndicator2 = dropIndicator) === null || _dropIndicator2 === void 0 ? void 0 : _dropIndicator2.dropIndicatorProps,
          ref: dropIndicatorRef
        }), showCheckbox && (0, import_jsx_runtime27.jsx)(Flex, {
          gridArea: "checkbox",
          alignItems: "center",
          justifyContent: "center",
          children: (0, import_jsx_runtime27.jsx)(Checkbox, {
            ...checkboxProps,
            UNSAFE_className: classNames(listViewItemClassList.element("checkbox"), css({
              paddingInlineEnd: tokenSchema.size.space.regular
            }))
          })
        }), (0, import_jsx_runtime27.jsxs)(SlotProvider, {
          slots: {
            text: {
              color: isDisabled ? "color.alias.foregroundDisabled" : void 0,
              gridArea: "content",
              flexGrow: 1,
              truncate: overflowMode === "truncate",
              weight: "medium",
              UNSAFE_className: listViewItemClassList.element("content")
            },
            description: {
              color: isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary",
              size: "small",
              gridArea: "description",
              flexGrow: 1,
              marginTop: "regular",
              truncate: overflowMode === "truncate",
              UNSAFE_className: listViewItemClassList.element("description"),
              ...descriptionProps
            },
            image: {
              borderRadius: "xsmall",
              gridArea: "thumbnail",
              marginEnd: "regular",
              overflow: "hidden",
              height: density === "compact" ? "element.small" : "element.regular",
              UNSAFE_className: listViewItemClassList.element("thumbnail")
            },
            button: {
              UNSAFE_className: listViewItemClassList.element("actions"),
              prominence: "low",
              gridArea: "actions"
            },
            actionGroup: {
              UNSAFE_className: listViewItemClassList.element("actions"),
              prominence: "low",
              gridArea: "actions",
              density: "compact"
            },
            actionMenu: {
              UNSAFE_className: listViewItemClassList.element("actionmenu"),
              prominence: "low",
              gridArea: "actionmenu"
            }
          },
          children: [content, (0, import_jsx_runtime27.jsx)(ClearSlots, {
            children: chevron
          })]
        })]
      })
    })
  });
}
function RootDropIndicator() {
  let {
    dropState,
    dragAndDropHooks
  } = useListViewContext();
  let ref = (0, import_react52.useRef)(null);
  assert(!!dragAndDropHooks.useDropIndicator, "dragAndDropHooks.useDropIndicator is not defined.");
  let {
    dropIndicatorProps
  } = dragAndDropHooks.useDropIndicator({
    target: {
      type: "root"
    }
  }, dropState, ref);
  let isDropTarget = dropState.isDropTarget({
    type: "root"
  });
  let {
    visuallyHiddenProps
  } = $5c3e21d68f1c4674$export$a966af930f325cab();
  if (!isDropTarget && dropIndicatorProps["aria-hidden"]) {
    return null;
  }
  return (0, import_jsx_runtime27.jsx)("div", {
    role: "row",
    "aria-hidden": dropIndicatorProps["aria-hidden"],
    children: (0, import_jsx_runtime27.jsx)("div", {
      role: "gridcell",
      "aria-selected": "false",
      children: (0, import_jsx_runtime27.jsx)("div", {
        role: "button",
        ...visuallyHiddenProps,
        ...dropIndicatorProps,
        ref
      })
    })
  });
}
var ROW_HEIGHTS = {
  compact: {
    medium: 32,
    large: 40
  },
  regular: {
    medium: 40,
    large: 50
  },
  spacious: {
    medium: 48,
    large: 60
  }
};
function useListLayout(state, density, overflowMode) {
  let {
    scale
  } = useProvider();
  let collator = $325a3faab7a68acd$export$a16aca283550c30d({
    usage: "search",
    sensitivity: "base"
  });
  let isEmpty = state.collection.size === 0;
  let layout = (0, import_react52.useMemo)(
    () => new $61ef60fc9b1041f4$export$cacbb3924155d68e({
      estimatedRowHeight: ROW_HEIGHTS[density][scale],
      padding: 0,
      collator,
      loaderHeight: isEmpty ? void 0 : ROW_HEIGHTS[density][scale]
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [collator, scale, density, isEmpty, overflowMode]
  );
  layout.collection = state.collection;
  layout.disabledKeys = state.disabledKeys;
  return layout;
}
function ListView(props, ref) {
  var _dropState, _droppableCollection;
  let {
    density = "regular",
    loadingState,
    onLoadMore,
    isQuiet,
    overflowMode = "truncate",
    onAction,
    dragAndDropHooks,
    ...otherProps
  } = props;
  let isListDraggable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDraggableCollectionState);
  let isListDroppable = !!(dragAndDropHooks !== null && dragAndDropHooks !== void 0 && dragAndDropHooks.useDroppableCollectionState);
  let dragHooksProvided = (0, import_react52.useRef)(isListDraggable);
  let dropHooksProvided = (0, import_react52.useRef)(isListDroppable);
  (0, import_react52.useEffect)(() => {
    if (dragHooksProvided.current !== isListDraggable) {
      console.warn("Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
    }
    if (dropHooksProvided.current !== isListDroppable) {
      console.warn("Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.");
    }
  }, [isListDraggable, isListDroppable]);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let state = $e72dd72e1c76a225$export$2f645645f7bca764({
    ...props,
    selectionBehavior: props.selectionStyle === "highlight" ? "replace" : "toggle"
  });
  let {
    collection: collection2,
    selectionManager
  } = state;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages5);
  let isLoading = loadingState === "loading" || loadingState === "loadingMore";
  let styleProps = useStyleProps(props);
  let preview = (0, import_react52.useRef)(null);
  let dragState = (() => {
    if (dragAndDropHooks != null && dragAndDropHooks.useDraggableCollectionState && dragAndDropHooks.useDraggableCollection) {
      let state2 = dragAndDropHooks.useDraggableCollectionState({
        collection: collection2,
        selectionManager,
        preview
      });
      dragAndDropHooks.useDraggableCollection({}, state2, domRef);
      return state2;
    }
  })();
  let layout = useListLayout(state, props.density || "regular", overflowMode);
  layout.allowDisabledKeyFocus = state.selectionManager.disabledBehavior === "selection" || !!(dragState !== null && dragState !== void 0 && dragState.draggingKeys.size);
  let DragPreview$1 = dragAndDropHooks === null || dragAndDropHooks === void 0 ? void 0 : dragAndDropHooks.DragPreview;
  let dropState;
  let droppableCollection;
  let isRootDropTarget;
  if (dragAndDropHooks && dragAndDropHooks.useDroppableCollectionState && dragAndDropHooks.useDroppableCollection) {
    dropState = dragAndDropHooks.useDroppableCollectionState({
      collection: collection2,
      selectionManager
    });
    droppableCollection = dragAndDropHooks.useDroppableCollection({
      keyboardDelegate: layout,
      dropTargetDelegate: layout
    }, dropState, domRef);
    isRootDropTarget = dropState.isDropTarget({
      type: "root"
    });
  }
  let {
    gridProps
  } = $f47efb0c3a859cf2$export$664f9155035607eb({
    ...props,
    isVirtualized: true,
    keyboardDelegate: layout,
    onAction
  }, state, domRef);
  layout.isLoading = isLoading;
  let focusedKey = selectionManager.focusedKey;
  if (((_dropState = dropState) === null || _dropState === void 0 || (_dropState = _dropState.target) === null || _dropState === void 0 ? void 0 : _dropState.type) === "item") {
    focusedKey = dropState.target.key;
  }
  let hasAnyChildren = (0, import_react52.useMemo)(() => [...collection2].some((item2) => item2.hasChildNodes), [collection2]);
  return (0, import_jsx_runtime27.jsxs)(ListViewProvider, {
    value: {
      density,
      // @ts-expect-error
      dragAndDropHooks,
      // @ts-expect-error
      dragState,
      // @ts-expect-error
      dropState,
      isListDraggable,
      isListDroppable,
      // @ts-expect-error
      layout,
      // @ts-expect-error
      loadingState,
      // @ts-expect-error
      onAction,
      overflowMode,
      state
    },
    children: [(0, import_jsx_runtime27.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
      children: (0, import_jsx_runtime27.jsx)(FocusRing, {
        children: (0, import_jsx_runtime27.jsx)($6d0a5c394373ae64$export$89be5a243e59c4b2, {
          ...$3ef42575df84b30b$export$9d1611c77c2fe928(
            // @ts-expect-error
            isListDroppable ? (_droppableCollection = droppableCollection) === null || _droppableCollection === void 0 ? void 0 : _droppableCollection.collectionProps : {},
            gridProps
          ),
          ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
          ...gridProps,
          ...styleProps,
          ...toDataAttributes({
            childNodes: hasAnyChildren,
            density,
            draggable: isListDraggable,
            // @ts-expect-error
            dropTarget: isRootDropTarget,
            overflowMode
          }),
          isLoading,
          onLoadMore,
          ref: domRef,
          focusedKey,
          scrollDirection: "vertical",
          className: classNames(listViewClassList.element("root"), css({
            backgroundColor: tokenSchema.color.background.canvas,
            border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
            borderRadius: tokenSchema.size.radius.medium,
            boxSizing: "content-box",
            // resolves measurement/scroll issues related to border
            outline: 0,
            overflow: "auto",
            position: "relative",
            transform: "translate3d(0, 0, 0)",
            userSelect: "none",
            "&[data-drop-target=true]": {
              borderColor: tokenSchema.color.alias.focusRing,
              backgroundColor: tokenSchema.color.alias.backgroundSelected,
              boxShadow: `inset 0 0 0 1px ${tokenSchema.color.alias.focusRing}`
            },
            "&[data-focus=visible]": {
              borderColor: tokenSchema.color.alias.focusRing,
              boxShadow: `inset 0 0 0 1px ${tokenSchema.color.alias.focusRing}`
            }
          }), styleProps.className),
          layout,
          collection: collection2,
          transitionDuration: isLoading ? 160 : 220,
          children: (type2, item2) => {
            if (type2 === "item") {
              return (0, import_jsx_runtime27.jsxs)(import_jsx_runtime27.Fragment, {
                children: [isListDroppable && collection2.getKeyBefore(item2.key) == null && (0, import_jsx_runtime27.jsx)(RootDropIndicator, {}, "root"), isListDroppable && (0, import_jsx_runtime27.jsx)(InsertionIndicator, {
                  target: {
                    key: item2.key,
                    type: "item",
                    dropPosition: "before"
                  }
                }, `${item2.key}-before`), (0, import_jsx_runtime27.jsx)(ListViewItem, {
                  item: item2,
                  isEmphasized: true,
                  hasActions: !!onAction
                }), isListDroppable && (0, import_jsx_runtime27.jsx)(InsertionIndicator, {
                  target: {
                    key: item2.key,
                    type: "item",
                    dropPosition: "after"
                  },
                  isPresentationOnly: collection2.getKeyAfter(item2.key) != null
                }, `${item2.key}-after`)]
              });
            } else if (type2 === "loader") {
              return (0, import_jsx_runtime27.jsx)(CenteredWrapper, {
                children: (0, import_jsx_runtime27.jsx)(ProgressCircle, {
                  isIndeterminate: true,
                  size: density === "compact" ? "small" : void 0,
                  "aria-label": collection2.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
                })
              });
            } else if (type2 === "placeholder") {
              let emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
              if (emptyState == null) {
                return null;
              }
              return (0, import_jsx_runtime27.jsx)(CenteredWrapper, {
                children: emptyState
              });
            }
          }
        })
      })
    }), DragPreview$1 && isListDraggable && (0, import_jsx_runtime27.jsx)(DragPreview$1, {
      ref: preview,
      children: () => {
        let item2 = state.collection.getItem(dragState.draggedKey);
        assert(item2 != null, "Dragged item must exist in collection.");
        let itemCount = dragState.draggingKeys.size;
        let itemHeight = layout.getLayoutInfo(dragState.draggedKey).rect.height;
        return (0, import_jsx_runtime27.jsx)(DragPreview, {
          item: item2,
          itemCount,
          itemHeight,
          density
        });
      }
    })]
  });
}
function CenteredWrapper({
  children
}) {
  let {
    state
  } = useListViewContext();
  return (0, import_jsx_runtime27.jsx)("div", {
    role: "row",
    "aria-rowindex": state.collection.size + 1,
    "data-has-items": state.collection.size > 0,
    className: classNames(listViewClassList.element("centered-wrapper"), css({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "100%",
      width: "100%",
      // if there's items it must be loading—add a gutter between the items
      // and the loading indicator
      "&[data-has-items=true]": {
        paddingTop: tokenSchema.size.space.regular
      }
    })),
    children: (0, import_jsx_runtime27.jsx)("div", {
      role: "gridcell",
      children
    })
  });
}
var _ListView = import_react52.default.forwardRef(ListView);

// node_modules/.pnpm/slate-react@0.91.11_react-dom@18.2.0_react@18.2.0_slate@0.91.4/node_modules/slate-react/dist/index.es.js
var import_direction = __toESM(require_direction());
var import_debounce = __toESM(require_debounce());
var import_throttle = __toESM(require_throttle());
var import_react53 = __toESM(require_react());

// node_modules/.pnpm/compute-scroll-into-view@1.0.20/node_modules/compute-scroll-into-view/dist/index.mjs
function t2(t5) {
  return "object" == typeof t5 && null != t5 && 1 === t5.nodeType;
}
function e(t5, e6) {
  return (!e6 || "hidden" !== t5) && "visible" !== t5 && "clip" !== t5;
}
function n2(t5, n6) {
  if (t5.clientHeight < t5.scrollHeight || t5.clientWidth < t5.scrollWidth) {
    var r7 = getComputedStyle(t5, null);
    return e(r7.overflowY, n6) || e(r7.overflowX, n6) || function(t6) {
      var e6 = function(t7) {
        if (!t7.ownerDocument || !t7.ownerDocument.defaultView)
          return null;
        try {
          return t7.ownerDocument.defaultView.frameElement;
        } catch (t8) {
          return null;
        }
      }(t6);
      return !!e6 && (e6.clientHeight < t6.scrollHeight || e6.clientWidth < t6.scrollWidth);
    }(t5);
  }
  return false;
}
function r3(t5, e6, n6, r7, i6, o5, l6, d5) {
  return o5 < t5 && l6 > e6 || o5 > t5 && l6 < e6 ? 0 : o5 <= t5 && d5 <= n6 || l6 >= e6 && d5 >= n6 ? o5 - t5 - r7 : l6 > e6 && d5 < n6 || o5 < t5 && d5 > n6 ? l6 - e6 + i6 : 0;
}
var i2 = function(e6, i6) {
  var o5 = window, l6 = i6.scrollMode, d5 = i6.block, f5 = i6.inline, h3 = i6.boundary, u4 = i6.skipOverflowHiddenElements, s4 = "function" == typeof h3 ? h3 : function(t5) {
    return t5 !== h3;
  };
  if (!t2(e6))
    throw new TypeError("Invalid target");
  for (var a3, c5, g3 = document.scrollingElement || document.documentElement, p5 = [], m2 = e6; t2(m2) && s4(m2); ) {
    if ((m2 = null == (c5 = (a3 = m2).parentElement) ? a3.getRootNode().host || null : c5) === g3) {
      p5.push(m2);
      break;
    }
    null != m2 && m2 === document.body && n2(m2) && !n2(document.documentElement) || null != m2 && n2(m2, u4) && p5.push(m2);
  }
  for (var w2 = o5.visualViewport ? o5.visualViewport.width : innerWidth, v5 = o5.visualViewport ? o5.visualViewport.height : innerHeight, W2 = window.scrollX || pageXOffset, H2 = window.scrollY || pageYOffset, b2 = e6.getBoundingClientRect(), y4 = b2.height, E2 = b2.width, M2 = b2.top, V = b2.right, x3 = b2.bottom, I3 = b2.left, C2 = "start" === d5 || "nearest" === d5 ? M2 : "end" === d5 ? x3 : M2 + y4 / 2, R2 = "center" === f5 ? I3 + E2 / 2 : "end" === f5 ? V : I3, T = [], k2 = 0; k2 < p5.length; k2++) {
    var B2 = p5[k2], D2 = B2.getBoundingClientRect(), O2 = D2.height, X2 = D2.width, Y2 = D2.top, L2 = D2.right, S2 = D2.bottom, j3 = D2.left;
    if ("if-needed" === l6 && M2 >= 0 && I3 >= 0 && x3 <= v5 && V <= w2 && M2 >= Y2 && x3 <= S2 && I3 >= j3 && V <= L2)
      return T;
    var N2 = getComputedStyle(B2), q2 = parseInt(N2.borderLeftWidth, 10), z3 = parseInt(N2.borderTopWidth, 10), A2 = parseInt(N2.borderRightWidth, 10), F = parseInt(N2.borderBottomWidth, 10), G2 = 0, J = 0, K = "offsetWidth" in B2 ? B2.offsetWidth - B2.clientWidth - q2 - A2 : 0, P2 = "offsetHeight" in B2 ? B2.offsetHeight - B2.clientHeight - z3 - F : 0, Q2 = "offsetWidth" in B2 ? 0 === B2.offsetWidth ? 0 : X2 / B2.offsetWidth : 0, U2 = "offsetHeight" in B2 ? 0 === B2.offsetHeight ? 0 : O2 / B2.offsetHeight : 0;
    if (g3 === B2)
      G2 = "start" === d5 ? C2 : "end" === d5 ? C2 - v5 : "nearest" === d5 ? r3(H2, H2 + v5, v5, z3, F, H2 + C2, H2 + C2 + y4, y4) : C2 - v5 / 2, J = "start" === f5 ? R2 : "center" === f5 ? R2 - w2 / 2 : "end" === f5 ? R2 - w2 : r3(W2, W2 + w2, w2, q2, A2, W2 + R2, W2 + R2 + E2, E2), G2 = Math.max(0, G2 + H2), J = Math.max(0, J + W2);
    else {
      G2 = "start" === d5 ? C2 - Y2 - z3 : "end" === d5 ? C2 - S2 + F + P2 : "nearest" === d5 ? r3(Y2, S2, O2, z3, F + P2, C2, C2 + y4, y4) : C2 - (Y2 + O2 / 2) + P2 / 2, J = "start" === f5 ? R2 - j3 - q2 : "center" === f5 ? R2 - (j3 + X2 / 2) + K / 2 : "end" === f5 ? R2 - L2 + A2 + K : r3(j3, L2, X2, q2, A2 + K, R2, R2 + E2, E2);
      var Z2 = B2.scrollLeft, $ = B2.scrollTop;
      C2 += $ - (G2 = Math.max(0, Math.min($ + G2 / U2, B2.scrollHeight - O2 / U2 + P2))), R2 += Z2 - (J = Math.max(0, Math.min(Z2 + J / Q2, B2.scrollWidth - X2 / Q2 + K)));
    }
    T.push({ el: B2, top: G2, left: J });
  }
  return T;
};

// node_modules/.pnpm/scroll-into-view-if-needed@2.2.31/node_modules/scroll-into-view-if-needed/es/index.js
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top,
        left,
        behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target, options) {
  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? i2(target, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(i2(target, computeOptions), computeOptions.behavior);
}
var es_default = scrollIntoView;

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function(obj) {
  return Object.freeze(obj);
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x3, y4, width, height) {
    this.x = x3;
    this.y = y4;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a2 = this, x3 = _a2.x, y4 = _a2.y, top = _a2.top, right = _a2.right, bottom = _a2.bottom, left = _a2.left, width = _a2.width, height = _a2.height;
    return { x: x3, y: y4, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a2 = target.getBBox(), width = _a2.width, height = _a2.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement2 = function(obj) {
  var _a2;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/global.js
var global2 = typeof window !== "undefined" ? window : {};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache2 = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size2 = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size2(),
  borderBoxSize: size2(),
  contentBoxSize: size2(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache2.has(target) && !forceRecalculation) {
    return cache2.get(target);
  }
  if (isHidden(target)) {
    cache2.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size2(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size2(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size2(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache2.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node3) {
  if (isHidden(node3)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node3.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/process.js
var process2 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config2 = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config2);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb);
  });
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout2) {
  if (timeout2 === void 0) {
    timeout2 = 0;
  }
  return Date.now() + timeout2;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout2) {
    var _this = this;
    if (timeout2 === void 0) {
      timeout2 = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout2);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process2();
      } finally {
        scheduled = false;
        timeout2 = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout2 > 0) {
          _this.run(timeout2);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global2.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name2) {
        return global2.addEventListener(name2, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name2) {
        return global2.removeEventListener(name2, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n6) {
  !watching && n6 > 0 && scheduler.start();
  watching += n6;
  !watching && scheduler.stop();
};

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size3 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size3;
    }
    if (this.lastReportedSize.inlineSize !== size3.inlineSize || this.lastReportedSize.blockSize !== size3.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i6 = 0; i6 < observationTargets.length; i6 += 1) {
    if (observationTargets[i6].target === target) {
      return i6;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index2 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index2 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index2, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();

// node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement2(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement2(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
}();

// node_modules/.pnpm/slate-react@0.91.11_react-dom@18.2.0_react@18.2.0_slate@0.91.4/node_modules/slate-react/dist/index.es.js
var import_is_hotkey = __toESM(require_lib3());
var import_react_dom6 = __toESM(require_react_dom());
function _defineProperty2(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i6;
  for (i6 = 0; i6 < sourceKeys.length; i6++) {
    key = sourceKeys[i6];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose3(source, excluded);
  var key, i6;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i6 = 0; i6 < sourceSymbolKeys.length; i6++) {
      key = sourceSymbolKeys[i6];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var n3 = 0;
var Key = class {
  constructor() {
    this.id = "".concat(n3++);
  }
};
var NODE_TO_INDEX = /* @__PURE__ */ new WeakMap();
var NODE_TO_PARENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_WINDOW = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PLACEHOLDER_ELEMENT = /* @__PURE__ */ new WeakMap();
var ELEMENT_TO_NODE = /* @__PURE__ */ new WeakMap();
var NODE_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var NODE_TO_KEY = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_KEY_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var IS_READ_ONLY = /* @__PURE__ */ new WeakMap();
var IS_FOCUSED = /* @__PURE__ */ new WeakMap();
var IS_COMPOSING = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ON_CHANGE = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_SCHEDULE_FLUSH = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_INSERTION_MARKS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_MARKS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_DIFFS = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_ACTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_PENDING_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_FORCE_RENDER = /* @__PURE__ */ new WeakMap();
var PLACEHOLDER_SYMBOL = Symbol("placeholder");
var MARK_PLACEHOLDER_SYMBOL = Symbol("mark-placeholder");
var DOMText = globalThis.Text;
var getDefaultView = (value2) => {
  return value2 && value2.ownerDocument && value2.ownerDocument.defaultView || null;
};
var isDOMComment = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 8;
};
var isDOMElement = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 1;
};
var isDOMNode = (value2) => {
  var window2 = getDefaultView(value2);
  return !!window2 && value2 instanceof window2.Node;
};
var isDOMSelection = (value2) => {
  var window2 = value2 && value2.anchorNode && getDefaultView(value2.anchorNode);
  return !!window2 && value2 instanceof window2.Selection;
};
var isDOMText = (value2) => {
  return isDOMNode(value2) && value2.nodeType === 3;
};
var isPlainTextOnlyPaste = (event) => {
  return event.clipboardData && event.clipboardData.getData("text/plain") !== "" && event.clipboardData.types.length === 1;
};
var normalizeDOMPoint = (domPoint) => {
  var [node3, offset] = domPoint;
  if (isDOMElement(node3) && node3.childNodes.length) {
    var isLast = offset === node3.childNodes.length;
    var index2 = isLast ? offset - 1 : offset;
    [node3, index2] = getEditableChildAndIndex(node3, index2, isLast ? "backward" : "forward");
    isLast = index2 < offset;
    while (isDOMElement(node3) && node3.childNodes.length) {
      var i6 = isLast ? node3.childNodes.length - 1 : 0;
      node3 = getEditableChild(node3, i6, isLast ? "backward" : "forward");
    }
    offset = isLast && node3.textContent != null ? node3.textContent.length : 0;
  }
  return [node3, offset];
};
var hasShadowRoot = (node3) => {
  var parent = node3 && node3.parentNode;
  while (parent) {
    if (parent.toString() === "[object ShadowRoot]") {
      return true;
    }
    parent = parent.parentNode;
  }
  return false;
};
var getEditableChildAndIndex = (parent, index2, direction) => {
  var {
    childNodes
  } = parent;
  var child = childNodes[index2];
  var i6 = index2;
  var triedForward = false;
  var triedBackward = false;
  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute("contenteditable") === "false") {
    if (triedForward && triedBackward) {
      break;
    }
    if (i6 >= childNodes.length) {
      triedForward = true;
      i6 = index2 - 1;
      direction = "backward";
      continue;
    }
    if (i6 < 0) {
      triedBackward = true;
      i6 = index2 + 1;
      direction = "forward";
      continue;
    }
    child = childNodes[i6];
    index2 = i6;
    i6 += direction === "forward" ? 1 : -1;
  }
  return [child, index2];
};
var getEditableChild = (parent, index2, direction) => {
  var [child] = getEditableChildAndIndex(parent, index2, direction);
  return child;
};
var getPlainText = (domNode) => {
  var text3 = "";
  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }
  if (isDOMElement(domNode)) {
    for (var childNode of Array.from(domNode.childNodes)) {
      text3 += getPlainText(childNode);
    }
    var display = getComputedStyle(domNode).getPropertyValue("display");
    if (display === "block" || display === "list" || domNode.tagName === "BR") {
      text3 += "\n";
    }
  }
  return text3;
};
var catchSlateFragment = /data-slate-fragment="(.+?)"/m;
var getSlateFragmentAttribute = (dataTransfer) => {
  var htmlData = dataTransfer.getData("text/html");
  var [, fragment] = htmlData.match(catchSlateFragment) || [];
  return fragment;
};
var isTrackedMutation = (editor, mutation, batch) => {
  var {
    target
  } = mutation;
  if (isDOMElement(target) && target.matches('[contentEditable="false"]')) {
    return false;
  }
  var {
    document: document3
  } = ReactEditor.getWindow(editor);
  if (document3.contains(target)) {
    return ReactEditor.hasDOMNode(editor, target, {
      editable: true
    });
  }
  var parentMutation = batch.find((_ref) => {
    var {
      addedNodes,
      removedNodes
    } = _ref;
    for (var node3 of addedNodes) {
      if (node3 === target || node3.contains(target)) {
        return true;
      }
    }
    for (var _node of removedNodes) {
      if (_node === target || _node.contains(target)) {
        return true;
      }
    }
  });
  if (!parentMutation || parentMutation === mutation) {
    return false;
  }
  return isTrackedMutation(editor, parentMutation, batch);
};
var IS_REACT_VERSION_17_OR_ABOVE = parseInt(import_react53.default.version.split(".")[0], 10) >= 17;
var IS_IOS = typeof navigator !== "undefined" && typeof window !== "undefined" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== "undefined" && /Mac OS X/.test(navigator.userAgent);
var IS_ANDROID = typeof navigator !== "undefined" && /Android/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_SAFARI = typeof navigator !== "undefined" && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
var IS_EDGE_LEGACY = typeof navigator !== "undefined" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent);
var IS_CHROME = typeof navigator !== "undefined" && /Chrome/i.test(navigator.userAgent);
var IS_CHROME_LEGACY = typeof navigator !== "undefined" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent);
var IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== "undefined" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent);
var IS_FIREFOX_LEGACY = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);
var IS_UC_MOBILE = typeof navigator !== "undefined" && /.*UCBrowser/.test(navigator.userAgent);
var IS_WECHATBROWSER = typeof navigator !== "undefined" && /.*Wechat/.test(navigator.userAgent);
var CAN_USE_DOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers
typeof globalThis !== "undefined" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges === "function";
var ReactEditor = {
  /**
   * Check if the user is currently composing inside the editor.
   */
  isComposing(editor) {
    return !!IS_COMPOSING.get(editor);
  },
  /**
   * Return the host window of the current editor.
   */
  getWindow(editor) {
    var window2 = EDITOR_TO_WINDOW.get(editor);
    if (!window2) {
      throw new Error("Unable to find a host window element for this editor");
    }
    return window2;
  },
  /**
   * Find a key for a Slate node.
   */
  findKey(editor, node3) {
    var key = NODE_TO_KEY.get(node3);
    if (!key) {
      key = new Key();
      NODE_TO_KEY.set(node3, key);
    }
    return key;
  },
  /**
   * Find the path of Slate node.
   */
  findPath(editor, node3) {
    var path2 = [];
    var child = node3;
    while (true) {
      var parent = NODE_TO_PARENT.get(child);
      if (parent == null) {
        if (Editor.isEditor(child)) {
          return path2;
        } else {
          break;
        }
      }
      var i6 = NODE_TO_INDEX.get(child);
      if (i6 == null) {
        break;
      }
      path2.unshift(i6);
      child = parent;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Scrubber.stringify(node3)));
  },
  /**
   * Find the DOM node that implements DocumentOrShadowRoot for the editor.
   */
  findDocumentOrShadowRoot(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = el.getRootNode();
    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {
      return root;
    }
    return el.ownerDocument;
  },
  /**
   * Check if the editor is focused.
   */
  isFocused(editor) {
    return !!IS_FOCUSED.get(editor);
  },
  /**
   * Check if the editor is in read-only mode.
   */
  isReadOnly(editor) {
    return !!IS_READ_ONLY.get(editor);
  },
  /**
   * Blur the editor.
   */
  blur(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, false);
    if (root.activeElement === el) {
      el.blur();
    }
  },
  /**
   * Focus the editor.
   */
  focus(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, true);
    if (root.activeElement !== el) {
      el.focus({
        preventScroll: true
      });
    }
  },
  /**
   * Deselect the editor.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root.getSelection();
    if (domSelection && domSelection.rangeCount > 0) {
      domSelection.removeAllRanges();
    }
    if (selection) {
      Transforms.deselect(editor);
    }
  },
  /**
   * Check if a DOM node is within the editor.
   */
  hasDOMNode(editor, target) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      editable = false
    } = options;
    var editorEl = ReactEditor.toDOMNode(editor, editor);
    var targetEl;
    try {
      targetEl = isDOMElement(target) ? target : target.parentElement;
    } catch (err) {
      if (!err.message.includes('Permission denied to access property "nodeType"')) {
        throw err;
      }
    }
    if (!targetEl) {
      return false;
    }
    return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    targetEl.closest('[contenteditable="false"]') === editorEl || !!targetEl.getAttribute("data-slate-zero-width"));
  },
  /**
   * Insert data from a `DataTransfer` into the editor.
   */
  insertData(editor, data) {
    editor.insertData(data);
  },
  /**
   * Insert fragment data from a `DataTransfer` into the editor.
   */
  insertFragmentData(editor, data) {
    return editor.insertFragmentData(data);
  },
  /**
   * Insert text data from a `DataTransfer` into the editor.
   */
  insertTextData(editor, data) {
    return editor.insertTextData(data);
  },
  /**
   * Sets data from the currently selected fragment on a `DataTransfer`.
   */
  setFragmentData(editor, data, originEvent) {
    editor.setFragmentData(data, originEvent);
  },
  /**
   * Find the native DOM element from a Slate node.
   */
  toDOMNode(editor, node3) {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    var domNode = Editor.isEditor(node3) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node3));
    if (!domNode) {
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Scrubber.stringify(node3)));
    }
    return domNode;
  },
  /**
   * Find a native DOM selection point from a Slate point.
   */
  toDOMPoint(editor, point) {
    var [node3] = Editor.node(editor, point.path);
    var el = ReactEditor.toDOMNode(editor, node3);
    var domPoint;
    if (Editor.void(editor, {
      at: point
    })) {
      point = {
        path: point.path,
        offset: 0
      };
    }
    var selector = "[data-slate-string], [data-slate-zero-width]";
    var texts = Array.from(el.querySelectorAll(selector));
    var start2 = 0;
    for (var i6 = 0; i6 < texts.length; i6++) {
      var text3 = texts[i6];
      var domNode = text3.childNodes[0];
      if (domNode == null || domNode.textContent == null) {
        continue;
      }
      var {
        length: length2
      } = domNode.textContent;
      var attr = text3.getAttribute("data-slate-length");
      var trueLength = attr == null ? length2 : parseInt(attr, 10);
      var end = start2 + trueLength;
      var nextText = texts[i6 + 1];
      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute("data-slate-mark-placeholder")) {
        var _nextText$textContent;
        var domText = nextText.childNodes[0];
        domPoint = [
          // COMPAT: If we don't explicity set the dom point to be on the actual
          // dom text element, chrome will put the selection behind the actual dom
          // text element, causing domRange.getBoundingClientRect() calls on a collapsed
          // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
          // which will cause issues when scrolling to it.
          domText instanceof DOMText ? domText : nextText,
          (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith("\uFEFF") ? 1 : 0
        ];
        break;
      }
      if (point.offset <= end) {
        var offset = Math.min(length2, Math.max(0, point.offset - start2));
        domPoint = [domNode, offset];
        break;
      }
      start2 = end;
    }
    if (!domPoint) {
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Scrubber.stringify(point)));
    }
    return domPoint;
  },
  /**
   * Find a native DOM range from a Slate `range`.
   *
   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.
   *
   * there is no way to create a reverse DOM Range using Range.setStart/setEnd
   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.
   */
  toDOMRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    var isBackward = Range.isBackward(range);
    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);
    var window2 = ReactEditor.getWindow(editor);
    var domRange = window2.document.createRange();
    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;
    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
    var isStartAtZeroWidth = !!startEl.getAttribute("data-slate-zero-width");
    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
    var isEndAtZeroWidth = !!endEl.getAttribute("data-slate-zero-width");
    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
    return domRange;
  },
  /**
   * Find a Slate node from a native DOM `element`.
   */
  toSlateNode(editor, domNode) {
    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;
    if (domEl && !domEl.hasAttribute("data-slate-node")) {
      domEl = domEl.closest("[data-slate-node]");
    }
    var node3 = domEl ? ELEMENT_TO_NODE.get(domEl) : null;
    if (!node3) {
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
    }
    return node3;
  },
  /**
   * Get the target range from a DOM `event`.
   */
  findEventRange(editor, event) {
    if ("nativeEvent" in event) {
      event = event.nativeEvent;
    }
    var {
      clientX: x3,
      clientY: y4,
      target
    } = event;
    if (x3 == null || y4 == null) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var node3 = ReactEditor.toSlateNode(editor, event.target);
    var path2 = ReactEditor.findPath(editor, node3);
    if (Element2.isElement(node3) && Editor.isVoid(editor, node3)) {
      var rect = target.getBoundingClientRect();
      var isPrev = editor.isInline(node3) ? x3 - rect.left < rect.left + rect.width - x3 : y4 - rect.top < rect.top + rect.height - y4;
      var edge = Editor.point(editor, path2, {
        edge: isPrev ? "start" : "end"
      });
      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);
      if (point) {
        var _range = Editor.range(editor, point);
        return _range;
      }
    }
    var domRange;
    var {
      document: document3
    } = ReactEditor.getWindow(editor);
    if (document3.caretRangeFromPoint) {
      domRange = document3.caretRangeFromPoint(x3, y4);
    } else {
      var position2 = document3.caretPositionFromPoint(x3, y4);
      if (position2) {
        domRange = document3.createRange();
        domRange.setStart(position2.offsetNode, position2.offset);
        domRange.setEnd(position2.offsetNode, position2.offset);
      }
    }
    if (!domRange) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var range = ReactEditor.toSlateRange(editor, domRange, {
      exactMatch: false,
      suppressThrow: false
    });
    return range;
  },
  /**
   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.
   */
  toSlatePoint(editor, domPoint, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);
    var parentNode = nearestNode.parentNode;
    var textNode = null;
    var offset = 0;
    if (parentNode) {
      var _domNode$textContent, _domNode$textContent2;
      var editorEl = ReactEditor.toDOMNode(editor, editor);
      var potentialVoidNode = parentNode.closest('[data-slate-void="true"]');
      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;
      var leafNode = parentNode.closest("[data-slate-leaf]");
      var domNode = null;
      if (leafNode) {
        textNode = leafNode.closest('[data-slate-node="text"]');
        if (textNode) {
          var window2 = ReactEditor.getWindow(editor);
          var range = window2.document.createRange();
          range.setStart(textNode, 0);
          range.setEnd(nearestNode, nearestOffset);
          var contents = range.cloneContents();
          var removals = [...Array.prototype.slice.call(contents.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(contents.querySelectorAll("[contenteditable=false]"))];
          removals.forEach((el) => {
            if (IS_ANDROID && !exactMatch && el.hasAttribute("data-slate-zero-width") && el.textContent.length > 0 && el.textContext !== "\uFEFF") {
              if (el.textContent.startsWith("\uFEFF")) {
                el.textContent = el.textContent.slice(1);
              }
              return;
            }
            el.parentNode.removeChild(el);
          });
          offset = contents.textContent.length;
          domNode = textNode;
        }
      } else if (voidNode) {
        var leafNodes = voidNode.querySelectorAll("[data-slate-leaf]");
        for (var index2 = 0; index2 < leafNodes.length; index2++) {
          var current = leafNodes[index2];
          if (ReactEditor.hasDOMNode(editor, current)) {
            leafNode = current;
            break;
          }
        }
        if (!leafNode) {
          offset = 1;
        } else {
          textNode = leafNode.closest('[data-slate-node="text"]');
          domNode = leafNode;
          offset = domNode.textContent.length;
          domNode.querySelectorAll("[data-slate-zero-width]").forEach((el) => {
            offset -= el.textContent.length;
          });
        }
      }
      if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      IS_ANDROID && domNode.getAttribute("data-slate-zero-width") === "z" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith("\uFEFF") && (parentNode.hasAttribute("data-slate-zero-width") || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith("\n\n"))) {
        offset--;
      }
    }
    if (IS_ANDROID && !textNode && !exactMatch) {
      var node3 = parentNode.hasAttribute("data-slate-node") ? parentNode : parentNode.closest("[data-slate-node]");
      if (node3 && ReactEditor.hasDOMNode(editor, node3, {
        editable: true
      })) {
        var _slateNode = ReactEditor.toSlateNode(editor, node3);
        var {
          path: _path,
          offset: _offset
        } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));
        if (!node3.querySelector("[data-slate-leaf]")) {
          _offset = nearestOffset;
        }
        return {
          path: _path,
          offset: _offset
        };
      }
    }
    if (!textNode) {
      if (suppressThrow) {
        return null;
      }
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
    }
    var slateNode = ReactEditor.toSlateNode(editor, textNode);
    var path2 = ReactEditor.findPath(editor, slateNode);
    return {
      path: path2,
      offset
    };
  },
  /**
   * Find a Slate range from a DOM range or selection.
   */
  toSlateRange(editor, domRange, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;
    var anchorNode;
    var anchorOffset;
    var focusNode;
    var focusOffset;
    var isCollapsed;
    if (el) {
      if (isDOMSelection(domRange)) {
        anchorNode = domRange.anchorNode;
        anchorOffset = domRange.anchorOffset;
        focusNode = domRange.focusNode;
        focusOffset = domRange.focusOffset;
        if (IS_CHROME && hasShadowRoot(anchorNode)) {
          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;
        } else {
          isCollapsed = domRange.isCollapsed;
        }
      } else {
        anchorNode = domRange.startContainer;
        anchorOffset = domRange.startOffset;
        focusNode = domRange.endContainer;
        focusOffset = domRange.endOffset;
        isCollapsed = domRange.collapsed;
      }
    }
    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
    }
    if ("getAttribute" in focusNode && focusNode.getAttribute("contenteditable") === "false") {
      var _anchorNode$textConte;
      focusNode = anchorNode;
      focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;
    }
    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {
      exactMatch,
      suppressThrow
    });
    if (!anchor) {
      return null;
    }
    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {
      exactMatch,
      suppressThrow
    });
    if (!focus) {
      return null;
    }
    if (IS_FIREFOX && !isCollapsed && anchorNode !== focusNode) {
      var isEnd = Editor.isEnd(editor, anchor, anchor.path);
      var isStart = Editor.isStart(editor, focus, focus.path);
      if (isEnd) {
        var after = Editor.after(editor, anchor);
        anchor = after || anchor;
      }
      if (isStart) {
        var before = Editor.before(editor, focus);
        focus = before || focus;
      }
    }
    var range = {
      anchor,
      focus
    };
    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {
      at: range.focus,
      mode: "highest"
    })) {
      range = Editor.unhangRange(editor, range, {
        voids: true
      });
    }
    return range;
  },
  hasRange(editor, range) {
    var {
      anchor,
      focus
    } = range;
    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);
  },
  /**
   * Check if the target is in the editor.
   */
  hasTarget(editor, target) {
    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);
  },
  /**
   * Check if the target is editable and in the editor.
   */
  hasEditableTarget(editor, target) {
    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
      editable: true
    });
  },
  /**
   * Check if the target can be selectable
   */
  hasSelectableTarget(editor, target) {
    return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);
  },
  /**
   * Check if the target is inside void and in an non-readonly editor.
   */
  isTargetInsideNonReadonlyVoid(editor, target) {
    if (IS_READ_ONLY.get(editor))
      return false;
    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
    return Element2.isElement(slateNode) && Editor.isVoid(editor, slateNode);
  },
  /**
   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.
   */
  androidScheduleFlush(editor) {
    var _EDITOR_TO_SCHEDULE_F;
    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();
  },
  /**
   * Experimental and android specific: Get pending diffs
   */
  androidPendingDiffs(editor) {
    return EDITOR_TO_PENDING_DIFFS.get(editor);
  }
};
var _excluded$32 = ["anchor", "focus"];
var _excluded2$12 = ["anchor", "focus"];
var shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
var isDecorationFlagsEqual = (range, other) => {
  var rangeOwnProps = _objectWithoutProperties2(range, _excluded$32);
  var otherOwnProps = _objectWithoutProperties2(other, _excluded2$12);
  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);
};
var isElementDecorationsEqual = (list2, another) => {
  if (list2.length !== another.length) {
    return false;
  }
  for (var i6 = 0; i6 < list2.length; i6++) {
    var range = list2[i6];
    var other = another[i6];
    if (!Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {
      return false;
    }
  }
  return true;
};
var isTextDecorationsEqual = (list2, another) => {
  if (list2.length !== another.length) {
    return false;
  }
  for (var i6 = 0; i6 < list2.length; i6++) {
    var range = list2[i6];
    var other = another[i6];
    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {
      return false;
    }
  }
  return true;
};
var useIsomorphicLayoutEffect = CAN_USE_DOM ? import_react53.useLayoutEffect : import_react53.useEffect;
var String2 = (props) => {
  var {
    isLast,
    leaf,
    parent,
    text: text3
  } = props;
  var editor = useSlateStatic();
  var path2 = ReactEditor.findPath(editor, text3);
  var parentPath = Path.parent(path2);
  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true;
  if (editor.isVoid(parent)) {
    return import_react53.default.createElement(ZeroWidthString, {
      length: Node3.string(parent).length
    });
  }
  if (leaf.text === "" && parent.children[parent.children.length - 1] === text3 && !editor.isInline(parent) && Editor.string(editor, parentPath) === "") {
    return import_react53.default.createElement(ZeroWidthString, {
      isLineBreak: true,
      isMarkPlaceholder
    });
  }
  if (leaf.text === "") {
    return import_react53.default.createElement(ZeroWidthString, {
      isMarkPlaceholder
    });
  }
  if (isLast && leaf.text.slice(-1) === "\n") {
    return import_react53.default.createElement(TextString, {
      isTrailing: true,
      text: leaf.text
    });
  }
  return import_react53.default.createElement(TextString, {
    text: leaf.text
  });
};
var TextString = (props) => {
  var {
    text: text3,
    isTrailing = false
  } = props;
  var ref = (0, import_react53.useRef)(null);
  var getTextContent = () => {
    return "".concat(text3 !== null && text3 !== void 0 ? text3 : "").concat(isTrailing ? "\n" : "");
  };
  var [initialText] = (0, import_react53.useState)(getTextContent);
  useIsomorphicLayoutEffect(() => {
    var textWithTrailing = getTextContent();
    if (ref.current && ref.current.textContent !== textWithTrailing) {
      ref.current.textContent = textWithTrailing;
    }
  });
  return import_react53.default.createElement(MemoizedText$1, {
    ref
  }, initialText);
};
var MemoizedText$1 = (0, import_react53.memo)((0, import_react53.forwardRef)((props, ref) => {
  return import_react53.default.createElement("span", {
    "data-slate-string": true,
    ref
  }, props.children);
}));
var ZeroWidthString = (props) => {
  var {
    length: length2 = 0,
    isLineBreak = false,
    isMarkPlaceholder = false
  } = props;
  var attributes = {
    "data-slate-zero-width": isLineBreak ? "n" : "z",
    "data-slate-length": length2
  };
  if (isMarkPlaceholder) {
    attributes["data-slate-mark-placeholder"] = true;
  }
  return import_react53.default.createElement("span", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? "\uFEFF" : null, isLineBreak ? import_react53.default.createElement("br", null) : null);
};
var EditorContext = (0, import_react53.createContext)(null);
var useSlateStatic = () => {
  var editor = (0, import_react53.useContext)(EditorContext);
  if (!editor) {
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  }
  return editor;
};
var Leaf = (props) => {
  var {
    leaf,
    isLast,
    text: text3,
    parent,
    renderPlaceholder,
    renderLeaf: renderLeaf2 = (props2) => import_react53.default.createElement(DefaultLeaf, Object.assign({}, props2))
  } = props;
  var lastPlaceholderRef = (0, import_react53.useRef)(null);
  var placeholderRef = (0, import_react53.useRef)(null);
  var editor = useSlateStatic();
  var placeholderResizeObserver = (0, import_react53.useRef)(null);
  (0, import_react53.useEffect)(() => {
    return () => {
      if (placeholderResizeObserver.current) {
        placeholderResizeObserver.current.disconnect();
      }
    };
  }, []);
  (0, import_react53.useEffect)(() => {
    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;
    if (placeholderEl) {
      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);
    } else {
      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);
    }
    if (placeholderResizeObserver.current) {
      placeholderResizeObserver.current.disconnect();
      if (placeholderEl)
        placeholderResizeObserver.current.observe(placeholderEl);
    } else if (placeholderEl) {
      var ResizeObserver$1 = window.ResizeObserver || ResizeObserver;
      placeholderResizeObserver.current = new ResizeObserver$1(() => {
        var forceRender2 = EDITOR_TO_FORCE_RENDER.get(editor);
        forceRender2 === null || forceRender2 === void 0 ? void 0 : forceRender2();
      });
      placeholderResizeObserver.current.observe(placeholderEl);
    }
    if (!placeholderEl && lastPlaceholderRef.current) {
      var forceRender = EDITOR_TO_FORCE_RENDER.get(editor);
      forceRender === null || forceRender === void 0 ? void 0 : forceRender();
    }
    lastPlaceholderRef.current = placeholderRef.current;
    return () => {
      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);
    };
  }, [placeholderRef, leaf]);
  var children = import_react53.default.createElement(String2, {
    isLast,
    leaf,
    parent,
    text: text3
  });
  if (leaf[PLACEHOLDER_SYMBOL]) {
    var placeholderProps = {
      children: leaf.placeholder,
      attributes: {
        "data-slate-placeholder": true,
        style: {
          position: "absolute",
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none"
        },
        contentEditable: false,
        ref: placeholderRef
      }
    };
    children = import_react53.default.createElement(import_react53.default.Fragment, null, renderPlaceholder(placeholderProps), children);
  }
  var attributes = {
    "data-slate-leaf": true
  };
  return renderLeaf2({
    attributes,
    children,
    leaf,
    text: text3
  });
};
var MemoizedLeaf = import_react53.default.memo(Leaf, (prev2, next2) => {
  return next2.parent === prev2.parent && next2.isLast === prev2.isLast && next2.renderLeaf === prev2.renderLeaf && next2.renderPlaceholder === prev2.renderPlaceholder && next2.text === prev2.text && Text2.equals(next2.leaf, prev2.leaf) && next2.leaf[PLACEHOLDER_SYMBOL] === prev2.leaf[PLACEHOLDER_SYMBOL];
});
var DefaultLeaf = (props) => {
  var {
    attributes,
    children
  } = props;
  return import_react53.default.createElement("span", Object.assign({}, attributes), children);
};
var Text3 = (props) => {
  var {
    decorations,
    isLast,
    parent,
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    text: text3
  } = props;
  var editor = useSlateStatic();
  var ref = (0, import_react53.useRef)(null);
  var leaves = Text2.decorations(text3, decorations);
  var key = ReactEditor.findKey(editor, text3);
  var children = [];
  for (var i6 = 0; i6 < leaves.length; i6++) {
    var leaf = leaves[i6];
    children.push(import_react53.default.createElement(MemoizedLeaf, {
      isLast: isLast && i6 === leaves.length - 1,
      key: "".concat(key.id, "-").concat(i6),
      renderPlaceholder,
      leaf,
      text: text3,
      parent,
      renderLeaf: renderLeaf2
    }));
  }
  var callbackRef = (0, import_react53.useCallback)((span) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (span) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);
      NODE_TO_ELEMENT.set(text3, span);
      ELEMENT_TO_NODE.set(span, text3);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(text3);
      if (ref.current) {
        ELEMENT_TO_NODE.delete(ref.current);
      }
    }
    ref.current = span;
  }, [ref, editor, key, text3]);
  return import_react53.default.createElement("span", {
    "data-slate-node": "text",
    ref: callbackRef
  }, children);
};
var MemoizedText = import_react53.default.memo(Text3, (prev2, next2) => {
  return next2.parent === prev2.parent && next2.isLast === prev2.isLast && next2.renderLeaf === prev2.renderLeaf && next2.renderPlaceholder === prev2.renderPlaceholder && next2.text === prev2.text && isTextDecorationsEqual(next2.decorations, prev2.decorations);
});
var Element3 = (props) => {
  var {
    decorations,
    element: element2,
    renderElement: renderElement2 = (p5) => import_react53.default.createElement(DefaultElement, Object.assign({}, p5)),
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    selection
  } = props;
  var editor = useSlateStatic();
  var readOnly = useReadOnly();
  var isInline = editor.isInline(element2);
  var key = ReactEditor.findKey(editor, element2);
  var ref = (0, import_react53.useCallback)((ref2) => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (ref2) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref2);
      NODE_TO_ELEMENT.set(element2, ref2);
      ELEMENT_TO_NODE.set(ref2, element2);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(element2);
    }
  }, [editor, key, element2]);
  var children = useChildren({
    decorations,
    node: element2,
    renderElement: renderElement2,
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    selection
  });
  var attributes = {
    "data-slate-node": "element",
    ref
  };
  if (isInline) {
    attributes["data-slate-inline"] = true;
  }
  if (!isInline && Editor.hasInlines(editor, element2)) {
    var text3 = Node3.string(element2);
    var dir = (0, import_direction.default)(text3);
    if (dir === "rtl") {
      attributes.dir = dir;
    }
  }
  if (Editor.isVoid(editor, element2)) {
    attributes["data-slate-void"] = true;
    if (!readOnly && isInline) {
      attributes.contentEditable = false;
    }
    var Tag2 = isInline ? "span" : "div";
    var [[_text]] = Node3.texts(element2);
    children = import_react53.default.createElement(Tag2, {
      "data-slate-spacer": true,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, import_react53.default.createElement(MemoizedText, {
      renderPlaceholder,
      decorations: [],
      isLast: false,
      parent: element2,
      text: _text
    }));
    NODE_TO_INDEX.set(_text, 0);
    NODE_TO_PARENT.set(_text, element2);
  }
  return renderElement2({
    attributes,
    children,
    element: element2
  });
};
var MemoizedElement = import_react53.default.memo(Element3, (prev2, next2) => {
  return prev2.element === next2.element && prev2.renderElement === next2.renderElement && prev2.renderLeaf === next2.renderLeaf && prev2.renderPlaceholder === next2.renderPlaceholder && isElementDecorationsEqual(prev2.decorations, next2.decorations) && (prev2.selection === next2.selection || !!prev2.selection && !!next2.selection && Range.equals(prev2.selection, next2.selection));
});
var DefaultElement = (props) => {
  var {
    attributes,
    children,
    element: element2
  } = props;
  var editor = useSlateStatic();
  var Tag2 = editor.isInline(element2) ? "span" : "div";
  return import_react53.default.createElement(Tag2, Object.assign({}, attributes, {
    style: {
      position: "relative"
    }
  }), children);
};
var DecorateContext = (0, import_react53.createContext)(() => []);
var useDecorate = () => {
  return (0, import_react53.useContext)(DecorateContext);
};
var SelectedContext = (0, import_react53.createContext)(false);
var useSelected = () => {
  return (0, import_react53.useContext)(SelectedContext);
};
var useChildren = (props) => {
  var {
    decorations,
    node: node3,
    renderElement: renderElement2,
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    selection
  } = props;
  var decorate = useDecorate();
  var editor = useSlateStatic();
  var path2 = ReactEditor.findPath(editor, node3);
  var children = [];
  var isLeafBlock = Element2.isElement(node3) && !editor.isInline(node3) && Editor.hasInlines(editor, node3);
  for (var i6 = 0; i6 < node3.children.length; i6++) {
    var p5 = path2.concat(i6);
    var n6 = node3.children[i6];
    var key = ReactEditor.findKey(editor, n6);
    var range = Editor.range(editor, p5);
    var sel = selection && Range.intersection(range, selection);
    var ds = decorate([n6, p5]);
    for (var dec of decorations) {
      var d5 = Range.intersection(dec, range);
      if (d5) {
        ds.push(d5);
      }
    }
    if (Element2.isElement(n6)) {
      children.push(import_react53.default.createElement(SelectedContext.Provider, {
        key: "provider-".concat(key.id),
        value: !!sel
      }, import_react53.default.createElement(MemoizedElement, {
        decorations: ds,
        element: n6,
        key: key.id,
        renderElement: renderElement2,
        renderPlaceholder,
        renderLeaf: renderLeaf2,
        selection: sel
      })));
    } else {
      children.push(import_react53.default.createElement(MemoizedText, {
        decorations: ds,
        key: key.id,
        isLast: isLeafBlock && i6 === node3.children.length - 1,
        parent: node3,
        renderPlaceholder,
        renderLeaf: renderLeaf2,
        text: n6
      }));
    }
    NODE_TO_INDEX.set(n6, i6);
    NODE_TO_PARENT.set(n6, node3);
  }
  return children;
};
var ReadOnlyContext = (0, import_react53.createContext)(false);
var useReadOnly = () => {
  return (0, import_react53.useContext)(ReadOnlyContext);
};
var SlateContext = (0, import_react53.createContext)(null);
var useSlate = () => {
  var context = (0, import_react53.useContext)(SlateContext);
  if (!context) {
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  }
  var {
    editor
  } = context;
  return editor;
};
var TRIPLE_CLICK = 3;
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
};
var APPLE_HOTKEYS = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var create2 = (key) => {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && (0, import_is_hotkey.isKeyHotkey)(generic);
  var isApple = apple && (0, import_is_hotkey.isKeyHotkey)(apple);
  var isWindows = windows && (0, import_is_hotkey.isKeyHotkey)(windows);
  return (event) => {
    if (isGeneric && isGeneric(event))
      return true;
    if (IS_APPLE && isApple && isApple(event))
      return true;
    if (!IS_APPLE && isWindows && isWindows(event))
      return true;
    return false;
  };
};
var Hotkeys = {
  isBold: create2("bold"),
  isCompose: create2("compose"),
  isMoveBackward: create2("moveBackward"),
  isMoveForward: create2("moveForward"),
  isDeleteBackward: create2("deleteBackward"),
  isDeleteForward: create2("deleteForward"),
  isDeleteLineBackward: create2("deleteLineBackward"),
  isDeleteLineForward: create2("deleteLineForward"),
  isDeleteWordBackward: create2("deleteWordBackward"),
  isDeleteWordForward: create2("deleteWordForward"),
  isExtendBackward: create2("extendBackward"),
  isExtendForward: create2("extendForward"),
  isExtendLineBackward: create2("extendLineBackward"),
  isExtendLineForward: create2("extendLineForward"),
  isItalic: create2("italic"),
  isMoveLineBackward: create2("moveLineBackward"),
  isMoveLineForward: create2("moveLineForward"),
  isMoveWordBackward: create2("moveWordBackward"),
  isMoveWordForward: create2("moveWordForward"),
  isRedo: create2("redo"),
  isSoftBreak: create2("insertSoftBreak"),
  isSplitBlock: create2("splitBlock"),
  isTransposeCharacter: create2("transposeCharacter"),
  isUndo: create2("undo")
};
var createRestoreDomManager = (editor, receivedUserInput) => {
  var bufferedMutations = [];
  var clear = () => {
    bufferedMutations = [];
  };
  var registerMutations = (mutations) => {
    if (!receivedUserInput.current) {
      return;
    }
    var trackedMutations = mutations.filter((mutation) => isTrackedMutation(editor, mutation, mutations));
    bufferedMutations.push(...trackedMutations);
  };
  function restoreDOM() {
    if (bufferedMutations.length > 0) {
      bufferedMutations.reverse().forEach((mutation) => {
        if (mutation.type === "characterData") {
          return;
        }
        mutation.removedNodes.forEach((node3) => {
          mutation.target.insertBefore(node3, mutation.nextSibling);
        });
        mutation.addedNodes.forEach((node3) => {
          mutation.target.removeChild(node3);
        });
      });
      clear();
    }
  }
  return {
    registerMutations,
    restoreDOM,
    clear
  };
};
var MUTATION_OBSERVER_CONFIG$1 = {
  subtree: true,
  childList: true,
  characterData: true,
  characterDataOldValue: true
};
var RestoreDOMComponent = class extends import_react53.Component {
  constructor() {
    super(...arguments);
    this.context = null;
    this.manager = null;
    this.mutationObserver = null;
  }
  observe() {
    var _this$mutationObserve;
    var {
      node: node3
    } = this.props;
    if (!node3.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node3.current, MUTATION_OBSERVER_CONFIG$1);
  }
  componentDidMount() {
    var {
      receivedUserInput
    } = this.props;
    var editor = this.context;
    this.manager = createRestoreDomManager(editor, receivedUserInput);
    this.mutationObserver = new MutationObserver(this.manager.registerMutations);
    this.observe();
  }
  getSnapshotBeforeUpdate() {
    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;
    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();
    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {
      var _this$manager;
      (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);
    }
    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();
    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();
    return null;
  }
  componentDidUpdate() {
    var _this$manager3;
    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();
    this.observe();
  }
  componentWillUnmount() {
    var _this$mutationObserve4;
    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();
  }
  render() {
    return this.props.children;
  }
};
RestoreDOMComponent.contextType = EditorContext;
var RestoreDOM = IS_ANDROID ? RestoreDOMComponent : (_ref) => {
  var {
    children
  } = _ref;
  return import_react53.default.createElement(import_react53.default.Fragment, null, children);
};
function verifyDiffState(editor, textDiff) {
  var {
    path: path2,
    diff
  } = textDiff;
  if (!Editor.hasPath(editor, path2)) {
    return false;
  }
  var node3 = Node3.get(editor, path2);
  if (!Text2.isText(node3)) {
    return false;
  }
  if (diff.start !== node3.text.length || diff.text.length === 0) {
    return node3.text.slice(diff.start, diff.start + diff.text.length) === diff.text;
  }
  var nextPath = Path.next(path2);
  if (!Editor.hasPath(editor, nextPath)) {
    return false;
  }
  var nextNode = Node3.get(editor, nextPath);
  return Text2.isText(nextNode) && nextNode.text.startsWith(diff.text);
}
function applyStringDiff(text3) {
  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    diffs[_key - 1] = arguments[_key];
  }
  return diffs.reduce((text4, diff) => text4.slice(0, diff.start) + diff.text + text4.slice(diff.end), text3);
}
function longestCommonPrefixLength(str, another) {
  var length2 = Math.min(str.length, another.length);
  for (var i6 = 0; i6 < length2; i6++) {
    if (str.charAt(i6) !== another.charAt(i6)) {
      return i6;
    }
  }
  return length2;
}
function longestCommonSuffixLength(str, another, max2) {
  var length2 = Math.min(str.length, another.length, max2);
  for (var i6 = 0; i6 < length2; i6++) {
    if (str.charAt(str.length - i6 - 1) !== another.charAt(another.length - i6 - 1)) {
      return i6;
    }
  }
  return length2;
}
function normalizeStringDiff(targetText, diff) {
  var {
    start: start2,
    end,
    text: text3
  } = diff;
  var removedText = targetText.slice(start2, end);
  var prefixLength = longestCommonPrefixLength(removedText, text3);
  var max2 = Math.min(removedText.length - prefixLength, text3.length - prefixLength);
  var suffixLength = longestCommonSuffixLength(removedText, text3, max2);
  var normalized = {
    start: start2 + prefixLength,
    end: end - suffixLength,
    text: text3.slice(prefixLength, text3.length - suffixLength)
  };
  if (normalized.start === normalized.end && normalized.text.length === 0) {
    return null;
  }
  return normalized;
}
function mergeStringDiffs(targetText, a3, b2) {
  var start2 = Math.min(a3.start, b2.start);
  var overlap = Math.max(0, Math.min(a3.start + a3.text.length, b2.end) - b2.start);
  var applied = applyStringDiff(targetText, a3, b2);
  var sliceEnd = Math.max(b2.start + b2.text.length, a3.start + a3.text.length + (a3.start + a3.text.length > b2.start ? b2.text.length : 0) - overlap);
  var text3 = applied.slice(start2, sliceEnd);
  var end = Math.max(a3.end, b2.end - a3.text.length + (a3.end - a3.start));
  return normalizeStringDiff(targetText, {
    start: start2,
    end,
    text: text3
  });
}
function targetRange(textDiff) {
  var {
    path: path2,
    diff
  } = textDiff;
  return {
    anchor: {
      path: path2,
      offset: diff.start
    },
    focus: {
      path: path2,
      offset: diff.end
    }
  };
}
function normalizePoint(editor, point) {
  var {
    path: path2,
    offset
  } = point;
  if (!Editor.hasPath(editor, path2)) {
    return null;
  }
  var leaf = Node3.get(editor, path2);
  if (!Text2.isText(leaf)) {
    return null;
  }
  var parentBlock = Editor.above(editor, {
    match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
    at: path2
  });
  if (!parentBlock) {
    return null;
  }
  while (offset > leaf.text.length) {
    var entry = Editor.next(editor, {
      at: path2,
      match: Text2.isText
    });
    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {
      return null;
    }
    offset -= leaf.text.length;
    leaf = entry[0];
    path2 = entry[1];
  }
  return {
    path: path2,
    offset
  };
}
function normalizeRange(editor, range) {
  var anchor = normalizePoint(editor, range.anchor);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus = normalizePoint(editor, range.focus);
  if (!focus) {
    return null;
  }
  return {
    anchor,
    focus
  };
}
function transformPendingPoint(editor, point, op) {
  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref) => {
    var {
      path: path2
    } = _ref;
    return Path.equals(path2, point.path);
  });
  if (!textDiff || point.offset <= textDiff.diff.start) {
    return Point.transform(point, op, {
      affinity: "backward"
    });
  }
  var {
    diff
  } = textDiff;
  if (point.offset <= diff.start + diff.text.length) {
    var _anchor = {
      path: point.path,
      offset: diff.start
    };
    var _transformed = Point.transform(_anchor, op, {
      affinity: "backward"
    });
    if (!_transformed) {
      return null;
    }
    return {
      path: _transformed.path,
      offset: _transformed.offset + point.offset - diff.start
    };
  }
  var anchor = {
    path: point.path,
    offset: point.offset - diff.text.length + diff.end - diff.start
  };
  var transformed = Point.transform(anchor, op, {
    affinity: "backward"
  });
  if (!transformed) {
    return null;
  }
  if (op.type === "split_node" && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {
    return transformed;
  }
  return {
    path: transformed.path,
    offset: transformed.offset + diff.text.length - diff.end + diff.start
  };
}
function transformPendingRange(editor, range, op) {
  var anchor = transformPendingPoint(editor, range.anchor, op);
  if (!anchor) {
    return null;
  }
  if (Range.isCollapsed(range)) {
    return {
      anchor,
      focus: anchor
    };
  }
  var focus = transformPendingPoint(editor, range.focus, op);
  if (!focus) {
    return null;
  }
  return {
    anchor,
    focus
  };
}
function transformTextDiff(textDiff, op) {
  var {
    path: path2,
    diff,
    id
  } = textDiff;
  switch (op.type) {
    case "insert_text": {
      if (!Path.equals(op.path, path2) || op.offset >= diff.end) {
        return textDiff;
      }
      if (op.offset <= diff.start) {
        return {
          diff: {
            start: op.text.length + diff.start,
            end: op.text.length + diff.end,
            text: diff.text
          },
          id,
          path: path2
        };
      }
      return {
        diff: {
          start: diff.start,
          end: diff.end + op.text.length,
          text: diff.text
        },
        id,
        path: path2
      };
    }
    case "remove_text": {
      if (!Path.equals(op.path, path2) || op.offset >= diff.end) {
        return textDiff;
      }
      if (op.offset + op.text.length <= diff.start) {
        return {
          diff: {
            start: diff.start - op.text.length,
            end: diff.end - op.text.length,
            text: diff.text
          },
          id,
          path: path2
        };
      }
      return {
        diff: {
          start: diff.start,
          end: diff.end - op.text.length,
          text: diff.text
        },
        id,
        path: path2
      };
    }
    case "split_node": {
      if (!Path.equals(op.path, path2) || op.position >= diff.end) {
        return {
          diff,
          id,
          path: Path.transform(path2, op, {
            affinity: "backward"
          })
        };
      }
      if (op.position > diff.start) {
        return {
          diff: {
            start: diff.start,
            end: Math.min(op.position, diff.end),
            text: diff.text
          },
          id,
          path: path2
        };
      }
      return {
        diff: {
          start: diff.start - op.position,
          end: diff.end - op.position,
          text: diff.text
        },
        id,
        path: Path.transform(path2, op, {
          affinity: "forward"
        })
      };
    }
    case "merge_node": {
      if (!Path.equals(op.path, path2)) {
        return {
          diff,
          id,
          path: Path.transform(path2, op)
        };
      }
      return {
        diff: {
          start: diff.start + op.position,
          end: diff.end + op.position,
          text: diff.text
        },
        id,
        path: Path.transform(path2, op)
      };
    }
  }
  var newPath = Path.transform(path2, op);
  if (!newPath) {
    return null;
  }
  return {
    diff,
    path: newPath,
    id
  };
}
function ownKeys$32(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$32(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$32(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$32(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var RESOLVE_DELAY = 25;
var FLUSH_DELAY = 200;
var debug2 = function debug3() {
};
var isDataTransfer = (value2) => (value2 === null || value2 === void 0 ? void 0 : value2.constructor.name) === "DataTransfer";
function createAndroidInputManager(_ref) {
  var {
    editor,
    scheduleOnDOMSelectionChange,
    onDOMSelectionChange
  } = _ref;
  var flushing = false;
  var compositionEndTimeoutId = null;
  var flushTimeoutId = null;
  var actionTimeoutId = null;
  var idCounter = 0;
  var insertPositionHint = false;
  var applyPendingSelection = () => {
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    if (pendingSelection) {
      var {
        selection
      } = editor;
      var normalized = normalizeRange(editor, pendingSelection);
      if (normalized && (!selection || !Range.equals(normalized, selection))) {
        Transforms.select(editor, normalized);
      }
    }
  };
  var performAction = () => {
    var action = EDITOR_TO_PENDING_ACTION.get(editor);
    EDITOR_TO_PENDING_ACTION.delete(editor);
    if (!action) {
      return;
    }
    if (action.at) {
      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);
      if (!target) {
        return;
      }
      var _targetRange = Editor.range(editor, target);
      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {
        Transforms.select(editor, target);
      }
    }
    action.run();
  };
  var flush2 = () => {
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    if (actionTimeoutId) {
      clearTimeout(actionTimeoutId);
      actionTimeoutId = null;
    }
    if (!hasPendingDiffs() && !hasPendingAction()) {
      applyPendingSelection();
      return;
    }
    if (!flushing) {
      flushing = true;
      setTimeout(() => flushing = false);
    }
    if (hasPendingAction()) {
      flushing = "action";
    }
    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {
      affinity: "forward"
    });
    EDITOR_TO_USER_MARKS.set(editor, editor.marks);
    debug2("flush", EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));
    var scheduleSelectionChange = hasPendingDiffs();
    var diff;
    while (diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {
      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;
      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
      if (pendingMarks !== void 0) {
        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
        editor.marks = pendingMarks;
      }
      if (pendingMarks && insertPositionHint === false) {
        insertPositionHint = null;
      }
      var range = targetRange(diff);
      if (!editor.selection || !Range.equals(editor.selection, range)) {
        Transforms.select(editor, range);
      }
      if (diff.diff.text) {
        Editor.insertText(editor, diff.diff.text);
      } else {
        Editor.deleteFragment(editor);
      }
      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2) => {
        var {
          id
        } = _ref2;
        return id !== diff.id;
      }));
      if (!verifyDiffState(editor, diff)) {
        scheduleSelectionChange = false;
        EDITOR_TO_PENDING_ACTION.delete(editor);
        EDITOR_TO_USER_MARKS.delete(editor);
        flushing = "action";
        EDITOR_TO_PENDING_SELECTION.delete(editor);
        scheduleOnDOMSelectionChange.cancel();
        onDOMSelectionChange.cancel();
        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
      }
    }
    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();
    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {
      Transforms.select(editor, selection);
    }
    if (hasPendingAction()) {
      performAction();
      return;
    }
    if (scheduleSelectionChange) {
      scheduleOnDOMSelectionChange();
    }
    scheduleOnDOMSelectionChange.flush();
    onDOMSelectionChange.flush();
    applyPendingSelection();
    var userMarks = EDITOR_TO_USER_MARKS.get(editor);
    EDITOR_TO_USER_MARKS.delete(editor);
    if (userMarks !== void 0) {
      editor.marks = userMarks;
      editor.onChange();
    }
  };
  var handleCompositionEnd = (_event) => {
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
    }
    compositionEndTimeoutId = setTimeout(() => {
      IS_COMPOSING.set(editor, false);
      flush2();
    }, RESOLVE_DELAY);
  };
  var handleCompositionStart = (_event) => {
    IS_COMPOSING.set(editor, true);
    if (compositionEndTimeoutId) {
      clearTimeout(compositionEndTimeoutId);
      compositionEndTimeoutId = null;
    }
  };
  var updatePlaceholderVisibility = function updatePlaceholderVisibility2() {
    var forceHide = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);
    if (!placeholderElement) {
      return;
    }
    if (hasPendingDiffs() || forceHide) {
      placeholderElement.style.display = "none";
      return;
    }
    placeholderElement.style.removeProperty("display");
  };
  var storeDiff = (path2, diff) => {
    var _EDITOR_TO_PENDING_DI3;
    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];
    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);
    var target = Node3.leaf(editor, path2);
    var idx = pendingDiffs.findIndex((change) => Path.equals(change.path, path2));
    if (idx < 0) {
      var normalized = normalizeStringDiff(target.text, diff);
      if (normalized) {
        pendingDiffs.push({
          path: path2,
          diff,
          id: idCounter++
        });
      }
      updatePlaceholderVisibility();
      return;
    }
    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);
    if (!merged) {
      pendingDiffs.splice(idx, 1);
      updatePlaceholderVisibility();
      return;
    }
    pendingDiffs[idx] = _objectSpread$32(_objectSpread$32({}, pendingDiffs[idx]), {}, {
      diff: merged
    });
  };
  var scheduleAction = function scheduleAction2(run) {
    var {
      at
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    insertPositionHint = false;
    EDITOR_TO_PENDING_SELECTION.delete(editor);
    scheduleOnDOMSelectionChange.cancel();
    onDOMSelectionChange.cancel();
    if (hasPendingAction()) {
      flush2();
    }
    EDITOR_TO_PENDING_ACTION.set(editor, {
      at,
      run
    });
    actionTimeoutId = setTimeout(flush2);
  };
  var handleDOMBeforeInput = (event) => {
    var _targetRange2;
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      inputType: type2
    } = event;
    var targetRange2 = null;
    var data = event.dataTransfer || event.data || void 0;
    if (insertPositionHint !== false && type2 !== "insertText" && type2 !== "insertCompositionText") {
      insertPositionHint = false;
    }
    var [nativeTargetRange] = event.getTargetRanges();
    if (nativeTargetRange) {
      targetRange2 = ReactEditor.toSlateRange(editor, nativeTargetRange, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    var window2 = ReactEditor.getWindow(editor);
    var domSelection = window2.getSelection();
    if (!targetRange2 && domSelection) {
      nativeTargetRange = domSelection;
      targetRange2 = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: false,
        suppressThrow: true
      });
    }
    targetRange2 = (_targetRange2 = targetRange2) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;
    if (!targetRange2) {
      return;
    }
    var canStoreDiff = true;
    if (type2.startsWith("delete")) {
      if (Range.isExpanded(targetRange2)) {
        var [_start, _end] = Range.edges(targetRange2);
        var _leaf = Node3.leaf(editor, _start.path);
        if (_leaf.text.length === _start.offset && _end.offset === 0) {
          var next2 = Editor.next(editor, {
            at: _start.path,
            match: Text2.isText
          });
          if (next2 && Path.equals(next2[1], _end.path)) {
            targetRange2 = {
              anchor: _end,
              focus: _end
            };
          }
        }
      }
      var direction = type2.endsWith("Backward") ? "backward" : "forward";
      var [start2, end] = Range.edges(targetRange2);
      var [leaf, path2] = Editor.leaf(editor, start2.path);
      var diff = {
        text: "",
        start: start2.offset,
        end: end.offset
      };
      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);
      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change) => Path.equals(change.path, path2));
      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];
      var text3 = applyStringDiff(leaf.text, ...diffs);
      if (text3.length === 0) {
        canStoreDiff = false;
      }
      if (Range.isExpanded(targetRange2)) {
        if (canStoreDiff && Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var point = {
            path: targetRange2.anchor.path,
            offset: start2.offset
          };
          var range = Editor.range(editor, point, point);
          handleUserSelect(range);
          return storeDiff(targetRange2.anchor.path, {
            text: "",
            end: end.offset,
            start: start2.offset
          });
        }
        return scheduleAction(() => Editor.deleteFragment(editor, {
          direction
        }), {
          at: targetRange2
        });
      }
    }
    switch (type2) {
      case "deleteByComposition":
      case "deleteByCut":
      case "deleteByDrag": {
        return scheduleAction(() => Editor.deleteFragment(editor), {
          at: targetRange2
        });
      }
      case "deleteContent":
      case "deleteContentForward": {
        var {
          anchor
        } = targetRange2;
        if (canStoreDiff && Range.isCollapsed(targetRange2)) {
          var targetNode = Node3.leaf(editor, anchor.path);
          if (anchor.offset < targetNode.text.length) {
            return storeDiff(anchor.path, {
              text: "",
              start: anchor.offset,
              end: anchor.offset + 1
            });
          }
        }
        return scheduleAction(() => Editor.deleteForward(editor), {
          at: targetRange2
        });
      }
      case "deleteContentBackward": {
        var _nativeTargetRange;
        var {
          anchor: _anchor
        } = targetRange2;
        var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);
        if (canStoreDiff && nativeCollapsed && Range.isCollapsed(targetRange2) && _anchor.offset > 0) {
          return storeDiff(_anchor.path, {
            text: "",
            start: _anchor.offset - 1,
            end: _anchor.offset
          });
        }
        return scheduleAction(() => Editor.deleteBackward(editor), {
          at: targetRange2
        });
      }
      case "deleteEntireSoftLine": {
        return scheduleAction(() => {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
        }, {
          at: targetRange2
        });
      }
      case "deleteHardLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteHardLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "block"
        }), {
          at: targetRange2
        });
      }
      case "deleteSoftLineForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "line"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordBackward": {
        return scheduleAction(() => Editor.deleteBackward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "deleteWordForward": {
        return scheduleAction(() => Editor.deleteForward(editor, {
          unit: "word"
        }), {
          at: targetRange2
        });
      }
      case "insertLineBreak": {
        return scheduleAction(() => Editor.insertSoftBreak(editor), {
          at: targetRange2
        });
      }
      case "insertParagraph": {
        return scheduleAction(() => Editor.insertBreak(editor), {
          at: targetRange2
        });
      }
      case "insertCompositionText":
      case "deleteCompositionText":
      case "insertFromComposition":
      case "insertFromDrop":
      case "insertFromPaste":
      case "insertFromYank":
      case "insertReplacementText":
      case "insertText": {
        if (isDataTransfer(data)) {
          return scheduleAction(() => ReactEditor.insertData(editor, data), {
            at: targetRange2
          });
        }
        var _text = data !== null && data !== void 0 ? data : "";
        if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {
          _text = _text.replace("\uFEFF", "");
        }
        if (type2 === "insertText" && /.*\n.*\n$/.test(_text)) {
          _text = _text.slice(0, -1);
        }
        if (_text.includes("\n")) {
          return scheduleAction(() => {
            var parts = _text.split("\n");
            parts.forEach((line2, i6) => {
              if (line2) {
                Editor.insertText(editor, line2);
              }
              if (i6 !== parts.length - 1) {
                Editor.insertSoftBreak(editor);
              }
            });
          }, {
            at: targetRange2
          });
        }
        if (Path.equals(targetRange2.anchor.path, targetRange2.focus.path)) {
          var [_start2, _end2] = Range.edges(targetRange2);
          var _diff = {
            start: _start2.offset,
            end: _end2.offset,
            text: _text
          };
          if (_text && insertPositionHint && type2 === "insertCompositionText") {
            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\S|$/);
            var diffPosition = _diff.start + _diff.text.search(/\S|$/);
            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {
              _diff.start -= 1;
              insertPositionHint = null;
              scheduleFlush();
            } else {
              insertPositionHint = false;
            }
          } else if (type2 === "insertText") {
            if (insertPositionHint === null) {
              insertPositionHint = _diff;
            } else if (insertPositionHint && Range.isCollapsed(targetRange2) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {
              insertPositionHint = _objectSpread$32(_objectSpread$32({}, insertPositionHint), {}, {
                text: insertPositionHint.text + _text
              });
            } else {
              insertPositionHint = false;
            }
          } else {
            insertPositionHint = false;
          }
          if (canStoreDiff) {
            storeDiff(_start2.path, _diff);
            return;
          }
        }
        return scheduleAction(() => Editor.insertText(editor, _text), {
          at: targetRange2
        });
      }
    }
  };
  var hasPendingAction = () => {
    return !!EDITOR_TO_PENDING_ACTION.get(editor);
  };
  var hasPendingDiffs = () => {
    var _EDITOR_TO_PENDING_DI4;
    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);
  };
  var hasPendingChanges = () => {
    return hasPendingAction() || hasPendingDiffs();
  };
  var isFlushing = () => {
    return flushing;
  };
  var handleUserSelect = (range) => {
    EDITOR_TO_PENDING_SELECTION.set(editor, range);
    if (flushTimeoutId) {
      clearTimeout(flushTimeoutId);
      flushTimeoutId = null;
    }
    var {
      selection
    } = editor;
    if (!range) {
      return;
    }
    var pathChanged = !selection || !Path.equals(selection.anchor.path, range.anchor.path);
    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));
    if (pathChanged && insertPositionHint || parentPathChanged) {
      insertPositionHint = false;
    }
    if (pathChanged || hasPendingDiffs()) {
      flushTimeoutId = setTimeout(flush2, FLUSH_DELAY);
    }
  };
  var handleInput = () => {
    if (hasPendingAction() || !hasPendingDiffs()) {
      flush2();
    }
  };
  var handleKeyDown = (_2) => {
    if (!hasPendingDiffs()) {
      updatePlaceholderVisibility(true);
      setTimeout(updatePlaceholderVisibility);
    }
  };
  var scheduleFlush = () => {
    if (!hasPendingAction()) {
      actionTimeoutId = setTimeout(flush2);
    }
  };
  var handleDomMutations = (mutations) => {
    if (hasPendingDiffs() || hasPendingAction()) {
      return;
    }
    if (mutations.some((mutation) => isTrackedMutation(editor, mutation, mutations))) {
      var _EDITOR_TO_FORCE_REND;
      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();
    }
  };
  return {
    flush: flush2,
    scheduleFlush,
    hasPendingDiffs,
    hasPendingAction,
    hasPendingChanges,
    isFlushing,
    handleUserSelect,
    handleCompositionEnd,
    handleCompositionStart,
    handleDOMBeforeInput,
    handleKeyDown,
    handleDomMutations,
    handleInput
  };
}
function useIsMounted2() {
  var isMountedRef = (0, import_react53.useRef)(false);
  (0, import_react53.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef.current;
}
function useMutationObserver(node3, callback, options) {
  var [mutationObserver] = (0, import_react53.useState)(() => new MutationObserver(callback));
  useIsomorphicLayoutEffect(() => {
    mutationObserver.takeRecords();
  });
  (0, import_react53.useEffect)(() => {
    if (!node3.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    mutationObserver.observe(node3.current, options);
    return () => mutationObserver.disconnect();
  }, []);
}
var _excluded$22 = ["node"];
function ownKeys$22(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$22(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$22(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$22(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var MUTATION_OBSERVER_CONFIG = {
  subtree: true,
  childList: true,
  characterData: true
};
function useAndroidInputManager(_ref) {
  var {
    node: node3
  } = _ref, options = _objectWithoutProperties2(_ref, _excluded$22);
  if (!IS_ANDROID) {
    return null;
  }
  var editor = useSlateStatic();
  var isMounted = useIsMounted2();
  var [inputManager] = (0, import_react53.useState)(() => createAndroidInputManager(_objectSpread$22({
    editor
  }, options)));
  useMutationObserver(node3, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);
  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);
  if (isMounted) {
    inputManager.flush();
  }
  return inputManager;
}
function useTrackUserInput() {
  var editor = useSlateStatic();
  var receivedUserInput = (0, import_react53.useRef)(false);
  var animationFrameIdRef = (0, import_react53.useRef)(0);
  var onUserInput = (0, import_react53.useCallback)(() => {
    if (receivedUserInput.current) {
      return;
    }
    receivedUserInput.current = true;
    var window2 = ReactEditor.getWindow(editor);
    window2.cancelAnimationFrame(animationFrameIdRef.current);
    animationFrameIdRef.current = window2.requestAnimationFrame(() => {
      receivedUserInput.current = false;
    });
  }, []);
  (0, import_react53.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);
  return {
    receivedUserInput,
    onUserInput
  };
}
var _excluded$12 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"];
var _excluded22 = ["text"];
function ownKeys$12(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$12(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys$12(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$12(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Children4 = (props) => import_react53.default.createElement(import_react53.default.Fragment, null, useChildren(props));
var Editable = (props) => {
  var _EDITOR_TO_PLACEHOLDE, _EDITOR_TO_PLACEHOLDE2;
  var defaultRenderPlaceholder = (0, import_react53.useCallback)((props2) => import_react53.default.createElement(DefaultPlaceholder, Object.assign({}, props2)), []);
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder,
    readOnly = false,
    renderElement: renderElement2,
    renderLeaf: renderLeaf2,
    renderPlaceholder = defaultRenderPlaceholder,
    scrollSelectionIntoView = defaultScrollSelectionIntoView,
    style: userStyle = {},
    as: Component2 = "div",
    disableDefaultStyles = false
  } = props, attributes = _objectWithoutProperties2(props, _excluded$12);
  var editor = useSlate();
  var [isComposing, setIsComposing] = (0, import_react53.useState)(false);
  var ref = (0, import_react53.useRef)(null);
  var deferredOperations = (0, import_react53.useRef)([]);
  var {
    onUserInput,
    receivedUserInput
  } = useTrackUserInput();
  var [, forceRender] = (0, import_react53.useReducer)((s4) => s4 + 1, 0);
  EDITOR_TO_FORCE_RENDER.set(editor, forceRender);
  IS_READ_ONLY.set(editor, readOnly);
  var state = (0, import_react53.useMemo)(() => ({
    isDraggingInternally: false,
    isUpdatingSelection: false,
    latestElement: null,
    hasMarkPlaceholder: false
  }), []);
  (0, import_react53.useEffect)(() => {
    if (ref.current && autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]);
  var onDOMSelectionChange = (0, import_react53.useCallback)((0, import_throttle.default)(() => {
    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      var {
        activeElement
      } = root;
      var el = ReactEditor.toDOMNode(editor, editor);
      var domSelection = root.getSelection();
      if (activeElement === el) {
        state.latestElement = activeElement;
        IS_FOCUSED.set(editor, true);
      } else {
        IS_FOCUSED.delete(editor);
      }
      if (!domSelection) {
        return Transforms.deselect(editor);
      }
      var {
        anchorNode,
        focusNode
      } = domSelection;
      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);
      var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);
      if (anchorNodeSelectable && focusNodeSelectable) {
        var range = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: true
        });
        if (range) {
          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {
            Transforms.select(editor, range);
          } else {
            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);
          }
        }
      }
      if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {
        Transforms.deselect(editor);
      }
    }
  }, 100), [readOnly]);
  var scheduleOnDOMSelectionChange = (0, import_react53.useMemo)(() => (0, import_debounce.default)(onDOMSelectionChange, 0), [onDOMSelectionChange]);
  var androidInputManager = useAndroidInputManager({
    node: ref,
    onDOMSelectionChange,
    scheduleOnDOMSelectionChange
  });
  useIsomorphicLayoutEffect(() => {
    var window2;
    if (ref.current && (window2 = getDefaultView(ref.current))) {
      EDITOR_TO_WINDOW.set(editor, window2);
      EDITOR_TO_ELEMENT.set(editor, ref.current);
      NODE_TO_ELEMENT.set(editor, ref.current);
      ELEMENT_TO_NODE.set(ref.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }
    var {
      selection
    } = editor;
    var root = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root.getSelection();
    if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {
      return;
    }
    var setDomSelection = (forceChange) => {
      var hasDomSelection = domSelection.type !== "None";
      if (!selection && !hasDomSelection) {
        return;
      }
      var editorElement = EDITOR_TO_ELEMENT.get(editor);
      var hasDomSelectionInEditor = false;
      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
        hasDomSelectionInEditor = true;
      }
      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {
        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: true,
          // domSelection is not necessarily a valid Slate range
          // (e.g. when clicking on contentEditable:false element)
          suppressThrow: true
        });
        if (slateRange && Range.equals(slateRange, selection)) {
          var _anchorNode$parentEle;
          if (!state.hasMarkPlaceholder) {
            return;
          }
          var {
            anchorNode
          } = domSelection;
          if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute("data-slate-mark-placeholder")) {
            return;
          }
        }
      }
      if (selection && !ReactEditor.hasRange(editor, selection)) {
        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: true
        });
        return;
      }
      state.isUpdatingSelection = true;
      var newDomRange2 = selection && ReactEditor.toDOMRange(editor, selection);
      if (newDomRange2) {
        if (Range.isBackward(selection)) {
          domSelection.setBaseAndExtent(newDomRange2.endContainer, newDomRange2.endOffset, newDomRange2.startContainer, newDomRange2.startOffset);
        } else {
          domSelection.setBaseAndExtent(newDomRange2.startContainer, newDomRange2.startOffset, newDomRange2.endContainer, newDomRange2.endOffset);
        }
        scrollSelectionIntoView(editor, newDomRange2);
      } else {
        domSelection.removeAllRanges();
      }
      return newDomRange2;
    };
    var newDomRange = setDomSelection();
    var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === "action";
    if (!IS_ANDROID || !ensureSelection) {
      setTimeout(() => {
        if (newDomRange && IS_FIREFOX) {
          var el = ReactEditor.toDOMNode(editor, editor);
          el.focus();
        }
        state.isUpdatingSelection = false;
      });
      return;
    }
    var timeoutId = null;
    var animationFrameId = requestAnimationFrame(() => {
      if (ensureSelection) {
        var ensureDomSelection = (forceChange) => {
          try {
            var el = ReactEditor.toDOMNode(editor, editor);
            el.focus();
            setDomSelection(forceChange);
          } catch (e6) {
          }
        };
        ensureDomSelection();
        timeoutId = setTimeout(() => {
          ensureDomSelection(true);
          state.isUpdatingSelection = false;
        });
      }
    });
    return () => {
      cancelAnimationFrame(animationFrameId);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  });
  var onDOMBeforeInput = (0, import_react53.useCallback)((event) => {
    onUserInput();
    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      var _EDITOR_TO_USER_SELEC;
      if (androidInputManager) {
        return androidInputManager.handleDOMBeforeInput(event);
      }
      scheduleOnDOMSelectionChange.flush();
      onDOMSelectionChange.flush();
      var {
        selection
      } = editor;
      var {
        inputType: type2
      } = event;
      var data = event.dataTransfer || event.data || void 0;
      var isCompositionChange = type2 === "insertCompositionText" || type2 === "deleteCompositionText";
      if (isCompositionChange && ReactEditor.isComposing(editor)) {
        return;
      }
      var native = false;
      if (type2 === "insertText" && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      selection.anchor.offset !== 0) {
        var _node$parentElement, _window$getComputedSt;
        native = true;
        if (editor.marks) {
          native = false;
        }
        var {
          anchor: anchor2
        } = selection;
        var [node3, offset] = ReactEditor.toDOMPoint(editor, anchor2);
        var anchorNode = (_node$parentElement = node3.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest("a");
        var window2 = ReactEditor.getWindow(editor);
        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {
          var _lastText$textContent;
          var lastText = window2 === null || window2 === void 0 ? void 0 : window2.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();
          if (lastText === node3 && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {
            native = false;
          }
        }
        if (native && node3.parentElement && (window2 === null || window2 === void 0 ? void 0 : (_window$getComputedSt = window2.getComputedStyle(node3.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === "pre") {
          var block5 = Editor.above(editor, {
            at: anchor2.path,
            match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6)
          });
          if (block5 && Node3.string(block5[0]).includes("	")) {
            native = false;
          }
        }
      }
      if (!type2.startsWith("delete") || type2.startsWith("deleteBy")) {
        var [targetRange2] = event.getTargetRanges();
        if (targetRange2) {
          var range = ReactEditor.toSlateRange(editor, targetRange2, {
            exactMatch: false,
            suppressThrow: false
          });
          if (!selection || !Range.equals(selection, range)) {
            native = false;
            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);
            Transforms.select(editor, range);
            if (selectionRef) {
              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);
            }
          }
        }
      }
      if (isCompositionChange) {
        return;
      }
      if (!native) {
        event.preventDefault();
      }
      if (selection && Range.isExpanded(selection) && type2.startsWith("delete")) {
        var direction = type2.endsWith("Backward") ? "backward" : "forward";
        Editor.deleteFragment(editor, {
          direction
        });
        return;
      }
      switch (type2) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          Editor.deleteFragment(editor);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          Editor.deleteForward(editor);
          break;
        }
        case "deleteContentBackward": {
          Editor.deleteBackward(editor);
          break;
        }
        case "deleteEntireSoftLine": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          Editor.deleteForward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          Editor.deleteBackward(editor, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          Editor.deleteForward(editor, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          Editor.insertSoftBreak(editor);
          break;
        case "insertParagraph": {
          Editor.insertBreak(editor);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          if (type2 === "insertFromComposition") {
            if (ReactEditor.isComposing(editor)) {
              setIsComposing(false);
              IS_COMPOSING.set(editor, false);
            }
          }
          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === "DataTransfer") {
            ReactEditor.insertData(editor, data);
          } else if (typeof data === "string") {
            if (native) {
              deferredOperations.current.push(() => Editor.insertText(editor, data));
            } else {
              Editor.insertText(editor, data);
            }
          }
          break;
        }
      }
      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
      EDITOR_TO_USER_SELECTION.delete(editor);
      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {
        Transforms.select(editor, toRestore);
      }
    }
  }, [readOnly, propsOnDOMBeforeInput]);
  var callbackRef = (0, import_react53.useCallback)((node3) => {
    if (node3 == null) {
      onDOMSelectionChange.cancel();
      scheduleOnDOMSelectionChange.cancel();
      EDITOR_TO_ELEMENT.delete(editor);
      NODE_TO_ELEMENT.delete(editor);
      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {
        ref.current.removeEventListener("beforeinput", onDOMBeforeInput);
      }
    } else {
      if (HAS_BEFORE_INPUT_SUPPORT) {
        node3.addEventListener("beforeinput", onDOMBeforeInput);
      }
    }
    ref.current = node3;
  }, [ref, onDOMBeforeInput, onDOMSelectionChange, scheduleOnDOMSelectionChange]);
  useIsomorphicLayoutEffect(() => {
    var window2 = ReactEditor.getWindow(editor);
    window2.document.addEventListener("selectionchange", scheduleOnDOMSelectionChange);
    return () => {
      window2.document.removeEventListener("selectionchange", scheduleOnDOMSelectionChange);
    };
  }, [scheduleOnDOMSelectionChange]);
  var decorations = decorate([editor, []]);
  if (placeholder && editor.children.length === 1 && Array.from(Node3.texts(editor)).length === 1 && Node3.string(editor) === "" && !isComposing) {
    var start2 = Editor.start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder,
      anchor: start2,
      focus: start2
    });
  }
  var {
    marks
  } = editor;
  state.hasMarkPlaceholder = false;
  if (editor.selection && Range.isCollapsed(editor.selection) && marks) {
    var {
      anchor
    } = editor.selection;
    var leaf = Node3.leaf(editor, anchor.path);
    var rest = _objectWithoutProperties2(leaf, _excluded22);
    if (!Text2.equals(leaf, marks, {
      loose: true
    })) {
      state.hasMarkPlaceholder = true;
      var unset = Object.fromEntries(Object.keys(rest).map((mark) => [mark, null]));
      decorations.push(_objectSpread$12(_objectSpread$12(_objectSpread$12({
        [MARK_PLACEHOLDER_SYMBOL]: true
      }, unset), marks), {}, {
        anchor,
        focus: anchor
      }));
    }
  }
  (0, import_react53.useEffect)(() => {
    setTimeout(() => {
      var {
        selection
      } = editor;
      if (selection) {
        var {
          anchor: _anchor
        } = selection;
        var _text = Node3.leaf(editor, _anchor.path);
        if (marks && !Text2.equals(_text, marks, {
          loose: true
        })) {
          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);
          return;
        }
      }
      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
    });
  });
  var placeholderHeight = (_EDITOR_TO_PLACEHOLDE = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor)) === null || _EDITOR_TO_PLACEHOLDE === void 0 ? void 0 : (_EDITOR_TO_PLACEHOLDE2 = _EDITOR_TO_PLACEHOLDE.getBoundingClientRect()) === null || _EDITOR_TO_PLACEHOLDE2 === void 0 ? void 0 : _EDITOR_TO_PLACEHOLDE2.height;
  return import_react53.default.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, import_react53.default.createElement(DecorateContext.Provider, {
    value: decorate
  }, import_react53.default.createElement(RestoreDOM, {
    node: ref,
    receivedUserInput
  }, import_react53.default.createElement(Component2, Object.assign({
    role: readOnly ? void 0 : "textbox",
    "aria-multiline": readOnly ? void 0 : true
  }, attributes, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,
    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : "false",
    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : "false",
    "data-slate-editor": true,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !readOnly,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: true,
    ref: callbackRef,
    style: _objectSpread$12(_objectSpread$12({}, disableDefaultStyles ? {} : _objectSpread$12({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Prevent the default outline styles.
      outline: "none",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, placeholderHeight ? {
      minHeight: placeholderHeight
    } : {})), userStyle),
    onBeforeInput: (0, import_react53.useCallback)((event) => {
      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {
        event.preventDefault();
        if (!ReactEditor.isComposing(editor)) {
          var _text2 = event.data;
          Editor.insertText(editor, _text2);
        }
      }
    }, [readOnly]),
    onInput: (0, import_react53.useCallback)((event) => {
      if (isEventHandled(event, attributes.onInput)) {
        return;
      }
      if (androidInputManager) {
        androidInputManager.handleInput();
        return;
      }
      for (var op of deferredOperations.current) {
        op();
      }
      deferredOperations.current = [];
    }, []),
    onBlur: (0, import_react53.useCallback)((event) => {
      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      }
      var root = ReactEditor.findDocumentOrShadowRoot(editor);
      if (state.latestElement === root.activeElement) {
        return;
      }
      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor);
      if (relatedTarget === el) {
        return;
      }
      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute("data-slate-spacer")) {
        return;
      }
      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node3 = ReactEditor.toSlateNode(editor, relatedTarget);
        if (Element2.isElement(node3) && !editor.isVoid(node3)) {
          return;
        }
      }
      if (IS_SAFARI) {
        var domSelection = root.getSelection();
        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();
      }
      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: (0, import_react53.useCallback)((event) => {
      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node3 = ReactEditor.toSlateNode(editor, event.target);
        var path2 = ReactEditor.findPath(editor, node3);
        if (!Editor.hasPath(editor, path2) || Node3.get(editor, path2) !== node3) {
          return;
        }
        if (event.detail === TRIPLE_CLICK && path2.length >= 1) {
          var blockPath = path2;
          if (!(Element2.isElement(node3) && Editor.isBlock(editor, node3))) {
            var _block$;
            var block5 = Editor.above(editor, {
              match: (n6) => Element2.isElement(n6) && Editor.isBlock(editor, n6),
              at: path2
            });
            blockPath = (_block$ = block5 === null || block5 === void 0 ? void 0 : block5[1]) !== null && _block$ !== void 0 ? _block$ : path2.slice(0, 1);
          }
          var range = Editor.range(editor, blockPath);
          Transforms.select(editor, range);
          return;
        }
        if (readOnly) {
          return;
        }
        var _start = Editor.start(editor, path2);
        var end = Editor.end(editor, path2);
        var startVoid = Editor.void(editor, {
          at: _start
        });
        var endVoid = Editor.void(editor, {
          at: end
        });
        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
          var _range = Editor.range(editor, _start);
          Transforms.select(editor, _range);
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: (0, import_react53.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target)) {
        if (ReactEditor.isComposing(editor)) {
          setIsComposing(false);
          IS_COMPOSING.set(editor, false);
        }
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);
        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {
          return;
        }
        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {
          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);
          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);
          if (placeholderMarks !== void 0) {
            EDITOR_TO_USER_MARKS.set(editor, editor.marks);
            editor.marks = placeholderMarks;
          }
          Editor.insertText(editor, event.data);
          var userMarks = EDITOR_TO_USER_MARKS.get(editor);
          EDITOR_TO_USER_MARKS.delete(editor);
          if (userMarks !== void 0) {
            editor.marks = userMarks;
          }
        }
      }
    }, [attributes.onCompositionEnd]),
    onCompositionUpdate: (0, import_react53.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
        if (!ReactEditor.isComposing(editor)) {
          setIsComposing(true);
          IS_COMPOSING.set(editor, true);
        }
      }
    }, [attributes.onCompositionUpdate]),
    onCompositionStart: (0, import_react53.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target)) {
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);
        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {
          return;
        }
        setIsComposing(true);
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
            return;
          }
          var inline4 = Editor.above(editor, {
            match: (n6) => Element2.isElement(n6) && Editor.isInline(editor, n6),
            mode: "highest"
          });
          if (inline4) {
            var [, inlinePath] = inline4;
            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {
              var point = Editor.after(editor, inlinePath);
              Transforms.setSelection(editor, {
                anchor: point,
                focus: point
              });
            }
          }
        }
      }
    }, [attributes.onCompositionStart]),
    onCopy: (0, import_react53.useCallback)((event) => {
      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "copy");
      }
    }, [attributes.onCopy]),
    onCut: (0, import_react53.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "cut");
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
          } else {
            var node3 = Node3.parent(editor, selection.anchor.path);
            if (Editor.isVoid(editor, node3)) {
              Transforms.delete(editor);
            }
          }
        }
      }
    }, [readOnly, attributes.onCut]),
    onDragOver: (0, import_react53.useCallback)((event) => {
      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
        var node3 = ReactEditor.toSlateNode(editor, event.target);
        if (Element2.isElement(node3) && Editor.isVoid(editor, node3)) {
          event.preventDefault();
        }
      }
    }, [attributes.onDragOver]),
    onDragStart: (0, import_react53.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
        var node3 = ReactEditor.toSlateNode(editor, event.target);
        var path2 = ReactEditor.findPath(editor, node3);
        var voidMatch = Element2.isElement(node3) && Editor.isVoid(editor, node3) || Editor.void(editor, {
          at: path2,
          voids: true
        });
        if (voidMatch) {
          var range = Editor.range(editor, path2);
          Transforms.select(editor, range);
        }
        state.isDraggingInternally = true;
        ReactEditor.setFragmentData(editor, event.dataTransfer, "drag");
      }
    }, [readOnly, attributes.onDragStart]),
    onDrop: (0, import_react53.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {
        event.preventDefault();
        var draggedRange = editor.selection;
        var range = ReactEditor.findEventRange(editor, event);
        var data = event.dataTransfer;
        Transforms.select(editor, range);
        if (state.isDraggingInternally) {
          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {
            at: range,
            voids: true
          })) {
            Transforms.delete(editor, {
              at: draggedRange
            });
          }
        }
        ReactEditor.insertData(editor, data);
        if (!ReactEditor.isFocused(editor)) {
          ReactEditor.focus(editor);
        }
      }
      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDrop]),
    onDragEnd: (0, import_react53.useCallback)((event) => {
      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {
        attributes.onDragEnd(event);
      }
      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDragEnd]),
    onFocus: (0, import_react53.useCallback)((event) => {
      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var el = ReactEditor.toDOMNode(editor, editor);
        var root = ReactEditor.findDocumentOrShadowRoot(editor);
        state.latestElement = root.activeElement;
        if (IS_FIREFOX && event.target !== el) {
          el.focus();
          return;
        }
        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onKeyDown: (0, import_react53.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {
        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleKeyDown(event);
        var {
          nativeEvent
        } = event;
        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {
          IS_COMPOSING.set(editor, false);
          setIsComposing(false);
        }
        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {
          return;
        }
        var {
          selection
        } = editor;
        var element2 = editor.children[selection !== null ? selection.focus.path[0] : 0];
        var isRTL = (0, import_direction.default)(Node3.string(element2)) === "rtl";
        if (Hotkeys.isRedo(nativeEvent)) {
          event.preventDefault();
          var maybeHistoryEditor = editor;
          if (typeof maybeHistoryEditor.redo === "function") {
            maybeHistoryEditor.redo();
          }
          return;
        }
        if (Hotkeys.isUndo(nativeEvent)) {
          event.preventDefault();
          var _maybeHistoryEditor = editor;
          if (typeof _maybeHistoryEditor.undo === "function") {
            _maybeHistoryEditor.undo();
          }
          return;
        }
        if (Hotkeys.isMoveLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isMoveLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line"
          });
          return;
        }
        if (Hotkeys.isExtendLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isExtendLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Hotkeys.isMoveBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: !isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: "start"
            });
          }
          return;
        }
        if (Hotkeys.isMoveForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: "end"
            });
          }
          return;
        }
        if (Hotkeys.isMoveWordBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: !isRTL
          });
          return;
        }
        if (Hotkeys.isMoveWordForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: isRTL
          });
          return;
        }
        if (!HAS_BEFORE_INPUT_SUPPORT) {
          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
            event.preventDefault();
            return;
          }
          if (Hotkeys.isSoftBreak(nativeEvent)) {
            event.preventDefault();
            Editor.insertSoftBreak(editor);
            return;
          }
          if (Hotkeys.isSplitBlock(nativeEvent)) {
            event.preventDefault();
            Editor.insertBreak(editor);
            return;
          }
          if (Hotkeys.isDeleteBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteLineForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "word"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "word"
              });
            }
            return;
          }
        } else {
          if (IS_CHROME || IS_SAFARI) {
            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {
              var currentNode = Node3.parent(editor, selection.anchor.path);
              if (Element2.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {
                event.preventDefault();
                Editor.deleteBackward(editor, {
                  unit: "block"
                });
                return;
              }
            }
          }
        }
      }
    }, [readOnly, attributes.onKeyDown]),
    onPaste: (0, import_react53.useCallback)((event) => {
      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {
        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_SAFARI) {
          event.preventDefault();
          ReactEditor.insertData(editor, event.clipboardData);
        }
      }
    }, [readOnly, attributes.onPaste])
  }), import_react53.default.createElement(Children4, {
    decorations,
    node: editor,
    renderElement: renderElement2,
    renderPlaceholder,
    renderLeaf: renderLeaf2,
    selection: editor.selection
  })))));
};
var DefaultPlaceholder = (_ref) => {
  var {
    attributes,
    children
  } = _ref;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    import_react53.default.createElement("span", Object.assign({}, attributes), children, IS_ANDROID && import_react53.default.createElement("br", null))
  );
};
var defaultDecorate = () => [];
var defaultScrollSelectionIntoView = (editor, domRange) => {
  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {
    var leafEl = domRange.startContainer.parentElement;
    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
    es_default(leafEl, {
      scrollMode: "if-needed"
    });
    delete leafEl.getBoundingClientRect;
  }
};
var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isDefaultPrevented() || event.isPropagationStopped();
};
var isDOMEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.defaultPrevented;
};
var FocusedContext = (0, import_react53.createContext)(false);
var SlateSelectorContext = (0, import_react53.createContext)({});
function getSelectorContext(editor) {
  var eventListeners = (0, import_react53.useRef)([]).current;
  var slateRef = (0, import_react53.useRef)({
    editor
  }).current;
  var onChange = (0, import_react53.useCallback)((editor2) => {
    slateRef.editor = editor2;
    eventListeners.forEach((listener) => listener(editor2));
  }, []);
  var selectorContext = (0, import_react53.useMemo)(() => {
    return {
      getSlate: () => slateRef.editor,
      addEventListener: (callback) => {
        eventListeners.push(callback);
        return () => {
          eventListeners.splice(eventListeners.indexOf(callback), 1);
        };
      }
    };
  }, [eventListeners, slateRef]);
  return {
    selectorContext,
    onChange
  };
}
var _excluded3 = ["editor", "children", "onChange", "value"];
var Slate = (props) => {
  var {
    editor,
    children,
    onChange,
    value: value2
  } = props, rest = _objectWithoutProperties2(props, _excluded3);
  var unmountRef = (0, import_react53.useRef)(false);
  var [context, setContext] = import_react53.default.useState(() => {
    if (!Node3.isNodeList(value2)) {
      throw new Error("[Slate] value is invalid! Expected a list of elements but got: ".concat(Scrubber.stringify(value2)));
    }
    if (!Editor.isEditor(editor)) {
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Scrubber.stringify(editor)));
    }
    editor.children = value2;
    Object.assign(editor, rest);
    return {
      v: 0,
      editor
    };
  });
  var {
    selectorContext,
    onChange: handleSelectorChange
  } = getSelectorContext(editor);
  var onContextChange = (0, import_react53.useCallback)(() => {
    if (onChange) {
      onChange(editor.children);
    }
    setContext((prevContext) => ({
      v: prevContext.v + 1,
      editor
    }));
    handleSelectorChange(editor);
  }, [onChange]);
  (0, import_react53.useEffect)(() => {
    EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
    return () => {
      EDITOR_TO_ON_CHANGE.set(editor, () => {
      });
      unmountRef.current = true;
    };
  }, [onContextChange]);
  var [isFocused, setIsFocused] = (0, import_react53.useState)(ReactEditor.isFocused(editor));
  (0, import_react53.useEffect)(() => {
    setIsFocused(ReactEditor.isFocused(editor));
  });
  useIsomorphicLayoutEffect(() => {
    var fn2 = () => setIsFocused(ReactEditor.isFocused(editor));
    if (IS_REACT_VERSION_17_OR_ABOVE) {
      document.addEventListener("focusin", fn2);
      document.addEventListener("focusout", fn2);
      return () => {
        document.removeEventListener("focusin", fn2);
        document.removeEventListener("focusout", fn2);
      };
    } else {
      document.addEventListener("focus", fn2, true);
      document.addEventListener("blur", fn2, true);
      return () => {
        document.removeEventListener("focus", fn2, true);
        document.removeEventListener("blur", fn2, true);
      };
    }
  }, []);
  return import_react53.default.createElement(SlateSelectorContext.Provider, {
    value: selectorContext
  }, import_react53.default.createElement(SlateContext.Provider, {
    value: context
  }, import_react53.default.createElement(EditorContext.Provider, {
    value: context.editor
  }, import_react53.default.createElement(FocusedContext.Provider, {
    value: isFocused
  }, children))));
};
var doRectsIntersect = (rect, compareRect) => {
  var middle = (compareRect.top + compareRect.bottom) / 2;
  return rect.top <= middle && rect.bottom >= middle;
};
var areRangesSameLine = (editor, range1, range2) => {
  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();
  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();
  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);
};
var findCurrentLineRange = (editor, parentRange) => {
  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));
  var positions = Array.from(Editor.positions(editor, {
    at: parentRange
  }));
  var left = 0;
  var right = positions.length;
  var middle = Math.floor(right / 2);
  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {
    return Editor.range(editor, positions[left], parentRangeBoundary);
  }
  if (positions.length < 2) {
    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);
  }
  while (middle !== positions.length && middle !== left) {
    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {
      right = middle;
    } else {
      left = middle;
    }
    middle = Math.floor((left + right) / 2);
  }
  return Editor.range(editor, positions[right], parentRangeBoundary);
};
function ownKeys2(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i6 = 1; i6 < arguments.length; i6++) {
    var source = arguments[i6] != null ? arguments[i6] : {};
    if (i6 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var withReact = function withReact2(editor) {
  var clipboardFormatKey2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment";
  var e6 = editor;
  var {
    apply,
    onChange,
    deleteBackward,
    addMark,
    removeMark
  } = e6;
  EDITOR_TO_KEY_TO_ELEMENT.set(e6, /* @__PURE__ */ new WeakMap());
  e6.addMark = (key, value2) => {
    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;
    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e6)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();
    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e6) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e6)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {
      EDITOR_TO_PENDING_INSERTION_MARKS.set(e6, null);
    }
    EDITOR_TO_USER_MARKS.delete(e6);
    addMark(key, value2);
  };
  e6.removeMark = (key) => {
    var _EDITOR_TO_PENDING_DI2;
    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e6) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e6)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {
      EDITOR_TO_PENDING_INSERTION_MARKS.set(e6, null);
    }
    EDITOR_TO_USER_MARKS.delete(e6);
    removeMark(key);
  };
  e6.deleteBackward = (unit) => {
    if (unit !== "line") {
      return deleteBackward(unit);
    }
    if (e6.selection && Range.isCollapsed(e6.selection)) {
      var parentBlockEntry = Editor.above(e6, {
        match: (n6) => Element2.isElement(n6) && Editor.isBlock(e6, n6),
        at: e6.selection
      });
      if (parentBlockEntry) {
        var [, parentBlockPath] = parentBlockEntry;
        var parentElementRange = Editor.range(e6, parentBlockPath, e6.selection.anchor);
        var currentLineRange = findCurrentLineRange(e6, parentElementRange);
        if (!Range.isCollapsed(currentLineRange)) {
          Transforms.delete(e6, {
            at: currentLineRange
          });
        }
      }
    }
  };
  e6.apply = (op) => {
    var matches = [];
    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e6);
    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {
      var transformed = pendingDiffs.map((textDiff) => transformTextDiff(textDiff, op)).filter(Boolean);
      EDITOR_TO_PENDING_DIFFS.set(e6, transformed);
    }
    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e6);
    if (pendingSelection) {
      EDITOR_TO_PENDING_SELECTION.set(e6, transformPendingRange(e6, pendingSelection, op));
    }
    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e6);
    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {
      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e6, pendingAction.at, op) : transformPendingRange(e6, pendingAction.at, op);
      EDITOR_TO_PENDING_ACTION.set(e6, at ? _objectSpread2(_objectSpread2({}, pendingAction), {}, {
        at
      }) : null);
    }
    switch (op.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        matches.push(...getMatches(e6, op.path));
        break;
      }
      case "set_selection": {
        var _EDITOR_TO_USER_SELEC;
        (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e6)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
        EDITOR_TO_USER_SELECTION.delete(e6);
        break;
      }
      case "insert_node":
      case "remove_node": {
        matches.push(...getMatches(e6, Path.parent(op.path)));
        break;
      }
      case "merge_node": {
        var prevPath = Path.previous(op.path);
        matches.push(...getMatches(e6, prevPath));
        break;
      }
      case "move_node": {
        var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));
        matches.push(...getMatches(e6, commonPath));
        break;
      }
    }
    apply(op);
    for (var [path2, key] of matches) {
      var [node3] = Editor.node(e6, path2);
      NODE_TO_KEY.set(node3, key);
    }
  };
  e6.setFragmentData = (data) => {
    var {
      selection
    } = e6;
    if (!selection) {
      return;
    }
    var [start2, end] = Range.edges(selection);
    var startVoid = Editor.void(e6, {
      at: start2.path
    });
    var endVoid = Editor.void(e6, {
      at: end.path
    });
    if (Range.isCollapsed(selection) && !startVoid) {
      return;
    }
    var domRange = ReactEditor.toDOMRange(e6, selection);
    var contents = domRange.cloneContents();
    var attach = contents.childNodes[0];
    contents.childNodes.forEach((node3) => {
      if (node3.textContent && node3.textContent.trim() !== "") {
        attach = node3;
      }
    });
    if (endVoid) {
      var [voidNode] = endVoid;
      var r7 = domRange.cloneRange();
      var domNode = ReactEditor.toDOMNode(e6, voidNode);
      r7.setEndAfter(domNode);
      contents = r7.cloneContents();
    }
    if (startVoid) {
      attach = contents.querySelector("[data-slate-spacer]");
    }
    Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
      var isNewline = zw.getAttribute("data-slate-zero-width") === "n";
      zw.textContent = isNewline ? "\n" : "";
    });
    if (isDOMText(attach)) {
      var span = attach.ownerDocument.createElement("span");
      span.style.whiteSpace = "pre";
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }
    var fragment = e6.getFragment();
    var string = JSON.stringify(fragment);
    var encoded = window.btoa(encodeURIComponent(string));
    attach.setAttribute("data-slate-fragment", encoded);
    data.setData("application/".concat(clipboardFormatKey2), encoded);
    var div = contents.ownerDocument.createElement("div");
    div.appendChild(contents);
    div.setAttribute("hidden", "true");
    contents.ownerDocument.body.appendChild(div);
    data.setData("text/html", div.innerHTML);
    data.setData("text/plain", getPlainText(div));
    contents.ownerDocument.body.removeChild(div);
    return data;
  };
  e6.insertData = (data) => {
    if (!e6.insertFragmentData(data)) {
      e6.insertTextData(data);
    }
  };
  e6.insertFragmentData = (data) => {
    var fragment = data.getData("application/".concat(clipboardFormatKey2)) || getSlateFragmentAttribute(data);
    if (fragment) {
      var decoded = decodeURIComponent(window.atob(fragment));
      var parsed = JSON.parse(decoded);
      e6.insertFragment(parsed);
      return true;
    }
    return false;
  };
  e6.insertTextData = (data) => {
    var text3 = data.getData("text/plain");
    if (text3) {
      var lines = text3.split(/\r\n|\r|\n/);
      var split2 = false;
      for (var line2 of lines) {
        if (split2) {
          Transforms.splitNodes(e6, {
            always: true
          });
        }
        e6.insertText(line2);
        split2 = true;
      }
      return true;
    }
    return false;
  };
  e6.onChange = (options) => {
    import_react_dom6.default.unstable_batchedUpdates(() => {
      var onContextChange = EDITOR_TO_ON_CHANGE.get(e6);
      if (onContextChange) {
        onContextChange();
      }
      onChange(options);
    });
  };
  return e6;
};
var getMatches = (e6, path2) => {
  var matches = [];
  for (var [n6, p5] of Editor.levels(e6, {
    at: path2
  })) {
    var key = ReactEditor.findKey(e6, n6);
    matches.push([p5, key]);
  }
  return matches;
};

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/editIcon/dist/keystar-ui-icon-icons-editIcon.esm.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var editIcon = (0, import_jsx_runtime28.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime28.jsx)("path", {
    d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
  }), (0, import_jsx_runtime28.jsx)("path", {
    d: "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/externalLinkIcon/dist/keystar-ui-icon-icons-externalLinkIcon.esm.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var externalLinkIcon = (0, import_jsx_runtime29.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime29.jsx)("path", {
    d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6M15 3h6v6M10 14 21 3"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/linkIcon/dist/keystar-ui-icon-icons-linkIcon.esm.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var linkIcon = (0, import_jsx_runtime30.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime30.jsx)("path", {
    d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"
  }), (0, import_jsx_runtime30.jsx)("path", {
    d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/unlinkIcon/dist/keystar-ui-icon-icons-unlinkIcon.esm.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var unlinkIcon = (0, import_jsx_runtime31.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime31.jsx)("path", {
    d: "m18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71M8 2v3M2 8h3M16 19v3M19 16h3"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/chevronDownIcon/dist/keystar-ui-icon-icons-chevronDownIcon.esm.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var chevronDownIcon = (0, import_jsx_runtime32.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime32.jsx)("path", {
    d: "m6 9 6 6 6-6"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/listbox/dist/keystar-ui-listbox.esm.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var import_react54 = __toESM(require_react());

// node_modules/.pnpm/@react-aria+listbox@3.11.2_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/listbox/dist/import.mjs
var $b1f0cad8af73213b$export$3585ede4d035bf14 = /* @__PURE__ */ new WeakMap();
function $b1f0cad8af73213b$var$normalizeKey(key) {
  if (typeof key === "string")
    return key.replace(/\s*/g, "");
  return "" + key;
}
function $b1f0cad8af73213b$export$9145995848b05025(state, itemKey) {
  let data = $b1f0cad8af73213b$export$3585ede4d035bf14.get(state);
  if (!data)
    throw new Error("Unknown list");
  return `${data.id}-option-${$b1f0cad8af73213b$var$normalizeKey(itemKey)}`;
}
function $c132121280ec012d$export$50eacbbf140a3141(props, state, ref) {
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let selectionBehavior = props.selectionBehavior || "toggle";
  let linkBehavior = props.linkBehavior || (selectionBehavior === "replace" ? "action" : "override");
  if (selectionBehavior === "toggle" && linkBehavior === "action")
    linkBehavior = "override";
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    ...props,
    ref,
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    linkBehavior
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onFocusWithin: props.onFocus,
    onBlurWithin: props.onBlur,
    onFocusWithinChange: props.onFocusChange
  });
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $b1f0cad8af73213b$export$3585ede4d035bf14).set(state, {
    id,
    shouldUseVirtualFocus: props.shouldUseVirtualFocus,
    shouldSelectOnPressUp: props.shouldSelectOnPressUp,
    shouldFocusOnHover: props.shouldFocusOnHover,
    isVirtualized: props.isVirtualized,
    onAction: props.onAction,
    linkBehavior
  });
  let { labelProps, fieldProps } = (0, $d191a55c9702f145$export$8467354a121f1b9f)({
    ...props,
    id,
    // listbox is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span"
  });
  return {
    labelProps,
    listBoxProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, focusWithinProps, state.selectionManager.selectionMode === "multiple" ? {
      "aria-multiselectable": "true"
    } : {}, {
      role: "listbox",
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(fieldProps, listProps)
    })
  };
}
function $293f70390ea03370$export$497855f14858aa34(props, state, ref) {
  var _item_props;
  let { key } = props;
  let data = (0, $b1f0cad8af73213b$export$3585ede4d035bf14).get(state);
  var _props_isDisabled;
  let isDisabled = (_props_isDisabled = props.isDisabled) !== null && _props_isDisabled !== void 0 ? _props_isDisabled : state.disabledKeys.has(key);
  var _props_isSelected;
  let isSelected = (_props_isSelected = props.isSelected) !== null && _props_isSelected !== void 0 ? _props_isSelected : state.selectionManager.isSelected(key);
  var _props_shouldSelectOnPressUp;
  let shouldSelectOnPressUp = (_props_shouldSelectOnPressUp = props.shouldSelectOnPressUp) !== null && _props_shouldSelectOnPressUp !== void 0 ? _props_shouldSelectOnPressUp : data === null || data === void 0 ? void 0 : data.shouldSelectOnPressUp;
  var _props_shouldFocusOnHover;
  let shouldFocusOnHover = (_props_shouldFocusOnHover = props.shouldFocusOnHover) !== null && _props_shouldFocusOnHover !== void 0 ? _props_shouldFocusOnHover : data === null || data === void 0 ? void 0 : data.shouldFocusOnHover;
  var _props_shouldUseVirtualFocus;
  let shouldUseVirtualFocus = (_props_shouldUseVirtualFocus = props.shouldUseVirtualFocus) !== null && _props_shouldUseVirtualFocus !== void 0 ? _props_shouldUseVirtualFocus : data === null || data === void 0 ? void 0 : data.shouldUseVirtualFocus;
  var _props_isVirtualized;
  let isVirtualized = (_props_isVirtualized = props.isVirtualized) !== null && _props_isVirtualized !== void 0 ? _props_isVirtualized : data === null || data === void 0 ? void 0 : data.isVirtualized;
  let labelId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let optionProps = {
    role: "option",
    "aria-disabled": isDisabled || void 0,
    "aria-selected": state.selectionManager.selectionMode !== "none" ? isSelected : void 0
  };
  if (!((0, $c87311424ea30a05$export$9ac100e40613ea10)() && (0, $c87311424ea30a05$export$78551043582a6a98)())) {
    optionProps["aria-label"] = props["aria-label"];
    optionProps["aria-labelledby"] = labelId;
    optionProps["aria-describedby"] = descriptionId;
  }
  let item2 = state.collection.getItem(key);
  if (isVirtualized) {
    let index2 = Number(item2 === null || item2 === void 0 ? void 0 : item2.index);
    optionProps["aria-posinset"] = Number.isNaN(index2) ? void 0 : index2 + 1;
    optionProps["aria-setsize"] = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state.collection);
  }
  let { itemProps, isPressed, isFocused, hasAction, allowsSelection } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key,
    ref,
    shouldSelectOnPressUp,
    allowsDifferentPressOrigin: shouldSelectOnPressUp && shouldFocusOnHover,
    isVirtualized,
    shouldUseVirtualFocus,
    isDisabled,
    onAction: (data === null || data === void 0 ? void 0 : data.onAction) ? () => {
      var _data_onAction;
      return data === null || data === void 0 ? void 0 : (_data_onAction = data.onAction) === null || _data_onAction === void 0 ? void 0 : _data_onAction.call(data, key);
    } : void 0,
    linkBehavior: data === null || data === void 0 ? void 0 : data.linkBehavior
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled: isDisabled || !shouldFocusOnHover,
    onHoverStart() {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()) {
        state.selectionManager.setFocused(true);
        state.selectionManager.setFocusedKey(key);
      }
    }
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(item2 === null || item2 === void 0 ? void 0 : item2.props, {
    isLink: !!(item2 === null || item2 === void 0 ? void 0 : (_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.href)
  });
  delete domProps.id;
  return {
    optionProps: {
      ...optionProps,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, itemProps, hoverProps),
      id: (0, $b1f0cad8af73213b$export$9145995848b05025)(state, key)
    },
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    isFocused,
    isFocusVisible: isFocused && (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)(),
    isSelected,
    isDisabled,
    isPressed,
    allowsSelection,
    hasAction
  };
}
function $af383d3bef1cfdc9$export$c3f9f39876e4bc7(props) {
  let { heading: heading2, "aria-label": ariaLabel } = props;
  let headingId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: heading2 ? {
      // Techincally, listbox cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a visual label for the nested group.
      id: headingId,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": ariaLabel,
      "aria-labelledby": heading2 ? headingId : void 0
    }
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/listbox/dist/keystar-ui-listbox.esm.js
var ListItem = forwardRefWithAs(function ListItem2(props, forwardedRef) {
  let {
    children,
    elementType: ElementType = "div",
    descriptionProps,
    keyboardShortcutProps,
    labelProps,
    isFocused,
    isHovered,
    isPressed,
    isSelected,
    ...otherProps
  } = props;
  let gridGutter = tokenSchema.size.space.regular;
  let contentGutter = tokenSchema.size.space.medium;
  let focusIndicatorWidth = tokenSchema.size.space.xsmall;
  let gridClassname = css({
    display: "grid",
    // listboxes (options) have selection indicators at the end, whilst menus have them at the start
    gridTemplateAreas: '". icon text . kbd checkmark ." ". icon description . kbd checkmark ."',
    gridTemplateColumns: `${gridGutter} auto 1fr ${contentGutter} auto ${tokenSchema.size.icon.regular} ${gridGutter}`,
    gridTemplateRows: "1fr auto",
    borderRadius: tokenSchema.size.radius.small,
    paddingBlock: tokenSchema.size.space.regular
  });
  let rootClassname = css({
    cursor: "default",
    color: tokenSchema.color.alias.foregroundIdle,
    display: "block",
    outline: 0,
    position: "relative",
    paddingInline: tokenSchema.size.space.small,
    // indicate when external link? e.g. `&[href^=http]`
    "a&": {
      cursor: "pointer"
    },
    "& .list-item-text": {
      marginBlock: `calc((${tokenSchema.size.icon.regular} - ${tokenSchema.typography.text.regular.capheight}) / 2)`
    },
    [`&:not([aria-disabled=true])`]: {
      "& .list-item-checkmark": {
        stroke: tokenSchema.color.alias.foregroundSelected
      },
      "& .list-item-text": {
        color: tokenSchema.color.foreground.neutralEmphasis
      },
      "& .list-item-icon": {
        color: tokenSchema.color.foreground.neutralSecondary
      }
    },
    // standard menu items: no selection indicator
    [`&[role=menuitem] .${gridClassname}`]: {
      gridTemplateAreas: '". icon text . kbd ." ". icon description . kbd ."',
      gridTemplateColumns: `${gridGutter} auto 1fr ${contentGutter} auto ${gridGutter}`
    },
    [[
      // selectable menu items: selection indicator at the start
      `&[role=menuitemcheckbox] .${gridClassname}, &[role=menuitemradio] .${gridClassname}`,
      // menus with _any_ selectable items must make space for the selection indicator
      `[data-selection=single] &[role=menuitem] .${gridClassname}, [data-selection=multiple] &[role=menuitem] .${gridClassname}`
    ].join(", ")]: {
      gridTemplateAreas: '". checkmark icon text . kbd ." ". checkmark icon description . kbd ."',
      gridTemplateColumns: `${tokenSchema.size.space.small} ${tokenSchema.size.icon.medium} auto 1fr ${contentGutter} auto ${gridGutter}`
    },
    // hover
    [`&[aria-disabled=false]:hover .${gridClassname}, &[data-hovered] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered,
      color: tokenSchema.color.alias.foregroundHovered
    },
    // focus
    [`&[aria-disabled=false]:focus .${gridClassname}, &[data-focused] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered,
      color: tokenSchema.color.alias.foregroundHovered
    },
    // emphasise `kbd` during interaction
    "&[aria-disabled=false]:hover kbd, &[data-hovered] kbd, &[aria-disabled=false]:focus kbd, &[data-focused] kbd": {
      color: tokenSchema.color.alias.foregroundIdle
    },
    // press
    [`&[aria-disabled=false]:active .${gridClassname}, &[data-pressed] .${gridClassname}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundPressed,
      color: tokenSchema.color.alias.foregroundPressed
    },
    // focus indicator
    "&[data-focused]": {
      // [`& .${gridClassname}`]: {
      //   backgroundColor: tokenSchema.color.alias.backgroundSelected,
      // },
      "&::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        borderRadius: focusIndicatorWidth,
        content: '""',
        insetBlock: tokenSchema.size.space.xsmall,
        insetInlineStart: 0,
        position: "absolute",
        width: focusIndicatorWidth
      }
    },
    // disabled
    "&[aria-disabled=true]": {
      color: tokenSchema.color.alias.foregroundDisabled,
      "& kbd": {
        color: "currentColor"
      },
      "& .list-item-checkmark": {
        stroke: "currentColor"
      }
    }
  });
  const slots = {
    text: {
      ...labelProps,
      color: "inherit",
      gridArea: "text",
      weight: "medium",
      UNSAFE_className: "list-item-text"
    },
    icon: {
      gridArea: "icon",
      marginEnd: "regular",
      UNSAFE_className: "list-item-icon"
    },
    description: {
      color: "neutralSecondary",
      gridArea: "description",
      marginY: "small",
      size: "small",
      ...descriptionProps
    },
    kbd: {
      UNSAFE_className: css({
        alignItems: "center",
        color: tokenSchema.color.foreground.neutralTertiary,
        display: "flex",
        gridArea: "kbd",
        height: tokenSchema.size.icon.regular
      }),
      ...keyboardShortcutProps
    }
  };
  return (0, import_jsx_runtime33.jsx)(
    ElementType,
    {
      ...toDataAttributes({
        focused: isFocused || void 0,
        hovered: isHovered || void 0,
        pressed: isPressed || void 0
      }),
      ...otherProps,
      ref: forwardedRef,
      className: classNames(rootClassname),
      children: (0, import_jsx_runtime33.jsx)("div", {
        className: gridClassname,
        children: (0, import_jsx_runtime33.jsx)(ClearSlots, {
          children: (0, import_jsx_runtime33.jsxs)(SlotProvider, {
            slots,
            children: [children, isSelected && (0, import_jsx_runtime33.jsx)(Icon, {
              src: checkIcon,
              slot: "checkmark",
              strokeScaling: false,
              gridArea: "checkmark",
              UNSAFE_className: "list-item-checkmark"
            })]
          })
        })
      })
    }
  );
});
var localizedMessages6 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    loadingMore: "جارٍ تحميل المزيد..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    loadingMore: "Зареждане на още..."
  },
  "cs-CZ": {
    loading: "Načítání...",
    loadingMore: "Načítání dalších..."
  },
  "da-DK": {
    loading: "Indlæser ...",
    loadingMore: "Indlæser flere ..."
  },
  "de-DE": {
    loading: "Laden...",
    loadingMore: "Mehr laden ..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    loadingMore: "Φόρτωση περισσότερων..."
  },
  "en-US": {
    loading: "Loading…",
    loadingMore: "Loading more…"
  },
  "es-ES": {
    loading: "Cargando…",
    loadingMore: "Cargando más…"
  },
  "et-EE": {
    loading: "Laadimine...",
    loadingMore: "Laadi rohkem..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    loadingMore: "Ladataan lisää…"
  },
  "fr-FR": {
    loading: "Chargement...",
    loadingMore: "Chargement supplémentaire..."
  },
  "he-IL": {
    loading: "טוען...",
    loadingMore: "טוען עוד..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    loadingMore: "Továbbiak betöltése folyamatban…"
  },
  "it-IT": {
    loading: "Caricamento...",
    loadingMore: "Caricamento altri..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    loadingMore: "さらに読み込み中..."
  },
  "ko-KR": {
    loading: "로드 중",
    loadingMore: "추가 로드 중"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    loadingMore: "Įkeliama daugiau..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    loadingMore: "Tiek ielādēts vēl..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    loadingMore: "Laster inn flere ..."
  },
  "nl-NL": {
    loading: "Laden...",
    loadingMore: "Meer laden..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    loadingMore: "Wczytywanie większej liczby..."
  },
  "pt-BR": {
    loading: "Carregando...",
    loadingMore: "Carregando mais..."
  },
  "pt-PT": {
    loading: "A carregar...",
    loadingMore: "A carregar mais..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    loadingMore: "Se încarcă mai multe..."
  },
  "ru-RU": {
    loading: "Загрузка...",
    loadingMore: "Дополнительная загрузка..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    loadingMore: "Načítava sa viac..."
  },
  "sl-SI": {
    loading: "Nalaganje...",
    loadingMore: "Nalaganje več vsebine..."
  },
  "sr-SP": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "sv-SE": {
    loading: "Läser in...",
    loadingMore: "Läser in mer..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    loadingMore: "Daha fazla yükleniyor..."
  },
  "uk-UA": {
    loading: "Завантаження…",
    loadingMore: "Завантаження інших об’єктів..."
  },
  "zh-CN": {
    loading: "正在加载...",
    loadingMore: "正在加载更多..."
  },
  "zh-T": {
    loading: "正在載入",
    loadingMore: "正在載入更多…"
  }
};
var ListBoxContext = (0, import_react54.createContext)(null);
function useListBoxContext() {
  let context = (0, import_react54.useContext)(ListBoxContext);
  assert(!!context, "ListBoxContext is missing");
  return context;
}
function ListBoxOption(props) {
  let {
    item: item2,
    shouldSelectOnPressUp,
    shouldFocusOnHover,
    shouldUseVirtualFocus
  } = props;
  let {
    rendered,
    key
  } = item2;
  let state = useListBoxContext();
  let ref = (0, import_react54.useRef)(null);
  let {
    optionProps,
    labelProps,
    descriptionProps,
    isSelected,
    isDisabled,
    isFocused,
    isPressed
  } = $293f70390ea03370$export$497855f14858aa34({
    "aria-label": item2["aria-label"],
    key,
    shouldSelectOnPressUp,
    shouldFocusOnHover,
    isVirtualized: true,
    shouldUseVirtualFocus
  }, state, ref);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    ...props,
    isDisabled
  });
  let {
    isFocusVisible: isFocusVisible$1,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let contents = isReactText(rendered) ? (0, import_jsx_runtime33.jsx)(Text, {
    children: rendered
  }) : rendered;
  let isKeyboardModality = $507fabe10e71c6fb$export$b9b3dfddab17db27();
  return (0, import_jsx_runtime33.jsx)(ListItem, {
    descriptionProps,
    labelProps,
    isFocused: shouldUseVirtualFocus ? isFocused && isKeyboardModality : isFocusVisible$1,
    isHovered: isHovered && !shouldFocusOnHover || isFocused && !isKeyboardModality,
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(optionProps, focusProps, shouldFocusOnHover ? {} : hoverProps),
    isPressed,
    isSelected,
    ref,
    children: contents
  });
}
function ListBoxSection(props) {
  let {
    children,
    layoutInfo,
    headerLayoutInfo,
    virtualizer,
    item: item2
  } = props;
  let {
    headingProps,
    groupProps
  } = $af383d3bef1cfdc9$export$c3f9f39876e4bc7({
    heading: item2.rendered,
    "aria-label": item2["aria-label"]
  });
  let headerRef = (0, import_react54.useRef)(null);
  $47736c1e63ba1c6d$export$1da781778207e0a2({
    layoutInfo: headerLayoutInfo,
    virtualizer,
    ref: headerRef
  });
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let state = useListBoxContext();
  return (0, import_jsx_runtime33.jsxs)(import_react54.Fragment, {
    children: [(0, import_jsx_runtime33.jsxs)("div", {
      role: "presentation",
      ref: headerRef,
      style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(headerLayoutInfo, direction),
      children: [item2.key !== state.collection.getFirstKey() && (0, import_jsx_runtime33.jsx)(Divider, {
        role: "presentation",
        elementType: "div",
        size: "medium",
        UNSAFE_className: css({
          margin: tokenSchema.size.space.medium
        })
      }), item2.rendered && (0, import_jsx_runtime33.jsx)(Text, {
        ...headingProps,
        casing: "uppercase",
        color: "neutralSecondary",
        size: "small",
        weight: "medium",
        UNSAFE_className: css({
          padding: tokenSchema.size.space.medium
        }),
        children: item2.rendered
      })]
    }), (0, import_jsx_runtime33.jsx)("div", {
      ...groupProps,
      style: $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(layoutInfo, direction),
      className: classNames(css({}), "ListBoxSection"),
      children
    })]
  });
}
function useListBoxLayout(state) {
  let {
    scale
  } = useProvider();
  let collator = $325a3faab7a68acd$export$a16aca283550c30d({
    usage: "search",
    sensitivity: "base"
  });
  let layout = (0, import_react54.useMemo)(() => new $61ef60fc9b1041f4$export$cacbb3924155d68e({
    estimatedRowHeight: scale === "large" ? 48 : 32,
    estimatedHeadingHeight: scale === "large" ? 33 : 26,
    padding: scale === "large" ? 5 : 4,
    loaderHeight: 40,
    placeholderHeight: scale === "large" ? 48 : 32,
    collator
  }), [collator, scale]);
  layout.collection = state.collection;
  layout.disabledKeys = state.disabledKeys;
  return layout;
}
function ListBoxBase(props, forwardedRef) {
  let {
    layout,
    state,
    shouldSelectOnPressUp,
    focusOnPointerEnter,
    shouldUseVirtualFocus,
    domProps = {},
    transitionDuration = 0,
    onScroll
  } = props;
  let {
    listBoxProps
  } = $c132121280ec012d$export$50eacbbf140a3141({
    ...props,
    keyboardDelegate: layout,
    isVirtualized: true
  }, state, forwardedRef);
  let styleProps = useStyleProps(props);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages6);
  layout.isLoading = !!props.isLoading;
  let renderWrapper = (parent, reusableView, children, renderChildren) => {
    if (reusableView.viewType === "section") {
      var _children$find;
      return (0, import_jsx_runtime33.jsx)(ListBoxSection, {
        item: reusableView.content,
        layoutInfo: reusableView.layoutInfo,
        virtualizer: reusableView.virtualizer,
        headerLayoutInfo: (_children$find = children.find((c5) => c5.viewType === "header")) === null || _children$find === void 0 ? void 0 : _children$find.layoutInfo,
        children: renderChildren(children.filter((c5) => c5.viewType === "item"))
      }, reusableView.key);
    }
    return (0, import_jsx_runtime33.jsx)($ccf8a0a04e4175ae$export$6796df8ba7398521, {
      layoutInfo: reusableView.layoutInfo,
      virtualizer: reusableView.virtualizer,
      parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
      children: reusableView.rendered
    }, reusableView.key);
  };
  return (0, import_jsx_runtime33.jsx)(ListBoxContext.Provider, {
    value: state,
    children: (0, import_jsx_runtime33.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
      children: (0, import_jsx_runtime33.jsx)($6d0a5c394373ae64$export$89be5a243e59c4b2, {
        ...styleProps,
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(listBoxProps, domProps),
        ref: forwardedRef,
        focusedKey: state.selectionManager.focusedKey,
        autoFocus: !!props.autoFocus,
        sizeToFit: "height",
        scrollDirection: "vertical",
        layout,
        collection: state.collection,
        renderWrapper,
        transitionDuration,
        isLoading: props.isLoading,
        onLoadMore: props.onLoadMore,
        shouldUseVirtualFocus,
        onScroll,
        children: (type2, item2) => {
          if (type2 === "item") {
            return (0, import_jsx_runtime33.jsx)(ListBoxOption, {
              item: item2,
              shouldSelectOnPressUp,
              shouldFocusOnHover: focusOnPointerEnter,
              shouldUseVirtualFocus
            });
          } else if (type2 === "loader") {
            return (0, import_jsx_runtime33.jsx)("div", {
              role: "option",
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                height: "100%"
              },
              children: (0, import_jsx_runtime33.jsx)(ProgressCircle, {
                isIndeterminate: true,
                size: "small",
                "aria-label": state.collection.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
              })
            });
          } else if (type2 === "placeholder") {
            let emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
            if (emptyState == null) {
              return null;
            }
            return (0, import_jsx_runtime33.jsx)("div", {
              role: "option",
              children: emptyState
            });
          }
        }
      })
    })
  });
}
var _ListBoxBase = (0, import_react54.forwardRef)(ListBoxBase);
function ListBox(props, forwardedRef) {
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let state = $e72dd72e1c76a225$export$2f645645f7bca764(props);
  let layout = useListBoxLayout(state);
  return (0, import_jsx_runtime33.jsx)(_ListBoxBase, {
    ...props,
    ref: domRef,
    state,
    layout
  });
}
var _ListBox = (0, import_react54.forwardRef)(ListBox);
var listStyles = css({
  borderRadius: "inherit",
  maxHeight: "inherit",
  // maxWidth: tokenSchema.size.dialog.small,
  outline: 0,
  overflowY: "auto",
  paddingBlock: tokenSchema.size.space.small,
  userSelect: "none"
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/menu/dist/keystar-ui-menu.esm.js
var import_react58 = __toESM(require_react());

// node_modules/.pnpm/@react-aria+menu@3.11.2_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/menu/dist/import.mjs
var import_react55 = __toESM(require_react(), 1);
function $parcel$interopDefault4(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $2cbb7ca666678a14$exports = {};
var $c0398ad35c3639b7$exports = {};
$c0398ad35c3639b7$exports = {
  "longPressMessage": `اضغط مطولاً أو اضغط على Alt + السهم لأسفل لفتح القائمة`
};
var $7af657c4165927c3$exports = {};
$7af657c4165927c3$exports = {
  "longPressMessage": `Натиснете продължително или натиснете Alt+ стрелка надолу, за да отворите менюто`
};
var $d95d4da6d531ab81$exports = {};
$d95d4da6d531ab81$exports = {
  "longPressMessage": `Dlouhým stiskem nebo stisknutím kláves Alt + šipka dolů otevřete nabídku`
};
var $24ebda9c775dca17$exports = {};
$24ebda9c775dca17$exports = {
  "longPressMessage": `Langt tryk eller tryk på Alt + pil ned for at åbne menuen`
};
var $743e0dfca6cab1e9$exports = {};
$743e0dfca6cab1e9$exports = {
  "longPressMessage": `Drücken Sie lange oder drücken Sie Alt + Nach-unten, um das Menü zu öffnen`
};
var $a2f41026e05f1c84$exports = {};
$a2f41026e05f1c84$exports = {
  "longPressMessage": `Πιέστε παρατεταμένα ή πατήστε Alt + κάτω βέλος για να ανοίξετε το μενού`
};
var $43b800e97c901737$exports = {};
$43b800e97c901737$exports = {
  "longPressMessage": `Long press or press Alt + ArrowDown to open menu`
};
var $442f5f6ac211e29f$exports = {};
$442f5f6ac211e29f$exports = {
  "longPressMessage": `Mantenga pulsado o pulse Alt + flecha abajo para abrir el menú`
};
var $dff280acfeb2d8ac$exports = {};
$dff280acfeb2d8ac$exports = {
  "longPressMessage": `Menüü avamiseks vajutage pikalt või vajutage klahve Alt + allanool`
};
var $51608325613944d7$exports = {};
$51608325613944d7$exports = {
  "longPressMessage": `Avaa valikko painamalla pohjassa tai näppäinyhdistelmällä Alt + Alanuoli`
};
var $c4a1b1eabeaa87be$exports = {};
$c4a1b1eabeaa87be$exports = {
  "longPressMessage": `Appuyez de manière prolongée ou appuyez sur Alt + Flèche vers le bas pour ouvrir le menu.`
};
var $8c74815cdee18d1b$exports = {};
$8c74815cdee18d1b$exports = {
  "longPressMessage": `לחץ לחיצה ארוכה או הקש Alt + ArrowDown כדי לפתוח את התפריט`
};
var $fd0e9ef6a7fe0ec9$exports = {};
$fd0e9ef6a7fe0ec9$exports = {
  "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika`
};
var $a89a74a39eba465a$exports = {};
$a89a74a39eba465a$exports = {
  "longPressMessage": `Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyíl gombot a menü megnyitásához`
};
var $edc7c66594a0ae8a$exports = {};
$edc7c66594a0ae8a$exports = {
  "longPressMessage": `Premere a lungo o premere Alt + Freccia giù per aprire il menu`
};
var $f1ab51510712db52$exports = {};
$f1ab51510712db52$exports = {
  "longPressMessage": `長押しまたは Alt+下矢印キーでメニューを開く`
};
var $f9b672d9b82fa3d6$exports = {};
$f9b672d9b82fa3d6$exports = {
  "longPressMessage": `길게 누르거나 Alt + 아래쪽 화살표를 눌러 메뉴 열기`
};
var $a385f3910feda499$exports = {};
$a385f3910feda499$exports = {
  "longPressMessage": `Norėdami atidaryti meniu, nuspaudę palaikykite arba paspauskite „Alt + ArrowDown“.`
};
var $4f1bde932c441789$exports = {};
$4f1bde932c441789$exports = {
  "longPressMessage": `Lai atvērtu izvēlni, turiet nospiestu vai nospiediet taustiņu kombināciju Alt + lejupvērstā bultiņa`
};
var $914a51a8a594d5be$exports = {};
$914a51a8a594d5be$exports = {
  "longPressMessage": `Langt trykk eller trykk Alt + PilNed for å åpne menyen`
};
var $89aaf803103bb500$exports = {};
$89aaf803103bb500$exports = {
  "longPressMessage": `Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen`
};
var $c685891476dbaaca$exports = {};
$c685891476dbaaca$exports = {
  "longPressMessage": `Naciśnij i przytrzymaj lub naciśnij klawisze Alt + Strzałka w dół, aby otworzyć menu`
};
var $885879b9b10c2959$exports = {};
$885879b9b10c2959$exports = {
  "longPressMessage": `Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu`
};
var $6b39616688a51692$exports = {};
$6b39616688a51692$exports = {
  "longPressMessage": `Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu`
};
var $f26362aed63f47e2$exports = {};
$f26362aed63f47e2$exports = {
  "longPressMessage": `Apăsați lung sau apăsați pe Alt + săgeată în jos pentru a deschide meniul`
};
var $06cbade644558bf0$exports = {};
$06cbade644558bf0$exports = {
  "longPressMessage": `Нажмите и удерживайте или нажмите Alt + Стрелка вниз, чтобы открыть меню`
};
var $0a391ff68f9d59b1$exports = {};
$0a391ff68f9d59b1$exports = {
  "longPressMessage": `Ponuku otvoríte dlhým stlačením alebo stlačením klávesu Alt + klávesu so šípkou nadol`
};
var $8193cf0e649c7928$exports = {};
$8193cf0e649c7928$exports = {
  "longPressMessage": `Za odprtje menija pritisnite in držite gumb ali pritisnite Alt+puščica navzdol`
};
var $f398debcce5a5c55$exports = {};
$f398debcce5a5c55$exports = {
  "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni`
};
var $9e9fef000aa4c013$exports = {};
$9e9fef000aa4c013$exports = {
  "longPressMessage": `Håll nedtryckt eller tryck på Alt + pil nedåt för att öppna menyn`
};
var $c016c8183bbe3d68$exports = {};
$c016c8183bbe3d68$exports = {
  "longPressMessage": `Menüyü açmak için uzun basın veya Alt + Aşağı Ok tuşuna basın`
};
var $ca4f6c8462244e62$exports = {};
$ca4f6c8462244e62$exports = {
  "longPressMessage": `Довго або звичайно натисніть комбінацію клавіш Alt і стрілка вниз, щоб відкрити меню`
};
var $2d9960c02ccac927$exports = {};
$2d9960c02ccac927$exports = {
  "longPressMessage": `长按或按 Alt + 向下方向键以打开菜单`
};
var $f1b682a4c8c5631c$exports = {};
$f1b682a4c8c5631c$exports = {
  "longPressMessage": `長按或按 Alt+向下鍵以開啟功能表`
};
$2cbb7ca666678a14$exports = {
  "ar-AE": $c0398ad35c3639b7$exports,
  "bg-BG": $7af657c4165927c3$exports,
  "cs-CZ": $d95d4da6d531ab81$exports,
  "da-DK": $24ebda9c775dca17$exports,
  "de-DE": $743e0dfca6cab1e9$exports,
  "el-GR": $a2f41026e05f1c84$exports,
  "en-US": $43b800e97c901737$exports,
  "es-ES": $442f5f6ac211e29f$exports,
  "et-EE": $dff280acfeb2d8ac$exports,
  "fi-FI": $51608325613944d7$exports,
  "fr-FR": $c4a1b1eabeaa87be$exports,
  "he-IL": $8c74815cdee18d1b$exports,
  "hr-HR": $fd0e9ef6a7fe0ec9$exports,
  "hu-HU": $a89a74a39eba465a$exports,
  "it-IT": $edc7c66594a0ae8a$exports,
  "ja-JP": $f1ab51510712db52$exports,
  "ko-KR": $f9b672d9b82fa3d6$exports,
  "lt-LT": $a385f3910feda499$exports,
  "lv-LV": $4f1bde932c441789$exports,
  "nb-NO": $914a51a8a594d5be$exports,
  "nl-NL": $89aaf803103bb500$exports,
  "pl-PL": $c685891476dbaaca$exports,
  "pt-BR": $885879b9b10c2959$exports,
  "pt-PT": $6b39616688a51692$exports,
  "ro-RO": $f26362aed63f47e2$exports,
  "ru-RU": $06cbade644558bf0$exports,
  "sk-SK": $0a391ff68f9d59b1$exports,
  "sl-SI": $8193cf0e649c7928$exports,
  "sr-SP": $f398debcce5a5c55$exports,
  "sv-SE": $9e9fef000aa4c013$exports,
  "tr-TR": $c016c8183bbe3d68$exports,
  "uk-UA": $ca4f6c8462244e62$exports,
  "zh-CN": $2d9960c02ccac927$exports,
  "zh-TW": $f1b682a4c8c5631c$exports
};
function $168583247155ddda$export$dc9c12ed27dd1b49(props, state, ref) {
  let { type: type2 = "menu", isDisabled, trigger: trigger2 = "press" } = props;
  let menuTriggerId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let { triggerProps, overlayProps } = (0, $628037886ba31236$export$f9d5c8beee7d008d)({
    type: type2
  }, state, ref);
  let onKeyDown = (e6) => {
    if (isDisabled)
      return;
    if (trigger2 === "longPress" && !e6.altKey)
      return;
    if (ref && ref.current)
      switch (e6.key) {
        case "Enter":
        case " ":
          if (trigger2 === "longPress")
            return;
        case "ArrowDown":
          if (!("continuePropagation" in e6))
            e6.stopPropagation();
          e6.preventDefault();
          state.toggle("first");
          break;
        case "ArrowUp":
          if (!("continuePropagation" in e6))
            e6.stopPropagation();
          e6.preventDefault();
          state.toggle("last");
          break;
        default:
          if ("continuePropagation" in e6)
            e6.continuePropagation();
      }
  };
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault4($2cbb7ca666678a14$exports)));
  let { longPressProps } = (0, $8a26561d2877236e$export$c24ed0104d07eab9)({
    isDisabled: isDisabled || trigger2 !== "longPress",
    accessibilityDescription: stringFormatter.format("longPressMessage"),
    onLongPressStart() {
      state.close();
    },
    onLongPress() {
      state.open("first");
    }
  });
  let pressProps = {
    onPressStart(e6) {
      if (e6.pointerType !== "touch" && e6.pointerType !== "keyboard" && !isDisabled)
        state.toggle(e6.pointerType === "virtual" ? "first" : null);
    },
    onPress(e6) {
      if (e6.pointerType === "touch" && !isDisabled)
        state.toggle();
    }
  };
  delete triggerProps.onPress;
  return {
    menuTriggerProps: {
      ...triggerProps,
      ...trigger2 === "press" ? pressProps : longPressProps,
      id: menuTriggerId,
      onKeyDown
    },
    menuProps: {
      ...overlayProps,
      "aria-labelledby": menuTriggerId,
      autoFocus: state.focusStrategy || true,
      onClose: state.close
    }
  };
}
var $d5336fe17ce95402$export$6f49b4016bfc8d56 = /* @__PURE__ */ new WeakMap();
function $d5336fe17ce95402$export$38eaa17faae8f579(props, state, ref) {
  let { shouldFocusWrap = true, ...otherProps } = props;
  if (!props["aria-label"] && !props["aria-labelledby"])
    console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { listProps } = (0, $982254629710d113$export$b95089534ab7c1fd)({
    ...otherProps,
    ref,
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    shouldFocusWrap,
    linkBehavior: "override"
  });
  $d5336fe17ce95402$export$6f49b4016bfc8d56.set(state, {
    onClose: props.onClose,
    onAction: props.onAction
  });
  return {
    menuProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      role: "menu",
      // this forces AT to move their cursors into any open sub dialogs, the sub dialogs contain hidden close buttons in order to come back to this level of the menu
      "aria-hidden": state.expandedKeys.size > 0 ? true : void 0,
      ...listProps,
      onKeyDown: (e6) => {
        if (e6.key !== "Escape")
          listProps.onKeyDown(e6);
      }
    })
  };
}
function $a2e5df62f93c7633$export$9d32628fc2aea7da(props, state, ref) {
  var _item_props;
  let { key, closeOnSelect, isVirtualized, "aria-haspopup": hasPopup } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let isTrigger = !!hasPopup;
  let isOpen = state.expandedKeys.has(key);
  var _props_isDisabled;
  let isDisabled = (_props_isDisabled = props.isDisabled) !== null && _props_isDisabled !== void 0 ? _props_isDisabled : state.disabledKeys.has(key);
  var _props_isSelected;
  let isSelected = (_props_isSelected = props.isSelected) !== null && _props_isSelected !== void 0 ? _props_isSelected : state.selectionManager.isSelected(key);
  let openTimeout = (0, import_react55.useRef)();
  let cancelOpenTimeout = (0, import_react55.useCallback)(() => {
    if (openTimeout.current) {
      clearTimeout(openTimeout.current);
      openTimeout.current = void 0;
    }
  }, [
    openTimeout
  ]);
  let onSubmenuOpen = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    cancelOpenTimeout();
    state.setExpandedKeys(/* @__PURE__ */ new Set([
      key
    ]));
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    return () => cancelOpenTimeout();
  }, [
    cancelOpenTimeout
  ]);
  let data = (0, $d5336fe17ce95402$export$6f49b4016bfc8d56).get(state);
  let onClose = props.onClose || data.onClose;
  let onActionMenuDialogTrigger = (0, import_react55.useCallback)(() => {
    onSubmenuOpen();
  }, []);
  let onAction = isTrigger ? onActionMenuDialogTrigger : props.onAction || data.onAction;
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let performAction = (e6) => {
    if (onAction)
      onAction(key);
    if (e6.target instanceof HTMLAnchorElement)
      router.open(e6.target, e6);
  };
  let role = "menuitem";
  if (state.selectionManager.selectionMode === "single")
    role = "menuitemradio";
  else if (state.selectionManager.selectionMode === "multiple")
    role = "menuitemcheckbox";
  let labelId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let keyboardId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let ariaProps = {
    "aria-disabled": isDisabled || void 0,
    role,
    "aria-label": props["aria-label"],
    "aria-labelledby": labelId,
    "aria-describedby": [
      descriptionId,
      keyboardId
    ].filter(Boolean).join(" ") || void 0
  };
  if (state.selectionManager.selectionMode !== "none")
    ariaProps["aria-checked"] = isSelected;
  let item2 = state.collection.getItem(key);
  if (isVirtualized) {
    ariaProps["aria-posinset"] = item2 === null || item2 === void 0 ? void 0 : item2.index;
    ariaProps["aria-setsize"] = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state.collection);
  }
  if (hasPopup != null) {
    ariaProps["aria-haspopup"] = hasPopup;
    ariaProps["aria-expanded"] = isOpen ? "true" : "false";
  }
  let onPressStart = (e6) => {
    if (e6.pointerType === "keyboard")
      performAction(e6);
  };
  let onPressUp = (e6) => {
    if (e6.pointerType !== "keyboard") {
      performAction(e6);
      if (!isTrigger && onClose && (closeOnSelect !== null && closeOnSelect !== void 0 ? closeOnSelect : state.selectionManager.selectionMode !== "multiple" || state.selectionManager.isLink(key)))
        onClose();
    }
  };
  let { itemProps, isFocused } = (0, $880e95eb8b93ba9a$export$ecf600387e221c37)({
    selectionManager: state.selectionManager,
    key,
    ref,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    // Disable all handling of links in useSelectable item
    // because we handle it ourselves. The behavior of menus
    // is slightly different from other collections because
    // actions are performed on key down rather than key up.
    linkBehavior: "none"
  });
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    onPressStart,
    onPressUp,
    isDisabled: isDisabled || isTrigger && state.expandedKeys.has(key)
  });
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    isDisabled,
    onHoverStart() {
      if (!(0, $507fabe10e71c6fb$export$b9b3dfddab17db27)() && !(isTrigger && state.expandedKeys.has(key))) {
        state.selectionManager.setFocused(true);
        state.selectionManager.setFocusedKey(key);
        let isFocused2 = key === state.selectionManager.focusedKey;
        if (isFocused2 && state.selectionManager.isFocused && document.activeElement !== ref.current)
          (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
      }
    },
    onHoverChange: (isHovered) => {
      if (isHovered && isTrigger && !state.expandedKeys.has(key)) {
        if (!openTimeout.current)
          openTimeout.current = setTimeout(() => {
            onSubmenuOpen();
          }, 200);
      } else if (!isHovered)
        cancelOpenTimeout();
    }
  });
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)({
    onKeyDown: (e6) => {
      if (e6.repeat) {
        e6.continuePropagation();
        return;
      }
      switch (e6.key) {
        case " ":
          if (!isDisabled && state.selectionManager.selectionMode === "none" && !isTrigger && closeOnSelect !== false && onClose)
            onClose();
          break;
        case "Enter":
          if (!isDisabled && closeOnSelect !== false && !isTrigger && onClose)
            onClose();
          break;
        case "ArrowRight":
          if (isTrigger && direction === "ltr")
            onSubmenuOpen();
          else
            e6.continuePropagation();
          break;
        case "ArrowLeft":
          if (isTrigger && direction === "rtl")
            onSubmenuOpen();
          else
            e6.continuePropagation();
          break;
        default:
          e6.continuePropagation();
          break;
      }
    }
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(item2.props, {
    isLink: !!(item2 === null || item2 === void 0 ? void 0 : (_item_props = item2.props) === null || _item_props === void 0 ? void 0 : _item_props.href)
  });
  delete domProps.id;
  return {
    menuItemProps: {
      ...ariaProps,
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, itemProps, pressProps, hoverProps, keyboardProps)
    },
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    keyboardShortcutProps: {
      id: keyboardId
    },
    isFocused,
    isSelected,
    isPressed,
    isDisabled
  };
}
function $3e5eb2498db5b506$export$73f7a44322579622(props) {
  let { heading: heading2, "aria-label": ariaLabel } = props;
  let headingId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: heading2 ? {
      // Techincally, menus cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a label for the nested group.
      id: headingId,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": ariaLabel,
      "aria-labelledby": heading2 ? headingId : void 0
    }
  };
}

// node_modules/.pnpm/@react-stately+tree@3.7.4_react@18.2.0/node_modules/@react-stately/tree/dist/import.mjs
var import_react56 = __toESM(require_react(), 1);
var $05ca4cd7c4a5a999$export$863faf230ee2118a = class {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node3 = this.keyMap.get(key);
    return node3 ? node3.prevKey : null;
  }
  getKeyAfter(key) {
    let node3 = this.keyMap.get(key);
    return node3 ? node3.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  constructor(nodes, { expandedKeys } = {}) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.iterable = nodes;
    expandedKeys = expandedKeys || /* @__PURE__ */ new Set();
    let visit2 = (node3) => {
      this.keyMap.set(node3.key, node3);
      if (node3.childNodes && (node3.type === "section" || expandedKeys.has(node3.key)))
        for (let child of node3.childNodes)
          visit2(child);
    };
    for (let node3 of nodes)
      visit2(node3);
    let last;
    let index2 = 0;
    for (let [key, node3] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node3.prevKey = last.key;
      } else {
        this.firstKey = key;
        node3.prevKey = void 0;
      }
      if (node3.type === "item")
        node3.index = index2++;
      last = node3;
      last.nextKey = void 0;
    }
    this.lastKey = last === null || last === void 0 ? void 0 : last.key;
  }
};
function $875d6693e12af071$export$728d6ba534403756(props) {
  let [expandedKeys, setExpandedKeys] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.expandedKeys ? new Set(props.expandedKeys) : void 0, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : /* @__PURE__ */ new Set(), props.onExpandedChange);
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react56.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let tree2 = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, (0, import_react56.useCallback)((nodes) => new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {
    expandedKeys
  }), [
    expandedKeys
  ]), null);
  (0, import_react56.useEffect)(() => {
    if (selectionState.focusedKey != null && !tree2.getItem(selectionState.focusedKey))
      selectionState.setFocusedKey(null);
  }, [
    tree2,
    selectionState.focusedKey
  ]);
  let onToggle = (key) => {
    setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));
  };
  return {
    collection: tree2,
    expandedKeys,
    disabledKeys,
    toggleKey: onToggle,
    setExpandedKeys,
    selectionManager: new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(tree2, selectionState)
  };
}
function $875d6693e12af071$var$toggleKey(set, key) {
  let res = new Set(set);
  if (res.has(key))
    res.delete(key);
  else
    res.add(key);
  return res;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/menu/dist/keystar-ui-menu.esm.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-stately+menu@3.5.7_react@18.2.0/node_modules/@react-stately/menu/dist/import.mjs
var import_react57 = __toESM(require_react(), 1);
function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {
  let overlayTriggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let [focusStrategy, setFocusStrategy] = (0, import_react57.useState)(null);
  return {
    focusStrategy,
    ...overlayTriggerState,
    open(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.open();
    },
    toggle(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.toggle();
    }
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/moreHorizontalIcon/dist/keystar-ui-icon-icons-moreHorizontalIcon.esm.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var moreHorizontalIcon = (0, import_jsx_runtime34.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime34.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime34.jsx)("circle", {
    cx: 19,
    cy: 12,
    r: 1
  }), (0, import_jsx_runtime34.jsx)("circle", {
    cx: 5,
    cy: 12,
    r: 1
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/menu/dist/keystar-ui-menu.esm.js
var localizedMessages7 = {
  "ar-AE": {
    moreActions: "المزيد من الإجراءات"
  },
  "bg-BG": {
    moreActions: "Повече действия"
  },
  "cs-CZ": {
    moreActions: "Další akce"
  },
  "da-DK": {
    moreActions: "Flere handlinger"
  },
  "de-DE": {
    moreActions: "Mehr Aktionen"
  },
  "el-GR": {
    moreActions: "Περισσότερες ενέργειες"
  },
  "en-US": {
    moreActions: "More actions"
  },
  "es-ES": {
    moreActions: "Más acciones"
  },
  "et-EE": {
    moreActions: "Veel toiminguid"
  },
  "fi-FI": {
    moreActions: "Lisää toimintoja"
  },
  "fr-FR": {
    moreActions: "Autres actions"
  },
  "he-IL": {
    moreActions: "פעולות נוספות"
  },
  "hr-HR": {
    moreActions: "Dodatne radnje"
  },
  "hu-HU": {
    moreActions: "További lehetőségek"
  },
  "it-IT": {
    moreActions: "Altre azioni"
  },
  "ja-JP": {
    moreActions: "その他のアクション"
  },
  "ko-KR": {
    moreActions: "기타 작업"
  },
  "lt-LT": {
    moreActions: "Daugiau veiksmų"
  },
  "lv-LV": {
    moreActions: "Citas darbības"
  },
  "nb-NO": {
    moreActions: "Flere handlinger"
  },
  "nl-NL": {
    moreActions: "Meer handelingen"
  },
  "pl-PL": {
    moreActions: "Więcej akcji"
  },
  "pt-BR": {
    moreActions: "Mais ações"
  },
  "pt-PT": {
    moreActions: "Mais ações"
  },
  "ro-RO": {
    moreActions: "Mai multe acțiuni"
  },
  "ru-RU": {
    moreActions: "Дополнительные действия"
  },
  "sk-SK": {
    moreActions: "Ďalšie akcie"
  },
  "sl-SI": {
    moreActions: "Več možnosti"
  },
  "sr-SP": {
    moreActions: "Dodatne radnje"
  },
  "sv-SE": {
    moreActions: "Fler åtgärder"
  },
  "tr-TR": {
    moreActions: "Daha fazla eylem"
  },
  "uk-UA": {
    moreActions: "Більше дій"
  },
  "zh-CN": {
    moreActions: "更多操作"
  },
  "zh-TW": {
    moreActions: "更多動作"
  }
};
var MenuContext = import_react58.default.createContext({});
function useMenuContext() {
  return (0, import_react58.useContext)(MenuContext);
}
function MenuItem(props) {
  let {
    item: item2,
    state,
    isVirtualized,
    onAction
  } = props;
  let {
    onClose,
    closeOnSelect
  } = useMenuContext();
  let {
    rendered,
    key
  } = item2;
  let isSelected = state.selectionManager.isSelected(key);
  let isDisabled = state.selectionManager.isDisabled(key);
  let ref = (0, import_react58.useRef)(null);
  let {
    menuItemProps,
    labelProps,
    descriptionProps,
    keyboardShortcutProps
  } = $a2e5df62f93c7633$export$9d32628fc2aea7da({
    isSelected,
    isDisabled,
    "aria-label": item2["aria-label"],
    key,
    onClose,
    closeOnSelect,
    isVirtualized,
    onAction
  }, state, ref);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let {
    focusProps,
    isFocusVisible
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let contents = isReactText(rendered) ? (0, import_jsx_runtime35.jsx)(Text, {
    children: rendered
  }) : rendered;
  let role = state.selectionManager.disabledBehavior === "selection" && state.disabledKeys.has(key) ? "menuitem" : void 0;
  return (0, import_jsx_runtime35.jsx)(ListItem, {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(menuItemProps, {
      role
    }, hoverProps, focusProps),
    elementType: item2.props.href ? "a" : "div",
    descriptionProps,
    keyboardShortcutProps,
    labelProps,
    isHovered,
    isFocused: isFocusVisible,
    isSelected,
    ref,
    children: contents
  });
}
function MenuSection(props) {
  let {
    item: item2,
    state,
    onAction
  } = props;
  let {
    itemProps,
    headingProps,
    groupProps
  } = $3e5eb2498db5b506$export$73f7a44322579622({
    heading: item2.rendered,
    "aria-label": item2["aria-label"]
  });
  let {
    separatorProps
  } = $f4b273590fab9f93$export$52210f68a14655d0({});
  return (0, import_jsx_runtime35.jsxs)(import_react58.Fragment, {
    children: [item2.key !== state.collection.getFirstKey() && (0, import_jsx_runtime35.jsx)(Divider, {
      ...separatorProps,
      marginY: "small"
    }), (0, import_jsx_runtime35.jsxs)("div", {
      ...itemProps,
      children: [item2.rendered && (0, import_jsx_runtime35.jsx)(Text, {
        casing: "uppercase",
        size: "small",
        color: "neutralSecondary",
        weight: "medium",
        UNSAFE_className: css({
          paddingBlock: tokenSchema.size.space.regular,
          paddingInline: tokenSchema.size.space.medium
        }),
        ...headingProps,
        children: item2.rendered
      }), (0, import_jsx_runtime35.jsx)("div", {
        ...groupProps,
        children: [...$c5a24bc478652b5f$export$1005530eda016c13(item2, state.collection)].map((node3) => {
          let item3 = (0, import_jsx_runtime35.jsx)(MenuItem, {
            item: node3,
            state,
            onAction
          }, node3.key);
          if (node3.wrapper) {
            item3 = node3.wrapper(item3);
          }
          return item3;
        })
      })]
    })]
  });
}
function Menu(props, forwardedRef) {
  let contextProps = (0, import_react58.useContext)(MenuContext);
  let completeProps = {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(contextProps, props)
  };
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let state = $875d6693e12af071$export$728d6ba534403756(completeProps);
  let {
    menuProps
  } = $d5336fe17ce95402$export$38eaa17faae8f579(completeProps, state, domRef);
  let styleProps = useStyleProps(completeProps);
  $e7801be82b4b2a53$export$4debdb1a3f0fa79e(contextProps, domRef);
  return (0, import_jsx_runtime35.jsx)("div", {
    ...menuProps,
    ...styleProps,
    ref: domRef,
    className: classNames(listStyles, styleProps.className),
    "data-selection": state.selectionManager.selectionMode,
    children: [...state.collection].map((item2) => {
      if (item2.type === "section") {
        return (0, import_jsx_runtime35.jsx)(MenuSection, {
          item: item2,
          state,
          onAction: completeProps.onAction
        }, item2.key);
      }
      let menuItem = (0, import_jsx_runtime35.jsx)(MenuItem, {
        item: item2,
        state,
        onAction: completeProps.onAction
      }, item2.key);
      if (item2.wrapper) {
        menuItem = item2.wrapper(menuItem);
      }
      return menuItem;
    })
  });
}
var _Menu = import_react58.default.forwardRef(Menu);
var MenuTrigger = (0, import_react58.forwardRef)(function MenuTrigger2(props, forwardedRef) {
  let triggerRef = (0, import_react58.useRef)(null);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let menuTriggerRef = domRef || triggerRef;
  let menuRef = (0, import_react58.useRef)(null);
  let {
    children,
    align = "start",
    shouldFlip = true,
    direction = "bottom",
    closeOnSelect,
    trigger: trigger2 = "press"
  } = props;
  let [menuTrigger, menu] = import_react58.default.Children.toArray(children);
  let state = $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props);
  let {
    menuTriggerProps,
    menuProps
  } = $168583247155ddda$export$dc9c12ed27dd1b49({
    trigger: trigger2
  }, state, menuTriggerRef);
  let initialPlacement;
  switch (direction) {
    case "left":
    case "right":
    case "start":
    case "end":
      initialPlacement = `${direction} ${align === "end" ? "bottom" : "top"}`;
      break;
    case "bottom":
    case "top":
    default:
      initialPlacement = `${direction} ${align}`;
  }
  let isMobile = useIsMobileDevice();
  let menuContext = {
    ...menuProps,
    ref: menuRef,
    onClose: state.close,
    closeOnSelect,
    autoFocus: state.focusStrategy || true,
    UNSAFE_style: isMobile ? {
      width: "100%",
      maxHeight: "inherit"
    } : {
      maxWidth: tokenSchema.size.dialog.xsmall
    }
  };
  let overlay;
  if (isMobile) {
    overlay = (0, import_jsx_runtime35.jsx)(Tray, {
      state,
      children: menu
    });
  } else {
    overlay = (0, import_jsx_runtime35.jsx)(Popover, {
      state,
      triggerRef: menuTriggerRef,
      scrollRef: menuRef,
      placement: initialPlacement,
      hideArrow: true,
      shouldFlip,
      children: menu
    });
  }
  return (0, import_jsx_runtime35.jsxs)(import_react58.Fragment, {
    children: [(0, import_jsx_runtime35.jsx)(SlotProvider, {
      slots: {
        actionButton: {
          holdAffordance: trigger2 === "longPress"
        }
      },
      children: (0, import_jsx_runtime35.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
        ...menuTriggerProps,
        ref: menuTriggerRef,
        isPressed: state.isOpen,
        children: menuTrigger
      })
    }), (0, import_jsx_runtime35.jsx)(MenuContext.Provider, {
      // TODO: Fix this type error
      // @ts-expect-error
      value: menuContext,
      children: overlay
    })]
  });
});
function ActionMenu(props, ref) {
  props = useSlotProps(props, "actionMenu");
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages7);
  let buttonProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
    labelable: true
  });
  if (buttonProps["aria-label"] === void 0) {
    buttonProps["aria-label"] = stringFormatter.format("moreActions");
  }
  return (0, import_jsx_runtime35.jsxs)(MenuTrigger, {
    isOpen: props.isOpen,
    defaultOpen: props.defaultOpen,
    onOpenChange: props.onOpenChange,
    align: props.align,
    direction: props.direction,
    shouldFlip: props.shouldFlip,
    children: [(0, import_jsx_runtime35.jsx)(ActionButton, {
      ref,
      ...props,
      ...buttonProps,
      children: (0, import_jsx_runtime35.jsx)(Icon, {
        src: moreHorizontalIcon
      })
    }), (0, import_jsx_runtime35.jsx)(_Menu, {
      children: props.children,
      items: props.items,
      disabledKeys: props.disabledKeys,
      onAction: props.onAction
    })]
  });
}
var _ActionMenu = (0, import_react58.forwardRef)(ActionMenu);

// node_modules/.pnpm/@react-aria+actiongroup@3.7.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/actiongroup/dist/import.mjs
var import_react59 = __toESM(require_react(), 1);
var $304ac34015d4535d$var$BUTTON_GROUP_ROLES = {
  "none": "toolbar",
  "single": "radiogroup",
  "multiple": "toolbar"
};
function $304ac34015d4535d$export$f4bf8d43c16de704(props, state, ref) {
  let { isDisabled, orientation = "horizontal" } = props;
  let [isInToolbar, setInToolbar] = (0, import_react59.useState)(false);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    var _ref_current_parentElement;
    setInToolbar(!!(ref.current && ((_ref_current_parentElement = ref.current.parentElement) === null || _ref_current_parentElement === void 0 ? void 0 : _ref_current_parentElement.closest('[role="toolbar"]'))));
  }, [
    ref
  ]);
  let allKeys = [
    ...state.collection.getKeys()
  ];
  if (!allKeys.some((key) => !state.disabledKeys.has(key)))
    isDisabled = true;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let focusManager = (0, $9bf71ea28793e738$export$c5251b9e124bf29)(ref);
  let flipDirection = direction === "rtl" && orientation === "horizontal";
  let onKeyDown = (e6) => {
    if (!e6.currentTarget.contains(e6.target))
      return;
    switch (e6.key) {
      case "ArrowRight":
      case "ArrowDown":
        e6.preventDefault();
        e6.stopPropagation();
        if (e6.key === "ArrowRight" && flipDirection)
          focusManager.focusPrevious({
            wrap: true
          });
        else
          focusManager.focusNext({
            wrap: true
          });
        break;
      case "ArrowLeft":
      case "ArrowUp":
        e6.preventDefault();
        e6.stopPropagation();
        if (e6.key === "ArrowLeft" && flipDirection)
          focusManager.focusNext({
            wrap: true
          });
        else
          focusManager.focusPrevious({
            wrap: true
          });
        break;
    }
  };
  let role = $304ac34015d4535d$var$BUTTON_GROUP_ROLES[state.selectionManager.selectionMode];
  if (isInToolbar && role === "toolbar")
    role = "group";
  return {
    actionGroupProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
        labelable: true
      }),
      role,
      "aria-orientation": role === "toolbar" ? orientation : void 0,
      "aria-disabled": isDisabled,
      onKeyDown
    }
  };
}
var $f0ac0fb73c3ec062$var$BUTTON_ROLES = {
  "none": void 0,
  "single": "radio",
  "multiple": "checkbox"
};
function $f0ac0fb73c3ec062$export$9597202bd3099a29(props, state, ref) {
  let selectionMode = state.selectionManager.selectionMode;
  let buttonProps = {
    role: $f0ac0fb73c3ec062$var$BUTTON_ROLES[selectionMode]
  };
  if (selectionMode !== "none") {
    let isSelected = state.selectionManager.isSelected(props.key);
    buttonProps["aria-checked"] = isSelected;
  }
  let isFocused = props.key === state.selectionManager.focusedKey;
  let onRemovedWithFocus = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(() => {
    if (isFocused)
      state.selectionManager.setFocusedKey(null);
  });
  (0, import_react59.useEffect)(() => {
    return () => {
      onRemovedWithFocus();
    };
  }, [
    onRemovedWithFocus
  ]);
  return {
    buttonProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(buttonProps, {
      tabIndex: isFocused || state.selectionManager.focusedKey == null ? 0 : -1,
      onFocus() {
        state.selectionManager.setFocusedKey(props.key);
      },
      onPress() {
        state.selectionManager.select(props.key);
      }
    })
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/action-group/dist/keystar-ui-action-group.esm.js
var import_react60 = __toESM(require_react());
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
function ActionGroup(props, forwardedRef) {
  props = useProviderProps(props);
  props = useSlotProps(props, "actionGroup");
  let {
    density,
    prominence,
    isJustified,
    isDisabled,
    orientation = "horizontal",
    overflowMode,
    onAction,
    buttonLabelBehavior,
    summaryIcon,
    ...otherProps
  } = props;
  prominence = prominence === "low" ? "low" : "default";
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let wrapperRef = (0, import_react60.useRef)(null);
  let state = $e72dd72e1c76a225$export$2f645645f7bca764({
    ...props,
    suppressTextValueWarning: true
  });
  let {
    actionGroupProps
  } = $304ac34015d4535d$export$f4bf8d43c16de704(props, state, domRef);
  let providerProps = {
    isDisabled
  };
  let styleProps = useStyleProps(props);
  let isIconCollapsible = (0, import_react60.useMemo)(() => [...state.collection].every((item2) => typeof item2.rendered !== "string"), [state.collection]);
  let [{
    visibleItems,
    hideButtonText,
    isMeasuring
  }, setVisibleItems] = $1dbecbe27a04f9af$export$14d238f342723f25({
    visibleItems: state.collection.size,
    hideButtonText: buttonLabelBehavior === "hide" && isIconCollapsible,
    isMeasuring: false
  });
  let selectionMode = state.selectionManager.selectionMode;
  let updateOverflow = (0, import_react60.useCallback)(() => {
    if (overflowMode !== "collapse") {
      return;
    }
    if (orientation === "vertical" && selectionMode !== "none") {
      return;
    }
    let computeVisibleItems = (visibleItems2) => {
      if (domRef.current && wrapperRef.current) {
        let listItems = Array.from(domRef.current.children);
        let containerSize = orientation === "horizontal" ? wrapperRef.current.offsetWidth : wrapperRef.current.offsetHeight;
        let isShowingMenu = visibleItems2 < state.collection.size;
        let calculatedSize = 0;
        let newVisibleItems = 0;
        if (isShowingMenu) {
          let item2 = listItems.pop();
          if (item2) {
            calculatedSize += orientation === "horizontal" ? outerWidth(item2, false, true) : outerHeight(item2, false, true);
          }
        }
        for (let [i6, item2] of listItems.entries()) {
          calculatedSize += orientation === "horizontal" ? outerWidth(item2, i6 === 0, i6 === listItems.length - 1) : outerHeight(item2, i6 === 0, i6 === listItems.length - 1);
          if (calculatedSize <= containerSize) {
            newVisibleItems++;
          } else {
            break;
          }
        }
        if (selectionMode === "single" && newVisibleItems < state.collection.size) {
          return 0;
        }
        return newVisibleItems;
      }
      return visibleItems2;
    };
    setVisibleItems(function* () {
      let hideButtonText2 = buttonLabelBehavior === "hide" && isIconCollapsible;
      yield {
        visibleItems: state.collection.size,
        hideButtonText: hideButtonText2,
        isMeasuring: true
      };
      let newVisibleItems = computeVisibleItems(state.collection.size);
      let isMeasuring2 = newVisibleItems < state.collection.size && newVisibleItems > 0;
      if (newVisibleItems < state.collection.size && buttonLabelBehavior === "collapse" && isIconCollapsible) {
        yield {
          visibleItems: state.collection.size,
          hideButtonText: true,
          isMeasuring: true
        };
        newVisibleItems = computeVisibleItems(state.collection.size);
        isMeasuring2 = newVisibleItems < state.collection.size && newVisibleItems > 0;
        hideButtonText2 = true;
      }
      yield {
        visibleItems: newVisibleItems,
        hideButtonText: hideButtonText2,
        isMeasuring: isMeasuring2
      };
      if (isMeasuring2) {
        yield {
          visibleItems: computeVisibleItems(newVisibleItems),
          hideButtonText: hideButtonText2,
          isMeasuring: false
        };
      }
    });
  }, [domRef, state.collection, setVisibleItems, overflowMode, selectionMode, buttonLabelBehavior, isIconCollapsible, orientation]);
  let parentRef = (0, import_react60.useMemo)(() => ({
    get current() {
      var _wrapperRef$current;
      return (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.parentElement;
    }
  }), [wrapperRef]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: overflowMode !== "wrap" ? parentRef : void 0,
    onResize: updateOverflow
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(updateOverflow, [updateOverflow, state.collection]);
  let children = [...state.collection];
  let menuItem = null;
  let menuProps = {};
  if (overflowMode === "collapse" && visibleItems === 0) {
    menuProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, {
      labelable: true
    });
    actionGroupProps = {};
  }
  if (overflowMode === "collapse" && visibleItems < state.collection.size) {
    let menuChildren = children.slice(visibleItems);
    children = children.slice(0, visibleItems);
    menuItem = (0, import_jsx_runtime36.jsx)(ActionGroupMenu, {
      ...menuProps,
      items: menuChildren,
      prominence,
      onAction,
      isDisabled,
      state,
      summaryIcon,
      hideButtonText,
      isOnlyItem: visibleItems === 0,
      orientation
    });
  }
  let style = {
    ...styleProps.style,
    // While measuring, take up as much space as possible.
    flexBasis: isMeasuring ? "100%" : void 0
  };
  return (0, import_jsx_runtime36.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    children: (0, import_jsx_runtime36.jsx)("div", {
      ...styleProps,
      style,
      className: classNames(css({
        display: "flex",
        maxWidth: "100%"
      }), styleProps.className),
      ref: wrapperRef,
      children: (0, import_jsx_runtime36.jsx)("div", {
        ...actionGroupProps,
        ...toDataAttributes({
          overflow: overflowMode,
          prominence,
          justified: isJustified && !isMeasuring || void 0,
          compact: density === "compact" || void 0,
          vertical: orientation === "vertical" || void 0
        }),
        ref: domRef,
        className: classNames(css({
          display: "flex",
          // gap: tokenSchema.size.space.regular,
          // NOTE: `gap` seems to break the measurement/collapse logic, so we use margin instead.
          width: "calc(100% + var(--action-item-gap) + 1px)",
          margin: `calc(var(--action-item-gap) / -2)`,
          "--action-item-gap": tokenSchema.size.space.regular,
          [actionButtonClassList.selector("root", "child")]: {
            margin: `calc(var(--action-item-gap) / 2)`
          },
          // wrap
          "&[data-overflow=wrap]": {
            flexWrap: "wrap"
          },
          // justified
          "&[data-justified]": {
            [actionButtonClassList.selector("root", "child")]: {
              flexGrow: 1
            }
          },
          // compact
          "&[data-compact]:not([data-prominence=low])": {
            "--action-item-gap": 0,
            // gap: 0,
            [actionButtonClassList.selector("root", "child")]: {
              borderRadius: 0,
              "&:first-of-type": {
                borderTopLeftRadius: tokenSchema.size.radius.regular,
                borderBottomLeftRadius: tokenSchema.size.radius.regular
              },
              "&:last-of-type": {
                borderTopRightRadius: tokenSchema.size.radius.regular,
                borderBottomRightRadius: tokenSchema.size.radius.regular
              },
              "&:not(:last-of-type)": {
                marginRight: `calc(${tokenSchema.size.border.regular} * -1)`
              },
              "&.is-hovered, &.is-focused, &.is-pressed": {
                zIndex: 1
              },
              "&.is-selected": {
                zIndex: 2
              }
            }
          },
          "&[data-compact][data-prominence=low]": {
            "--action-item-gap": tokenSchema.size.space.small
          }
        }), otherProps.UNSAFE_className),
        children: (0, import_jsx_runtime36.jsxs)(KeystarProvider, {
          ...providerProps,
          children: [children.map((item2) => (0, import_jsx_runtime36.jsx)(ActionGroupItem, {
            onAction,
            prominence,
            isDisabled,
            item: item2,
            state,
            hideButtonText,
            orientation
          }, item2.key)), menuItem]
        })
      })
    })
  });
}
var _ActionGroup = (0, import_react60.forwardRef)(ActionGroup);
function ActionGroupItem({
  item: item2,
  state,
  isDisabled,
  onAction,
  hideButtonText,
  orientation,
  prominence
}) {
  let ref = (0, import_react60.useRef)(null);
  let {
    buttonProps
  } = $f0ac0fb73c3ec062$export$9597202bd3099a29({
    key: item2.key
  }, state);
  isDisabled = isDisabled || state.disabledKeys.has(item2.key);
  let isSelected = state.selectionManager.isSelected(item2.key);
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(item2.props);
  if (onAction && !isDisabled) {
    buttonProps = $3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, {
      onPress: () => onAction(item2.key)
    });
  }
  let textId = $bdb11010cef70236$export$f680877a34711e37();
  let kbdId = $bdb11010cef70236$export$f680877a34711e37();
  let [textContent, setTextContent] = (0, import_react60.useState)("");
  let [kbdContent, setKbdContent] = (0, import_react60.useState)("");
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (hideButtonText) {
      var _document$getElementB, _document$getElementB2;
      setTextContent((_document$getElementB = document.getElementById(textId)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.textContent);
      setKbdContent((_document$getElementB2 = document.getElementById(kbdId)) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.textContent);
    }
  }, [hideButtonText, item2.rendered, textId, kbdId]);
  let button = (
    // Use a PressResponder to send DOM props through.
    // Button doesn't allow overriding the role by default.
    (0, import_jsx_runtime36.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(buttonProps, domProps),
      children: (0, import_jsx_runtime36.jsx)(ClearSlots, {
        children: (0, import_jsx_runtime36.jsx)(SlotProvider, {
          slots: {
            kbd: {
              id: hideButtonText ? kbdId : void 0,
              isHidden: true
              // always hide kbd in buttons
            },
            text: {
              id: hideButtonText ? textId : void 0,
              isHidden: hideButtonText
            }
          },
          children: (0, import_jsx_runtime36.jsx)(ActionButton, {
            ...item2.props,
            prominence,
            ref,
            UNSAFE_className: classNames(css({
              flexShrink: 0
            })),
            isSelected,
            isDisabled,
            "aria-label": item2["aria-label"],
            "aria-labelledby": item2["aria-label"] == null && hideButtonText ? textId : void 0,
            children: item2.rendered
          })
        })
      })
    })
  );
  if (hideButtonText && textContent) {
    button = (0, import_jsx_runtime36.jsxs)(_TooltipTrigger, {
      placement: orientation === "vertical" ? "end" : "top",
      children: [button, (0, import_jsx_runtime36.jsx)(Tooltip, {
        children: kbdContent ? (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, {
          children: [(0, import_jsx_runtime36.jsx)(Text, {
            children: textContent
          }), (0, import_jsx_runtime36.jsx)(Kbd, {
            children: kbdContent
          })]
        }) : textContent
      })]
    });
  }
  if (item2.wrapper) {
    button = item2.wrapper(button);
  }
  return button;
}
function ActionGroupMenu({
  hideButtonText,
  isDisabled,
  isOnlyItem,
  items,
  onAction,
  orientation,
  prominence,
  state,
  staticColor,
  summaryIcon,
  ...otherProps
}) {
  let key = items[0].key;
  let {
    buttonProps
  } = $f0ac0fb73c3ec062$export$9597202bd3099a29({
    key
  }, state);
  delete buttonProps.onPress;
  delete buttonProps.role;
  delete buttonProps["aria-checked"];
  let ariaLabel = otherProps["aria-label"] || (otherProps["aria-labelledby"] ? void 0 : "…");
  let ariaLabelledby = otherProps["aria-labelledby"];
  let textId = $bdb11010cef70236$export$f680877a34711e37();
  let id = $bdb11010cef70236$export$f680877a34711e37();
  if (state.selectionManager.selectionMode === "none") {
    summaryIcon = null;
  }
  let isSelected = state.selectionManager.selectionMode !== "none" && items.some((i6) => state.selectionManager.isSelected(i6.key));
  if (!summaryIcon && state.selectionManager.selectionMode === "single" && state.selectionManager.disallowEmptySelection && state.selectionManager.firstSelectedKey != null) {
    let selectedItem = state.collection.getItem(state.selectionManager.firstSelectedKey);
    if (selectedItem) {
      var _ariaLabelledby;
      summaryIcon = selectedItem.rendered;
      if (isReactText(summaryIcon)) {
        summaryIcon = (0, import_jsx_runtime36.jsx)(Text, {
          children: summaryIcon
        });
      }
      ariaLabelledby = `${(_ariaLabelledby = ariaLabelledby) !== null && _ariaLabelledby !== void 0 ? _ariaLabelledby : id} ${textId}`;
    }
  }
  if (summaryIcon) {
    summaryIcon = (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, {
      children: [summaryIcon, (0, import_jsx_runtime36.jsx)(Icon, {
        src: chevronDownIcon
      })]
    });
  }
  return (
    // Use a PressResponder to send DOM props through.
    (0, import_jsx_runtime36.jsxs)(MenuTrigger, {
      align: isOnlyItem ? "start" : "end",
      direction: orientation === "vertical" ? "end" : "bottom",
      children: [(0, import_jsx_runtime36.jsx)(SlotProvider, {
        slots: {
          text: {
            id: hideButtonText ? textId : void 0,
            isHidden: hideButtonText
          }
        },
        children: (0, import_jsx_runtime36.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
          ...buttonProps,
          children: (0, import_jsx_runtime36.jsx)(ActionButton, {
            ...otherProps,
            id,
            prominence,
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledby,
            isDisabled,
            isSelected,
            children: summaryIcon || (0, import_jsx_runtime36.jsx)(Icon, {
              src: moreHorizontalIcon
            })
          })
        })
      }), (0, import_jsx_runtime36.jsx)(_Menu, {
        items,
        disabledKeys: state.disabledKeys,
        selectionMode: state.selectionManager.selectionMode,
        selectedKeys: state.selectionManager.selectedKeys,
        disallowEmptySelection: state.selectionManager.disallowEmptySelection,
        onSelectionChange: (keys) => state.selectionManager.setSelectedKeys(keys),
        onAction,
        children: (node3) => (0, import_jsx_runtime36.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          ...node3.props,
          textValue: node3.textValue,
          children: node3.rendered
        })
      })]
    })
  );
}
function outerWidth(element2, ignoreLeftMargin, ignoreRightMargin) {
  let style = window.getComputedStyle(element2);
  return element2.offsetWidth + (ignoreLeftMargin ? 0 : toNumber(style.marginLeft)) + (ignoreRightMargin ? 0 : toNumber(style.marginRight));
}
function outerHeight(element2, ignoreTopMargin, ignoreBottomMargin) {
  let style = window.getComputedStyle(element2);
  return element2.offsetHeight + (ignoreTopMargin ? 0 : toNumber(style.marginTop)) + (ignoreBottomMargin ? 0 : toNumber(style.marginBottom));
}
function toNumber(value2) {
  let parsed = parseInt(value2, 10);
  return isNaN(parsed) ? 0 : parsed;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/boldIcon/dist/keystar-ui-icon-icons-boldIcon.esm.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var boldIcon = (0, import_jsx_runtime37.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime37.jsx)("path", {
    d: "M14 12a4 4 0 0 0 0-8H6v8M15 20a4 4 0 0 0 0-8H6v8Z"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/codeIcon/dist/keystar-ui-icon-icons-codeIcon.esm.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var codeIcon = (0, import_jsx_runtime38.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime38.jsx)("path", {
    d: "m16 18 6-6-6-6M8 6l-6 6 6 6"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/italicIcon/dist/keystar-ui-icon-icons-italicIcon.esm.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var italicIcon = (0, import_jsx_runtime39.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime39.jsx)("path", {
    d: "M19 4h-9M14 20H5M15 4 9 20"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/maximizeIcon/dist/keystar-ui-icon-icons-maximizeIcon.esm.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var maximizeIcon = (0, import_jsx_runtime40.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime40.jsx)("path", {
    d: "M8 3H5a2 2 0 0 0-2 2v3M21 8V5a2 2 0 0 0-2-2h-3M3 16v3a2 2 0 0 0 2 2h3M16 21h3a2 2 0 0 0 2-2v-3"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/minimizeIcon/dist/keystar-ui-icon-icons-minimizeIcon.esm.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var minimizeIcon = (0, import_jsx_runtime41.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime41.jsx)("path", {
    d: "M8 3v3a2 2 0 0 1-2 2H3M21 8h-3a2 2 0 0 1-2-2V3M3 16h3a2 2 0 0 1 2 2v3M16 21v-3a2 2 0 0 1 2-2h3"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/plusIcon/dist/keystar-ui-icon-icons-plusIcon.esm.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var plusIcon = (0, import_jsx_runtime42.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime42.jsx)("path", {
    d: "M12 5v14M5 12h14"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/removeFormattingIcon/dist/keystar-ui-icon-icons-removeFormattingIcon.esm.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var removeFormattingIcon = (0, import_jsx_runtime43.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime43.jsx)("path", {
    d: "M4 7V4h16v3M5 20h6M13 4 8 20M15 15l5 5M20 15l-5 5"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/strikethroughIcon/dist/keystar-ui-icon-icons-strikethroughIcon.esm.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var strikethroughIcon = (0, import_jsx_runtime44.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime44.jsx)("path", {
    d: "M16 4H9a3 3 0 0 0-2.83 4M14 12a4 4 0 0 1 0 8H6M4 12h16"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/subscriptIcon/dist/keystar-ui-icon-icons-subscriptIcon.esm.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var subscriptIcon = (0, import_jsx_runtime45.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime45.jsx)("path", {
    d: "m4 5 8 8M12 5l-8 8M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/superscriptIcon/dist/keystar-ui-icon-icons-superscriptIcon.esm.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var superscriptIcon = (0, import_jsx_runtime46.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime46.jsx)("path", {
    d: "m4 19 8-8M12 19l-8-8M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/typeIcon/dist/keystar-ui-icon-icons-typeIcon.esm.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var typeIcon = (0, import_jsx_runtime47.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime47.jsx)("path", {
    d: "M4 7V4h16v3M9 20h6M12 4v16"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/underlineIcon/dist/keystar-ui-icon-icons-underlineIcon.esm.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var underlineIcon = (0, import_jsx_runtime48.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime48.jsx)("path", {
    d: "M6 4v6a6 6 0 0 0 12 0V4M4 20h16"
  })
});

// node_modules/.pnpm/@react-aria+select@3.14.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/select/dist/import.mjs
var import_react61 = __toESM(require_react(), 1);
var $58aed456727eb0f3$export$703601b7e90536f8 = /* @__PURE__ */ new WeakMap();
function $58aed456727eb0f3$export$e64b2f635402ca43(props, state, ref) {
  let { keyboardDelegate, isDisabled, isRequired, name: name2, validationBehavior = "aria" } = props;
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let delegate = (0, import_react61.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(state.collection, state.disabledKeys, null, collator), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    collator
  ]);
  let { menuTriggerProps, menuProps } = (0, $168583247155ddda$export$dc9c12ed27dd1b49)({
    isDisabled,
    type: "listbox"
  }, state, ref);
  let onKeyDown = (e6) => {
    switch (e6.key) {
      case "ArrowLeft": {
        e6.preventDefault();
        let key = state.selectedKey != null ? delegate.getKeyAbove(state.selectedKey) : delegate.getFirstKey();
        if (key)
          state.setSelectedKey(key);
        break;
      }
      case "ArrowRight": {
        e6.preventDefault();
        let key = state.selectedKey != null ? delegate.getKeyBelow(state.selectedKey) : delegate.getFirstKey();
        if (key)
          state.setSelectedKey(key);
        break;
      }
    }
  };
  let { typeSelectProps } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({
    keyboardDelegate: delegate,
    selectionManager: state.selectionManager,
    onTypeSelect(key) {
      state.setSelectedKey(key);
    }
  });
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    labelElementType: "span",
    isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;
  delete typeSelectProps.onKeyDownCapture;
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let triggerProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(typeSelectProps, menuTriggerProps, fieldProps);
  let valueId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  $58aed456727eb0f3$export$703601b7e90536f8.set(state, {
    isDisabled,
    isRequired,
    name: name2,
    validationBehavior
  });
  return {
    labelProps: {
      ...labelProps,
      onClick: () => {
        if (!props.isDisabled) {
          ref.current.focus();
          (0, $507fabe10e71c6fb$export$8397ddfc504fdb9a)("keyboard");
        }
      }
    },
    triggerProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...triggerProps,
      isDisabled,
      onKeyDown: (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),
      onKeyUp: props.onKeyUp,
      "aria-labelledby": [
        valueId,
        triggerProps["aria-labelledby"],
        triggerProps["aria-label"] && !triggerProps["aria-labelledby"] ? triggerProps.id : null
      ].filter(Boolean).join(" "),
      onFocus(e6) {
        if (state.isFocused)
          return;
        if (props.onFocus)
          props.onFocus(e6);
        if (props.onFocusChange)
          props.onFocusChange(true);
        state.setFocused(true);
      },
      onBlur(e6) {
        if (state.isOpen)
          return;
        if (props.onBlur)
          props.onBlur(e6);
        if (props.onFocusChange)
          props.onFocusChange(false);
        state.setFocused(false);
      }
    }),
    valueProps: {
      id: valueId
    },
    menuProps: {
      ...menuProps,
      autoFocus: state.focusStrategy || true,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      disallowEmptySelection: true,
      linkBehavior: "selection",
      onBlur: (e6) => {
        if (e6.currentTarget.contains(e6.relatedTarget))
          return;
        if (props.onBlur)
          props.onBlur(e6);
        if (props.onFocusChange)
          props.onFocusChange(false);
        state.setFocused(false);
      },
      "aria-labelledby": [
        fieldProps["aria-labelledby"],
        triggerProps["aria-label"] && !fieldProps["aria-labelledby"] ? triggerProps.id : null
      ].filter(Boolean).join(" ")
    },
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}
function $bdd25dc72710631f$export$f809e80f58e251d1(props, state, triggerRef) {
  let data = (0, $58aed456727eb0f3$export$703601b7e90536f8).get(state) || {};
  let { autoComplete, name: name2 = data.name, isDisabled = data.isDisabled } = props;
  let { validationBehavior, isRequired } = data;
  let modality = (0, $507fabe10e71c6fb$export$98e20ec92f614cfe)();
  let { visuallyHiddenProps } = (0, $5c3e21d68f1c4674$export$a966af930f325cab)();
  (0, $99facab73266f662$export$5add1d006293d136)(props.selectRef, state.selectedKey, state.setSelectedKey);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)({
    validationBehavior,
    focus: () => triggerRef.current.focus()
  }, state, props.selectRef);
  var _state_selectedKey;
  return {
    containerProps: {
      ...visuallyHiddenProps,
      "aria-hidden": true,
      ["data-a11y-ignore"]: "aria-hidden-focus"
    },
    inputProps: {
      type: "text",
      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,
      style: {
        fontSize: 16
      },
      onFocus: () => triggerRef.current.focus(),
      disabled: isDisabled
    },
    selectProps: {
      tabIndex: -1,
      autoComplete,
      disabled: isDisabled,
      required: validationBehavior === "native" && isRequired,
      name: name2,
      value: (_state_selectedKey = state.selectedKey) !== null && _state_selectedKey !== void 0 ? _state_selectedKey : "",
      onChange: (e6) => state.setSelectedKey(e6.target.value)
    }
  };
}
function $bdd25dc72710631f$export$cbd84cdb2e668835(props) {
  let { state, triggerRef, label, name: name2, isDisabled } = props;
  let selectRef = (0, import_react61.useRef)(null);
  let { containerProps, inputProps, selectProps } = $bdd25dc72710631f$export$f809e80f58e251d1({
    ...props,
    selectRef
  }, state, triggerRef);
  var _state_selectedKey;
  if (state.collection.size <= 300)
    return (0, import_react61.default).createElement("div", {
      ...containerProps,
      "data-testid": "hidden-select-container"
    }, (0, import_react61.default).createElement("input", inputProps), (0, import_react61.default).createElement("label", null, label, (0, import_react61.default).createElement("select", {
      ...selectProps,
      ref: selectRef
    }, (0, import_react61.default).createElement("option", null), [
      ...state.collection.getKeys()
    ].map((key) => {
      let item2 = state.collection.getItem(key);
      if (item2.type === "item")
        return (0, import_react61.default).createElement("option", {
          key: item2.key,
          value: item2.key
        }, item2.textValue);
    }))));
  else if (name2)
    return (0, import_react61.default).createElement("input", {
      type: "hidden",
      autoComplete: selectProps.autoComplete,
      name: name2,
      disabled: isDisabled,
      value: (_state_selectedKey = state.selectedKey) !== null && _state_selectedKey !== void 0 ? _state_selectedKey : ""
    });
  return null;
}

// node_modules/.pnpm/@react-stately+select@3.6.0_react@18.2.0/node_modules/@react-stately/select/dist/import.mjs
var import_react62 = __toESM(require_react(), 1);
function $2bc3a590c5373a4e$export$5159ec8b34d4ec12(props) {
  let triggerState = (0, $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)(props);
  let listState = (0, $a0d645289fe9b86b$export$e7f05e985daf4b5f)({
    ...props,
    onSelectionChange: (key) => {
      if (props.onSelectionChange != null)
        props.onSelectionChange(key);
      triggerState.close();
      validationState.commitValidation();
    }
  });
  let validationState = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: listState.selectedKey
  });
  let [isFocused, setFocused] = (0, import_react62.useState)(false);
  return {
    ...validationState,
    ...listState,
    ...triggerState,
    open() {
      if (listState.collection.size !== 0)
        triggerState.open();
    },
    toggle(focusStrategy) {
      if (listState.collection.size !== 0)
        triggerState.toggle(focusStrategy);
    },
    isFocused,
    setFocused
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/picker/dist/keystar-ui-picker.esm.js
var import_react63 = __toESM(require_react());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/chevronsUpDownIcon/dist/keystar-ui-icon-icons-chevronsUpDownIcon.esm.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var chevronsUpDownIcon = (0, import_jsx_runtime49.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime49.jsx)("path", {
    d: "m7 15 5 5 5-5M7 9l5-5 5 5"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/picker/dist/keystar-ui-picker.esm.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var localizedMessages8 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    placeholder: "حدد خيارًا..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    placeholder: "Изберете опция"
  },
  "cs-CZ": {
    loading: "Načítání...",
    placeholder: "Vyberte vhodnou možnost..."
  },
  "da-DK": {
    loading: "Indlæser ...",
    placeholder: "Vælg en mulighed ..."
  },
  "de-DE": {
    loading: "Laden...",
    placeholder: "Option auswählen..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    placeholder: "Επιλέξτε…"
  },
  "en-US": {
    placeholder: "Select an option…",
    loading: "Loading…"
  },
  "es-ES": {
    loading: "Cargando…",
    placeholder: "Selecciona una de estas opciones..."
  },
  "et-EE": {
    loading: "Laadimine...",
    placeholder: "Valige valikuline..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    placeholder: "Valitse vaihtoehto..."
  },
  "fr-FR": {
    loading: "Chargement...",
    placeholder: "Sélectionnez une option..."
  },
  "he-IL": {
    loading: "טוען...",
    placeholder: "בחר אפשרות..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    placeholder: "Odaberite opciju"
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    placeholder: "Válasszon egy opciót…"
  },
  "it-IT": {
    loading: "Caricamento...",
    placeholder: "Seleziona un’opzione..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    placeholder: "オプションを選択..."
  },
  "ko-KR": {
    loading: "로드 중",
    placeholder: "선택 사항 선택"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    placeholder: "Pasirinkite parinktį..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    placeholder: "Atlasiet opciju..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    placeholder: "Velg et alternativ..."
  },
  "nl-NL": {
    loading: "Laden...",
    placeholder: "Optie selecteren..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    placeholder: "Wybierz opcję..."
  },
  "pt-BR": {
    loading: "Carregando...",
    placeholder: "Selecione uma opção..."
  },
  "pt-PT": {
    loading: "A carregar...",
    placeholder: "Selecionar uma opção..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    placeholder: "Selectați o opțiune"
  },
  "ru-RU": {
    loading: "Загрузка...",
    placeholder: "Выбрать параметр..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    placeholder: "Vyberte možnosť..."
  },
  "sl-SI": {
    loading: "Nalaganje...",
    placeholder: "Izberite možnost"
  },
  "sr-SP": {
    loading: "Učitavam...",
    placeholder: "Izaberite opciju"
  },
  "sv-SE": {
    loading: "Läser in...",
    placeholder: "Välj ett alternativ..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    placeholder: "Bir seçim yapın…"
  },
  "uk-UA": {
    loading: "Завантаження…",
    placeholder: "Виберіть опцію..."
  },
  "zh-CN": {
    loading: "正在加载...",
    placeholder: "选择一个选项..."
  },
  "zh-T": {
    loading: "正在載入",
    placeholder: "選取一個選項"
  }
};
function Picker(props, forwardedRef) {
  props = useSlotProps(props, "picker");
  props = useProviderProps(props);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages8);
  let {
    align = "start",
    autoComplete,
    autoFocus,
    direction = "bottom",
    isDisabled,
    label,
    menuWidth,
    name: name2,
    placeholder = stringFormatter.format("placeholder"),
    prominence,
    shouldFlip = true
  } = props;
  let popoverRef = (0, import_react63.useRef)(null);
  let triggerRef = (0, import_react63.useRef)(null);
  let listboxRef = (0, import_react63.useRef)(null);
  let state = $2bc3a590c5373a4e$export$5159ec8b34d4ec12(props);
  let layout = useListBoxLayout(state);
  let {
    labelProps,
    triggerProps,
    valueProps,
    menuProps,
    descriptionProps,
    errorMessageProps
  } = $58aed456727eb0f3$export$e64b2f635402ca43({
    ...props,
    keyboardDelegate: layout
  }, state, triggerRef);
  let isMobile = useIsMobileDevice();
  let isLoadingInitial = props.isLoading && state.collection.size === 0;
  let isLoadingMore = props.isLoading && state.collection.size > 0;
  let listbox = (0, import_jsx_runtime50.jsx)(_ListBoxBase, {
    ...menuProps,
    ref: listboxRef,
    disallowEmptySelection: true,
    autoFocus: state.focusStrategy || true,
    shouldSelectOnPressUp: true,
    focusOnPointerEnter: true,
    layout,
    state,
    UNSAFE_className: listStyles,
    isLoading: isLoadingMore,
    onLoadMore: props.onLoadMore
  });
  let [buttonWidth, setButtonWidth] = (0, import_react63.useState)();
  let {
    scale
  } = useProvider();
  let onResize = (0, import_react63.useCallback)(() => {
    if (!isMobile && triggerRef.current) {
      let width = triggerRef.current.offsetWidth;
      setButtonWidth(width);
    }
  }, [triggerRef, setButtonWidth, isMobile]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: triggerRef,
    onResize
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(onResize, [scale, state.selectedKey, onResize]);
  let overlay;
  if (isMobile) {
    overlay = (0, import_jsx_runtime50.jsx)(Tray, {
      state,
      children: listbox
    });
  } else {
    let style = {
      minWidth: buttonWidth,
      width: menuWidth !== null && menuWidth !== void 0 ? menuWidth : buttonWidth
    };
    overlay = (0, import_jsx_runtime50.jsx)(Popover, {
      UNSAFE_style: style,
      ref: popoverRef,
      placement: `${direction} ${align}`,
      shouldFlip,
      hideArrow: true,
      state,
      triggerRef,
      scrollRef: listboxRef,
      children: listbox
    });
  }
  let contents = state.selectedItem ? state.selectedItem.rendered : placeholder;
  if (isReactText(contents)) {
    contents = (0, import_jsx_runtime50.jsx)(Text, {
      children: contents
    });
  }
  let picker = (0, import_jsx_runtime50.jsxs)("div", {
    children: [(0, import_jsx_runtime50.jsx)($bdd25dc72710631f$export$cbd84cdb2e668835, {
      autoComplete,
      isDisabled,
      label,
      name: name2,
      state,
      triggerRef
    }), (0, import_jsx_runtime50.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
      ...triggerProps,
      children: (0, import_jsx_runtime50.jsxs)(FieldButton, {
        "aria-required": true,
        prominence,
        ref: triggerRef,
        isActive: state.isOpen,
        isDisabled,
        autoFocus,
        UNSAFE_className: classNames(css({
          alignItems: "center",
          display: "flex",
          justifyContent: "space-between",
          position: "relative",
          width: "100%",
          /* Ensure that changing the selected item doesn't affect the size of the dropdown and its parents */
          contain: "size"
        })),
        children: [(0, import_jsx_runtime50.jsx)(SlotProvider, {
          slots: {
            icon: {
              marginEnd: "small"
            },
            text: {
              ...valueProps,
              // when no item is selected, we're styling the placeholder
              color: !state.selectedItem ? "neutralSecondary" : "inherit",
              weight: state.selectedItem ? "medium" : void 0
            },
            // we try to maintain most of the selected item's rendered content
            // within the button, but description text is too long
            description: {
              isHidden: true
            }
          },
          children: contents
        }), isLoadingInitial && (0, import_jsx_runtime50.jsx)(ProgressCircle, {
          isIndeterminate: true,
          size: "small",
          "aria-label": stringFormatter.format("loading"),
          UNSAFE_className: css({
            marginInlineStart: tokenSchema.size.space.small
          })
        }), (0, import_jsx_runtime50.jsx)(Icon, {
          src: chevronsUpDownIcon,
          UNSAFE_className: css({
            marginInlineStart: tokenSchema.size.space.small
          })
        })]
      })
    }), state.collection.size === 0 ? null : overlay]
  });
  return (0, import_jsx_runtime50.jsx)(FieldPrimitive, {
    width: "alias.singleLineWidth",
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    supplementRequiredState: true,
    children: picker
  });
}
var _Picker = (0, import_react63.forwardRef)(Picker);

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/alignLeftIcon/dist/keystar-ui-icon-icons-alignLeftIcon.esm.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var alignLeftIcon = (0, import_jsx_runtime51.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime51.jsx)("path", {
    d: "M21 6H3M15 12H3M17 18H3"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/alignRightIcon/dist/keystar-ui-icon-icons-alignRightIcon.esm.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var alignRightIcon = (0, import_jsx_runtime52.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime52.jsx)("path", {
    d: "M21 6H3M21 12H9M21 18H7"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/alignCenterIcon/dist/keystar-ui-icon-icons-alignCenterIcon.esm.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());
var alignCenterIcon = (0, import_jsx_runtime53.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime53.jsx)("path", {
    d: "M21 6H3M17 12H7M19 18H5"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/quoteIcon/dist/keystar-ui-icon-icons-quoteIcon.esm.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
var quoteIcon = (0, import_jsx_runtime54.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime54.jsx)("path", {
    d: "M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1zM15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z"
  })
});

// node_modules/.pnpm/@babel+runtime@7.23.5/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/.pnpm/match-sorter@6.3.1/node_modules/match-sorter/dist/match-sorter.esm.js
var import_remove_accents = __toESM(require_remove_accents());
var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
matchSorter.rankings = rankings;
var defaultBaseSortFn = function defaultBaseSortFn2(a3, b2) {
  return String(a3.rankedValue).localeCompare(String(b2.rankedValue));
};
function matchSorter(items, value2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, keys = _options.keys, _options$threshold = _options.threshold, threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold, _options$baseSort = _options.baseSort, baseSort = _options$baseSort === void 0 ? defaultBaseSortFn : _options$baseSort, _options$sorter = _options.sorter, sorter = _options$sorter === void 0 ? function(matchedItems2) {
    return matchedItems2.sort(function(a3, b2) {
      return sortRankedValues(a3, b2, baseSort);
    });
  } : _options$sorter;
  var matchedItems = items.reduce(reduceItemsToRanked, []);
  return sorter(matchedItems).map(function(_ref) {
    var item2 = _ref.item;
    return item2;
  });
  function reduceItemsToRanked(matches, item2, index2) {
    var rankingInfo = getHighestRanking(item2, keys, value2, options);
    var rank = rankingInfo.rank, _rankingInfo$keyThres = rankingInfo.keyThreshold, keyThreshold = _rankingInfo$keyThres === void 0 ? threshold : _rankingInfo$keyThres;
    if (rank >= keyThreshold) {
      matches.push(_extends({}, rankingInfo, {
        item: item2,
        index: index2
      }));
    }
    return matches;
  }
}
function getHighestRanking(item2, keys, value2, options) {
  if (!keys) {
    var stringItem = item2;
    return {
      // ends up being duplicate of 'item' in matches but consistent
      rankedValue: stringItem,
      rank: getMatchRanking(stringItem, value2, options),
      keyIndex: -1,
      keyThreshold: options.threshold
    };
  }
  var valuesToRank = getAllValuesToRank(item2, keys);
  return valuesToRank.reduce(function(_ref2, _ref3, i6) {
    var rank = _ref2.rank, rankedValue = _ref2.rankedValue, keyIndex = _ref2.keyIndex, keyThreshold = _ref2.keyThreshold;
    var itemValue = _ref3.itemValue, attributes = _ref3.attributes;
    var newRank = getMatchRanking(itemValue, value2, options);
    var newRankedValue = rankedValue;
    var minRanking = attributes.minRanking, maxRanking = attributes.maxRanking, threshold = attributes.threshold;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    if (newRank > rank) {
      rank = newRank;
      keyIndex = i6;
      keyThreshold = threshold;
      newRankedValue = itemValue;
    }
    return {
      rankedValue: newRankedValue,
      rank,
      keyIndex,
      keyThreshold
    };
  }, {
    rankedValue: item2,
    rank: rankings.NO_MATCH,
    keyIndex: -1,
    keyThreshold: options.threshold
  });
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(" " + stringToRank)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string) {
  var acronym = "";
  var wordsInString = string.split(" ");
  wordsInString.forEach(function(wordInString) {
    var splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach(function(splitByHyphenWord) {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  var matchingInOrderCharCount = 0;
  var charNumber = 0;
  function findMatchingCharacter(matchChar2, string, index2) {
    for (var j3 = index2, J = string.length; j3 < J; j3++) {
      var stringChar = string[j3];
      if (stringChar === matchChar2) {
        matchingInOrderCharCount += 1;
        return j3 + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    var spreadPercentage = 1 / spread2;
    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    var ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (var i6 = 1, I3 = stringToRank.length; i6 < I3; i6++) {
    var matchChar = stringToRank[i6];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    var found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  var spread = charNumber - firstIndex;
  return getRanking(spread);
}
function sortRankedValues(a3, b2, baseSort) {
  var aFirst = -1;
  var bFirst = 1;
  var aRank = a3.rank, aKeyIndex = a3.keyIndex;
  var bRank = b2.rank, bKeyIndex = b2.keyIndex;
  var same = aRank === bRank;
  if (same) {
    if (aKeyIndex === bKeyIndex) {
      return baseSort(a3, b2);
    } else {
      return aKeyIndex < bKeyIndex ? aFirst : bFirst;
    }
  } else {
    return aRank > bRank ? aFirst : bFirst;
  }
}
function prepareValueForComparison(value2, _ref4) {
  var keepDiacritics = _ref4.keepDiacritics;
  value2 = "" + value2;
  if (!keepDiacritics) {
    value2 = (0, import_remove_accents.default)(value2);
  }
  return value2;
}
function getItemValues(item2, key) {
  if (typeof key === "object") {
    key = key.key;
  }
  var value2;
  if (typeof key === "function") {
    value2 = key(item2);
  } else if (item2 == null) {
    value2 = null;
  } else if (Object.hasOwnProperty.call(item2, key)) {
    value2 = item2[key];
  } else if (key.includes(".")) {
    return getNestedValues(key, item2);
  } else {
    value2 = null;
  }
  if (value2 == null) {
    return [];
  }
  if (Array.isArray(value2)) {
    return value2;
  }
  return [String(value2)];
}
function getNestedValues(path2, item2) {
  var keys = path2.split(".");
  var values2 = [item2];
  for (var i6 = 0, I3 = keys.length; i6 < I3; i6++) {
    var nestedKey = keys[i6];
    var nestedValues = [];
    for (var j3 = 0, J = values2.length; j3 < J; j3++) {
      var nestedItem = values2[j3];
      if (nestedItem == null)
        continue;
      if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {
        var nestedValue = nestedItem[nestedKey];
        if (nestedValue != null) {
          nestedValues.push(nestedValue);
        }
      } else if (nestedKey === "*") {
        nestedValues = nestedValues.concat(nestedItem);
      }
    }
    values2 = nestedValues;
  }
  if (Array.isArray(values2[0])) {
    var result = [];
    return result.concat.apply(result, values2);
  }
  return values2;
}
function getAllValuesToRank(item2, keys) {
  var allValues = [];
  for (var j3 = 0, J = keys.length; j3 < J; j3++) {
    var key = keys[j3];
    var attributes = getKeyAttributes(key);
    var itemValues = getItemValues(item2, key);
    for (var i6 = 0, I3 = itemValues.length; i6 < I3; i6++) {
      allValues.push({
        itemValue: itemValues[i6],
        attributes
      });
    }
  }
  return allValues;
}
var defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getKeyAttributes(key) {
  if (typeof key === "string") {
    return defaultKeyAttributes;
  }
  return _extends({}, defaultKeyAttributes, key);
}

// node_modules/.pnpm/@react-aria+combobox@3.8.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/combobox/dist/import.mjs
var import_react64 = __toESM(require_react(), 1);
function $parcel$interopDefault5(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $de5926a92e8ebc5b$exports = {};
var $02cb4c75c506befe$exports = {};
$02cb4c75c506befe$exports = {
  "buttonLabel": `عرض المقترحات`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} خيار`,
    other: () => `${formatter.number(args.optionCount)} خيارات`
  })} متاحة.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `المجموعة المدخلة ${args.groupTitle}, مع ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} خيار`,
      other: () => `${formatter.number(args.groupCount)} خيارات`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, محدد`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `مقترحات`,
  "selectedAnnouncement": (args) => `${args.optionText}، محدد`
};
var $568b8163f1e56faf$exports = {};
$568b8163f1e56faf$exports = {
  "buttonLabel": `Покажи предложения`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} опция`,
    other: () => `${formatter.number(args.optionCount)} опции`
  })} на разположение.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Въведена група ${args.groupTitle}, с ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} опция`,
      other: () => `${formatter.number(args.groupCount)} опции`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, избрани`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Предложения`,
  "selectedAnnouncement": (args) => `${args.optionText}, избрани`
};
var $87581c0202d106b8$exports = {};
$87581c0202d106b8$exports = {
  "buttonLabel": `Zobrazit doporučení`,
  "countAnnouncement": (args, formatter) => `K dispozici ${formatter.plural(args.optionCount, {
    one: () => `je ${formatter.number(args.optionCount)} možnost`,
    other: () => `jsou/je ${formatter.number(args.optionCount)} možnosti/-í`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Zadaná skupina „${args.groupTitle}“ ${formatter.plural(args.groupCount, {
      one: () => `s ${formatter.number(args.groupCount)} možností`,
      other: () => `se ${formatter.number(args.groupCount)} možnostmi`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: ` (vybráno)`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Návrhy`,
  "selectedAnnouncement": (args) => `${args.optionText}, vybráno`
};
var $a10a0369f5433ed1$exports = {};
$a10a0369f5433ed1$exports = {
  "buttonLabel": `Vis forslag`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} mulighed tilgængelig`,
    other: () => `${formatter.number(args.optionCount)} muligheder tilgængelige`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Angivet gruppe ${args.groupTitle}, med ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} mulighed`,
      other: () => `${formatter.number(args.groupCount)} muligheder`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valgt`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Forslag`,
  "selectedAnnouncement": (args) => `${args.optionText}, valgt`
};
var $bfd288727d5cb166$exports = {};
$bfd288727d5cb166$exports = {
  "buttonLabel": `Empfehlungen anzeigen`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} Option`,
    other: () => `${formatter.number(args.optionCount)} Optionen`
  })} verfügbar.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Eingetretene Gruppe ${args.groupTitle}, mit ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} Option`,
      other: () => `${formatter.number(args.groupCount)} Optionen`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, ausgewählt`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Empfehlungen`,
  "selectedAnnouncement": (args) => `${args.optionText}, ausgewählt`
};
var $ca177778f9a74e3c$exports = {};
$ca177778f9a74e3c$exports = {
  "buttonLabel": `Προβολή προτάσεων`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} επιλογή`,
    other: () => `${formatter.number(args.optionCount)} επιλογές `
  })} διαθέσιμες.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Εισαγμένη ομάδα ${args.groupTitle}, με ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} επιλογή`,
      other: () => `${formatter.number(args.groupCount)} επιλογές`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, επιλεγμένο`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Προτάσεις`,
  "selectedAnnouncement": (args) => `${args.optionText}, επιλέχθηκε`
};
var $9b5aa79ef84beb6c$exports = {};
$9b5aa79ef84beb6c$exports = {
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Entered group ${args.groupTitle}, with ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} option`,
      other: () => `${formatter.number(args.groupCount)} options`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selected`,
    other: ``
  }, args.isSelected)}`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} option`,
    other: () => `${formatter.number(args.optionCount)} options`
  })} available.`,
  "selectedAnnouncement": (args) => `${args.optionText}, selected`,
  "buttonLabel": `Show suggestions`,
  "listboxLabel": `Suggestions`
};
var $57968e8209de2557$exports = {};
$57968e8209de2557$exports = {
  "buttonLabel": `Mostrar sugerencias`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opción`,
    other: () => `${formatter.number(args.optionCount)} opciones`
  })} disponible(s).`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Se ha unido al grupo ${args.groupTitle}, con ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opción`,
      other: () => `${formatter.number(args.groupCount)} opciones`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, seleccionado`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugerencias`,
  "selectedAnnouncement": (args) => `${args.optionText}, seleccionado`
};
var $60690790bf4c1c6a$exports = {};
$60690790bf4c1c6a$exports = {
  "buttonLabel": `Kuva soovitused`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} valik`,
    other: () => `${formatter.number(args.optionCount)} valikud`
  })} saadaval.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Sisestatud rühm ${args.groupTitle}, valikuga ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} valik`,
      other: () => `${formatter.number(args.groupCount)} valikud`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valitud`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Soovitused`,
  "selectedAnnouncement": (args) => `${args.optionText}, valitud`
};
var $1101246e8c7d9357$exports = {};
$1101246e8c7d9357$exports = {
  "buttonLabel": `Näytä ehdotukset`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} vaihtoehto`,
    other: () => `${formatter.number(args.optionCount)} vaihtoehdot`
  })} saatavilla.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Mentiin ryhmään ${args.groupTitle}, ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} vaihtoehdon`,
      other: () => `${formatter.number(args.groupCount)} vaihtoehdon`
    })} kanssa.`,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valittu`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Ehdotukset`,
  "selectedAnnouncement": (args) => `${args.optionText}, valittu`
};
var $6404b5cb5b241730$exports = {};
$6404b5cb5b241730$exports = {
  "buttonLabel": `Afficher les suggestions`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} option`,
    other: () => `${formatter.number(args.optionCount)} options`
  })} disponible(s).`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Groupe ${args.groupTitle} saisi, avec ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} option`,
      other: () => `${formatter.number(args.groupCount)} options`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, sélectionné(s)`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Suggestions`,
  "selectedAnnouncement": (args) => `${args.optionText}, sélectionné`
};
var $dfeafa702e92e31f$exports = {};
$dfeafa702e92e31f$exports = {
  "buttonLabel": `הצג הצעות`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `אפשרות ${formatter.number(args.optionCount)}`,
    other: () => `${formatter.number(args.optionCount)} אפשרויות`
  })} במצב זמין.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `נכנס לקבוצה ${args.groupTitle}, עם ${formatter.plural(args.groupCount, {
      one: () => `אפשרות ${formatter.number(args.groupCount)}`,
      other: () => `${formatter.number(args.groupCount)} אפשרויות`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, נבחר`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `הצעות`,
  "selectedAnnouncement": (args) => `${args.optionText}, נבחר`
};
var $2d125e0b34676352$exports = {};
$2d125e0b34676352$exports = {
  "buttonLabel": `Prikaži prijedloge`,
  "countAnnouncement": (args, formatter) => `Dostupno još: ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcija`,
    other: () => `${formatter.number(args.optionCount)} opcije/a`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Unesena skupina ${args.groupTitle}, s ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opcijom`,
      other: () => `${formatter.number(args.groupCount)} opcije/a`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, odabranih`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Prijedlozi`,
  "selectedAnnouncement": (args) => `${args.optionText}, odabrano`
};
var $ea029611d7634059$exports = {};
$ea029611d7634059$exports = {
  "buttonLabel": `Javaslatok megjelenítése`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} lehetőség`,
    other: () => `${formatter.number(args.optionCount)} lehetőség`
  })} áll rendelkezésre.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Belépett a(z) ${args.groupTitle} csoportba, amely ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} lehetőséget`,
      other: () => `${formatter.number(args.groupCount)} lehetőséget`
    })} tartalmaz. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, kijelölve`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Javaslatok`,
  "selectedAnnouncement": (args) => `${args.optionText}, kijelölve`
};
var $77f075bb86ad7091$exports = {};
$77f075bb86ad7091$exports = {
  "buttonLabel": `Mostra suggerimenti`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opzione disponibile`,
    other: () => `${formatter.number(args.optionCount)} opzioni disponibili`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Ingresso nel gruppo ${args.groupTitle}, con ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opzione`,
      other: () => `${formatter.number(args.groupCount)} opzioni`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selezionato`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Suggerimenti`,
  "selectedAnnouncement": (args) => `${args.optionText}, selezionato`
};
var $6e87462e84907983$exports = {};
$6e87462e84907983$exports = {
  "buttonLabel": `候補を表示`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} 個のオプション`,
    other: () => `${formatter.number(args.optionCount)} 個のオプション`
  })}を利用できます。`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `入力されたグループ ${args.groupTitle}、${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} 個のオプション`,
      other: () => `${formatter.number(args.groupCount)} 個のオプション`
    })}を含む。`,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `、選択済み`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `候補`,
  "selectedAnnouncement": (args) => `${args.optionText}、選択済み`
};
var $9246f2c6edc6b232$exports = {};
$9246f2c6edc6b232$exports = {
  "buttonLabel": `제안 사항 표시`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)}개 옵션`,
    other: () => `${formatter.number(args.optionCount)}개 옵션`
  })}을 사용할 수 있습니다.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `입력한 그룹 ${args.groupTitle}, ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)}개 옵션`,
      other: () => `${formatter.number(args.groupCount)}개 옵션`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, 선택됨`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `제안`,
  "selectedAnnouncement": (args) => `${args.optionText}, 선택됨`
};
var $e587accc6c0a434c$exports = {};
$e587accc6c0a434c$exports = {
  "buttonLabel": `Rodyti pasiūlymus`,
  "countAnnouncement": (args, formatter) => `Yra ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} parinktis`,
    other: () => `${formatter.number(args.optionCount)} parinktys (-ių)`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Įvesta grupė ${args.groupTitle}, su ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} parinktimi`,
      other: () => `${formatter.number(args.groupCount)} parinktimis (-ių)`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, pasirinkta`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Pasiūlymai`,
  "selectedAnnouncement": (args) => `${args.optionText}, pasirinkta`
};
var $03a1900e7400b5ab$exports = {};
$03a1900e7400b5ab$exports = {
  "buttonLabel": `Rādīt ieteikumus`,
  "countAnnouncement": (args, formatter) => `Pieejamo opciju skaits: ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcija`,
    other: () => `${formatter.number(args.optionCount)} opcijas`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Ievadīta grupa ${args.groupTitle}, ar ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opciju`,
      other: () => `${formatter.number(args.groupCount)} opcijām`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, atlasīta`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Ieteikumi`,
  "selectedAnnouncement": (args) => `${args.optionText}, atlasīta`
};
var $1387676441be6cf6$exports = {};
$1387676441be6cf6$exports = {
  "buttonLabel": `Vis forslag`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} alternativ`,
    other: () => `${formatter.number(args.optionCount)} alternativer`
  })} finnes.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Angitt gruppe ${args.groupTitle}, med ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} alternativ`,
      other: () => `${formatter.number(args.groupCount)} alternativer`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valgt`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Forslag`,
  "selectedAnnouncement": (args) => `${args.optionText}, valgt`
};
var $17e82ebf0f8ab91f$exports = {};
$17e82ebf0f8ab91f$exports = {
  "buttonLabel": `Suggesties weergeven`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} optie`,
    other: () => `${formatter.number(args.optionCount)} opties`
  })} beschikbaar.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Groep ${args.groupTitle} ingevoerd met ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} optie`,
      other: () => `${formatter.number(args.groupCount)} opties`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, geselecteerd`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Suggesties`,
  "selectedAnnouncement": (args) => `${args.optionText}, geselecteerd`
};
var $2f5377d3471630e5$exports = {};
$2f5377d3471630e5$exports = {
  "buttonLabel": `Wyświetlaj sugestie`,
  "countAnnouncement": (args, formatter) => `dostępna/dostępne(-nych) ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcja`,
    other: () => `${formatter.number(args.optionCount)} opcje(-i)`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Dołączono do grupy ${args.groupTitle}, z ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opcją`,
      other: () => `${formatter.number(args.groupCount)} opcjami`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, wybrano`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugestie`,
  "selectedAnnouncement": (args) => `${args.optionText}, wybrano`
};
var $dee9868b6fa95ffe$exports = {};
$dee9868b6fa95ffe$exports = {
  "buttonLabel": `Mostrar sugestões`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opção`,
    other: () => `${formatter.number(args.optionCount)} opções`
  })} disponível.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Grupo inserido ${args.groupTitle}, com ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opção`,
      other: () => `${formatter.number(args.groupCount)} opções`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selecionado`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugestões`,
  "selectedAnnouncement": (args) => `${args.optionText}, selecionado`
};
var $f8b2e63637cbb5a6$exports = {};
$f8b2e63637cbb5a6$exports = {
  "buttonLabel": `Apresentar sugestões`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opção`,
    other: () => `${formatter.number(args.optionCount)} opções`
  })} disponível.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Grupo introduzido ${args.groupTitle}, com ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opção`,
      other: () => `${formatter.number(args.groupCount)} opções`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selecionado`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugestões`,
  "selectedAnnouncement": (args) => `${args.optionText}, selecionado`
};
var $46a885db3b44ea95$exports = {};
$46a885db3b44ea95$exports = {
  "buttonLabel": `Afișare sugestii`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opțiune`,
    other: () => `${formatter.number(args.optionCount)} opțiuni`
  })} disponibile.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Grup ${args.groupTitle} introdus, cu ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opțiune`,
      other: () => `${formatter.number(args.groupCount)} opțiuni`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, selectat`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Sugestii`,
  "selectedAnnouncement": (args) => `${args.optionText}, selectat`
};
var $50d8a8f0afa9dee5$exports = {};
$50d8a8f0afa9dee5$exports = {
  "buttonLabel": `Показать предложения`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} параметр`,
    other: () => `${formatter.number(args.optionCount)} параметров`
  })} доступно.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Введенная группа ${args.groupTitle}, с ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} параметром`,
      other: () => `${formatter.number(args.groupCount)} параметрами`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, выбранными`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Предложения`,
  "selectedAnnouncement": (args) => `${args.optionText}, выбрано`
};
var $2867ee6173245507$exports = {};
$2867ee6173245507$exports = {
  "buttonLabel": `Zobraziť návrhy`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} možnosť`,
    other: () => `${formatter.number(args.optionCount)} možnosti/-í`
  })} k dispozícii.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Zadaná skupina ${args.groupTitle}, s ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} možnosťou`,
      other: () => `${formatter.number(args.groupCount)} možnosťami`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, vybraté`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Návrhy`,
  "selectedAnnouncement": (args) => `${args.optionText}, vybraté`
};
var $0631b65beeb09b50$exports = {};
$0631b65beeb09b50$exports = {
  "buttonLabel": `Prikaži predloge`,
  "countAnnouncement": (args, formatter) => `Na voljo je ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcija`,
    other: () => `${formatter.number(args.optionCount)} opcije`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Vnesena skupina ${args.groupTitle}, z ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opcija`,
      other: () => `${formatter.number(args.groupCount)} opcije`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, izbrano`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Predlogi`,
  "selectedAnnouncement": (args) => `${args.optionText}, izbrano`
};
var $65fc749265dcd686$exports = {};
$65fc749265dcd686$exports = {
  "buttonLabel": `Prikaži predloge`,
  "countAnnouncement": (args, formatter) => `Dostupno još: ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} opcija`,
    other: () => `${formatter.number(args.optionCount)} opcije/a`
  })}.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Unesena grupa ${args.groupTitle}, s ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} opcijom`,
      other: () => `${formatter.number(args.groupCount)} optione/a`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, izabranih`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Predlozi`,
  "selectedAnnouncement": (args) => `${args.optionText}, izabrano`
};
var $69ba655c7853c08e$exports = {};
$69ba655c7853c08e$exports = {
  "buttonLabel": `Visa förslag`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} alternativ`,
    other: () => `${formatter.number(args.optionCount)} alternativ`
  })} tillgängliga.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Ingick i gruppen ${args.groupTitle} med ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} alternativ`,
      other: () => `${formatter.number(args.groupCount)} alternativ`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, valda`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Förslag`,
  "selectedAnnouncement": (args) => `${args.optionText}, valda`
};
var $a79794784d61577c$exports = {};
$a79794784d61577c$exports = {
  "buttonLabel": `Önerileri göster`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} seçenek`,
    other: () => `${formatter.number(args.optionCount)} seçenekler`
  })} kullanılabilir.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Girilen grup ${args.groupTitle}, ile ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} seçenek`,
      other: () => `${formatter.number(args.groupCount)} seçenekler`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, seçildi`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Öneriler`,
  "selectedAnnouncement": (args) => `${args.optionText}, seçildi`
};
var $c2845791417ebaf4$exports = {};
$c2845791417ebaf4$exports = {
  "buttonLabel": `Показати пропозиції`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} параметр`,
    other: () => `${formatter.number(args.optionCount)} параметри(-ів)`
  })} доступно.`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `Введена група ${args.groupTitle}, з ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} параметр`,
      other: () => `${formatter.number(args.groupCount)} параметри(-ів)`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, вибрано`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `Пропозиції`,
  "selectedAnnouncement": (args) => `${args.optionText}, вибрано`
};
var $29b642d0025cc7a4$exports = {};
$29b642d0025cc7a4$exports = {
  "buttonLabel": `显示建议`,
  "countAnnouncement": (args, formatter) => `有 ${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} 个选项`,
    other: () => `${formatter.number(args.optionCount)} 个选项`
  })}可用。`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `进入了 ${args.groupTitle} 组，其中有 ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} 个选项`,
      other: () => `${formatter.number(args.groupCount)} 个选项`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, 已选择`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `建议`,
  "selectedAnnouncement": (args) => `${args.optionText}, 已选择`
};
var $cd36dd33f9d46936$exports = {};
$cd36dd33f9d46936$exports = {
  "buttonLabel": `顯示建議`,
  "countAnnouncement": (args, formatter) => `${formatter.plural(args.optionCount, {
    one: () => `${formatter.number(args.optionCount)} 選項`,
    other: () => `${formatter.number(args.optionCount)} 選項`
  })} 可用。`,
  "focusAnnouncement": (args, formatter) => `${formatter.select({
    true: () => `輸入的群組 ${args.groupTitle}, 有 ${formatter.plural(args.groupCount, {
      one: () => `${formatter.number(args.groupCount)} 選項`,
      other: () => `${formatter.number(args.groupCount)} 選項`
    })}. `,
    other: ``
  }, args.isGroupChange)}${args.optionText}${formatter.select({
    true: `, 已選取`,
    other: ``
  }, args.isSelected)}`,
  "listboxLabel": `建議`,
  "selectedAnnouncement": (args) => `${args.optionText}, 已選取`
};
$de5926a92e8ebc5b$exports = {
  "ar-AE": $02cb4c75c506befe$exports,
  "bg-BG": $568b8163f1e56faf$exports,
  "cs-CZ": $87581c0202d106b8$exports,
  "da-DK": $a10a0369f5433ed1$exports,
  "de-DE": $bfd288727d5cb166$exports,
  "el-GR": $ca177778f9a74e3c$exports,
  "en-US": $9b5aa79ef84beb6c$exports,
  "es-ES": $57968e8209de2557$exports,
  "et-EE": $60690790bf4c1c6a$exports,
  "fi-FI": $1101246e8c7d9357$exports,
  "fr-FR": $6404b5cb5b241730$exports,
  "he-IL": $dfeafa702e92e31f$exports,
  "hr-HR": $2d125e0b34676352$exports,
  "hu-HU": $ea029611d7634059$exports,
  "it-IT": $77f075bb86ad7091$exports,
  "ja-JP": $6e87462e84907983$exports,
  "ko-KR": $9246f2c6edc6b232$exports,
  "lt-LT": $e587accc6c0a434c$exports,
  "lv-LV": $03a1900e7400b5ab$exports,
  "nb-NO": $1387676441be6cf6$exports,
  "nl-NL": $17e82ebf0f8ab91f$exports,
  "pl-PL": $2f5377d3471630e5$exports,
  "pt-BR": $dee9868b6fa95ffe$exports,
  "pt-PT": $f8b2e63637cbb5a6$exports,
  "ro-RO": $46a885db3b44ea95$exports,
  "ru-RU": $50d8a8f0afa9dee5$exports,
  "sk-SK": $2867ee6173245507$exports,
  "sl-SI": $0631b65beeb09b50$exports,
  "sr-SP": $65fc749265dcd686$exports,
  "sv-SE": $69ba655c7853c08e$exports,
  "tr-TR": $a79794784d61577c$exports,
  "uk-UA": $c2845791417ebaf4$exports,
  "zh-CN": $29b642d0025cc7a4$exports,
  "zh-TW": $cd36dd33f9d46936$exports
};
function $c350ade66beef0af$export$8c18d1b4f7232bbf(props, state) {
  let { buttonRef, popoverRef, inputRef, listBoxRef, keyboardDelegate, shouldFocusWrap, isReadOnly, isDisabled } = props;
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault5($de5926a92e8ebc5b$exports)));
  let { menuTriggerProps, menuProps } = (0, $168583247155ddda$export$dc9c12ed27dd1b49)({
    type: "listbox",
    isDisabled: isDisabled || isReadOnly
  }, state, buttonRef);
  (0, $b1f0cad8af73213b$export$3585ede4d035bf14).set(state, {
    id: menuProps.id
  });
  let delegate = (0, import_react64.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(state.collection, state.disabledKeys, listBoxRef), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    listBoxRef
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    selectionManager: state.selectionManager,
    keyboardDelegate: delegate,
    disallowTypeAhead: true,
    disallowEmptySelection: true,
    shouldFocusWrap,
    ref: inputRef,
    // Prevent item scroll behavior from being applied here, should be handled in the user's Popover + ListBox component
    isVirtualized: true
  });
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onKeyDown = (e6) => {
    switch (e6.key) {
      case "Enter":
      case "Tab":
        if (state.isOpen && e6.key === "Enter")
          e6.preventDefault();
        if (state.isOpen && state.selectionManager.focusedKey != null && state.selectionManager.isLink(state.selectionManager.focusedKey)) {
          if (e6.key === "Enter") {
            let item2 = listBoxRef.current.querySelector(`[data-key="${state.selectionManager.focusedKey}"]`);
            if (item2 instanceof HTMLAnchorElement)
              router.open(item2, e6);
          }
          state.close();
        } else
          state.commit();
        break;
      case "Escape":
        if (state.selectedKey !== null || state.inputValue === "" || props.allowsCustomValue)
          e6.continuePropagation();
        state.revert();
        break;
      case "ArrowDown":
        state.open("first", "manual");
        break;
      case "ArrowUp":
        state.open("last", "manual");
        break;
      case "ArrowLeft":
      case "ArrowRight":
        state.selectionManager.setFocusedKey(null);
        break;
    }
  };
  let onBlur = (e6) => {
    var _popoverRef_current;
    if (e6.relatedTarget === (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) || ((_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(e6.relatedTarget)))
      return;
    if (props.onBlur)
      props.onBlur(e6);
    state.setFocused(false);
  };
  let onFocus = (e6) => {
    if (state.isFocused)
      return;
    if (props.onFocus)
      props.onFocus(e6);
    state.setFocused(true);
  };
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, inputProps, descriptionProps, errorMessageProps } = (0, $2d73ec29415bd339$export$712718f7aec83d5)({
    ...props,
    onChange: state.setInputValue,
    onKeyDown: !isReadOnly && (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(state.isOpen && collectionProps.onKeyDown, onKeyDown, props.onKeyDown),
    onBlur,
    value: state.inputValue,
    onFocus,
    autoComplete: "off",
    validate: void 0,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: state
  }, inputRef);
  let onPress = (e6) => {
    if (e6.pointerType === "touch") {
      inputRef.current.focus();
      state.toggle(null, "manual");
    }
  };
  let onPressStart = (e6) => {
    if (e6.pointerType !== "touch") {
      inputRef.current.focus();
      state.toggle(e6.pointerType === "keyboard" || e6.pointerType === "virtual" ? "first" : null, "manual");
    }
  };
  let triggerLabelProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id: menuTriggerProps.id,
    "aria-label": stringFormatter.format("buttonLabel"),
    "aria-labelledby": props["aria-labelledby"] || labelProps.id
  });
  let listBoxProps = (0, $313b98861ee5dd6c$export$d6875122194c7b44)({
    id: menuProps.id,
    "aria-label": stringFormatter.format("listboxLabel"),
    "aria-labelledby": props["aria-labelledby"] || labelProps.id
  });
  let lastEventTime = (0, import_react64.useRef)(0);
  let onTouchEnd = (e6) => {
    if (isDisabled || isReadOnly)
      return;
    if (e6.timeStamp - lastEventTime.current < 500) {
      e6.preventDefault();
      inputRef.current.focus();
      return;
    }
    let rect = e6.target.getBoundingClientRect();
    let touch = e6.changedTouches[0];
    let centerX = Math.ceil(rect.left + 0.5 * rect.width);
    let centerY = Math.ceil(rect.top + 0.5 * rect.height);
    if (touch.clientX === centerX && touch.clientY === centerY) {
      e6.preventDefault();
      inputRef.current.focus();
      state.toggle(null, "manual");
      lastEventTime.current = e6.timeStamp;
    }
  };
  let focusedItem = state.selectionManager.focusedKey != null && state.isOpen ? state.collection.getItem(state.selectionManager.focusedKey) : void 0;
  var _focusedItem_parentKey;
  let sectionKey = (_focusedItem_parentKey = focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.parentKey) !== null && _focusedItem_parentKey !== void 0 ? _focusedItem_parentKey : null;
  var _state_selectionManager_focusedKey;
  let itemKey = (_state_selectionManager_focusedKey = state.selectionManager.focusedKey) !== null && _state_selectionManager_focusedKey !== void 0 ? _state_selectionManager_focusedKey : null;
  let lastSection = (0, import_react64.useRef)(sectionKey);
  let lastItem = (0, import_react64.useRef)(itemKey);
  (0, import_react64.useEffect)(() => {
    if ((0, $c87311424ea30a05$export$e1865c3bedcd822b)() && focusedItem != null && itemKey !== lastItem.current) {
      let isSelected = state.selectionManager.isSelected(itemKey);
      let section = sectionKey != null ? state.collection.getItem(sectionKey) : null;
      let sectionTitle = (section === null || section === void 0 ? void 0 : section["aria-label"]) || (typeof (section === null || section === void 0 ? void 0 : section.rendered) === "string" ? section.rendered : "") || "";
      let announcement = stringFormatter.format("focusAnnouncement", {
        isGroupChange: section && sectionKey !== lastSection.current,
        groupTitle: sectionTitle,
        groupCount: section ? [
          ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(section, state.collection)
        ].length : 0,
        optionText: focusedItem["aria-label"] || focusedItem.textValue || "",
        isSelected
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSection.current = sectionKey;
    lastItem.current = itemKey;
  });
  let optionCount = (0, $453cc9f0df89c0a5$export$77d5aafae4e095b2)(state.collection);
  let lastSize = (0, import_react64.useRef)(optionCount);
  let lastOpen = (0, import_react64.useRef)(state.isOpen);
  (0, import_react64.useEffect)(() => {
    let didOpenWithoutFocusedItem = state.isOpen !== lastOpen.current && (state.selectionManager.focusedKey == null || (0, $c87311424ea30a05$export$e1865c3bedcd822b)());
    if (state.isOpen && (didOpenWithoutFocusedItem || optionCount !== lastSize.current)) {
      let announcement = stringFormatter.format("countAnnouncement", {
        optionCount
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSize.current = optionCount;
    lastOpen.current = state.isOpen;
  });
  let lastSelectedKey = (0, import_react64.useRef)(state.selectedKey);
  (0, import_react64.useEffect)(() => {
    if ((0, $c87311424ea30a05$export$e1865c3bedcd822b)() && state.isFocused && state.selectedItem && state.selectedKey !== lastSelectedKey.current) {
      let optionText = state.selectedItem["aria-label"] || state.selectedItem.textValue || "";
      let announcement = stringFormatter.format("selectedAnnouncement", {
        optionText
      });
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(announcement);
    }
    lastSelectedKey.current = state.selectedKey;
  });
  (0, import_react64.useEffect)(() => {
    if (state.isOpen)
      return (0, $5e3802645cc19319$export$1c3ebcada18427bf)([
        inputRef.current,
        popoverRef.current
      ]);
  }, [
    state.isOpen,
    inputRef,
    popoverRef
  ]);
  return {
    labelProps,
    buttonProps: {
      ...menuTriggerProps,
      ...triggerLabelProps,
      excludeFromTabOrder: true,
      onPress,
      onPressStart,
      isDisabled: isDisabled || isReadOnly
    },
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(inputProps, {
      role: "combobox",
      "aria-expanded": menuTriggerProps["aria-expanded"],
      "aria-controls": state.isOpen ? menuProps.id : void 0,
      // TODO: readd proper logic for completionMode = complete (aria-autocomplete: both)
      "aria-autocomplete": "list",
      "aria-activedescendant": focusedItem ? (0, $b1f0cad8af73213b$export$9145995848b05025)(state, focusedItem.key) : void 0,
      onTouchEnd,
      // This disable's iOS's autocorrect suggestions, since the combo box provides its own suggestions.
      autoCorrect: "off",
      // This disable's the macOS Safari spell check auto corrections.
      spellCheck: "false"
    }),
    listBoxProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(menuProps, listBoxProps, {
      autoFocus: state.focusStrategy,
      shouldUseVirtualFocus: true,
      shouldSelectOnPressUp: true,
      shouldFocusOnHover: true,
      linkBehavior: "selection"
    }),
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/.pnpm/@react-stately+combobox@3.8.0_react@18.2.0/node_modules/@react-stately/combobox/dist/import.mjs
var import_react65 = __toESM(require_react(), 1);
function $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e(props) {
  var _collection_getItem, _collection_getItem1;
  let { defaultFilter, menuTrigger = "input", allowsEmptyCollection = false, allowsCustomValue, shouldCloseOnBlur = true } = props;
  let [showAllItems, setShowAllItems] = (0, import_react65.useState)(false);
  let [isFocused, setFocusedState] = (0, import_react65.useState)(false);
  let onSelectionChange = (key) => {
    if (props.onSelectionChange)
      props.onSelectionChange(key);
    if (key === selectedKey) {
      resetInputValue();
      closeMenu();
    }
  };
  var _props_items;
  let { collection: collection2, selectionManager, selectedKey, setSelectedKey, selectedItem, disabledKeys } = (0, $a0d645289fe9b86b$export$e7f05e985daf4b5f)({
    ...props,
    onSelectionChange,
    items: (_props_items = props.items) !== null && _props_items !== void 0 ? _props_items : props.defaultItems
  });
  var _props_defaultInputValue, _ref;
  let [inputValue, setInputValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.inputValue, (_ref = (_props_defaultInputValue = props.defaultInputValue) !== null && _props_defaultInputValue !== void 0 ? _props_defaultInputValue : (_collection_getItem = collection2.getItem(selectedKey)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue) !== null && _ref !== void 0 ? _ref : "", props.onInputChange);
  let originalCollection = collection2;
  let filteredCollection = (0, import_react65.useMemo)(() => (
    // No default filter if items are controlled.
    props.items != null || !defaultFilter ? collection2 : $a9e7382a7d111cb5$var$filterCollection(collection2, inputValue, defaultFilter)
  ), [
    collection2,
    inputValue,
    defaultFilter,
    props.items
  ]);
  let [lastCollection, setLastCollection] = (0, import_react65.useState)(filteredCollection);
  let menuOpenTrigger = (0, import_react65.useRef)("focus");
  let onOpenChange = (open2) => {
    if (props.onOpenChange)
      props.onOpenChange(open2, open2 ? menuOpenTrigger.current : void 0);
    selectionManager.setFocused(open2);
    if (!open2)
      selectionManager.setFocusedKey(null);
  };
  let triggerState = (0, $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)({
    ...props,
    onOpenChange,
    isOpen: void 0,
    defaultOpen: void 0
  });
  let open = (focusStrategy, trigger2) => {
    let displayAllItems = trigger2 === "manual" || trigger2 === "focus" && menuTrigger === "focus";
    if (allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) {
      if (displayAllItems && !triggerState.isOpen && props.items === void 0)
        setShowAllItems(true);
      menuOpenTrigger.current = trigger2;
      triggerState.open(focusStrategy);
    }
  };
  let toggle = (focusStrategy, trigger2) => {
    let displayAllItems = trigger2 === "manual" || trigger2 === "focus" && menuTrigger === "focus";
    if (!(allowsEmptyCollection || filteredCollection.size > 0 || displayAllItems && originalCollection.size > 0 || props.items) && !triggerState.isOpen)
      return;
    if (displayAllItems && !triggerState.isOpen && props.items === void 0)
      setShowAllItems(true);
    if (!triggerState.isOpen)
      menuOpenTrigger.current = trigger2;
    toggleMenu(focusStrategy);
  };
  let toggleMenu = (0, import_react65.useCallback)((focusStrategy) => {
    if (triggerState.isOpen)
      setLastCollection(filteredCollection);
    triggerState.toggle(focusStrategy);
  }, [
    triggerState,
    filteredCollection
  ]);
  let closeMenu = (0, import_react65.useCallback)(() => {
    if (triggerState.isOpen) {
      setLastCollection(filteredCollection);
      triggerState.close();
    }
  }, [
    triggerState,
    filteredCollection
  ]);
  let [lastValue, setLastValue] = (0, import_react65.useState)(inputValue);
  let resetInputValue = () => {
    var _collection_getItem2;
    var _collection_getItem_textValue2;
    let itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
    setLastValue(itemText);
    setInputValue(itemText);
  };
  var _props_selectedKey, _ref1;
  let lastSelectedKey = (0, import_react65.useRef)((_ref1 = (_props_selectedKey = props.selectedKey) !== null && _props_selectedKey !== void 0 ? _props_selectedKey : props.defaultSelectedKey) !== null && _ref1 !== void 0 ? _ref1 : null);
  var _collection_getItem_textValue;
  let lastSelectedKeyText = (0, import_react65.useRef)((_collection_getItem_textValue = (_collection_getItem1 = collection2.getItem(selectedKey)) === null || _collection_getItem1 === void 0 ? void 0 : _collection_getItem1.textValue) !== null && _collection_getItem_textValue !== void 0 ? _collection_getItem_textValue : "");
  (0, import_react65.useEffect)(() => {
    var _collection_getItem2;
    if (isFocused && (filteredCollection.size > 0 || allowsEmptyCollection) && !triggerState.isOpen && inputValue !== lastValue && menuTrigger !== "manual")
      open(null, "input");
    if (!showAllItems && !allowsEmptyCollection && triggerState.isOpen && filteredCollection.size === 0)
      closeMenu();
    if (selectedKey != null && selectedKey !== lastSelectedKey.current)
      closeMenu();
    if (inputValue !== lastValue) {
      selectionManager.setFocusedKey(null);
      setShowAllItems(false);
      if (inputValue === "" && (props.inputValue === void 0 || props.selectedKey === void 0))
        setSelectedKey(null);
    }
    if (selectedKey !== lastSelectedKey.current && (props.inputValue === void 0 || props.selectedKey === void 0))
      resetInputValue();
    else if (lastValue !== inputValue)
      setLastValue(inputValue);
    var _collection_getItem_textValue2;
    let selectedItemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
    if (!isFocused && selectedKey != null && props.inputValue === void 0 && selectedKey === lastSelectedKey.current) {
      if (lastSelectedKeyText.current !== selectedItemText) {
        setLastValue(selectedItemText);
        setInputValue(selectedItemText);
      }
    }
    lastSelectedKey.current = selectedKey;
    lastSelectedKeyText.current = selectedItemText;
  });
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: (0, import_react65.useMemo)(() => ({
      inputValue,
      selectedKey
    }), [
      inputValue,
      selectedKey
    ])
  });
  let revert = () => {
    if (allowsCustomValue && selectedKey == null)
      commitCustomValue();
    else
      commitSelection();
  };
  let commitCustomValue = () => {
    lastSelectedKey.current = null;
    setSelectedKey(null);
    closeMenu();
  };
  let commitSelection = () => {
    if (props.selectedKey !== void 0 && props.inputValue !== void 0) {
      var _collection_getItem2;
      props.onSelectionChange(selectedKey);
      var _collection_getItem_textValue2;
      let itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
      setLastValue(itemText);
      closeMenu();
    } else {
      resetInputValue();
      closeMenu();
    }
  };
  const commitValue = () => {
    if (allowsCustomValue) {
      var _collection_getItem2;
      var _collection_getItem_textValue2;
      const itemText = (_collection_getItem_textValue2 = (_collection_getItem2 = collection2.getItem(selectedKey)) === null || _collection_getItem2 === void 0 ? void 0 : _collection_getItem2.textValue) !== null && _collection_getItem_textValue2 !== void 0 ? _collection_getItem_textValue2 : "";
      inputValue === itemText ? commitSelection() : commitCustomValue();
    } else
      commitSelection();
  };
  let commit = () => {
    if (triggerState.isOpen && selectionManager.focusedKey != null) {
      if (selectedKey === selectionManager.focusedKey)
        commitSelection();
      else
        setSelectedKey(selectionManager.focusedKey);
    } else
      commitValue();
  };
  let valueOnFocus = (0, import_react65.useRef)(inputValue);
  let setFocused = (isFocused2) => {
    if (isFocused2) {
      valueOnFocus.current = inputValue;
      if (menuTrigger === "focus")
        open(null, "focus");
    } else {
      if (shouldCloseOnBlur)
        commitValue();
      if (inputValue !== valueOnFocus.current)
        validation.commitValidation();
    }
    setFocusedState(isFocused2);
  };
  let displayedCollection = (0, import_react65.useMemo)(() => {
    if (triggerState.isOpen) {
      if (showAllItems)
        return originalCollection;
      else
        return filteredCollection;
    } else
      return lastCollection;
  }, [
    triggerState.isOpen,
    originalCollection,
    filteredCollection,
    showAllItems,
    lastCollection
  ]);
  return {
    ...validation,
    ...triggerState,
    toggle,
    open,
    close: commitValue,
    selectionManager,
    selectedKey,
    setSelectedKey,
    disabledKeys,
    isFocused,
    setFocused,
    selectedItem,
    collection: displayedCollection,
    inputValue,
    setInputValue,
    commit,
    revert
  };
}
function $a9e7382a7d111cb5$var$filterCollection(collection2, inputValue, filter3) {
  return new (0, $a02d57049d202695$export$d085fb9e920b5ca7)($a9e7382a7d111cb5$var$filterNodes(collection2, collection2, inputValue, filter3));
}
function $a9e7382a7d111cb5$var$filterNodes(collection2, nodes, inputValue, filter3) {
  let filteredNode = [];
  for (let node3 of nodes) {
    if (node3.type === "section" && node3.hasChildNodes) {
      let filtered = $a9e7382a7d111cb5$var$filterNodes(collection2, (0, $c5a24bc478652b5f$export$1005530eda016c13)(node3, collection2), inputValue, filter3);
      if ([
        ...filtered
      ].some((node4) => node4.type === "item"))
        filteredNode.push({
          ...node3,
          childNodes: filtered
        });
    } else if (node3.type === "item" && filter3(node3.textValue, inputValue))
      filteredNode.push({
        ...node3
      });
    else if (node3.type !== "item")
      filteredNode.push({
        ...node3
      });
  }
  return filteredNode;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/combobox/dist/keystar-ui-combobox.esm.js
var import_react66 = __toESM(require_react());
var import_jsx_runtime55 = __toESM(require_jsx_runtime());
var comboboxClassList = new ClassList("Combobox", ["input", "mobile-trigger"]);
var localizedMessages9 = {
  "ar-AE": {
    clear: "مسح",
    invalid: "(غير صالح)",
    loading: "جارٍ التحميل...",
    noResults: "لا توجد نتائج"
  },
  "bg-BG": {
    clear: "Изчисти",
    invalid: "(невалиден)",
    loading: "Зареждане...",
    noResults: "Няма резултати"
  },
  "cs-CZ": {
    clear: "Vymazat",
    invalid: "(neplatné)",
    loading: "Načítání...",
    noResults: "Žádné výsledky"
  },
  "da-DK": {
    clear: "Ryd",
    invalid: "(ugyldig)",
    loading: "Indlæser ...",
    noResults: "Ingen resultater"
  },
  "de-DE": {
    clear: "Löschen",
    invalid: "(ungültig)",
    loading: "Wird geladen...",
    noResults: "Keine Ergebnisse"
  },
  "el-GR": {
    clear: "Καθαρισμός",
    invalid: "(δεν ισχύει)",
    loading: "Φόρτωση...",
    noResults: "Χωρίς αποτέλεσμα"
  },
  "en-US": {
    loading: "Loading...",
    noResults: "No results",
    clear: "Clear",
    invalid: "(invalid)"
  },
  "es-ES": {
    clear: "Borrar",
    invalid: "(no válido)",
    loading: "Cargando...",
    noResults: "Sin resultados"
  },
  "et-EE": {
    clear: "Puhasta",
    invalid: "(kehtetu)",
    loading: "Laadimine...",
    noResults: "Tulemusi pole"
  },
  "fi-FI": {
    clear: "Kirkas",
    invalid: "(epäkelpo)",
    loading: "Ladataan...",
    noResults: "Ei tuloksia"
  },
  "fr-FR": {
    clear: "Effacer",
    invalid: "(non valide)",
    loading: "Chargement en cours...",
    noResults: "Aucun résultat"
  },
  "he-IL": {
    clear: "נקי",
    invalid: "(לא חוקי)",
    loading: "טוען...",
    noResults: "אין תוצאות"
  },
  "hr-HR": {
    clear: "Izbriši",
    invalid: "(nevažeće)",
    loading: "Učitavam...",
    noResults: "Nema rezultata"
  },
  "hu-HU": {
    clear: "Törlés",
    invalid: "(érvénytelen)",
    loading: "Betöltés folyamatban…",
    noResults: "Nincsenek találatok"
  },
  "it-IT": {
    clear: "Cancella",
    invalid: "(non valido)",
    loading: "Caricamento in corso...",
    noResults: "Nessun risultato"
  },
  "ja-JP": {
    clear: "クリア",
    invalid: "(無効)",
    loading: "読み込み中...",
    noResults: "結果なし"
  },
  "ko-KR": {
    clear: "지우기",
    invalid: "(유효하지 않음)",
    loading: "로드 중...",
    noResults: "결과 없음"
  },
  "lt-LT": {
    clear: "Skaidrus",
    invalid: "(netinkama)",
    loading: "Įkeliama...",
    noResults: "Be rezultatų"
  },
  "lv-LV": {
    clear: "Notīrīt",
    invalid: "(nederīgs)",
    loading: "Notiek ielāde...",
    noResults: "Nav rezultātu"
  },
  "nb-NO": {
    clear: "Tøm",
    invalid: "(ugyldig)",
    loading: "Laster inn ...",
    noResults: "Ingen resultater"
  },
  "nl-NL": {
    clear: "Helder",
    invalid: "(ongeldig)",
    loading: "Laden...",
    noResults: "Geen resultaten"
  },
  "pl-PL": {
    clear: "Wyczyść",
    invalid: "(nieprawidłowy)",
    loading: "Trwa ładowanie...",
    noResults: "Brak wyników"
  },
  "pt-BR": {
    clear: "Limpar",
    invalid: "(inválido)",
    loading: "Carregando...",
    noResults: "Nenhum resultado"
  },
  "pt-PT": {
    clear: "Limpar",
    invalid: "(inválido)",
    loading: "A carregar...",
    noResults: "Sem resultados"
  },
  "ro-RO": {
    clear: "Golire",
    invalid: "(nevalid)",
    loading: "Se încarcă...",
    noResults: "Niciun rezultat"
  },
  "ru-RU": {
    clear: "Очистить",
    invalid: "(недействительно)",
    loading: "Загрузка...",
    noResults: "Результаты отсутствуют"
  },
  "sk-SK": {
    clear: "Vymazať",
    invalid: "(neplatné)",
    loading: "Načítava sa...",
    noResults: "Žiadne výsledky"
  },
  "sl-SI": {
    clear: "Jasen",
    invalid: "(neveljavno)",
    loading: "Nalaganje...",
    noResults: "Ni rezultatov"
  },
  "sr-SP": {
    clear: "Izbriši",
    invalid: "(nevažeće)",
    loading: "Učitavam...",
    noResults: "Nema rezultata"
  },
  "sv-SE": {
    clear: "Rensa",
    invalid: "(ogiltigt)",
    loading: "Läser in...",
    noResults: "Inga resultat"
  },
  "tr-TR": {
    clear: "Temizle",
    invalid: "(geçersiz)",
    loading: "Yükleniyor...",
    noResults: "Sonuç yok"
  },
  "uk-UA": {
    clear: "Очистити",
    invalid: "(недійсне)",
    loading: "Завантаження...",
    noResults: "Результатів немає"
  },
  "zh-CN": {
    clear: "透明",
    invalid: "（无效）",
    loading: "正在加载...",
    noResults: "无结果"
  },
  "zh-TW": {
    clear: "清除",
    invalid: "(無效)",
    loading: "正在載入...",
    noResults: "無任何結果"
  }
};
function MobileCombobox(props, forwardedRef) {
  props = useProviderProps(props);
  let {
    isDisabled,
    validationState,
    isReadOnly
  } = props;
  let {
    contains
  } = $bb77f239b46e8c72$export$3274cf84b703fff({
    sensitivity: "base"
  });
  let state = $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e({
    ...props,
    defaultFilter: contains,
    allowsEmptyCollection: true,
    // Needs to be false here otherwise we double up on
    // commitSelection/commitCustomValue calls when user taps on underlay (i.e.
    // initial tap will call setFocused(false) ->
    // commitSelection/commitCustomValue via onBlur, then the closing of the
    // tray will call setFocused(false) again due to cleanup effect)
    shouldCloseOnBlur: false
  });
  let buttonRef = (0, import_react66.useRef)(null);
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    triggerProps,
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d({
    type: "listbox"
  }, state, buttonRef);
  let {
    labelProps,
    fieldProps
  } = $2baaea4c71418dea$export$294aa081a6c6f55d({
    ...props,
    labelElementType: "span"
  });
  labelProps.onClick = () => {
    let button = buttonRef.current;
    if (button && !props.isDisabled) {
      button.focus();
      $507fabe10e71c6fb$export$8397ddfc504fdb9a("keyboard");
    }
  };
  return (0, import_jsx_runtime55.jsxs)(import_jsx_runtime55.Fragment, {
    children: [(0, import_jsx_runtime55.jsx)(FieldPrimitive, {
      ...props,
      labelProps,
      ref: domRef,
      supplementRequiredState: true,
      children: (0, import_jsx_runtime55.jsx)(ComboboxButton, {
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(triggerProps, fieldProps, {
          autoFocus: props.autoFocus
        }),
        ref: buttonRef,
        isDisabled,
        isReadOnly,
        isPlaceholder: !state.inputValue,
        validationState,
        onPress: () => !isReadOnly && state.open(null, "manual"),
        children: state.inputValue || props.placeholder || ""
      })
    }), (0, import_jsx_runtime55.jsx)(Tray, {
      state,
      isFixedHeight: true,
      ...overlayProps,
      children: (0, import_jsx_runtime55.jsx)(ComboboxTray, {
        ...props,
        onClose: state.close,
        overlayProps,
        state
      })
    })]
  });
}
var ComboboxButton = import_react66.default.forwardRef(function ComboboxButton2(props, forwardedRef) {
  let {
    isDisabled,
    isPlaceholder,
    validationState,
    children,
    style
  } = props;
  let valueId = $bdb11010cef70236$export$f680877a34711e37();
  let invalidId = $bdb11010cef70236$export$f680877a34711e37();
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({});
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    ...props,
    "aria-labelledby": [props["aria-labelledby"], props["aria-label"] && !props["aria-labelledby"] ? props.id : null, valueId, validationState === "invalid" ? invalidId : null].filter(Boolean).join(" "),
    elementType: "div"
  }, domRef);
  return (0, import_jsx_runtime55.jsx)(FocusRing, {
    children: (0, import_jsx_runtime55.jsxs)(Flex, {
      position: "relative",
      width: "alias.singleLineWidth",
      zIndex: 0,
      ...toDataAttributes({
        readonly: props.isReadOnly
      }),
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, buttonProps),
      "aria-haspopup": "dialog",
      ref: domRef,
      UNSAFE_className: comboboxClassList.element("mobile-trigger"),
      UNSAFE_style: {
        ...style,
        outline: "none"
      },
      children: [(0, import_jsx_runtime55.jsx)(Flex, {
        alignItems: "center",
        paddingX: "medium",
        flex: true,
        children: (0, import_jsx_runtime55.jsx)(Text, {
          id: valueId,
          color: isPlaceholder ? "neutralSecondary" : void 0,
          trim: false,
          truncate: true,
          children
        })
      }), (0, import_jsx_runtime55.jsx)(InputStateIndicator2, {
        isHovered,
        isPressed,
        isDisabled,
        validationState
      }), (0, import_jsx_runtime55.jsx)(CosmeticFieldButton, {
        isHovered,
        isPressed,
        isDisabled,
        validationState,
        UNSAFE_className: css({
          borderEndStartRadius: 0,
          borderStartStartRadius: 0,
          [`${comboboxClassList.selector("mobile-trigger")}[data-focus] &`]: {
            borderColor: tokenSchema.color.alias.borderFocused
          }
        }),
        children: (0, import_jsx_runtime55.jsx)(Icon, {
          src: chevronDownIcon
        })
      })]
    })
  });
});
var CosmeticFieldButton = (props) => {
  let {
    isHovered,
    isPressed,
    ...otherProps
  } = props;
  let {
    children,
    styleProps
  } = useFieldButton(otherProps, {
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime55.jsx)("div", {
    "data-disabled": props.isDisabled,
    ...styleProps,
    children
  });
};
var InputStateIndicator2 = (props) => {
  let {
    isDisabled,
    isHovered,
    isPressed
  } = props;
  return (0, import_jsx_runtime55.jsx)("div", {
    role: "presentation",
    ...toDataAttributes({
      disabled: isDisabled,
      interaction: isPressed ? "press" : isHovered ? "hover" : void 0,
      validation: props.validationState
    }),
    className: css({
      backgroundColor: tokenSchema.color.background.canvas,
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`,
      borderRadius: tokenSchema.size.radius.regular,
      inset: 0,
      position: "absolute",
      transition: transition(["border-color", "box-shadow"]),
      zIndex: -1,
      "&[data-interaction=hover]": {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      "&[data-validation=invalid]": {
        borderColor: tokenSchema.color.alias.borderInvalid
      },
      [`${comboboxClassList.selector("mobile-trigger")}[data-focus] &`]: {
        borderColor: tokenSchema.color.alias.borderFocused
      },
      [`${comboboxClassList.selector("mobile-trigger")}[data-focus]:not([data-readonly]) &`]: {
        boxShadow: `0 0 0 1px ${tokenSchema.color.alias.borderFocused}`
      },
      "&[data-disabled=true]": {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        borderColor: "transparent"
      }
    })
  });
};
function ComboboxTray(props) {
  let {
    state,
    isDisabled,
    validationState,
    label,
    overlayProps,
    loadingState,
    onLoadMore,
    onClose
  } = props;
  let timeoutRef = (0, import_react66.useRef)();
  let [showLoading, setShowLoading] = (0, import_react66.useState)(false);
  let inputRef = (0, import_react66.useRef)(null);
  let buttonRef = (0, import_react66.useRef)(null);
  let popoverRef = (0, import_react66.useRef)(null);
  let listBoxRef = (0, import_react66.useRef)(null);
  let layout = useListBoxLayout(state);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages9);
  let {
    inputProps,
    listBoxProps,
    labelProps
  } = $c350ade66beef0af$export$8c18d1b4f7232bbf({
    ...props,
    keyboardDelegate: layout,
    buttonRef,
    popoverRef,
    listBoxRef,
    inputRef
  }, state);
  import_react66.default.useEffect(() => {
    let input = inputRef.current;
    if (input) {
      $6a99195332edec8b$export$80f3e147d781571c(input);
    }
    return () => {
      state.setFocused(false);
    };
  }, []);
  let {
    dialogProps
  } = $40df3f8667284809$export$d55e7ee900f34e93({
    "aria-labelledby": $bdb11010cef70236$export$f680877a34711e37(labelProps.id)
  }, popoverRef);
  inputProps.role = "searchbox";
  inputProps["aria-haspopup"] = "listbox";
  delete inputProps.onTouchEnd;
  let clearButton = (0, import_jsx_runtime55.jsx)(ClearButton, {
    preventFocus: true,
    "aria-label": stringFormatter.format("clear"),
    excludeFromTabOrder: true,
    onPress: () => {
      state.setInputValue("");
      let input = inputRef.current;
      if (input) {
        input.focus();
      }
    },
    isDisabled
  });
  let loadingCircle = (0, import_jsx_runtime55.jsx)(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: (0, import_jsx_runtime55.jsx)(ProgressCircle, {
      "aria-label": stringFormatter.format("loading"),
      size: "small",
      isIndeterminate: true
    })
  });
  let isTouchDown = (0, import_react66.useRef)(false);
  let onTouchStart = () => {
    isTouchDown.current = true;
  };
  let onTouchEnd = () => {
    isTouchDown.current = false;
  };
  let onScroll = (0, import_react66.useCallback)(() => {
    let input = inputRef.current;
    let popover = popoverRef.current;
    if (!input || document.activeElement !== input || !isTouchDown.current) {
      return;
    }
    if (popover) {
      popover.focus();
    }
  }, [inputRef, popoverRef, isTouchDown]);
  let inputValue = inputProps.value;
  let lastInputValue = (0, import_react66.useRef)(inputValue);
  (0, import_react66.useEffect)(() => {
    if (loadingState === "filtering" && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (loadingState !== "filtering") {
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = void 0;
    }
    lastInputValue.current = inputValue;
  }, [loadingState, inputValue, showLoading]);
  let onKeyDown = (e6) => {
    let popover = popoverRef.current;
    if (popover && e6.key === "Enter" && state.selectionManager.focusedKey == null) {
      popover.focus();
    } else {
      var _inputProps$onKeyDown;
      (_inputProps$onKeyDown = inputProps.onKeyDown) === null || _inputProps$onKeyDown === void 0 || _inputProps$onKeyDown.call(inputProps, e6);
    }
  };
  return (0, import_jsx_runtime55.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    restoreFocus: true,
    contain: true,
    children: (0, import_jsx_runtime55.jsxs)(Flex, {
      direction: "column",
      height: "100%",
      ref: popoverRef,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, dialogProps),
      children: [(0, import_jsx_runtime55.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: onClose
      }), (0, import_jsx_runtime55.jsx)(TextFieldPrimitive, {
        label,
        labelProps,
        inputProps: {
          ...inputProps,
          onKeyDown
        },
        ref: inputRef,
        isDisabled,
        marginX: "small",
        marginTop: "regular",
        endElement: (0, import_jsx_runtime55.jsxs)(Flex, {
          children: [showLoading && loadingState === "filtering" && loadingCircle, (state.inputValue !== "" || loadingState === "filtering" || validationState != null) && !props.isReadOnly && clearButton]
        })
      }), (0, import_jsx_runtime55.jsx)(_ListBoxBase, {
        ...listBoxProps,
        domProps: {
          onTouchStart,
          onTouchEnd
        },
        disallowEmptySelection: true,
        shouldSelectOnPressUp: true,
        focusOnPointerEnter: true,
        layout,
        state,
        shouldUseVirtualFocus: true,
        renderEmptyState: () => loadingState !== "loading" && (0, import_jsx_runtime55.jsx)(Flex, {
          height: "element.regular",
          alignItems: "center",
          paddingX: "medium",
          children: (0, import_jsx_runtime55.jsx)(Text, {
            color: "neutralSecondary",
            children: stringFormatter.format("noResults")
          })
        }),
        ref: listBoxRef,
        onScroll,
        onLoadMore,
        isLoading: loadingState === "loading" || loadingState === "loadingMore"
      }), (0, import_jsx_runtime55.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: onClose
      })]
    })
  });
}
var _MobileCombobox = import_react66.default.forwardRef(MobileCombobox);
function Combobox(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateTextFieldProps(props);
  let isMobile = useIsMobileDevice();
  if (isMobile) {
    return (0, import_jsx_runtime55.jsx)(_MobileCombobox, {
      ...props,
      menuTrigger: "input",
      ref: forwardedRef
    });
  } else {
    return (0, import_jsx_runtime55.jsx)(ComboboxBase, {
      ...props,
      ref: forwardedRef
    });
  }
}
var ComboboxBase = import_react66.default.forwardRef(function ComboboxBase2(props, forwardedRef) {
  let {
    align = "start",
    menuTrigger = "input",
    shouldFlip = true,
    direction = "bottom",
    loadingState,
    menuWidth: menuWidthProp,
    onLoadMore
  } = props;
  let isAsync = loadingState != null;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages9);
  let buttonRef = (0, import_react66.useRef)(null);
  let inputRef = (0, import_react66.useRef)(null);
  let listBoxRef = (0, import_react66.useRef)(null);
  let [popoverRefLikeValue, popoverRef] = useStatefulRef();
  let fieldRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    contains
  } = $bb77f239b46e8c72$export$3274cf84b703fff({
    sensitivity: "base"
  });
  let state = $a9e7382a7d111cb5$export$b453a3bfd4a5fa9e({
    ...props,
    defaultFilter: contains,
    allowsEmptyCollection: isAsync
  });
  let layout = useListBoxLayout(state);
  let {
    buttonProps,
    inputProps,
    listBoxProps,
    labelProps,
    descriptionProps,
    errorMessageProps
  } = $c350ade66beef0af$export$8c18d1b4f7232bbf({
    ...props,
    keyboardDelegate: layout,
    buttonRef,
    popoverRef: popoverRefLikeValue,
    listBoxRef,
    inputRef,
    menuTrigger
  }, state);
  let [menuWidth, setMenuWidth] = (0, import_react66.useState)();
  let {
    scale
  } = useProvider();
  let onResize = (0, import_react66.useCallback)(() => {
    if (buttonRef.current && inputRef.current) {
      let buttonWidth = buttonRef.current.offsetWidth;
      let inputWidth = inputRef.current.offsetWidth;
      setMenuWidth(inputWidth + buttonWidth);
    }
  }, [buttonRef, inputRef, setMenuWidth]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: fieldRef,
    onResize
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(onResize, [scale, onResize]);
  let style = {
    width: menuWidth,
    minWidth: menuWidthProp !== null && menuWidthProp !== void 0 ? menuWidthProp : menuWidth
  };
  return (0, import_jsx_runtime55.jsxs)(import_jsx_runtime55.Fragment, {
    children: [(0, import_jsx_runtime55.jsx)(FieldPrimitive, {
      width: "alias.singleLineWidth",
      ...props,
      descriptionProps,
      errorMessageProps,
      labelProps,
      ref: fieldRef,
      children: (0, import_jsx_runtime55.jsx)(ComboboxInput, {
        ...props,
        isOpen: state.isOpen,
        loadingState,
        inputProps,
        inputRef,
        triggerProps: buttonProps,
        triggerRef: buttonRef
      })
    }), (0, import_jsx_runtime55.jsx)(Popover, {
      state,
      UNSAFE_style: style,
      ref: popoverRef,
      triggerRef: align === "end" ? buttonRef : inputRef,
      scrollRef: listBoxRef,
      placement: `${direction} ${align}`,
      hideArrow: true,
      isNonModal: true,
      shouldFlip,
      children: (0, import_jsx_runtime55.jsx)(_ListBoxBase, {
        ...listBoxProps,
        ref: listBoxRef,
        disallowEmptySelection: true,
        autoFocus: state.focusStrategy,
        shouldSelectOnPressUp: true,
        focusOnPointerEnter: true,
        layout,
        state,
        shouldUseVirtualFocus: true,
        isLoading: loadingState === "loadingMore",
        onLoadMore,
        UNSAFE_className: listStyles,
        renderEmptyState: () => isAsync && (0, import_jsx_runtime55.jsx)(Flex, {
          height: "element.regular",
          alignItems: "center",
          paddingX: "medium",
          children: (0, import_jsx_runtime55.jsx)(Text, {
            color: "neutralSecondary",
            children: loadingState === "loading" ? stringFormatter.format("loading") : stringFormatter.format("noResults")
          })
        })
      })
    })]
  });
});
function useStatefulRef() {
  let [current, statefulRef] = (0, import_react66.useState)(null);
  return (0, import_react66.useMemo)(() => {
    return [{
      current
    }, statefulRef];
  }, [current, statefulRef]);
}
var ComboboxInput = import_react66.default.forwardRef(function ComboboxInput2(props, forwardedRef) {
  let {
    isDisabled,
    inputProps,
    inputRef,
    triggerProps,
    triggerRef,
    autoFocus,
    style,
    loadingState,
    isOpen,
    menuTrigger
  } = props;
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages9);
  let timeoutRef = (0, import_react66.useRef)();
  let [showLoading, setShowLoading] = (0, import_react66.useState)(false);
  let loadingCircle = (0, import_jsx_runtime55.jsx)(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: (0, import_jsx_runtime55.jsx)(ProgressCircle, {
      "aria-label": stringFormatter.format("loading"),
      size: "small",
      isIndeterminate: true
    })
  });
  let isLoading = loadingState === "loading" || loadingState === "filtering";
  let inputValue = inputProps.value;
  let lastInputValue = (0, import_react66.useRef)(inputValue);
  (0, import_react66.useEffect)(() => {
    if (isLoading && !showLoading) {
      if (!timeoutRef.current) {
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
      if (inputValue !== lastInputValue.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(() => {
          setShowLoading(true);
        }, 500);
      }
    } else if (!isLoading) {
      setShowLoading(false);
      clearTimeout(timeoutRef.current);
      timeoutRef.current = void 0;
    }
    lastInputValue.current = inputValue;
  }, [isLoading, showLoading, inputValue]);
  return (0, import_jsx_runtime55.jsx)(FocusRing, {
    autoFocus,
    isTextInput: true,
    within: true,
    children: (0, import_jsx_runtime55.jsx)("div", {
      ref: forwardedRef,
      style,
      children: (0, import_jsx_runtime55.jsx)(TextFieldPrimitive, {
        inputProps: {
          ...inputProps,
          className: comboboxClassList.element("input")
        },
        ref: inputRef,
        isDisabled,
        endElement: (0, import_jsx_runtime55.jsxs)(import_jsx_runtime55.Fragment, {
          children: [showLoading && (isOpen || menuTrigger === "manual" || loadingState === "loading") ? loadingCircle : null, (0, import_jsx_runtime55.jsx)($f1ab8c75478c6f73$export$3351871ee4b288b8, {
            preventFocusOnPress: true,
            isPressed: isOpen,
            children: (0, import_jsx_runtime55.jsx)(FieldButton, {
              ...triggerProps,
              ref: triggerRef,
              UNSAFE_className: css({
                borderEndStartRadius: 0,
                borderStartStartRadius: 0,
                [`${comboboxClassList.selector("input")}[aria-invalid] ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderInvalid
                },
                [`${comboboxClassList.selector("input")}[readonly] ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderIdle
                },
                [`${comboboxClassList.selector("input")}:focus ~ &`]: {
                  borderColor: tokenSchema.color.alias.borderFocused
                }
              }),
              children: (0, import_jsx_runtime55.jsx)(Icon, {
                src: chevronDownIcon
              })
            })
          })]
        })
      })
    })
  });
});
var _Combobox = import_react66.default.forwardRef(Combobox);

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/trashIcon/dist/keystar-ui-icon-icons-trashIcon.esm.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
var trashIcon = (0, import_jsx_runtime56.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime56.jsx)("path", {
    d: "M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/columnsIcon/dist/keystar-ui-icon-icons-columnsIcon.esm.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());
var columnsIcon = (0, import_jsx_runtime57.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime57.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime57.jsx)("path", {
    d: "M12 3v18"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/listIcon/dist/keystar-ui-icon-icons-listIcon.esm.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
var listIcon = (0, import_jsx_runtime58.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime58.jsx)("path", {
    d: "M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/listOrderedIcon/dist/keystar-ui-icon-icons-listOrderedIcon.esm.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());
var listOrderedIcon = (0, import_jsx_runtime59.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime59.jsx)("path", {
    d: "M10 6h11M10 12h11M10 18h11M4 6h1v4M4 10h2M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/fileUpIcon/dist/keystar-ui-icon-icons-fileUpIcon.esm.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());
var fileUpIcon = (0, import_jsx_runtime60.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime60.jsx)("path", {
    d: "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"
  }), (0, import_jsx_runtime60.jsx)("path", {
    d: "M14 2v6h6M12 12v6M15 15l-3-3-3 3"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/imageIcon/dist/keystar-ui-icon-icons-imageIcon.esm.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());
var imageIcon = (0, import_jsx_runtime61.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime61.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime61.jsx)("circle", {
    cx: 9,
    cy: 9,
    r: 2
  }), (0, import_jsx_runtime61.jsx)("path", {
    d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"
  })]
});

// node_modules/.pnpm/@react-aria+numberfield@3.10.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/numberfield/dist/import.mjs
var import_react68 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+spinbutton@3.6.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/spinbutton/dist/import.mjs
var import_react67 = __toESM(require_react(), 1);
function $parcel$interopDefault6(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $a99895ee3dc79e61$exports = {};
var $ed6aae4e5f766f1e$exports = {};
$ed6aae4e5f766f1e$exports = {
  "Empty": `فارغ`
};
var $38854e2b175151fa$exports = {};
$38854e2b175151fa$exports = {
  "Empty": `Изпразни`
};
var $15b25ab20f3945b2$exports = {};
$15b25ab20f3945b2$exports = {
  "Empty": `Prázdné`
};
var $692a4298b6b649a2$exports = {};
$692a4298b6b649a2$exports = {
  "Empty": `Tom`
};
var $1c6e1539193f1243$exports = {};
$1c6e1539193f1243$exports = {
  "Empty": `Leer`
};
var $1e8678632c464b6d$exports = {};
$1e8678632c464b6d$exports = {
  "Empty": `Άδειο`
};
var $4adc85d9bf5b9eed$exports = {};
$4adc85d9bf5b9eed$exports = {
  "Empty": `Empty`
};
var $41c4b2bb61dafbca$exports = {};
$41c4b2bb61dafbca$exports = {
  "Empty": `Vacío`
};
var $405f8b24f5dd2a60$exports = {};
$405f8b24f5dd2a60$exports = {
  "Empty": `Tühjenda`
};
var $7efe3ed02b9b9dd4$exports = {};
$7efe3ed02b9b9dd4$exports = {
  "Empty": `Tyhjä`
};
var $99fc4c101d92daf3$exports = {};
$99fc4c101d92daf3$exports = {
  "Empty": `Vide`
};
var $f9e155e6e8cacaa2$exports = {};
$f9e155e6e8cacaa2$exports = {
  "Empty": `ריק`
};
var $c31b5e8e9a249fd5$exports = {};
$c31b5e8e9a249fd5$exports = {
  "Empty": `Prazno`
};
var $9c5435bc17499bd9$exports = {};
$9c5435bc17499bd9$exports = {
  "Empty": `Üres`
};
var $6d1fc8e84d8165e1$exports = {};
$6d1fc8e84d8165e1$exports = {
  "Empty": `Vuoto`
};
var $46ea6b3641b83e71$exports = {};
$46ea6b3641b83e71$exports = {
  "Empty": `空`
};
var $0e3cc9a288289dc5$exports = {};
$0e3cc9a288289dc5$exports = {
  "Empty": `비어 있음`
};
var $4ff2bb25c0089ffb$exports = {};
$4ff2bb25c0089ffb$exports = {
  "Empty": `Tuščias`
};
var $6cf33cd4c010a2fb$exports = {};
$6cf33cd4c010a2fb$exports = {
  "Empty": `Tukšs`
};
var $5a9f8486f8b8837e$exports = {};
$5a9f8486f8b8837e$exports = {
  "Empty": `Tom`
};
var $583f94d807f6ecea$exports = {};
$583f94d807f6ecea$exports = {
  "Empty": `Leeg`
};
var $cc4dcfeea2b4050d$exports = {};
$cc4dcfeea2b4050d$exports = {
  "Empty": `Pusty`
};
var $68ac2954d56e12b4$exports = {};
$68ac2954d56e12b4$exports = {
  "Empty": `Vazio`
};
var $fdb0616f309780b0$exports = {};
$fdb0616f309780b0$exports = {
  "Empty": `Vazio`
};
var $fe1eccf4ee1d6f52$exports = {};
$fe1eccf4ee1d6f52$exports = {
  "Empty": `Gol`
};
var $a38b6c4e18725976$exports = {};
$a38b6c4e18725976$exports = {
  "Empty": `Не заполнено`
};
var $6c14ae2b766b652c$exports = {};
$6c14ae2b766b652c$exports = {
  "Empty": `Prázdne`
};
var $8f1c9692e16dc5eb$exports = {};
$8f1c9692e16dc5eb$exports = {
  "Empty": `Prazen`
};
var $d2aa7abea627cafa$exports = {};
$d2aa7abea627cafa$exports = {
  "Empty": `Prazno`
};
var $676b82e4b56408e6$exports = {};
$676b82e4b56408e6$exports = {
  "Empty": `Tomt`
};
var $14c9042552d7ce08$exports = {};
$14c9042552d7ce08$exports = {
  "Empty": `Boş`
};
var $393254ebcb66c9f5$exports = {};
$393254ebcb66c9f5$exports = {
  "Empty": `Пусто`
};
var $d49d621f310cf6ce$exports = {};
$d49d621f310cf6ce$exports = {
  "Empty": `空`
};
var $94b60c866ca5dfe6$exports = {};
$94b60c866ca5dfe6$exports = {
  "Empty": `空白`
};
$a99895ee3dc79e61$exports = {
  "ar-AE": $ed6aae4e5f766f1e$exports,
  "bg-BG": $38854e2b175151fa$exports,
  "cs-CZ": $15b25ab20f3945b2$exports,
  "da-DK": $692a4298b6b649a2$exports,
  "de-DE": $1c6e1539193f1243$exports,
  "el-GR": $1e8678632c464b6d$exports,
  "en-US": $4adc85d9bf5b9eed$exports,
  "es-ES": $41c4b2bb61dafbca$exports,
  "et-EE": $405f8b24f5dd2a60$exports,
  "fi-FI": $7efe3ed02b9b9dd4$exports,
  "fr-FR": $99fc4c101d92daf3$exports,
  "he-IL": $f9e155e6e8cacaa2$exports,
  "hr-HR": $c31b5e8e9a249fd5$exports,
  "hu-HU": $9c5435bc17499bd9$exports,
  "it-IT": $6d1fc8e84d8165e1$exports,
  "ja-JP": $46ea6b3641b83e71$exports,
  "ko-KR": $0e3cc9a288289dc5$exports,
  "lt-LT": $4ff2bb25c0089ffb$exports,
  "lv-LV": $6cf33cd4c010a2fb$exports,
  "nb-NO": $5a9f8486f8b8837e$exports,
  "nl-NL": $583f94d807f6ecea$exports,
  "pl-PL": $cc4dcfeea2b4050d$exports,
  "pt-BR": $68ac2954d56e12b4$exports,
  "pt-PT": $fdb0616f309780b0$exports,
  "ro-RO": $fe1eccf4ee1d6f52$exports,
  "ru-RU": $a38b6c4e18725976$exports,
  "sk-SK": $6c14ae2b766b652c$exports,
  "sl-SI": $8f1c9692e16dc5eb$exports,
  "sr-SP": $d2aa7abea627cafa$exports,
  "sv-SE": $676b82e4b56408e6$exports,
  "tr-TR": $14c9042552d7ce08$exports,
  "uk-UA": $393254ebcb66c9f5$exports,
  "zh-CN": $d49d621f310cf6ce$exports,
  "zh-TW": $94b60c866ca5dfe6$exports
};
function $d2e8511e6f209edf$export$e908e06f4b8e3402(props) {
  const _async = (0, import_react67.useRef)();
  let { value: value2, textValue, minValue, maxValue, isDisabled, isReadOnly, isRequired, onIncrement, onIncrementPage, onDecrement, onDecrementPage, onDecrementToMin, onIncrementToMax } = props;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault6($a99895ee3dc79e61$exports)));
  const clearAsync = () => clearTimeout(_async.current);
  (0, import_react67.useEffect)(() => {
    return () => clearAsync();
  }, []);
  let onKeyDown = (e6) => {
    if (e6.ctrlKey || e6.metaKey || e6.shiftKey || e6.altKey || isReadOnly)
      return;
    switch (e6.key) {
      case "PageUp":
        if (onIncrementPage) {
          e6.preventDefault();
          onIncrementPage();
          break;
        }
      case "ArrowUp":
      case "Up":
        if (onIncrement) {
          e6.preventDefault();
          onIncrement();
        }
        break;
      case "PageDown":
        if (onDecrementPage) {
          e6.preventDefault();
          onDecrementPage();
          break;
        }
      case "ArrowDown":
      case "Down":
        if (onDecrement) {
          e6.preventDefault();
          onDecrement();
        }
        break;
      case "Home":
        if (onDecrementToMin) {
          e6.preventDefault();
          onDecrementToMin();
        }
        break;
      case "End":
        if (onIncrementToMax) {
          e6.preventDefault();
          onIncrementToMax();
        }
        break;
    }
  };
  let isFocused = (0, import_react67.useRef)(false);
  let onFocus = () => {
    isFocused.current = true;
  };
  let onBlur = () => {
    isFocused.current = false;
  };
  textValue = textValue === "" ? stringFormatter.format("Empty") : (textValue || `${value2}`).replace("-", "−");
  (0, import_react67.useEffect)(() => {
    if (isFocused.current) {
      (0, $319e236875307eab$export$d10ae4f68404609a)("assertive");
      (0, $319e236875307eab$export$a9b970dcc4ae71a9)(textValue, "assertive");
    }
  }, [
    textValue
  ]);
  const onIncrementPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((initialStepDelay) => {
    clearAsync();
    onIncrement();
    _async.current = window.setTimeout(() => {
      if (isNaN(maxValue) || isNaN(value2) || value2 < maxValue)
        onIncrementPressStart(60);
    }, initialStepDelay);
  });
  const onDecrementPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((initialStepDelay) => {
    clearAsync();
    onDecrement();
    _async.current = window.setTimeout(() => {
      if (isNaN(minValue) || isNaN(value2) || value2 > minValue)
        onDecrementPressStart(60);
    }, initialStepDelay);
  });
  let cancelContextMenu = (e6) => {
    e6.preventDefault();
  };
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed6)();
  return {
    spinButtonProps: {
      role: "spinbutton",
      "aria-valuenow": !isNaN(value2) ? value2 : null,
      "aria-valuetext": textValue,
      "aria-valuemin": minValue,
      "aria-valuemax": maxValue,
      "aria-disabled": isDisabled || null,
      "aria-readonly": isReadOnly || null,
      "aria-required": isRequired || null,
      onKeyDown,
      onFocus,
      onBlur
    },
    incrementButtonProps: {
      onPressStart: () => {
        onIncrementPressStart(400);
        addGlobalListener(window, "contextmenu", cancelContextMenu);
      },
      onPressEnd: () => {
        clearAsync();
        removeAllGlobalListeners();
      },
      onFocus,
      onBlur
    },
    decrementButtonProps: {
      onPressStart: () => {
        onDecrementPressStart(400);
        addGlobalListener(window, "contextmenu", cancelContextMenu);
      },
      onPressEnd: () => {
        clearAsync();
        removeAllGlobalListeners();
      },
      onFocus,
      onBlur
    }
  };
}

// node_modules/.pnpm/@react-aria+numberfield@3.10.0_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/numberfield/dist/import.mjs
function $parcel$interopDefault7(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $280a227d7cb94b92$exports = {};
var $fb78e0f6ab6349ed$exports = {};
$fb78e0f6ab6349ed$exports = {
  "decrease": (args) => `خفض ${args.fieldLabel}`,
  "increase": (args) => `زيادة ${args.fieldLabel}`,
  "numberField": `حقل رقمي`
};
var $2776acdd9959a647$exports = {};
$2776acdd9959a647$exports = {
  "decrease": (args) => `Намаляване ${args.fieldLabel}`,
  "increase": (args) => `Усилване ${args.fieldLabel}`,
  "numberField": `Номер на полето`
};
var $741954410a365ad3$exports = {};
$741954410a365ad3$exports = {
  "decrease": (args) => `Snížit ${args.fieldLabel}`,
  "increase": (args) => `Zvýšit ${args.fieldLabel}`,
  "numberField": `Číselné pole`
};
var $8321ed0f8ab642f0$exports = {};
$8321ed0f8ab642f0$exports = {
  "decrease": (args) => `Reducer ${args.fieldLabel}`,
  "increase": (args) => `Øg ${args.fieldLabel}`,
  "numberField": `Talfelt`
};
var $92978e0c4ecafa32$exports = {};
$92978e0c4ecafa32$exports = {
  "decrease": (args) => `${args.fieldLabel} verringern`,
  "increase": (args) => `${args.fieldLabel} erhöhen`,
  "numberField": `Nummernfeld`
};
var $ac5ff71962864a84$exports = {};
$ac5ff71962864a84$exports = {
  "decrease": (args) => `Μείωση ${args.fieldLabel}`,
  "increase": (args) => `Αύξηση ${args.fieldLabel}`,
  "numberField": `Πεδίο αριθμού`
};
var $efe4685e2440d8be$exports = {};
$efe4685e2440d8be$exports = {
  "decrease": (args) => `Decrease ${args.fieldLabel}`,
  "increase": (args) => `Increase ${args.fieldLabel}`,
  "numberField": `Number field`
};
var $e50a9a48739b90e1$exports = {};
$e50a9a48739b90e1$exports = {
  "decrease": (args) => `Reducir ${args.fieldLabel}`,
  "increase": (args) => `Aumentar ${args.fieldLabel}`,
  "numberField": `Campo de número`
};
var $6e0d5294ecbb8ab6$exports = {};
$6e0d5294ecbb8ab6$exports = {
  "decrease": (args) => `Vähenda ${args.fieldLabel}`,
  "increase": (args) => `Suurenda ${args.fieldLabel}`,
  "numberField": `Numbri väli`
};
var $e7129d65f607f77f$exports = {};
$e7129d65f607f77f$exports = {
  "decrease": (args) => `Vähennä ${args.fieldLabel}`,
  "increase": (args) => `Lisää ${args.fieldLabel}`,
  "numberField": `Numerokenttä`
};
var $d72adf5b20573e34$exports = {};
$d72adf5b20573e34$exports = {
  "decrease": (args) => `Diminuer ${args.fieldLabel}`,
  "increase": (args) => `Augmenter ${args.fieldLabel}`,
  "numberField": `Champ de nombre`
};
var $a25c707e88b844a7$exports = {};
$a25c707e88b844a7$exports = {
  "decrease": (args) => `הקטן ${args.fieldLabel}`,
  "increase": (args) => `הגדל ${args.fieldLabel}`,
  "numberField": `שדה מספר`
};
var $69b41140b9a4ca54$exports = {};
$69b41140b9a4ca54$exports = {
  "decrease": (args) => `Smanji ${args.fieldLabel}`,
  "increase": (args) => `Povećaj ${args.fieldLabel}`,
  "numberField": `Polje broja`
};
var $81dab28f37f59d1a$exports = {};
$81dab28f37f59d1a$exports = {
  "decrease": (args) => `${args.fieldLabel} csökkentése`,
  "increase": (args) => `${args.fieldLabel} növelése`,
  "numberField": `Számmező`
};
var $866555b31f2d7711$exports = {};
$866555b31f2d7711$exports = {
  "decrease": (args) => `Riduci ${args.fieldLabel}`,
  "increase": (args) => `Aumenta ${args.fieldLabel}`,
  "numberField": `Campo numero`
};
var $dafcd55d52b9d371$exports = {};
$dafcd55d52b9d371$exports = {
  "decrease": (args) => `${args.fieldLabel}を縮小`,
  "increase": (args) => `${args.fieldLabel}を拡大`,
  "numberField": `数値フィールド`
};
var $f090c1f8c5da0145$exports = {};
$f090c1f8c5da0145$exports = {
  "decrease": (args) => `${args.fieldLabel} 감소`,
  "increase": (args) => `${args.fieldLabel} 증가`,
  "numberField": `번호 필드`
};
var $6f10f3a13360a75c$exports = {};
$6f10f3a13360a75c$exports = {
  "decrease": (args) => `Sumažinti ${args.fieldLabel}`,
  "increase": (args) => `Padidinti ${args.fieldLabel}`,
  "numberField": `Numerio laukas`
};
var $47432cefd4b7bd1b$exports = {};
$47432cefd4b7bd1b$exports = {
  "decrease": (args) => `Samazināšana ${args.fieldLabel}`,
  "increase": (args) => `Palielināšana ${args.fieldLabel}`,
  "numberField": `Skaitļu lauks`
};
var $dc578a950a2bf23d$exports = {};
$dc578a950a2bf23d$exports = {
  "decrease": (args) => `Reduser ${args.fieldLabel}`,
  "increase": (args) => `Øk ${args.fieldLabel}`,
  "numberField": `Tallfelt`
};
var $353f1bfca4dc395a$exports = {};
$353f1bfca4dc395a$exports = {
  "decrease": (args) => `${args.fieldLabel} verlagen`,
  "increase": (args) => `${args.fieldLabel} verhogen`,
  "numberField": `Getalveld`
};
var $241bc0bbd870e982$exports = {};
$241bc0bbd870e982$exports = {
  "decrease": (args) => `Zmniejsz ${args.fieldLabel}`,
  "increase": (args) => `Zwiększ ${args.fieldLabel}`,
  "numberField": `Pole numeru`
};
var $da3005c7bd72b0a8$exports = {};
$da3005c7bd72b0a8$exports = {
  "decrease": (args) => `Diminuir ${args.fieldLabel}`,
  "increase": (args) => `Aumentar ${args.fieldLabel}`,
  "numberField": `Campo de número`
};
var $cf48bfc540882310$exports = {};
$cf48bfc540882310$exports = {
  "decrease": (args) => `Diminuir ${args.fieldLabel}`,
  "increase": (args) => `Aumentar ${args.fieldLabel}`,
  "numberField": `Campo numérico`
};
var $b63a28c481ab9ee3$exports = {};
$b63a28c481ab9ee3$exports = {
  "decrease": (args) => `Scădere ${args.fieldLabel}`,
  "increase": (args) => `Creștere ${args.fieldLabel}`,
  "numberField": `Câmp numeric`
};
var $19f9df95c2464ab6$exports = {};
$19f9df95c2464ab6$exports = {
  "decrease": (args) => `Уменьшение ${args.fieldLabel}`,
  "increase": (args) => `Увеличение ${args.fieldLabel}`,
  "numberField": `Числовое поле`
};
var $b272932a685e8482$exports = {};
$b272932a685e8482$exports = {
  "decrease": (args) => `Znížiť ${args.fieldLabel}`,
  "increase": (args) => `Zvýšiť ${args.fieldLabel}`,
  "numberField": `Číselné pole`
};
var $cbaf8b5b61f9e544$exports = {};
$cbaf8b5b61f9e544$exports = {
  "decrease": (args) => `Upadati ${args.fieldLabel}`,
  "increase": (args) => `Povečajte ${args.fieldLabel}`,
  "numberField": `Številčno polje`
};
var $e0a3af6ac1449b2f$exports = {};
$e0a3af6ac1449b2f$exports = {
  "decrease": (args) => `Smanji ${args.fieldLabel}`,
  "increase": (args) => `Povećaj ${args.fieldLabel}`,
  "numberField": `Polje broja`
};
var $71e167d2458a6019$exports = {};
$71e167d2458a6019$exports = {
  "decrease": (args) => `Minska ${args.fieldLabel}`,
  "increase": (args) => `Öka ${args.fieldLabel}`,
  "numberField": `Nummerfält`
};
var $3719245abc082946$exports = {};
$3719245abc082946$exports = {
  "decrease": (args) => `${args.fieldLabel} azalt`,
  "increase": (args) => `${args.fieldLabel} arttır`,
  "numberField": `Sayı alanı`
};
var $2ccc589e2f51824d$exports = {};
$2ccc589e2f51824d$exports = {
  "decrease": (args) => `Зменшити ${args.fieldLabel}`,
  "increase": (args) => `Збільшити ${args.fieldLabel}`,
  "numberField": `Поле номера`
};
var $e1103cb9b4c13942$exports = {};
$e1103cb9b4c13942$exports = {
  "decrease": (args) => `降低 ${args.fieldLabel}`,
  "increase": (args) => `提高 ${args.fieldLabel}`,
  "numberField": `数字字段`
};
var $448607634f80dccb$exports = {};
$448607634f80dccb$exports = {
  "decrease": (args) => `縮小 ${args.fieldLabel}`,
  "increase": (args) => `放大 ${args.fieldLabel}`,
  "numberField": `數字欄位`
};
$280a227d7cb94b92$exports = {
  "ar-AE": $fb78e0f6ab6349ed$exports,
  "bg-BG": $2776acdd9959a647$exports,
  "cs-CZ": $741954410a365ad3$exports,
  "da-DK": $8321ed0f8ab642f0$exports,
  "de-DE": $92978e0c4ecafa32$exports,
  "el-GR": $ac5ff71962864a84$exports,
  "en-US": $efe4685e2440d8be$exports,
  "es-ES": $e50a9a48739b90e1$exports,
  "et-EE": $6e0d5294ecbb8ab6$exports,
  "fi-FI": $e7129d65f607f77f$exports,
  "fr-FR": $d72adf5b20573e34$exports,
  "he-IL": $a25c707e88b844a7$exports,
  "hr-HR": $69b41140b9a4ca54$exports,
  "hu-HU": $81dab28f37f59d1a$exports,
  "it-IT": $866555b31f2d7711$exports,
  "ja-JP": $dafcd55d52b9d371$exports,
  "ko-KR": $f090c1f8c5da0145$exports,
  "lt-LT": $6f10f3a13360a75c$exports,
  "lv-LV": $47432cefd4b7bd1b$exports,
  "nb-NO": $dc578a950a2bf23d$exports,
  "nl-NL": $353f1bfca4dc395a$exports,
  "pl-PL": $241bc0bbd870e982$exports,
  "pt-BR": $da3005c7bd72b0a8$exports,
  "pt-PT": $cf48bfc540882310$exports,
  "ro-RO": $b63a28c481ab9ee3$exports,
  "ru-RU": $19f9df95c2464ab6$exports,
  "sk-SK": $b272932a685e8482$exports,
  "sl-SI": $cbaf8b5b61f9e544$exports,
  "sr-SP": $e0a3af6ac1449b2f$exports,
  "sv-SE": $71e167d2458a6019$exports,
  "tr-TR": $3719245abc082946$exports,
  "uk-UA": $2ccc589e2f51824d$exports,
  "zh-CN": $e1103cb9b4c13942$exports,
  "zh-TW": $448607634f80dccb$exports
};
function $81397a9303501bda$export$23f548e970bdf099(props, state, inputRef) {
  let { id, decrementAriaLabel, incrementAriaLabel, isDisabled, isReadOnly, isRequired, minValue, maxValue, autoFocus, label, formatOptions, onBlur = () => {
  }, onFocus, onFocusChange, onKeyDown, onKeyUp, description, errorMessage, ...otherProps } = props;
  let { increment: increment2, incrementToMax, decrement, decrementToMin, numberValue, inputValue, commit, commitValidation } = state;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault7($280a227d7cb94b92$exports)));
  let inputId = (0, $bdb11010cef70236$export$f680877a34711e37)(id);
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    onBlur() {
      commit();
    }
  });
  let numberFormatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)(formatOptions);
  let intlOptions = (0, import_react68.useMemo)(() => numberFormatter.resolvedOptions(), [
    numberFormatter
  ]);
  let textValueFormatter = (0, $a916eb452884faea$export$b7a616150fdb9f44)({
    ...formatOptions,
    currencySign: void 0
  });
  let textValue = (0, import_react68.useMemo)(() => isNaN(numberValue) ? "" : textValueFormatter.format(numberValue), [
    textValueFormatter,
    numberValue
  ]);
  let { spinButtonProps, incrementButtonProps: incButtonProps, decrementButtonProps: decButtonProps } = (0, $d2e8511e6f209edf$export$e908e06f4b8e3402)({
    isDisabled,
    isReadOnly,
    isRequired,
    maxValue,
    minValue,
    onIncrement: increment2,
    onIncrementToMax: incrementToMax,
    onDecrement: decrement,
    onDecrementToMin: decrementToMin,
    value: numberValue,
    textValue
  });
  let [focusWithin, setFocusWithin] = (0, import_react68.useState)(false);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled,
    onFocusWithinChange: setFocusWithin
  });
  let onWheel = (0, import_react68.useCallback)((e6) => {
    if (Math.abs(e6.deltaY) <= Math.abs(e6.deltaX))
      return;
    if (e6.deltaY > 0)
      increment2();
    else if (e6.deltaY < 0)
      decrement();
  }, [
    decrement,
    increment2
  ]);
  let scrollingDisabled = isDisabled || isReadOnly || !focusWithin;
  (0, $7d0a636d7a4dcefd$export$2123ff2b87c81ca)({
    onScroll: onWheel,
    isDisabled: scrollingDisabled
  }, inputRef);
  let hasDecimals = intlOptions.maximumFractionDigits > 0;
  let hasNegative = isNaN(state.minValue) || state.minValue < 0;
  let inputMode = "numeric";
  if ((0, $c87311424ea30a05$export$186c6964ca17d99)()) {
    if (hasNegative)
      inputMode = "text";
    else if (hasDecimals)
      inputMode = "decimal";
  } else if ((0, $c87311424ea30a05$export$a11b0059900ceec8)()) {
    if (hasNegative)
      inputMode = "numeric";
    else if (hasDecimals)
      inputMode = "decimal";
  }
  let onChange = (value2) => {
    if (state.validate(value2))
      state.setInputValue(value2);
  };
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props);
  let onKeyDownEnter = (0, import_react68.useCallback)((e6) => {
    if (e6.key === "Enter") {
      commit();
      commitValidation();
    } else
      e6.continuePropagation();
  }, [
    commit,
    commitValidation
  ]);
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps } = (0, $d841c8010a73d545$export$4f384c9210e583c3)({
    ...otherProps,
    ...domProps,
    name: void 0,
    label,
    autoFocus,
    isDisabled,
    isReadOnly,
    isRequired,
    validate: void 0,
    [(0, $e5be200c675c3b3a$export$a763b9476acd3eb)]: state,
    value: inputValue,
    defaultValue: void 0,
    autoComplete: "off",
    "aria-label": props["aria-label"] || null,
    "aria-labelledby": props["aria-labelledby"] || null,
    id: inputId,
    type: "text",
    inputMode,
    onChange,
    onBlur,
    onFocus,
    onFocusChange,
    onKeyDown: (0, import_react68.useMemo)(() => (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(onKeyDownEnter, onKeyDown), [
      onKeyDownEnter,
      onKeyDown
    ]),
    onKeyUp,
    description,
    errorMessage
  }, state, inputRef);
  (0, $99facab73266f662$export$5add1d006293d136)(inputRef, state.numberValue, state.setNumberValue);
  let inputProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(spinButtonProps, focusProps, textFieldProps, {
    // override the spinbutton role, we can't focus a spin button with VO
    role: null,
    // ignore aria-roledescription on iOS so that required state will announce when it is present
    "aria-roledescription": !(0, $c87311424ea30a05$export$fedb369cb70207f1)() ? stringFormatter.format("numberField") : null,
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null,
    autoCorrect: "off",
    spellCheck: "false"
  });
  if (props.validationBehavior === "native")
    inputProps["aria-required"] = void 0;
  let onButtonPressStart = (e6) => {
    if (document.activeElement === inputRef.current)
      return;
    if (e6.pointerType === "mouse")
      inputRef.current.focus();
    else
      e6.target.focus();
  };
  let fieldLabel = props["aria-label"] || (typeof props.label === "string" ? props.label : "");
  let ariaLabelledby;
  if (!fieldLabel)
    ariaLabelledby = props.label != null ? labelProps.id : props["aria-labelledby"];
  let incrementId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let decrementId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let incrementButtonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(incButtonProps, {
    "aria-label": incrementAriaLabel || stringFormatter.format("increase", {
      fieldLabel
    }).trim(),
    id: ariaLabelledby && !incrementAriaLabel ? incrementId : null,
    "aria-labelledby": ariaLabelledby && !incrementAriaLabel ? `${incrementId} ${ariaLabelledby}` : null,
    "aria-controls": inputId,
    excludeFromTabOrder: true,
    preventFocusOnPress: true,
    allowFocusWhenDisabled: true,
    isDisabled: !state.canIncrement,
    onPressStart: onButtonPressStart
  });
  let decrementButtonProps = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(decButtonProps, {
    "aria-label": decrementAriaLabel || stringFormatter.format("decrease", {
      fieldLabel
    }).trim(),
    id: ariaLabelledby && !decrementAriaLabel ? decrementId : null,
    "aria-labelledby": ariaLabelledby && !decrementAriaLabel ? `${decrementId} ${ariaLabelledby}` : null,
    "aria-controls": inputId,
    excludeFromTabOrder: true,
    preventFocusOnPress: true,
    allowFocusWhenDisabled: true,
    isDisabled: !state.canDecrement,
    onPressStart: onButtonPressStart
  });
  return {
    groupProps: {
      ...focusWithinProps,
      role: "group",
      "aria-disabled": isDisabled,
      "aria-invalid": isInvalid ? "true" : void 0
    },
    labelProps,
    inputProps,
    incrementButtonProps,
    decrementButtonProps,
    errorMessageProps,
    descriptionProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/.pnpm/@react-stately+numberfield@3.7.0_react@18.2.0/node_modules/@react-stately/numberfield/dist/import.mjs
var import_react69 = __toESM(require_react(), 1);
function $de67e98908f0c6ee$export$7f629e9dc1ecf37c(props) {
  let { minValue, maxValue, step, formatOptions, value: value2, defaultValue, onChange, locale, isDisabled, isReadOnly } = props;
  let [numberValue, setNumberValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(value2, isNaN(defaultValue) ? NaN : defaultValue, onChange);
  let [inputValue, setInputValue] = (0, import_react69.useState)(() => isNaN(numberValue) ? "" : new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, formatOptions).format(numberValue));
  let numberParser = (0, import_react69.useMemo)(() => new (0, $6c7bd7858deea686$export$cd11ab140839f11d)(locale, formatOptions), [
    locale,
    formatOptions
  ]);
  let numberingSystem = (0, import_react69.useMemo)(() => numberParser.getNumberingSystem(inputValue), [
    numberParser,
    inputValue
  ]);
  let formatter = (0, import_react69.useMemo)(() => new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(locale, {
    ...formatOptions,
    numberingSystem
  }), [
    locale,
    formatOptions,
    numberingSystem
  ]);
  let intlOptions = (0, import_react69.useMemo)(() => formatter.resolvedOptions(), [
    formatter
  ]);
  let format2 = (0, import_react69.useCallback)((value3) => isNaN(value3) || value3 === null ? "" : formatter.format(value3), [
    formatter
  ]);
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: numberValue
  });
  let clampStep = !isNaN(step) ? step : 1;
  if (intlOptions.style === "percent" && isNaN(step))
    clampStep = 0.01;
  let [prevValue, setPrevValue] = (0, import_react69.useState)(numberValue);
  let [prevLocale, setPrevLocale] = (0, import_react69.useState)(locale);
  let [prevFormatOptions, setPrevFormatOptions] = (0, import_react69.useState)(formatOptions);
  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {
    setInputValue(format2(numberValue));
    setPrevValue(numberValue);
    setPrevLocale(locale);
    setPrevFormatOptions(formatOptions);
  }
  let parsedValue = (0, import_react69.useMemo)(() => numberParser.parse(inputValue), [
    numberParser,
    inputValue
  ]);
  let commit = () => {
    if (!inputValue.length) {
      setNumberValue(NaN);
      setInputValue(value2 === void 0 ? "" : format2(numberValue));
      return;
    }
    if (isNaN(parsedValue)) {
      setInputValue(format2(numberValue));
      return;
    }
    let clampedValue;
    if (isNaN(step))
      clampedValue = (0, $9446cca9a3875146$export$7d15b64cf5a3a4c4)(parsedValue, minValue, maxValue);
    else
      clampedValue = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, step);
    clampedValue = numberParser.parse(format2(clampedValue));
    setNumberValue(clampedValue);
    setInputValue(format2(value2 === void 0 ? clampedValue : numberValue));
  };
  let safeNextStep = (operation, minMax) => {
    let prev2 = parsedValue;
    if (isNaN(prev2)) {
      let newValue = isNaN(minMax) ? 0 : minMax;
      return (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(newValue, minValue, maxValue, clampStep);
    } else {
      let newValue = (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(prev2, minValue, maxValue, clampStep);
      if (operation === "+" && newValue > prev2 || operation === "-" && newValue < prev2)
        return newValue;
      return (0, $9446cca9a3875146$export$cb6e0bb50bc19463)($de67e98908f0c6ee$var$handleDecimalOperation(operation, prev2, clampStep), minValue, maxValue, clampStep);
    }
  };
  let increment2 = () => {
    let newValue = safeNextStep("+", minValue);
    if (newValue === numberValue)
      setInputValue(format2(newValue));
    setNumberValue(newValue);
    validation.commitValidation();
  };
  let decrement = () => {
    let newValue = safeNextStep("-", maxValue);
    if (newValue === numberValue)
      setInputValue(format2(newValue));
    setNumberValue(newValue);
    validation.commitValidation();
  };
  let incrementToMax = () => {
    if (maxValue != null) {
      setNumberValue((0, $9446cca9a3875146$export$cb6e0bb50bc19463)(maxValue, minValue, maxValue, clampStep));
      validation.commitValidation();
    }
  };
  let decrementToMin = () => {
    if (minValue != null) {
      setNumberValue(minValue);
      validation.commitValidation();
    }
  };
  let canIncrement = (0, import_react69.useMemo)(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(maxValue) || (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, clampStep) > parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation("+", parsedValue, clampStep) <= maxValue), [
    isDisabled,
    isReadOnly,
    minValue,
    maxValue,
    clampStep,
    parsedValue
  ]);
  let canDecrement = (0, import_react69.useMemo)(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(minValue) || (0, $9446cca9a3875146$export$cb6e0bb50bc19463)(parsedValue, minValue, maxValue, clampStep) < parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation("-", parsedValue, clampStep) >= minValue), [
    isDisabled,
    isReadOnly,
    minValue,
    maxValue,
    clampStep,
    parsedValue
  ]);
  let validate3 = (value3) => numberParser.isValidPartialNumber(value3, minValue, maxValue);
  return {
    ...validation,
    validate: validate3,
    increment: increment2,
    incrementToMax,
    decrement,
    decrementToMin,
    canIncrement,
    canDecrement,
    minValue,
    maxValue,
    numberValue: parsedValue,
    setNumberValue,
    setInputValue,
    inputValue,
    commit
  };
}
function $de67e98908f0c6ee$var$handleDecimalOperation(operator, value1, value2) {
  let result = operator === "+" ? value1 + value2 : value1 - value2;
  if (value1 % 1 !== 0 || value2 % 1 !== 0) {
    const value1Decimal = value1.toString().split(".");
    const value2Decimal = value2.toString().split(".");
    const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;
    const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;
    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));
    value1 = Math.round(value1 * multiplier);
    value2 = Math.round(value2 * multiplier);
    result = operator === "+" ? value1 + value2 : value1 - value2;
    result /= multiplier;
  }
  return result;
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/number-field/dist/keystar-ui-number-field.esm.js
var import_react70 = __toESM(require_react());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/chevronUpIcon/dist/keystar-ui-icon-icons-chevronUpIcon.esm.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
var chevronUpIcon = (0, import_jsx_runtime62.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime62.jsx)("path", {
    d: "m18 15-6-6-6 6"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/number-field/dist/keystar-ui-number-field.esm.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());
var StepButton = (0, import_react70.forwardRef)(function StepButton2(props, forwardedRef) {
  props = useProviderProps(props);
  let {
    scale
  } = useProvider();
  let {
    direction
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    buttonProps,
    isPressed
  } = $701a24aa0da5b062$export$ea18c227d4417cc3({
    ...props,
    elementType: "div"
  }, domRef);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(props);
  let incrementIcon = scale === "large" ? plusIcon : chevronUpIcon;
  let decrementIcon = scale === "large" ? minusIcon : chevronDownIcon;
  return (0, import_jsx_runtime63.jsxs)("div", {
    ...toDataAttributes({
      direction,
      hovered: isHovered || void 0,
      pressed: isPressed || void 0,
      scale
    }),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(hoverProps, buttonProps),
    ref: domRef,
    className: classNames(css({
      alignItems: "center",
      color: tokenSchema.color.alias.foregroundIdle,
      cursor: "default",
      display: "flex",
      justifyContent: "center",
      transition: transition("border-color"),
      svg: {
        position: "absolute"
        // stop SVG from taking space; affecting layout.
      },
      // states
      "&[data-hovered]": {
        backgroundColor: tokenSchema.color.alias.backgroundHovered,
        color: tokenSchema.color.alias.foregroundHovered
      },
      "&[data-pressed]": {
        backgroundColor: tokenSchema.color.alias.backgroundPressed
      },
      "&[aria-disabled=true]": {
        backgroundColor: tokenSchema.color.background.surfaceSecondary,
        color: tokenSchema.color.alias.foregroundDisabled
      },
      "&[data-direction=up]": {
        gridArea: "increment"
      },
      "&[data-direction=down]": {
        gridArea: "decrement"
      },
      // fine pointers
      "&:not([data-scale=large])": {
        "&[data-direction=up]": {
          borderStartStartRadius: tokenSchema.size.radius.small,
          borderStartEndRadius: tokenSchema.size.radius.small
        },
        "&[data-direction=down]": {
          borderEndStartRadius: tokenSchema.size.radius.small,
          borderEndEndRadius: tokenSchema.size.radius.small
        },
        svg: {
          width: tokenSchema.size.icon.small
        }
      },
      // coarse pointers
      "&[data-scale=large]": {
        "&[data-direction=up]": {
          borderStartEndRadius: tokenSchema.size.radius.regular,
          borderEndEndRadius: tokenSchema.size.radius.regular
        },
        "&[data-direction=down]": {
          borderEndStartRadius: tokenSchema.size.radius.regular,
          borderStartStartRadius: tokenSchema.size.radius.regular
        },
        "input:enabled ~ &": {
          border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.alias.borderIdle}`
        },
        "input:focus ~ &": {
          borderColor: tokenSchema.color.alias.borderFocused
        }
      }
    })),
    children: [direction === "up" && (0, import_jsx_runtime63.jsx)(Icon, {
      src: incrementIcon
    }), direction === "down" && (0, import_jsx_runtime63.jsx)(Icon, {
      src: decrementIcon
    })]
  });
});
var NumberField = (0, import_react70.forwardRef)(function NumberField2(props, forwardedRef) {
  props = useProviderProps(props);
  let {
    isReadOnly,
    isDisabled,
    hideStepper,
    label,
    description
  } = props;
  let {
    locale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let state = $de67e98908f0c6ee$export$7f629e9dc1ecf37c({
    ...props,
    locale
  });
  let inputRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let {
    groupProps,
    labelProps,
    inputProps,
    incrementButtonProps,
    decrementButtonProps,
    descriptionProps,
    errorMessageProps
  } = $81397a9303501bda$export$23f548e970bdf099(props, state, inputRef);
  let inputWrapperStyleProps = useInputWrapperStyleProps();
  return (0, import_jsx_runtime63.jsx)(TextFieldPrimitive, {
    width: "alias.singleLineWidth",
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(props),
    ...onlyStyleProps(props),
    label,
    description,
    descriptionProps,
    errorMessageProps,
    labelProps,
    inputWrapperProps: {
      ...groupProps,
      ...inputWrapperStyleProps
    },
    ref: inputRef,
    inputProps,
    isDisabled,
    isReadOnly,
    endElement: !hideStepper && (0, import_jsx_runtime63.jsxs)(import_jsx_runtime63.Fragment, {
      children: [(0, import_jsx_runtime63.jsx)(StepButton, {
        direction: "up",
        ...incrementButtonProps
      }), (0, import_jsx_runtime63.jsx)(StepButton, {
        direction: "down",
        ...decrementButtonProps
      })]
    })
  });
});
function useInputWrapperStyleProps() {
  let {
    scale
  } = useProvider();
  let className = css({
    display: "grid",
    gap: tokenSchema.size.border.regular,
    gridTemplateColumns: `1fr calc(${tokenSchema.size.element.regular} - ${tokenSchema.size.border.regular} * 2) ${tokenSchema.size.border.regular}`,
    gridTemplateRows: `${tokenSchema.size.border.regular} auto auto ${tokenSchema.size.border.regular}`,
    gridTemplateAreas: '"field . ." "field increment ." "field decrement ." "field . ."',
    '&[data-scale="large"]': {
      gridTemplateColumns: `${tokenSchema.size.element.regular} 1fr ${tokenSchema.size.element.regular}`,
      gridTemplateRows: "auto",
      gridTemplateAreas: '"decrement field increment"'
    },
    input: {
      gridArea: "field"
    }
  });
  return {
    ...toDataAttributes({
      scale
    }),
    className
  };
}

// node_modules/.pnpm/minimatch@7.4.6/node_modules/minimatch/dist/mjs/index.js
var import_brace_expansion = __toESM(require_brace_expansion());

// node_modules/.pnpm/minimatch@7.4.6/node_modules/minimatch/dist/mjs/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s4) => s4.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s4) => s4.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob, position2) => {
  const pos = position2;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i6 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping2 = false;
  let negate2 = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE:
    while (i6 < glob.length) {
      const c5 = glob.charAt(i6);
      if ((c5 === "!" || c5 === "^") && i6 === pos + 1) {
        negate2 = true;
        i6++;
        continue;
      }
      if (c5 === "]" && sawStart && !escaping2) {
        endPos = i6 + 1;
        break;
      }
      sawStart = true;
      if (c5 === "\\") {
        if (!escaping2) {
          escaping2 = true;
          i6++;
          continue;
        }
      }
      if (c5 === "[" && !escaping2) {
        for (const [cls, [unip, u4, neg]] of Object.entries(posixClasses)) {
          if (glob.startsWith(cls, i6)) {
            if (rangeStart) {
              return ["$.", false, glob.length - pos, true];
            }
            i6 += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u4;
            continue WHILE;
          }
        }
      }
      escaping2 = false;
      if (rangeStart) {
        if (c5 > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c5));
        } else if (c5 === rangeStart) {
          ranges.push(braceEscape(c5));
        }
        rangeStart = "";
        i6++;
        continue;
      }
      if (glob.startsWith("-]", i6 + 1)) {
        ranges.push(braceEscape(c5 + "-"));
        i6 += 2;
        continue;
      }
      if (glob.startsWith("-", i6 + 1)) {
        rangeStart = c5;
        i6 += 2;
        continue;
      }
      ranges.push(braceEscape(c5));
      i6++;
    }
  if (endPos < i6) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate2) {
    const r7 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r7), false, endPos - pos, false];
  }
  const sranges = "[" + (negate2 ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate2 ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};

// node_modules/.pnpm/minimatch@7.4.6/node_modules/minimatch/dist/mjs/escape.js
var escape = (s4, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s4.replace(/[?*()[\]]/g, "[$&]") : s4.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/.pnpm/minimatch@7.4.6/node_modules/minimatch/dist/mjs/unescape.js
var unescape = (s4, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s4.replace(/\[([^\/\\])\]/g, "$1") : s4.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/.pnpm/minimatch@7.4.6/node_modules/minimatch/dist/mjs/index.js
var minimatch = (p5, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p5);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f5) => !f5.startsWith(".") && f5.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f5) => f5.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f5) => !f5.startsWith(".") && f5.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f5) => f5.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f5) => !f5.startsWith(".") && f5.includes(".");
var starDotStarTestDot = (f5) => f5 !== "." && f5 !== ".." && f5.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f5) => f5 !== "." && f5 !== ".." && f5.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f5) => f5.length !== 0 && !f5.startsWith(".");
var starTestDot = (f5) => f5.length !== 0 && f5 !== "." && f5 !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f5) => noext(f5) && f5.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f5) => noext(f5) && f5.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f5) => noext(f5) && f5.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f5) => noext(f5) && f5.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f5) => f5.length === len && !f5.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f5) => f5.length === len && f5 !== "." && f5 !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
var qmark = "[^/]";
var star = qmark + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var charSet = (s4) => s4.split("").reduce((set, c5) => {
  set[c5] = true;
  return set;
}, {});
var reSpecials = charSet("().*{}+?[]^$\\!");
var addPatternStartSet = charSet("[.(");
var filter = (pattern, options = {}) => (p5) => minimatch(p5, pattern, options);
minimatch.filter = filter;
var ext = (a3, b2 = {}) => Object.assign({}, a3, b2);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m2 = (p5, pattern, options = {}) => orig(p5, pattern, ext(def, options));
  return Object.assign(m2, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    unescape: (s4, options = {}) => orig.unescape(s4, ext(def, options)),
    escape: (s4, options = {}) => orig.escape(s4, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list2, pattern, options = {}) => orig.match(list2, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match2 = (list2, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options);
  list2 = list2.filter((f5) => mm.match(f5));
  if (mm.options.nonull && !list2.length) {
    list2.push(pattern);
  }
  return list2;
};
minimatch.match = match2;
var globUnescape = (s4) => s4.replace(/\\(.)/g, "$1");
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape = (s4) => s4.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  constructor(pattern, options = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._2) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s4) => this.slashSplit(s4));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s4, _2, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s4[0] === "" && s4[1] === "" && (s4[2] === "?" || !globMagic.test(s4[2])) && !globMagic.test(s4[3]);
        const isDrive = /^[a-z]:/i.test(s4[0]);
        if (isUNC) {
          return [...s4.slice(0, 4), ...s4.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s4[0], ...s4.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s4.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s4) => s4.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i6 = 0; i6 < this.set.length; i6++) {
        const p5 = this.set[i6];
        if (p5[0] === "" && p5[1] === "" && this.globParts[i6][2] === "?" && typeof p5[3] === "string" && /^[a-z]:$/i.test(p5[3])) {
          p5[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i6 = 0; i6 < globParts.length; i6++) {
        for (let j3 = 0; j3 < globParts[i6].length; j3++) {
          if (globParts[i6][j3] === "**") {
            globParts[i6][j3] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i6 = gs;
        while (parts[i6 + 1] === "**") {
          i6++;
        }
        if (i6 !== gs) {
          parts.splice(gs, i6 - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev2 = set[set.length - 1];
        if (part === "**" && prev2 === "**") {
          return set;
        }
        if (part === "..") {
          if (prev2 && prev2 !== ".." && prev2 !== "." && prev2 !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i6 = 1; i6 < parts.length - 1; i6++) {
          const p5 = parts[i6];
          if (i6 === 1 && p5 === "" && parts[0] === "")
            continue;
          if (p5 === "." || p5 === "") {
            didSomething = true;
            parts.splice(i6, 1);
            i6--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p5 = parts[dd - 1];
        if (p5 && p5 !== "." && p5 !== ".." && p5 !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next2 = parts[gs + 1];
          const p5 = parts[gs + 2];
          const p22 = parts[gs + 3];
          if (next2 !== "..")
            continue;
          if (!p5 || p5 === "." || p5 === ".." || !p22 || p22 === "." || p22 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i6 = 1; i6 < parts.length - 1; i6++) {
            const p5 = parts[i6];
            if (i6 === 1 && p5 === "" && parts[0] === "")
              continue;
            if (p5 === "." || p5 === "") {
              didSomething = true;
              parts.splice(i6, 1);
              i6--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p5 = parts[dd - 1];
          if (p5 && p5 !== "." && p5 !== ".." && p5 !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i6 = 0; i6 < globParts.length - 1; i6++) {
      for (let j3 = i6 + 1; j3 < globParts.length; j3++) {
        const matched = this.partsMatch(globParts[i6], globParts[j3], !this.preserveMultipleSlashes);
        if (!matched)
          continue;
        globParts[i6] = matched;
        globParts[j3] = [];
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a3, b2, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a3.length && bi < b2.length) {
      if (a3[ai] === b2[bi]) {
        result.push(which === "b" ? b2[bi] : a3[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a3[ai] === "**" && b2[bi] === a3[ai + 1]) {
        result.push(a3[ai]);
        ai++;
      } else if (emptyGSMatch && b2[bi] === "**" && a3[ai] === b2[bi + 1]) {
        result.push(b2[bi]);
        bi++;
      } else if (a3[ai] === "*" && b2[bi] && (this.options.dot || !b2[bi].startsWith(".")) && b2[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a3[ai]);
        ai++;
        bi++;
      } else if (b2[bi] === "*" && a3[ai] && (this.options.dot || !a3[ai].startsWith(".")) && a3[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b2[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a3.length === b2.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate2 = false;
    let negateOffset = 0;
    for (let i6 = 0; i6 < pattern.length && pattern.charAt(i6) === "!"; i6++) {
      negate2 = !negate2;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate2;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial2 = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileUNC = file[0] === "" && file[1] === "" && file[2] === "?" && typeof file[3] === "string" && /^[a-z]:$/i.test(file[3]);
      const patternUNC = pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      if (fileUNC && patternUNC) {
        const fd = file[3];
        const pd = pattern[3];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          file[3] = pd;
        }
      } else if (patternUNC && typeof file[0] === "string") {
        const pd = pattern[3];
        const fd = file[0];
        if (pd.toLowerCase() === fd.toLowerCase()) {
          pattern[3] = fd;
          pattern = pattern.slice(3);
        }
      } else if (fileUNC && typeof pattern[0] === "string") {
        const fd = file[3];
        if (fd.toLowerCase() === pattern[0].toLowerCase()) {
          pattern[0] = fd;
          file = file.slice(3);
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p5 = pattern[pi];
      var f5 = file[fi];
      this.debug(pattern, p5, f5);
      if (p5 === false) {
        return false;
      }
      if (p5 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p5, f5]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial2)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial2) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p5 === "string") {
        hit = f5 === p5;
        this.debug("string match", p5, f5, hit);
      } else {
        hit = p5.test(f5);
        this.debug("pattern match", p5, f5, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial2;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m2;
    let fastTest = null;
    if (m2 = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m2 = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m2[1]);
    } else if (m2 = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m2);
    } else if (m2 = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m2 = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    let re = "";
    let hasMagic = false;
    let escaping2 = false;
    const patternListStack = [];
    const negativeLists = [];
    let stateChar = false;
    let uflag = false;
    let pl;
    let dotTravAllowed = pattern.charAt(0) === ".";
    let dotFileAllowed = options.dot || dotTravAllowed;
    const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    const subPatternStart = (p5) => p5.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    const clearStateChar = () => {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        this.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    };
    for (let i6 = 0, c5; i6 < pattern.length && (c5 = pattern.charAt(i6)); i6++) {
      this.debug("%s	%s %s %j", pattern, i6, re, c5);
      if (escaping2) {
        if (c5 === "/") {
          return false;
        }
        if (reSpecials[c5]) {
          re += "\\";
        }
        re += c5;
        escaping2 = false;
        continue;
      }
      switch (c5) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping2 = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i6, re, c5);
          this.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c5;
          if (options.noext)
            clearStateChar();
          continue;
        case "(": {
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          const plEntry = {
            type: stateChar,
            start: i6 - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          };
          this.debug(this.pattern, "	", plEntry);
          patternListStack.push(plEntry);
          re += plEntry.open;
          if (plEntry.start === 0 && plEntry.type !== "!") {
            dotTravAllowed = true;
            re += subPatternStart(pattern.slice(i6 + 1));
          }
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        }
        case ")": {
          const plEntry = patternListStack[patternListStack.length - 1];
          if (!plEntry) {
            re += "\\)";
            continue;
          }
          patternListStack.pop();
          clearStateChar();
          hasMagic = true;
          pl = plEntry;
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(Object.assign(pl, { reEnd: re.length }));
          }
          continue;
        }
        case "|": {
          const plEntry = patternListStack[patternListStack.length - 1];
          if (!plEntry) {
            re += "\\|";
            continue;
          }
          clearStateChar();
          re += "|";
          if (plEntry.start === 0 && plEntry.type !== "!") {
            dotTravAllowed = true;
            re += subPatternStart(pattern.slice(i6 + 1));
          }
          continue;
        }
        case "[":
          clearStateChar();
          const [src, needUflag, consumed, magic] = parseClass(pattern, i6);
          if (consumed) {
            re += src;
            uflag = uflag || needUflag;
            i6 += consumed - 1;
            hasMagic = hasMagic || magic;
          } else {
            re += "\\[";
          }
          continue;
        case "]":
          re += "\\" + c5;
          continue;
        default:
          clearStateChar();
          re += regExpEscape(c5);
          break;
      }
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail;
      tail = re.slice(pl.reStart + pl.open.length);
      this.debug(this.pattern, "setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      const t5 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t5 + "\\(" + tail;
    }
    clearStateChar();
    if (escaping2) {
      re += "\\\\";
    }
    const addPatternStart = addPatternStartSet[re.charAt(0)];
    for (let n6 = negativeLists.length - 1; n6 > -1; n6--) {
      const nl = negativeLists[n6];
      const nlBefore = re.slice(0, nl.reStart);
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      let nlAfter = re.slice(nl.reEnd);
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
      const closeParensBefore = nlBefore.split(")").length;
      const openParensBefore = nlBefore.split("(").length - closeParensBefore;
      let cleanAfter = nlAfter;
      for (let i6 = 0; i6 < openParensBefore; i6++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      const dollar = nlAfter === "" ? "(?:$|\\/)" : "";
      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart() + re;
    }
    if (options.nocase && !hasMagic && !options.nocaseMagicOnly) {
      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
    }
    if (!hasMagic) {
      return globUnescape(re);
    }
    const flags = (options.nocase ? "i" : "") + (uflag ? "u" : "");
    try {
      const ext2 = fastTest ? {
        _glob: pattern,
        _src: re,
        test: fastTest
      } : {
        _glob: pattern,
        _src: re
      };
      return Object.assign(new RegExp("^" + re + "$", flags), ext2);
    } catch (er) {
      this.debug("invalid regexp", er);
      return new RegExp("$.");
    }
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    const flags = options.nocase ? "i" : "";
    let re = set.map((pattern) => {
      const pp = pattern.map((p5) => typeof p5 === "string" ? regExpEscape(p5) : p5 === GLOBSTAR ? GLOBSTAR : p5._src);
      pp.forEach((p5, i6) => {
        const next2 = pp[i6 + 1];
        const prev2 = pp[i6 - 1];
        if (p5 !== GLOBSTAR || prev2 === GLOBSTAR) {
          return;
        }
        if (prev2 === void 0) {
          if (next2 !== void 0 && next2 !== GLOBSTAR) {
            pp[i6 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next2;
          } else {
            pp[i6] = twoStar;
          }
        } else if (next2 === void 0) {
          pp[i6 - 1] = prev2 + "(?:\\/|" + twoStar + ")?";
        } else if (next2 !== GLOBSTAR) {
          pp[i6 - 1] = prev2 + "(?:\\/|\\/" + twoStar + "\\/)" + next2;
          pp[i6 + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p5) => p5 !== GLOBSTAR).join("/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p5) {
    if (this.preserveMultipleSlashes) {
      return p5.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p5)) {
      return ["", ...p5.split(/\/+/)];
    } else {
      return p5.split(/\/+/);
    }
  }
  match(f5, partial2 = this.partial) {
    this.debug("match", f5, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f5 === "";
    }
    if (f5 === "/" && partial2) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f5 = f5.split("\\").join("/");
    }
    const ff = this.slashSplit(f5);
    this.debug(this.pattern, "split", ff);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename) {
      for (let i6 = ff.length - 2; !filename && i6 >= 0; i6--) {
        filename = ff[i6];
      }
    }
    for (let i6 = 0; i6 < set.length; i6++) {
      const pattern = set[i6];
      let file = ff;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial2);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 8,
  patch: 1,
  preReleaseTag: null
});

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value2) {
  return typeof value2 == "object" && value2 !== null;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position2) {
  let lastLineStart = 0;
  let line2 = 1;
  for (const match3 of source.body.matchAll(LineRegExp)) {
    typeof match3.index === "number" || invariant(false);
    if (match3.index >= position2) {
      break;
    }
    lastLineStart = match3.index + match3[0].length;
    line2 += 1;
  }
  return {
    line: line2,
    column: position2 + 1 - lastLineStart
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(
    location2.source,
    getLocation(location2.source, location2.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i6 = 0; i6 < locationLine.length; i6 += 80) {
      subLines.push(locationLine.slice(i6, i6 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_2, line2]) => line2 !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix3]) => prefix3.length));
  return existingLines.map(([prefix3, line2]) => prefix3.padStart(padLen) + (line2 ? " " + line2 : "")).join("\n");
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path: path2, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path2 !== null && path2 !== void 0 ? path2 : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node3) => node3.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node3 of this.nodes) {
        if (node3.loc) {
          output += "\n\n" + printLocation(node3.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location2 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location2);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position2, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position2]
  });
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start2, end, line2, column2, value2) {
    this.kind = kind;
    this.start = start2;
    this.end = end;
    this.line = line2;
    this.column = column2;
    this.value = value2;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code2) {
  return code2 === 9 || code2 === 32;
}
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isLetter(code2) {
  return code2 >= 97 && code2 <= 122 || // A-Z
  code2 >= 65 && code2 <= 90;
}
function isNameStart(code2) {
  return isLetter(code2) || code2 === 95;
}
function isNameContinue(code2) {
  return isLetter(code2) || isDigit(code2) || code2 === 95;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i6 = 0; i6 < lines.length; ++i6) {
    var _firstNonEmptyLine;
    const line2 = lines[i6];
    const indent2 = leadingWhitespace(line2);
    if (indent2 === line2.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i6;
    lastNonEmptyLine = i6;
    if (i6 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line2, i6) => i6 === 0 ? line2 : line2.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i6 = 0;
  while (i6 < str.length && isWhiteSpace(str.charCodeAt(i6))) {
    ++i6;
  }
  return i6;
}
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line2) => line2.length === 0 || isWhiteSpace(line2.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token2 = this.token = this.lookahead();
    return token2;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token2 = this.token;
    if (token2.kind !== TokenKind.EOF) {
      do {
        if (token2.next) {
          token2 = token2.next;
        } else {
          const nextToken = readNextToken(this, token2.end);
          token2.next = nextToken;
          nextToken.prev = token2;
          token2 = nextToken;
        }
      } while (token2.kind === TokenKind.COMMENT);
    }
    return token2;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code2) {
  return code2 >= 0 && code2 <= 55295 || code2 >= 57344 && code2 <= 1114111;
}
function isSupplementaryCodePoint(body, location2) {
  return isLeadingSurrogate(body.charCodeAt(location2)) && isTrailingSurrogate(body.charCodeAt(location2 + 1));
}
function isLeadingSurrogate(code2) {
  return code2 >= 55296 && code2 <= 56319;
}
function isTrailingSurrogate(code2) {
  return code2 >= 56320 && code2 <= 57343;
}
function printCodePointAt(lexer, location2) {
  const code2 = lexer.source.body.codePointAt(location2);
  if (code2 === void 0) {
    return TokenKind.EOF;
  } else if (code2 >= 32 && code2 <= 126) {
    const char2 = String.fromCodePoint(code2);
    return char2 === '"' ? `'"'` : `"${char2}"`;
  }
  return "U+" + code2.toString(16).toUpperCase().padStart(4, "0");
}
function createToken2(lexer, kind, start2, end, value2) {
  const line2 = lexer.line;
  const col = 1 + start2 - lexer.lineStart;
  return new Token(kind, start2, end, line2, col, value2);
}
function readNextToken(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start2;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    switch (code2) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position2;
        continue;
      case 10:
        ++position2;
        ++lexer.line;
        lexer.lineStart = position2;
        continue;
      case 13:
        if (body.charCodeAt(position2 + 1) === 10) {
          position2 += 2;
        } else {
          ++position2;
        }
        ++lexer.line;
        lexer.lineStart = position2;
        continue;
      case 35:
        return readComment(lexer, position2);
      case 33:
        return createToken2(lexer, TokenKind.BANG, position2, position2 + 1);
      case 36:
        return createToken2(lexer, TokenKind.DOLLAR, position2, position2 + 1);
      case 38:
        return createToken2(lexer, TokenKind.AMP, position2, position2 + 1);
      case 40:
        return createToken2(lexer, TokenKind.PAREN_L, position2, position2 + 1);
      case 41:
        return createToken2(lexer, TokenKind.PAREN_R, position2, position2 + 1);
      case 46:
        if (body.charCodeAt(position2 + 1) === 46 && body.charCodeAt(position2 + 2) === 46) {
          return createToken2(lexer, TokenKind.SPREAD, position2, position2 + 3);
        }
        break;
      case 58:
        return createToken2(lexer, TokenKind.COLON, position2, position2 + 1);
      case 61:
        return createToken2(lexer, TokenKind.EQUALS, position2, position2 + 1);
      case 64:
        return createToken2(lexer, TokenKind.AT, position2, position2 + 1);
      case 91:
        return createToken2(lexer, TokenKind.BRACKET_L, position2, position2 + 1);
      case 93:
        return createToken2(lexer, TokenKind.BRACKET_R, position2, position2 + 1);
      case 123:
        return createToken2(lexer, TokenKind.BRACE_L, position2, position2 + 1);
      case 124:
        return createToken2(lexer, TokenKind.PIPE, position2, position2 + 1);
      case 125:
        return createToken2(lexer, TokenKind.BRACE_R, position2, position2 + 1);
      case 34:
        if (body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
          return readBlockString(lexer, position2);
        }
        return readString(lexer, position2);
    }
    if (isDigit(code2) || code2 === 45) {
      return readNumber(lexer, position2, code2);
    }
    if (isNameStart(code2)) {
      return readName(lexer, position2);
    }
    throw syntaxError(
      lexer.source,
      position2,
      code2 === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code2) || isSupplementaryCodePoint(body, position2) ? `Unexpected character: ${printCodePointAt(lexer, position2)}.` : `Invalid character: ${printCodePointAt(lexer, position2)}.`
    );
  }
  return createToken2(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start2 + 1;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 10 || code2 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      break;
    }
  }
  return createToken2(
    lexer,
    TokenKind.COMMENT,
    start2,
    position2,
    body.slice(start2 + 1, position2)
  );
}
function readNumber(lexer, start2, firstCode) {
  const body = lexer.source.body;
  let position2 = start2;
  let code2 = firstCode;
  let isFloat2 = false;
  if (code2 === 45) {
    code2 = body.charCodeAt(++position2);
  }
  if (code2 === 48) {
    code2 = body.charCodeAt(++position2);
    if (isDigit(code2)) {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  } else {
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 46) {
    isFloat2 = true;
    code2 = body.charCodeAt(++position2);
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 69 || code2 === 101) {
    isFloat2 = true;
    code2 = body.charCodeAt(++position2);
    if (code2 === 43 || code2 === 45) {
      code2 = body.charCodeAt(++position2);
    }
    position2 = readDigits(lexer, position2, code2);
    code2 = body.charCodeAt(position2);
  }
  if (code2 === 46 || isNameStart(code2)) {
    throw syntaxError(
      lexer.source,
      position2,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position2
      )}.`
    );
  }
  return createToken2(
    lexer,
    isFloat2 ? TokenKind.FLOAT : TokenKind.INT,
    start2,
    position2,
    body.slice(start2, position2)
  );
}
function readDigits(lexer, start2, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start2,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start2
      )}.`
    );
  }
  const body = lexer.source.body;
  let position2 = start2 + 1;
  while (isDigit(body.charCodeAt(position2))) {
    ++position2;
  }
  return position2;
}
function readString(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start2 + 1;
  let chunkStart = position2;
  let value2 = "";
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 34) {
      value2 += body.slice(chunkStart, position2);
      return createToken2(lexer, TokenKind.STRING, start2, position2 + 1, value2);
    }
    if (code2 === 92) {
      value2 += body.slice(chunkStart, position2);
      const escape2 = body.charCodeAt(position2 + 1) === 117 ? body.charCodeAt(position2 + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position2) : readEscapedUnicodeFixedWidth(lexer, position2) : readEscapedCharacter(lexer, position2);
      value2 += escape2.value;
      position2 += escape2.size;
      chunkStart = position2;
      continue;
    }
    if (code2 === 10 || code2 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position2, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position2) {
  const body = lexer.source.body;
  let point = 0;
  let size3 = 3;
  while (size3 < 12) {
    const code2 = body.charCodeAt(position2 + size3++);
    if (code2 === 125) {
      if (size3 < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size: size3
      };
    }
    point = point << 4 | readHexDigit(code2);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid Unicode escape sequence: "${body.slice(
      position2,
      position2 + size3
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position2) {
  const body = lexer.source.body;
  const code2 = read16BitHexCode(body, position2 + 2);
  if (isUnicodeScalarValue(code2)) {
    return {
      value: String.fromCodePoint(code2),
      size: 6
    };
  }
  if (isLeadingSurrogate(code2)) {
    if (body.charCodeAt(position2 + 6) === 92 && body.charCodeAt(position2 + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position2 + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code2, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid Unicode escape sequence: "${body.slice(position2, position2 + 6)}".`
  );
}
function read16BitHexCode(body, position2) {
  return readHexDigit(body.charCodeAt(position2)) << 12 | readHexDigit(body.charCodeAt(position2 + 1)) << 8 | readHexDigit(body.charCodeAt(position2 + 2)) << 4 | readHexDigit(body.charCodeAt(position2 + 3));
}
function readHexDigit(code2) {
  return code2 >= 48 && code2 <= 57 ? code2 - 48 : code2 >= 65 && code2 <= 70 ? code2 - 55 : code2 >= 97 && code2 <= 102 ? code2 - 87 : -1;
}
function readEscapedCharacter(lexer, position2) {
  const body = lexer.source.body;
  const code2 = body.charCodeAt(position2 + 1);
  switch (code2) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position2,
    `Invalid character escape sequence: "${body.slice(
      position2,
      position2 + 2
    )}".`
  );
}
function readBlockString(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position2 = start2 + 3;
  let chunkStart = position2;
  let currentLine = "";
  const blockLines = [];
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (code2 === 34 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34) {
      currentLine += body.slice(chunkStart, position2);
      blockLines.push(currentLine);
      const token2 = createToken2(
        lexer,
        TokenKind.BLOCK_STRING,
        start2,
        position2 + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token2;
    }
    if (code2 === 92 && body.charCodeAt(position2 + 1) === 34 && body.charCodeAt(position2 + 2) === 34 && body.charCodeAt(position2 + 3) === 34) {
      currentLine += body.slice(chunkStart, position2);
      chunkStart = position2 + 1;
      position2 += 4;
      continue;
    }
    if (code2 === 10 || code2 === 13) {
      currentLine += body.slice(chunkStart, position2);
      blockLines.push(currentLine);
      if (code2 === 13 && body.charCodeAt(position2 + 1) === 10) {
        position2 += 2;
      } else {
        ++position2;
      }
      currentLine = "";
      chunkStart = position2;
      lineStart = position2;
      continue;
    }
    if (isUnicodeScalarValue(code2)) {
      ++position2;
    } else if (isSupplementaryCodePoint(body, position2)) {
      position2 += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position2,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position2
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position2, "Unterminated string.");
}
function readName(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position2 = start2 + 1;
  while (position2 < bodyLength) {
    const code2 = body.charCodeAt(position2);
    if (isNameContinue(code2)) {
      ++position2;
    } else {
      break;
    }
  }
  return createToken2(
    lexer,
    TokenKind.NAME,
    start2,
    position2,
    body.slice(start2, position2)
  );
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue2(value2, []);
}
function formatValue2(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object2, seenValues) {
  const entries = Object.entries(object2);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  const properties = entries.map(
    ([key, value2]) => key + ": " + formatValue2(value2, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i6 = 0; i6 < len; ++i6) {
    items.push(formatValue2(array[i6], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object2) {
  const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object2.constructor === "function") {
    const name2 = object2.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value2, constructor) {
    return value2 instanceof constructor;
  } : function instanceOf3(value2, constructor) {
    if (value2 instanceof constructor) {
      return true;
    }
    if (typeof value2 === "object" && value2 !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value2 ? value2[Symbol.toStringTag] : (_value$constructor = value2.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value2);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name2 = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name2;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/parser.mjs
function parse4(source, options) {
  const parser2 = new Parser2(source, options);
  return parser2.parseDocument();
}
var Parser2 = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token2 = this.expectToken(TokenKind.NAME);
    return this.node(token2, {
      kind: Kind.NAME,
      value: token2.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start2 = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start2, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name2;
    if (this.peek(TokenKind.NAME)) {
      name2 = this.parseName();
    }
    return this.node(start2, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name: name2,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start2, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start2 = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name2;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name2 = this.parseName();
    } else {
      name2 = nameOrAlias;
    }
    return this.node(start2, {
      kind: Kind.FIELD,
      alias,
      name: name2,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item2 = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item2, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start2, {
      kind: Kind.ARGUMENT,
      name: name2,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start2, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start2, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start2 = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start2, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start2, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token2 = this._lexer.token;
    switch (token2.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.INT,
          value: token2.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token2, {
          kind: Kind.FLOAT,
          value: token2.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token2.value) {
          case "true":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token2, {
              kind: Kind.NULL
            });
          default:
            return this.node(token2, {
              kind: Kind.ENUM,
              value: token2.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token2.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token2);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token2 = this._lexer.token;
    this.advanceLexer();
    return this.node(token2, {
      kind: Kind.STRING,
      value: token2.value,
      block: token2.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item2 = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item2, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item2 = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item2, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start2, {
      kind: Kind.OBJECT_FIELD,
      name: name2,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives2 = [];
    while (this.peek(TokenKind.AT)) {
      directives2.push(this.parseDirective(isConst));
    }
    return directives2;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start2, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start2 = this._lexer.token;
    let type2;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type2 = this.node(start2, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type2 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start2, {
        kind: Kind.NON_NULL_TYPE,
        type: type2
      });
    }
    return type2;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives2 = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start2, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives: directives2,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start2 = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseNamedType();
    return this.node(start2, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type2
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name: name2,
      directives: directives2
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start2, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name: name2,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseTypeReference();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name: name2,
      arguments: args,
      type: type2,
      directives: directives2
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name: name2,
      type: type2,
      defaultValue,
      directives: directives2
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start2, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name: name2,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start2, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name: name2,
      directives: directives2,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const values2 = this.parseEnumValuesDefinition();
    return this.node(start2, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name: name2,
      directives: directives2,
      values: values2
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseEnumValueName();
    const directives2 = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name: name2,
      directives: directives2
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start2, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name: name2,
      directives: directives2,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives2 = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives2.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.SCHEMA_EXTENSION,
      directives: directives2,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    if (directives2.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name: name2,
      directives: directives2
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives: directives2,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives2.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name: name2,
      directives: directives2,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const values2 = this.parseEnumValuesDefinition();
    if (directives2.length === 0 && values2.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name: name2,
      directives: directives2,
      values: values2
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name2 = this.parseName();
    const directives2 = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives2.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name: name2,
      directives: directives2,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name2 = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start2, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name: name2,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name2.value)) {
      return name2;
    }
    throw this.unexpected(start2);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node3) {
    if (this._options.noLocation !== true) {
      node3.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node3;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return token2;
    }
    throw syntaxError(
      this._lexer.source,
      token2.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token2)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token2 = this._lexer.token;
    if (token2.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value2) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value2) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token2.start,
        `Expected "${value2}", found ${getTokenDesc(token2)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value2) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value2) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token2.start,
      `Unexpected ${getTokenDesc(token2)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token2 = this._lexer.advance();
    if (maxTokens !== void 0 && token2.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token2.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token2) {
  const value2 = token2.value;
  return getTokenKindDesc(token2.kind) + (value2 != null ? ` "${value2}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x3) => `"${x3}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x3) {
  return x3;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list2, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item2 of list2) {
    result[keyFn(item2)] = item2;
  }
  return result;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list2, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item2 of list2) {
    result[keyFn(item2)] = valFn(item2);
  }
  return result;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map2, fn2) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map2)) {
    result[key] = fn2(map2[key], key);
  }
  return result;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code2) {
  return !isNaN(code2) && DIGIT_0 <= code2 && code2 <= DIGIT_9;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a3, b2) => {
    const distanceDiff = optionsByDistance[a3] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a3, b2);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a3 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a3.length < b2.length) {
      const tmp = a3;
      a3 = b2;
      b2 = tmp;
    }
    const aLength = a3.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j3 = 0; j3 <= bLength; j3++) {
      rows[0][j3] = j3;
    }
    for (let i6 = 1; i6 <= aLength; i6++) {
      const upRow = rows[(i6 - 1) % 3];
      const currentRow = rows[i6 % 3];
      let smallestCell = currentRow[0] = i6;
      for (let j3 = 1; j3 <= bLength; j3++) {
        const cost = a3[i6 - 1] === b2[j3 - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j3] + 1,
          // delete
          currentRow[j3 - 1] + 1,
          // insert
          upRow[j3 - 1] + cost
          // substitute
        );
        if (i6 > 1 && j3 > 1 && a3[i6 - 1] === b2[j3 - 2] && a3[i6 - 2] === b2[j3 - 1]) {
          const doubleDiagonalCell = rows[(i6 - 2) % 3][j3 - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j3] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i6 = 0; i6 < strLength; ++i6) {
    array[i6] = str.charCodeAt(i6);
  }
  return array;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map2 = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    map2[key] = value2;
  }
  return map2;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index2 = -1;
  let edits = [];
  let node3 = root;
  let key = void 0;
  let parent = void 0;
  const path2 = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path2[path2.length - 1];
      node3 = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node3 = node3.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node3.splice(arrayKey, 1);
              editOffset++;
            } else {
              node3[arrayKey] = editValue;
            }
          }
        } else {
          node3 = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node3)
          );
          for (const [editKey, editValue] of edits) {
            node3[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys[index2];
      node3 = parent[key];
      if (node3 === null || node3 === void 0) {
        continue;
      }
      path2.push(key);
    }
    let result;
    if (!Array.isArray(node3)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node3) || devAssert(false, `Invalid AST Node: ${inspect(node3)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node3.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node3.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node3, key, parent, path2, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path2.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node3 = result;
          } else {
            path2.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node3]);
    }
    if (isLeaving) {
      path2.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node3);
      keys = inArray ? node3 : (_node$kind = visitorKeys[node3.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node3;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node3) => node3.value
  },
  Variable: {
    leave: (node3) => "$" + node3.name
  },
  // Document
  Document: {
    leave: (node3) => join(node3.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node3) {
      const varDefs = wrap("(", join(node3.variableDefinitions, ", "), ")");
      const prefix3 = join(
        [
          node3.operation,
          join([node3.name, varDefs]),
          join(node3.directives, " ")
        ],
        " "
      );
      return (prefix3 === "query" ? "" : prefix3 + " ") + node3.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives: directives2 }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives2, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block4(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives: directives2, selectionSet: selectionSet2 }) {
      const prefix3 = wrap("", alias, ": ") + name2;
      let argsLine = prefix3 + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix3 + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives2, " "), selectionSet2], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives: directives2 }) => "..." + name2 + wrap(" ", join(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: typeCondition2, directives: directives2, selectionSet: selectionSet2 }) => join(
      [
        "...",
        wrap("on ", typeCondition2),
        join(directives2, " "),
        selectionSet2
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition: typeCondition2, variableDefinitions, directives: directives2, selectionSet: selectionSet2 }) => (
      // or removed in the future.
      `fragment ${name2}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition2} ${wrap("", join(directives2, " "), " ")}` + selectionSet2
    )
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values: values2 }) => "[" + join(values2, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives: directives2, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives2, " "), block4(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join(["scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block4(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args, type: type2, directives: directives2 }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue, directives: directives2 }) => wrap("", description, "\n") + join(
      [name2 + ": " + type2, wrap("= ", defaultValue), join(directives2, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block4(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, types }) => wrap("", description, "\n") + join(
      ["union", name2, join(directives2, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, values: values2 }) => wrap("", description, "\n") + join(["enum", name2, join(directives2, " "), block4(values2)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join([name2, join(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, fields }) => wrap("", description, "\n") + join(["input", name2, join(directives2, " "), block4(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join(
      ["extend schema", join(directives2, " "), block4(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives: directives2 }) => join(["extend scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block4(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block4(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives: directives2, types }) => join(
      [
        "extend union",
        name2,
        join(directives2, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives: directives2, values: values2 }) => join(["extend enum", name2, join(directives2, " "), block4(values2)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives: directives2, fields }) => join(["extend input", name2, join(directives2, " "), block4(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x3) => x3).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block4(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start2, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start2 + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node3) => valueFromASTUntyped(node3, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field2) => field2.name.value,
        (field2) => valueFromASTUntyped(field2.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/assertName.mjs
function assertName(name2) {
  name2 != null || devAssert(false, "Must provide name.");
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i6 = 1; i6 < name2.length; ++i6) {
    if (!isNameContinue(name2.charCodeAt(i6))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
      );
    }
  }
  if (!isNameStart(name2.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name2}" does not.`
    );
  }
  return name2;
}
function assertEnumValueName(name2) {
  if (name2 === "true" || name2 === "false" || name2 === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name2}`);
  }
  return assertName(name2);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/definition.mjs
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function isOutputType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function getNamedType(type2) {
  if (type2) {
    let unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config2) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.specifiedByURL = config2.specifiedByURL;
    this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node3, variables) => parseValue2(valueFromASTUntyped(node3, variables));
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config2.specifiedByURL)}.`
    );
    config2.serialize == null || typeof config2.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config2.parseLiteral) {
      typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config2) {
    var _config$extensionASTN2;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.isTypeOf = config2.isTypeOf;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config2);
    this._interfaces = () => defineInterfaces(config2);
    config2.isTypeOf == null || typeof config2.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config2.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config2) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config2.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config2) {
  const fieldMap = resolveObjMapThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config2.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config2.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config2) {
  return Object.entries(config2).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field2) => ({
    description: field2.description,
    type: field2.type,
    args: argsToArgsConfig(field2.args),
    resolve: field2.resolve,
    subscribe: field2.subscribe,
    deprecationReason: field2.deprecationReason,
    extensions: field2.extensions,
    astNode: field2.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config2) {
    var _config$extensionASTN3;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.resolveType = config2.resolveType;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config2);
    this._interfaces = defineInterfaces.bind(void 0, config2);
    config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config2.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config2) {
    var _config$extensionASTN4;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.resolveType = config2.resolveType;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config2);
    config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config2.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config2) {
  const types = resolveReadonlyArrayThunk(config2.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config2) {
    var _config$extensionASTN5;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config2.values);
    this._valueLookup = new Map(
      this._values.map((enumValue) => [enumValue.value, enumValue])
    );
    this._nameLookup = keyMap(this._values, (value2) => value2.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name2) {
    return this._nameLookup[name2];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values2 = keyValMap(
      this.getValues(),
      (value2) => value2.name,
      (value2) => ({
        description: value2.description,
        value: value2.value,
        deprecationReason: value2.deprecationReason,
        extensions: value2.extensions,
        astNode: value2.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values: values2,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value2) => value2.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config2) {
    var _config$extensionASTN6;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(void 0, config2);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field2) => ({
      description: field2.description,
      type: field2.type,
      defaultValue: field2.defaultValue,
      deprecationReason: field2.deprecationReason,
      extensions: field2.extensions,
      astNode: field2.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config2) {
  const fieldMap = resolveObjMapThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field2) {
  return isNonNullType(field2.type) && field2.defaultValue === void 0;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
var GraphQLDirective = class {
  constructor(config2) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.locations = config2.locations;
    this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    Array.isArray(config2.locations) || devAssert(false, `@${config2.name} locations must be an Array.`);
    const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config2.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value2, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value2, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value2 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value2 === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value2)) {
      const valuesNodes = [];
      for (const item2 of value2) {
        const itemNode = astFromValue(item2, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value2, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value2)) {
      return null;
    }
    const fieldNodes = [];
    for (const field2 of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value2[field2.name], field2.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field2.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value2);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field2, { includeDeprecated }) {
        return includeDeprecated ? field2.args : field2.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => (
        /* c8 ignore next */
        "description" in type2 ? type2.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field2) => field2.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values2 = type2.getValues();
          return includeDeprecated ? values2 : values2.filter((field2) => field2.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values2 = Object.values(type2.getFields());
          return includeDeprecated ? values2 : values2.filter((field2) => field2.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field2) => field2.name
    },
    description: {
      type: GraphQLString,
      resolve: (field2) => field2.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field2, { includeDeprecated }) {
        return includeDeprecated ? field2.args : field2.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field2) => field2.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field2) => field2.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field2) => field2.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type2);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field2) => field2.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/type/schema.mjs
var GraphQLSchema = class {
  // Used as a cache for validateSchema().
  constructor(config2) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config2.assumeValid === true ? [] : void 0;
    isObjectLike(config2) || devAssert(false, "Must provide configuration object.");
    !config2.types || Array.isArray(config2.types) || devAssert(
      false,
      `"types" must be Array if provided but got: ${inspect(config2.types)}.`
    );
    !config2.directives || Array.isArray(config2.directives) || devAssert(
      false,
      `"directives" must be Array if provided but got: ${inspect(config2.directives)}.`
    );
    this.description = config2.description;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    this._queryType = config2.query;
    this._mutationType = config2.mutation;
    this._subscriptionType = config2.subscription;
    this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config2.types);
    if (config2.types != null) {
      for (const type2 of config2.types) {
        allReferencedTypes.delete(type2);
        collectReferencedTypes(type2, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = /* @__PURE__ */ Object.create(null);
    this._subTypeMap = /* @__PURE__ */ Object.create(null);
    this._implementationsMap = /* @__PURE__ */ Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(
        false,
        "One of the provided types for building the Schema is missing a name."
      );
      if (this._typeMap[typeName] !== void 0) {
        throw new Error(
          `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
        );
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name2) {
    return this.getTypeMap()[name2];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== void 0 ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map2 = this._subTypeMap[abstractType.name];
    if (map2 === void 0) {
      map2 = /* @__PURE__ */ Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type2 of abstractType.getTypes()) {
          map2[type2.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type2 of implementations.objects) {
          map2[type2.name] = true;
        }
        for (const type2 of implementations.interfaces) {
          map2[type2.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map2;
    }
    return map2[maybeSubType.name] !== void 0;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name2) {
    return this.getDirectives().find((directive) => directive.name === name2);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== void 0
    };
  }
};
function collectReferencedTypes(type2, typeSet) {
  const namedType = getNamedType(type2);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field2 of Object.values(namedType.getFields())) {
        collectReferencedTypes(field2.type, typeSet);
        for (const arg of field2.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field2 of Object.values(namedType.getFields())) {
        collectReferencedTypes(field2.type, typeSet);
      }
    }
  }
  return typeSet;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/TypeInfo.mjs
var TypeInfo = class {
  constructor(schema, initialType, getFieldDefFn) {
    this._schema = schema;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node3) {
    const schema = this._schema;
    switch (node3.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(
          isCompositeType(namedType) ? namedType : void 0
        );
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema, parentType, node3);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema.getDirective(node3.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema.getRootType(node3.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node3.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema, node3.type);
        this._inputTypeStack.push(
          isInputType(inputType) ? inputType : void 0
        );
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find(
            (arg) => arg.name === node3.name.value
          );
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(void 0);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node3.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(
          inputField ? inputField.defaultValue : void 0
        );
        this._inputTypeStack.push(
          isInputType(inputFieldType) ? inputFieldType : void 0
        );
        break;
      }
      case Kind.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node3.value);
        }
        this._enumValue = enumValue;
        break;
      }
      default:
    }
  }
  leave(node3) {
    switch (node3.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
      default:
    }
  }
};
function getFieldDef(schema, parentType, fieldNode) {
  const name2 = fieldNode.name.value;
  if (name2 === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name2 === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name2 === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name2];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node3 = args[0];
      typeInfo.enter(node3);
      const fn2 = getEnterLeaveForKind(visitor, node3.kind).enter;
      if (fn2) {
        const result = fn2.apply(visitor, args);
        if (result !== void 0) {
          typeInfo.leave(node3);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node3 = args[0];
      const fn2 = getEnterLeaveForKind(visitor, node3.kind).leave;
      let result;
      if (fn2) {
        result = fn2.apply(visitor, args);
      }
      typeInfo.leave(node3);
      return result;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node3) {
  return node3.kind === Kind.OPERATION_DEFINITION || node3.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node3) {
  return node3.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node3) || node3.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node3) {
  return node3.kind === Kind.SCALAR_TYPE_DEFINITION || node3.kind === Kind.OBJECT_TYPE_DEFINITION || node3.kind === Kind.INTERFACE_TYPE_DEFINITION || node3.kind === Kind.UNION_TYPE_DEFINITION || node3.kind === Kind.ENUM_TYPE_DEFINITION || node3.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node3) {
  return node3.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node3);
}
function isTypeExtensionNode(node3) {
  return node3.kind === Kind.SCALAR_TYPE_EXTENSION || node3.kind === Kind.OBJECT_TYPE_EXTENSION || node3.kind === Kind.INTERFACE_TYPE_EXTENSION || node3.kind === Kind.UNION_TYPE_EXTENSION || node3.kind === Kind.ENUM_TYPE_EXTENSION || node3.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node3) {
      for (const definition of node3.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node3) {
      const type2 = context.getParentType();
      if (type2) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node3.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type2, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
              {
                nodes: node3
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type2)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x3) => x3.name);
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node3) {
      const typeCondition2 = node3.typeCondition;
      if (typeCondition2) {
        const type2 = typeFromAST(context.getSchema(), typeCondition2);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print(typeCondition2);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition2
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node3) {
      const type2 = typeFromAST(context.getSchema(), node3.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        const typeStr = print(node3.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node3.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node3.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
    }
  }
  return {
    Directive(node3, _key, _parent, _path, ancestors) {
      const name2 = node3.name.value;
      const locations = locationsMap[name2];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name2}".`, {
            nodes: node3
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name2}" may not be used on ${candidateLocation}.`,
            {
              nodes: node3
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node3) {
      const fragmentName = node3.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node3.name
          })
        );
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node3, _1, parent, _2, ancestors) {
      const typeName = node3.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node3
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type2) => type2.name
);
function isSDLNode(value2) {
  return "kind" in value2 && (isTypeSystemDefinitionNode(value2) || isTypeSystemExtensionNode(value2));
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node3) {
      operationCount = node3.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node3) {
      if (!node3.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node3
            }
          )
        );
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node3) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node3
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node3
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node3) {
      detectCycleRecursive(node3);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s4) => '"' + s4.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node3 } of usages) {
          const varName = node3.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node3, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node3) {
      variableNameDefined[node3.variable.name.value] = true;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node3) {
      operationDefs.push(node3);
      return false;
    },
    FragmentDefinition(node3) {
      fragmentDefs.push(node3);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node3 } of usages) {
          variableNameUsed[node3.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet2) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet2
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet2) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet2
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i6 = 0; i6 < fragmentNames.length; i6++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i6]
      );
      for (let j3 = i6 + 1; j3 < fragmentNames.length; j3++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i6],
          fragmentNames[j3]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i6 = 0; i6 < fields.length; i6++) {
        for (let j3 = i6 + 1; j3 < fields.length; j3++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i6],
            fields[j3]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node22, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node22.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node22]
      ];
    }
    if (!sameArguments(node1, node22)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node22]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node22]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node22.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node22);
  }
}
function sameArguments(node1, node22) {
  const args1 = node1.arguments;
  const args2 = node22.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name: name2, value: value2 }) => [name2.value, value2]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value2) {
  return print(sortValueNode(value2));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet2) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet2);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet2,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet2, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet2, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition2 = selection.typeCondition;
        const inlineFragmentType = typeCondition2 ? typeFromAST(context.getSchema(), typeCondition2) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node22) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node22, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a3, b2, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a3 < b2 ? [a3, b2] : [b2, a3];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a3, b2, areMutuallyExclusive) {
    const [key1, key2] = a3 < b2 ? [a3, b2] : [b2, a3];
    const map2 = this._data.get(key1);
    if (map2 === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map2.set(key2, areMutuallyExclusive);
    }
  }
};

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node3) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node3
            }
          )
        );
      }
    },
    FragmentSpread(node3) {
      const fragName = node3.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node3
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name2) {
  const frag = context.getFragment(name2);
  if (frag) {
    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node3) {
    const typeName = node3.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node3.kind) {
        const kindStr = extensionKindToTypeName(node3.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node3] : node3
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node3.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node3) {
      const type2 = context.getType();
      const selectionSet2 = node3.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet2) {
            const fieldName = node3.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet2
                }
              )
            );
          }
        } else if (!selectionSet2) {
          const fieldName = node3.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node3
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field2) => field2.name.value);
    for (const field2 of Object.values(type2.getFields())) {
      const fieldNode = fieldNodes[field2.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field2.defaultValue !== void 0) {
          coercedObj[field2.name] = field2.defaultValue;
        } else if (isNonNullType(field2.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field2.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field2.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    let result;
    try {
      result = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node3, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node3.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name2 = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name2];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name2] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name2}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node3
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull2 = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name2}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull2 = variableValues[variableName] == null;
    }
    if (isNull2 && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name2}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name2}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name2] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node3, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node3.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet2) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet2,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node3 of fieldNodes) {
    if (node3.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node3.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet2, fields, visitedFragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name2 = getFieldEntryKey(selection);
        const fieldList = fields.get(name2);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name2, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node3) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node3, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node3,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey(node3) {
  return node3.alias ? node3.alias.value : node3.name.value;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node3) {
      if (node3.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node3.name ? node3.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document3 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document3.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node3.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field2 = fieldNodes[0];
            const fieldName = field2.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list2, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item2 of list2) {
    const key = keyFn(item2);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item2]);
    } else {
      group.push(item2);
    }
  }
  return result;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node3) => node3.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node3) => node3.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node3) {
      const directiveName = node3.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node3.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node3.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node3.name;
      }
      return false;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node3) {
      if (!("directives" in node3) || !node3.directives) {
        return;
      }
      let seenDirectives;
      if (node3.kind === Kind.SCHEMA_DEFINITION || node3.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node3) || isTypeExtensionNode(node3)) {
        const typeName = node3.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node3.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node3) {
    var _node$values;
    const typeName = node3.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node3.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node3) {
    var _node$fields;
    const typeName = node3.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node3.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node3) {
      const fragmentName = node3.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node3.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node3.name;
      }
      return false;
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node3) {
      const fieldName = node3.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node3.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node3.name;
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node3) {
      const operationName = node3.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node3) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node3.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node3) {
    const typeName = node3.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node3.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node3.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node3.name;
    }
    return false;
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node3) => node3.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node3) => node3.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node3) {
      const type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node3);
        return false;
      }
    },
    ObjectValue(node3) {
      const type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node3);
        return false;
      }
      const fieldNodeMap = keyMap(node3.fields, (field2) => field2.name.value);
      for (const fieldDef of Object.values(type2.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node3
              }
            )
          );
        }
      }
    },
    ObjectField(node3) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node3.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node3.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node3
            }
          )
        );
      }
    },
    NullValue(node3) {
      const type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type2)}", found ${print(node3)}.`,
            {
              nodes: node3
            }
          )
        );
      }
    },
    EnumValue: (node3) => isValidValueNode(context, node3),
    IntValue: (node3) => isValidValueNode(context, node3),
    FloatValue: (node3) => isValidValueNode(context, node3),
    StringValue: (node3) => isValidValueNode(context, node3),
    BooleanValue: (node3) => isValidValueNode(context, node3)
  };
}
function isValidValueNode(context, node3) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node3)}.`,
        {
          nodes: node3
        }
      )
    );
    return;
  }
  try {
    const parseResult = type2.parseLiteral(
      node3,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node3)}.`,
          {
            nodes: node3
          }
        )
      );
    }
  } catch (error3) {
    const typeStr = inspect(locationType);
    if (error3 instanceof GraphQLError) {
      context.reportError(error3);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node3)}; ` + error3.message,
          {
            nodes: node3,
            originalError: error3
          }
        )
      );
    }
  }
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node3) {
      const type2 = typeFromAST(context.getSchema(), node3.type);
      if (type2 !== void 0 && !isInputType(type2)) {
        const variableName = node3.variable.name.value;
        const typeName = print(node3.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node3.type
            }
          )
        );
      }
    }
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node3, type: type2, defaultValue } of usages) {
          const varName = node3.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type2) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type2,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type2);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node3]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node3) {
      varDefMap[node3.variable.name.value] = node3;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/validation/ValidationContext.mjs
var ASTValidationContext = class {
  constructor(ast, onError) {
    this._ast = ast;
    this._fragments = void 0;
    this._fragmentSpreads = /* @__PURE__ */ new Map();
    this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error3) {
    this._onError(error3);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name2) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = /* @__PURE__ */ Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name2];
  }
  getFragmentSpreads(node3) {
    let spreads = this._fragmentSpreads.get(node3);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node3];
      let set;
      while (set = setsToVisit.pop()) {
        for (const selection of set.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node3, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = /* @__PURE__ */ Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node3;
      while (node3 = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node3)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
};
var SDLValidationContext = class extends ASTValidationContext {
  constructor(ast, schema, onError) {
    super(ast, onError);
    this._schema = schema;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
};
var ValidationContext = class extends ASTValidationContext {
  constructor(schema, ast, typeInfo, onError) {
    super(ast, onError);
    this._schema = schema;
    this._typeInfo = typeInfo;
    this._variableUsages = /* @__PURE__ */ new Map();
    this._recursiveVariableUsages = /* @__PURE__ */ new Map();
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node3) {
    let usages = this._variableUsages.get(node3);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(
        node3,
        visitWithTypeInfo(typeInfo, {
          VariableDefinition: () => false,
          Variable(variable) {
            newUsages.push({
              node: variable,
              type: typeInfo.getInputType(),
              defaultValue: typeInfo.getDefaultValue()
            });
          }
        })
      );
      usages = newUsages;
      this._variableUsages.set(node3, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
};

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn2) {
  let cache0;
  return function memoized(a1, a22, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache22 = cache1.get(a22);
    if (cache22 === void 0) {
      cache22 = /* @__PURE__ */ new WeakMap();
      cache1.set(a22, cache22);
    }
    let fnResult = cache22.get(a3);
    if (fnResult === void 0) {
      fnResult = fn2(a1, a22, a3);
      cache22.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type2) => type2.name
);

// node_modules/.pnpm/graphql@16.8.1/node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/.pnpm/graphql-tag@2.12.6_graphql@16.8.1/node_modules/graphql-tag/lib/index.js
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition2) {
    if (fragmentDefinition2.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition2.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition2.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition2);
      }
    } else {
      definitions.push(fragmentDefinition2);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node3) {
    if (node3.loc)
      delete node3.loc;
    Object.keys(node3).forEach(function(key) {
      var value2 = node3[key];
      if (value2 && typeof value2 === "object") {
        workSet.add(value2);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse4(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i6) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i6 + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default2 = gql;

// node_modules/.pnpm/@0no-co+graphql.web@1.0.4_graphql@16.8.1/node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e2 = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError2 = class extends Error {
  constructor(e6, r7, i6, n6, a3, t5, o5) {
    super(e6);
    this.name = "GraphQLError";
    this.message = e6;
    if (a3) {
      this.path = a3;
    }
    if (r7) {
      this.nodes = Array.isArray(r7) ? r7 : [r7];
    }
    if (i6) {
      this.source = i6;
    }
    if (n6) {
      this.positions = n6;
    }
    if (t5) {
      this.originalError = t5;
    }
    var l6 = o5;
    if (!l6 && t5) {
      var u4 = t5.extensions;
      if (u4 && "object" == typeof u4) {
        l6 = u4;
      }
    }
    this.extensions = l6 || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var i3;
var n4;
function error2(e6) {
  return new GraphQLError2(`Syntax Error: Unexpected token at ${n4} in ${e6}`);
}
function advance(e6) {
  e6.lastIndex = n4;
  if (e6.test(i3)) {
    return i3.slice(n4, n4 = e6.lastIndex);
  }
}
var a2 = / +(?=[^\s])/y;
function blockString(e6) {
  var r7 = e6.split("\n");
  var i6 = "";
  var n6 = 0;
  var t5 = 0;
  var o5 = r7.length - 1;
  for (var l6 = 0; l6 < r7.length; l6++) {
    a2.lastIndex = 0;
    if (a2.test(r7[l6])) {
      if (l6 && (!n6 || a2.lastIndex < n6)) {
        n6 = a2.lastIndex;
      }
      t5 = t5 || l6;
      o5 = l6;
    }
  }
  for (var u4 = t5; u4 <= o5; u4++) {
    if (u4 !== t5) {
      i6 += "\n";
    }
    i6 += r7[u4].slice(n6).replace(/\\"""/g, '"""');
  }
  return i6;
}
function ignored() {
  for (var e6 = 0 | i3.charCodeAt(n4++); 9 === e6 || 10 === e6 || 13 === e6 || 32 === e6 || 35 === e6 || 44 === e6 || 65279 === e6; e6 = 0 | i3.charCodeAt(n4++)) {
    if (35 === e6) {
      while (10 !== (e6 = i3.charCodeAt(n4++)) && 13 !== e6) {
      }
    }
  }
  n4--;
}
var t3 = /[_A-Za-z]\w*/y;
function name() {
  var e6;
  if (e6 = advance(t3)) {
    return {
      kind: "Name",
      value: e6
    };
  }
}
var o2 = /(?:null|true|false)/y;
var l2 = /\$[_A-Za-z]\w*/y;
var u2 = /-?\d+/y;
var v2 = /(?:\.\d+)?[eE][+-]?\d+|\.\d+/y;
var d2 = /\\/g;
var s3 = /"""(?:"""|(?:[\s\S]*?[^\\])""")/y;
var c2 = /"(?:"|[^\r\n]*?[^\\]")/y;
function value(e6) {
  var r7;
  var a3;
  if (a3 = advance(o2)) {
    r7 = "null" === a3 ? {
      kind: "NullValue"
    } : {
      kind: "BooleanValue",
      value: "true" === a3
    };
  } else if (!e6 && (a3 = advance(l2))) {
    r7 = {
      kind: "Variable",
      name: {
        kind: "Name",
        value: a3.slice(1)
      }
    };
  } else if (a3 = advance(u2)) {
    var f5 = a3;
    if (a3 = advance(v2)) {
      r7 = {
        kind: "FloatValue",
        value: f5 + a3
      };
    } else {
      r7 = {
        kind: "IntValue",
        value: f5
      };
    }
  } else if (a3 = advance(t3)) {
    r7 = {
      kind: "EnumValue",
      value: a3
    };
  } else if (a3 = advance(s3)) {
    r7 = {
      kind: "StringValue",
      value: blockString(a3.slice(3, -3)),
      block: true
    };
  } else if (a3 = advance(c2)) {
    r7 = {
      kind: "StringValue",
      value: d2.test(a3) ? JSON.parse(a3) : a3.slice(1, -1),
      block: false
    };
  } else if (r7 = function list2(e7) {
    var r8;
    if (91 === i3.charCodeAt(n4)) {
      n4++;
      ignored();
      var a4 = [];
      while (r8 = value(e7)) {
        a4.push(r8);
      }
      if (93 !== i3.charCodeAt(n4++)) {
        throw error2("ListValue");
      }
      ignored();
      return {
        kind: "ListValue",
        values: a4
      };
    }
  }(e6) || function object2(e7) {
    if (123 === i3.charCodeAt(n4)) {
      n4++;
      ignored();
      var r8 = [];
      var a4;
      while (a4 = name()) {
        ignored();
        if (58 !== i3.charCodeAt(n4++)) {
          throw error2("ObjectField");
        }
        ignored();
        var t5 = value(e7);
        if (!t5) {
          throw error2("ObjectField");
        }
        r8.push({
          kind: "ObjectField",
          name: a4,
          value: t5
        });
      }
      if (125 !== i3.charCodeAt(n4++)) {
        throw error2("ObjectValue");
      }
      ignored();
      return {
        kind: "ObjectValue",
        fields: r8
      };
    }
  }(e6)) {
    return r7;
  }
  ignored();
  return r7;
}
function arguments_(e6) {
  var r7 = [];
  ignored();
  if (40 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    var a3;
    while (a3 = name()) {
      ignored();
      if (58 !== i3.charCodeAt(n4++)) {
        throw error2("Argument");
      }
      ignored();
      var t5 = value(e6);
      if (!t5) {
        throw error2("Argument");
      }
      r7.push({
        kind: "Argument",
        name: a3,
        value: t5
      });
    }
    if (!r7.length || 41 !== i3.charCodeAt(n4++)) {
      throw error2("Argument");
    }
    ignored();
  }
  return r7;
}
function directives(e6) {
  var r7 = [];
  ignored();
  while (64 === i3.charCodeAt(n4)) {
    n4++;
    var a3 = name();
    if (!a3) {
      throw error2("Directive");
    }
    ignored();
    r7.push({
      kind: "Directive",
      name: a3,
      arguments: arguments_(e6)
    });
  }
  return r7;
}
function field() {
  var e6 = name();
  if (e6) {
    ignored();
    var r7;
    if (58 === i3.charCodeAt(n4)) {
      n4++;
      ignored();
      r7 = e6;
      if (!(e6 = name())) {
        throw error2("Field");
      }
      ignored();
    }
    return {
      kind: "Field",
      alias: r7,
      name: e6,
      arguments: arguments_(false),
      directives: directives(false),
      selectionSet: selectionSet()
    };
  }
}
function type() {
  var e6;
  ignored();
  if (91 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    var r7 = type();
    if (!r7 || 93 !== i3.charCodeAt(n4++)) {
      throw error2("ListType");
    }
    e6 = {
      kind: "ListType",
      type: r7
    };
  } else if (e6 = name()) {
    e6 = {
      kind: "NamedType",
      name: e6
    };
  } else {
    throw error2("NamedType");
  }
  ignored();
  if (33 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    return {
      kind: "NonNullType",
      type: e6
    };
  } else {
    return e6;
  }
}
var f2 = /on/y;
function typeCondition() {
  if (advance(f2)) {
    ignored();
    var e6 = name();
    if (!e6) {
      throw error2("NamedType");
    }
    ignored();
    return {
      kind: "NamedType",
      name: e6
    };
  }
}
var p2 = /\.\.\./y;
function fragmentSpread() {
  if (advance(p2)) {
    ignored();
    var e6 = n4;
    var r7;
    if ((r7 = name()) && "on" !== r7.value) {
      return {
        kind: "FragmentSpread",
        name: r7,
        directives: directives(false)
      };
    } else {
      n4 = e6;
      var i6 = typeCondition();
      var a3 = directives(false);
      var t5 = selectionSet();
      if (!t5) {
        throw error2("InlineFragment");
      }
      return {
        kind: "InlineFragment",
        typeCondition: i6,
        directives: a3,
        selectionSet: t5
      };
    }
  }
}
function selectionSet() {
  var e6;
  ignored();
  if (123 === i3.charCodeAt(n4)) {
    n4++;
    ignored();
    var r7 = [];
    while (e6 = fragmentSpread() || field()) {
      r7.push(e6);
    }
    if (!r7.length || 125 !== i3.charCodeAt(n4++)) {
      throw error2("SelectionSet");
    }
    ignored();
    return {
      kind: "SelectionSet",
      selections: r7
    };
  }
}
var m = /fragment/y;
function fragmentDefinition() {
  if (advance(m)) {
    ignored();
    var e6 = name();
    if (!e6) {
      throw error2("FragmentDefinition");
    }
    ignored();
    var r7 = typeCondition();
    if (!r7) {
      throw error2("FragmentDefinition");
    }
    var i6 = directives(false);
    var n6 = selectionSet();
    if (!n6) {
      throw error2("FragmentDefinition");
    }
    return {
      kind: "FragmentDefinition",
      name: e6,
      typeCondition: r7,
      directives: i6,
      selectionSet: n6
    };
  }
}
var g2 = /(?:query|mutation|subscription)/y;
function operationDefinition() {
  var e6;
  var r7;
  var a3 = [];
  var t5 = [];
  if (e6 = advance(g2)) {
    ignored();
    r7 = name();
    a3 = function variableDefinitions() {
      var e7;
      var r8 = [];
      ignored();
      if (40 === i3.charCodeAt(n4)) {
        n4++;
        ignored();
        while (e7 = advance(l2)) {
          ignored();
          if (58 !== i3.charCodeAt(n4++)) {
            throw error2("VariableDefinition");
          }
          var a4 = type();
          var t6 = void 0;
          if (61 === i3.charCodeAt(n4)) {
            n4++;
            ignored();
            if (!(t6 = value(true))) {
              throw error2("VariableDefinition");
            }
          }
          ignored();
          r8.push({
            kind: "VariableDefinition",
            variable: {
              kind: "Variable",
              name: {
                kind: "Name",
                value: e7.slice(1)
              }
            },
            type: a4,
            defaultValue: t6,
            directives: directives(true)
          });
        }
        if (41 !== i3.charCodeAt(n4++)) {
          throw error2("VariableDefinition");
        }
        ignored();
      }
      return r8;
    }();
    t5 = directives(false);
  }
  var o5 = selectionSet();
  if (o5) {
    return {
      kind: "OperationDefinition",
      operation: e6 || "query",
      name: r7,
      variableDefinitions: a3,
      directives: t5,
      selectionSet: o5
    };
  }
}
function parse5(e6, r7) {
  i3 = "string" == typeof e6.body ? e6.body : e6;
  n4 = 0;
  return function document3() {
    var e7;
    ignored();
    var r8 = [];
    while (e7 = fragmentDefinition() || operationDefinition()) {
      r8.push(e7);
    }
    return {
      kind: "Document",
      definitions: r8
    };
  }();
}
function printString2(e6) {
  return JSON.stringify(e6);
}
function printBlockString2(e6) {
  return '"""\n' + e6.replace(/"""/g, '\\"""') + '\n"""';
}
var hasItems = (e6) => !(!e6 || !e6.length);
var y2 = {
  OperationDefinition(e6) {
    if ("query" === e6.operation && !e6.name && !hasItems(e6.variableDefinitions) && !hasItems(e6.directives)) {
      return y2.SelectionSet(e6.selectionSet);
    }
    var r7 = e6.operation;
    if (e6.name) {
      r7 += " " + e6.name.value;
    }
    if (hasItems(e6.variableDefinitions)) {
      if (!e6.name) {
        r7 += " ";
      }
      r7 += "(" + e6.variableDefinitions.map(y2.VariableDefinition).join(", ") + ")";
    }
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7 + " " + y2.SelectionSet(e6.selectionSet);
  },
  VariableDefinition(e6) {
    var r7 = y2.Variable(e6.variable) + ": " + print2(e6.type);
    if (e6.defaultValue) {
      r7 += " = " + print2(e6.defaultValue);
    }
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7;
  },
  Field(e6) {
    var r7 = (e6.alias ? e6.alias.value + ": " : "") + e6.name.value;
    if (hasItems(e6.arguments)) {
      var i6 = e6.arguments.map(y2.Argument);
      var n6 = r7 + "(" + i6.join(", ") + ")";
      r7 = n6.length > 80 ? r7 + "(\n  " + i6.join("\n").replace(/\n/g, "\n  ") + "\n)" : n6;
    }
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return e6.selectionSet ? r7 + " " + y2.SelectionSet(e6.selectionSet) : r7;
  },
  StringValue: (e6) => e6.block ? printBlockString2(e6.value) : printString2(e6.value),
  BooleanValue: (e6) => "" + e6.value,
  NullValue: (e6) => "null",
  IntValue: (e6) => e6.value,
  FloatValue: (e6) => e6.value,
  EnumValue: (e6) => e6.value,
  Name: (e6) => e6.value,
  Variable: (e6) => "$" + e6.name.value,
  ListValue: (e6) => "[" + e6.values.map(print2).join(", ") + "]",
  ObjectValue: (e6) => "{" + e6.fields.map(y2.ObjectField).join(", ") + "}",
  ObjectField: (e6) => e6.name.value + ": " + print2(e6.value),
  Document: (e6) => hasItems(e6.definitions) ? e6.definitions.map(print2).join("\n\n") : "",
  SelectionSet: (e6) => "{\n  " + e6.selections.map(print2).join("\n").replace(/\n/g, "\n  ") + "\n}",
  Argument: (e6) => e6.name.value + ": " + print2(e6.value),
  FragmentSpread(e6) {
    var r7 = "..." + e6.name.value;
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7;
  },
  InlineFragment(e6) {
    var r7 = "...";
    if (e6.typeCondition) {
      r7 += " on " + e6.typeCondition.name.value;
    }
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7 + " " + print2(e6.selectionSet);
  },
  FragmentDefinition(e6) {
    var r7 = "fragment " + e6.name.value;
    r7 += " on " + e6.typeCondition.name.value;
    if (hasItems(e6.directives)) {
      r7 += " " + e6.directives.map(y2.Directive).join(" ");
    }
    return r7 + " " + print2(e6.selectionSet);
  },
  Directive(e6) {
    var r7 = "@" + e6.name.value;
    if (hasItems(e6.arguments)) {
      r7 += "(" + e6.arguments.map(y2.Argument).join(", ") + ")";
    }
    return r7;
  },
  NamedType: (e6) => e6.name.value,
  ListType: (e6) => "[" + print2(e6.type) + "]",
  NonNullType: (e6) => print2(e6.type) + "!"
};
function print2(e6) {
  return y2[e6.kind] ? y2[e6.kind](e6) : "";
}
function valueFromASTUntyped2(e6, r7) {
  switch (e6.kind) {
    case "NullValue":
      return null;
    case "IntValue":
      return parseInt(e6.value, 10);
    case "FloatValue":
      return parseFloat(e6.value);
    case "StringValue":
    case "EnumValue":
    case "BooleanValue":
      return e6.value;
    case "ListValue":
      var i6 = [];
      for (var n6 = 0, a3 = e6.values; n6 < a3.length; n6 += 1) {
        i6.push(valueFromASTUntyped2(a3[n6], r7));
      }
      return i6;
    case "ObjectValue":
      var t5 = /* @__PURE__ */ Object.create(null);
      for (var o5 = 0, l6 = e6.fields; o5 < l6.length; o5 += 1) {
        var u4 = l6[o5];
        t5[u4.name.value] = valueFromASTUntyped2(u4.value, r7);
      }
      return t5;
    case "Variable":
      return r7 && r7[e6.name.value];
  }
}

// node_modules/.pnpm/wonka@6.3.4/node_modules/wonka/dist/wonka.mjs
var teardownPlaceholder = () => {
};
var e3 = teardownPlaceholder;
function start(e6) {
  return {
    tag: 0,
    0: e6
  };
}
function push(e6) {
  return {
    tag: 1,
    0: e6
  };
}
var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";
var identity2 = (e6) => e6;
function filter2(r7) {
  return (t5) => (i6) => {
    var a3 = e3;
    t5((e6) => {
      if (0 === e6) {
        i6(0);
      } else if (0 === e6.tag) {
        a3 = e6[0];
        i6(e6);
      } else if (!r7(e6[0])) {
        a3(0);
      } else {
        i6(e6);
      }
    });
  };
}
function map(e6) {
  return (r7) => (t5) => r7((r8) => {
    if (0 === r8 || 0 === r8.tag) {
      t5(r8);
    } else {
      t5(push(e6(r8[0])));
    }
  });
}
function mergeMap(r7) {
  return (t5) => (i6) => {
    var a3 = [];
    var f5 = e3;
    var n6 = false;
    var s4 = false;
    t5((t6) => {
      if (s4) {
      } else if (0 === t6) {
        s4 = true;
        if (!a3.length) {
          i6(0);
        }
      } else if (0 === t6.tag) {
        f5 = t6[0];
      } else {
        n6 = false;
        !function applyInnerSource(r8) {
          var t7 = e3;
          r8((e6) => {
            if (0 === e6) {
              if (a3.length) {
                var r9 = a3.indexOf(t7);
                if (r9 > -1) {
                  (a3 = a3.slice()).splice(r9, 1);
                }
                if (!a3.length) {
                  if (s4) {
                    i6(0);
                  } else if (!n6) {
                    n6 = true;
                    f5(0);
                  }
                }
              }
            } else if (0 === e6.tag) {
              a3.push(t7 = e6[0]);
              t7(0);
            } else if (a3.length) {
              i6(e6);
              t7(0);
            }
          });
        }(r7(t6[0]));
        if (!n6) {
          n6 = true;
          f5(0);
        }
      }
    });
    i6(start((e6) => {
      if (1 === e6) {
        if (!s4) {
          s4 = true;
          f5(1);
        }
        for (var r8 = 0, t6 = a3, i7 = a3.length; r8 < i7; r8++) {
          t6[r8](1);
        }
        a3.length = 0;
      } else {
        if (!s4 && !n6) {
          n6 = true;
          f5(0);
        } else {
          n6 = false;
        }
        for (var l6 = 0, u4 = a3, o5 = a3.length; l6 < o5; l6++) {
          u4[l6](0);
        }
      }
    }));
  };
}
function mergeAll(e6) {
  return mergeMap(identity2)(e6);
}
function merge3(e6) {
  return mergeAll(r4(e6));
}
function onEnd(e6) {
  return (r7) => (t5) => {
    var i6 = false;
    r7((r8) => {
      if (i6) {
      } else if (0 === r8) {
        i6 = true;
        t5(0);
        e6();
      } else if (0 === r8.tag) {
        var a3 = r8[0];
        t5(start((r9) => {
          if (1 === r9) {
            i6 = true;
            a3(1);
            e6();
          } else {
            a3(r9);
          }
        }));
      } else {
        t5(r8);
      }
    });
  };
}
function onPush(e6) {
  return (r7) => (t5) => {
    var i6 = false;
    r7((r8) => {
      if (i6) {
      } else if (0 === r8) {
        i6 = true;
        t5(0);
      } else if (0 === r8.tag) {
        var a3 = r8[0];
        t5(start((e7) => {
          if (1 === e7) {
            i6 = true;
          }
          a3(e7);
        }));
      } else {
        e6(r8[0]);
        t5(r8);
      }
    });
  };
}
function onStart(e6) {
  return (r7) => (t5) => r7((r8) => {
    if (0 === r8) {
      t5(0);
    } else if (0 === r8.tag) {
      t5(r8);
      e6();
    } else {
      t5(r8);
    }
  });
}
function share(r7) {
  var t5 = [];
  var i6 = e3;
  var a3 = false;
  return (e6) => {
    t5.push(e6);
    if (1 === t5.length) {
      r7((e7) => {
        if (0 === e7) {
          for (var r8 = 0, f5 = t5, n6 = t5.length; r8 < n6; r8++) {
            f5[r8](0);
          }
          t5.length = 0;
        } else if (0 === e7.tag) {
          i6 = e7[0];
        } else {
          a3 = false;
          for (var s4 = 0, l6 = t5, u4 = t5.length; s4 < u4; s4++) {
            l6[s4](e7);
          }
        }
      });
    }
    e6(start((r8) => {
      if (1 === r8) {
        var f5 = t5.indexOf(e6);
        if (f5 > -1) {
          (t5 = t5.slice()).splice(f5, 1);
        }
        if (!t5.length) {
          i6(1);
        }
      } else if (!a3) {
        a3 = true;
        i6(0);
      }
    }));
  };
}
function switchMap(r7) {
  return (t5) => (i6) => {
    var a3 = e3;
    var f5 = e3;
    var n6 = false;
    var s4 = false;
    var l6 = false;
    var u4 = false;
    t5((t6) => {
      if (u4) {
      } else if (0 === t6) {
        u4 = true;
        if (!l6) {
          i6(0);
        }
      } else if (0 === t6.tag) {
        a3 = t6[0];
      } else {
        if (l6) {
          f5(1);
          f5 = e3;
        }
        if (!n6) {
          n6 = true;
          a3(0);
        } else {
          n6 = false;
        }
        !function applyInnerSource(e6) {
          l6 = true;
          e6((e7) => {
            if (!l6) {
            } else if (0 === e7) {
              l6 = false;
              if (u4) {
                i6(0);
              } else if (!n6) {
                n6 = true;
                a3(0);
              }
            } else if (0 === e7.tag) {
              s4 = false;
              (f5 = e7[0])(0);
            } else {
              i6(e7);
              if (!s4) {
                f5(0);
              } else {
                s4 = false;
              }
            }
          });
        }(r7(t6[0]));
      }
    });
    i6(start((e6) => {
      if (1 === e6) {
        if (!u4) {
          u4 = true;
          a3(1);
        }
        if (l6) {
          l6 = false;
          f5(1);
        }
      } else {
        if (!u4 && !n6) {
          n6 = true;
          a3(0);
        }
        if (l6 && !s4) {
          s4 = true;
          f5(0);
        }
      }
    }));
  };
}
function take(r7) {
  return (t5) => (i6) => {
    var a3 = e3;
    var f5 = false;
    var n6 = 0;
    t5((e6) => {
      if (f5) {
      } else if (0 === e6) {
        f5 = true;
        i6(0);
      } else if (0 === e6.tag) {
        if (r7 <= 0) {
          f5 = true;
          i6(0);
          e6[0](1);
        } else {
          a3 = e6[0];
        }
      } else if (n6++ < r7) {
        i6(e6);
        if (!f5 && n6 >= r7) {
          f5 = true;
          i6(0);
          a3(1);
        }
      } else {
        i6(e6);
      }
    });
    i6(start((e6) => {
      if (1 === e6 && !f5) {
        f5 = true;
        a3(1);
      } else if (0 === e6 && !f5 && n6 < r7) {
        a3(0);
      }
    }));
  };
}
function takeUntil(r7) {
  return (t5) => (i6) => {
    var a3 = e3;
    var f5 = e3;
    var n6 = false;
    t5((e6) => {
      if (n6) {
      } else if (0 === e6) {
        n6 = true;
        f5(1);
        i6(0);
      } else if (0 === e6.tag) {
        a3 = e6[0];
        r7((e7) => {
          if (0 === e7) {
          } else if (0 === e7.tag) {
            (f5 = e7[0])(0);
          } else {
            n6 = true;
            f5(1);
            a3(1);
            i6(0);
          }
        });
      } else {
        i6(e6);
      }
    });
    i6(start((e6) => {
      if (1 === e6 && !n6) {
        n6 = true;
        a3(1);
        f5(1);
      } else if (!n6) {
        a3(0);
      }
    }));
  };
}
function takeWhile(r7, t5) {
  return (i6) => (a3) => {
    var f5 = e3;
    var n6 = false;
    i6((e6) => {
      if (n6) {
      } else if (0 === e6) {
        n6 = true;
        a3(0);
      } else if (0 === e6.tag) {
        f5 = e6[0];
        a3(e6);
      } else if (!r7(e6[0])) {
        n6 = true;
        if (t5) {
          a3(e6);
        }
        a3(0);
        f5(1);
      } else {
        a3(e6);
      }
    });
  };
}
function lazy(e6) {
  return (r7) => e6()(r7);
}
function fromAsyncIterable(e6) {
  return (r7) => {
    var t5 = e6[asyncIteratorSymbol()] && e6[asyncIteratorSymbol()]() || e6;
    var i6 = false;
    var a3 = false;
    var f5 = false;
    var n6;
    r7(start(async (e7) => {
      if (1 === e7) {
        i6 = true;
        if (t5.return) {
          t5.return();
        }
      } else if (a3) {
        f5 = true;
      } else {
        for (f5 = a3 = true; f5 && !i6; ) {
          if ((n6 = await t5.next()).done) {
            i6 = true;
            if (t5.return) {
              await t5.return();
            }
            r7(0);
          } else {
            try {
              f5 = false;
              r7(push(n6.value));
            } catch (e8) {
              if (t5.throw) {
                if (i6 = !!(await t5.throw(e8)).done) {
                  r7(0);
                }
              } else {
                throw e8;
              }
            }
          }
        }
        a3 = false;
      }
    }));
  };
}
function fromIterable(e6) {
  if (e6[Symbol.asyncIterator]) {
    return fromAsyncIterable(e6);
  }
  return (r7) => {
    var t5 = e6[Symbol.iterator]();
    var i6 = false;
    var a3 = false;
    var f5 = false;
    var n6;
    r7(start((e7) => {
      if (1 === e7) {
        i6 = true;
        if (t5.return) {
          t5.return();
        }
      } else if (a3) {
        f5 = true;
      } else {
        for (f5 = a3 = true; f5 && !i6; ) {
          if ((n6 = t5.next()).done) {
            i6 = true;
            if (t5.return) {
              t5.return();
            }
            r7(0);
          } else {
            try {
              f5 = false;
              r7(push(n6.value));
            } catch (e8) {
              if (t5.throw) {
                if (i6 = !!t5.throw(e8).done) {
                  r7(0);
                }
              } else {
                throw e8;
              }
            }
          }
        }
        a3 = false;
      }
    }));
  };
}
var r4 = fromIterable;
function fromValue(e6) {
  return (r7) => {
    var t5 = false;
    r7(start((i6) => {
      if (1 === i6) {
        t5 = true;
      } else if (!t5) {
        t5 = true;
        r7(push(e6));
        r7(0);
      }
    }));
  };
}
function make(e6) {
  return (r7) => {
    var t5 = false;
    var i6 = e6({
      next(e7) {
        if (!t5) {
          r7(push(e7));
        }
      },
      complete() {
        if (!t5) {
          t5 = true;
          r7(0);
        }
      }
    });
    r7(start((e7) => {
      if (1 === e7 && !t5) {
        t5 = true;
        i6();
      }
    }));
  };
}
function makeSubject() {
  var e6;
  var r7;
  return {
    source: share(make((t5) => {
      e6 = t5.next;
      r7 = t5.complete;
      return teardownPlaceholder;
    })),
    next(r8) {
      if (e6) {
        e6(r8);
      }
    },
    complete() {
      if (r7) {
        r7();
      }
    }
  };
}
var empty = (e6) => {
  var r7 = false;
  e6(start((t5) => {
    if (1 === t5) {
      r7 = true;
    } else if (!r7) {
      r7 = true;
      e6(0);
    }
  }));
};
function fromPromise(e6) {
  return make((r7) => {
    e6.then((e7) => {
      Promise.resolve(e7).then(() => {
        r7.next(e7);
        r7.complete();
      });
    });
    return teardownPlaceholder;
  });
}
function subscribe2(r7) {
  return (t5) => {
    var i6 = e3;
    var a3 = false;
    t5((e6) => {
      if (0 === e6) {
        a3 = true;
      } else if (0 === e6.tag) {
        (i6 = e6[0])(0);
      } else if (!a3) {
        r7(e6[0]);
        i6(0);
      }
    });
    return {
      unsubscribe() {
        if (!a3) {
          a3 = true;
          i6(1);
        }
      }
    };
  };
}
function publish(e6) {
  subscribe2((e7) => {
  })(e6);
}
function toPromise(r7) {
  return new Promise((t5) => {
    var i6 = e3;
    var a3;
    r7((e6) => {
      if (0 === e6) {
        Promise.resolve(a3).then(t5);
      } else if (0 === e6.tag) {
        (i6 = e6[0])(0);
      } else {
        a3 = e6[0];
        i6(0);
      }
    });
  });
}

// node_modules/.pnpm/@urql+core@4.2.0_graphql@16.8.1/node_modules/@urql/core/dist/urql-core-chunk.mjs
var rehydrateGraphQlError = (e6) => {
  if (e6 && e6.message && (e6.extensions || "GraphQLError" === e6.name)) {
    return e6;
  } else if ("object" == typeof e6 && e6.message) {
    return new GraphQLError2(e6.message, e6.nodes, e6.source, e6.positions, e6.path, e6, e6.extensions || {});
  } else {
    return new GraphQLError2(e6);
  }
};
var CombinedError = class extends Error {
  constructor(r7) {
    var e6 = (r7.graphQLErrors || []).map(rehydrateGraphQlError);
    var t5 = ((r8, e7) => {
      var t6 = "";
      if (r8) {
        return `[Network] ${r8.message}`;
      }
      if (e7) {
        for (var a3 of e7) {
          if (t6) {
            t6 += "\n";
          }
          t6 += `[GraphQL] ${a3.message}`;
        }
      }
      return t6;
    })(r7.networkError, e6);
    super(t5);
    this.name = "CombinedError";
    this.message = t5;
    this.graphQLErrors = e6;
    this.networkError = r7.networkError;
    this.response = r7.response;
  }
  toString() {
    return this.message;
  }
};
var phash = (r7, e6) => {
  var t5 = 0 | (e6 || 5381);
  for (var a3 = 0, n6 = 0 | r7.length; a3 < n6; a3++) {
    t5 = (t5 << 5) + t5 + r7.charCodeAt(a3);
  }
  return t5;
};
var i4 = /* @__PURE__ */ new Set();
var f3 = /* @__PURE__ */ new WeakMap();
var stringify2 = (r7) => {
  if (null === r7 || i4.has(r7)) {
    return "null";
  } else if ("object" != typeof r7) {
    return JSON.stringify(r7) || "";
  } else if (r7.toJSON) {
    return stringify2(r7.toJSON());
  } else if (Array.isArray(r7)) {
    var e6 = "[";
    for (var t5 of r7) {
      if (e6.length > 1) {
        e6 += ",";
      }
      e6 += stringify2(t5) || "null";
    }
    return e6 += "]";
  } else if (v3 !== NoopConstructor && r7 instanceof v3 || l3 !== NoopConstructor && r7 instanceof l3) {
    return "null";
  }
  var a3 = Object.keys(r7).sort();
  if (!a3.length && r7.constructor && r7.constructor !== Object) {
    var n6 = f3.get(r7) || Math.random().toString(36).slice(2);
    f3.set(r7, n6);
    return stringify2({
      __key: n6
    });
  }
  i4.add(r7);
  var o5 = "{";
  for (var s4 of a3) {
    var c5 = stringify2(r7[s4]);
    if (c5) {
      if (o5.length > 1) {
        o5 += ",";
      }
      o5 += stringify2(s4) + ":" + c5;
    }
  }
  i4.delete(r7);
  return o5 += "}";
};
var extract = (r7, e6, t5) => {
  if (null == t5 || "object" != typeof t5 || t5.toJSON || i4.has(t5)) {
  } else if (Array.isArray(t5)) {
    for (var a3 = 0, n6 = t5.length; a3 < n6; a3++) {
      extract(r7, `${e6}.${a3}`, t5[a3]);
    }
  } else if (t5 instanceof v3 || t5 instanceof l3) {
    r7.set(e6, t5);
  } else {
    i4.add(t5);
    for (var o5 of Object.keys(t5)) {
      extract(r7, `${e6}.${o5}`, t5[o5]);
    }
  }
};
var stringifyVariables = (r7) => {
  i4.clear();
  return stringify2(r7);
};
var NoopConstructor = class {
};
var v3 = "undefined" != typeof File ? File : NoopConstructor;
var l3 = "undefined" != typeof Blob ? Blob : NoopConstructor;
var c3 = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var d3 = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g;
var replaceOutsideStrings = (r7, e6) => e6 % 2 == 0 ? r7.replace(d3, "\n") : r7;
var sanitizeDocument = (r7) => r7.split(c3).map(replaceOutsideStrings).join("").trim();
var p3 = /* @__PURE__ */ new Map();
var u3 = /* @__PURE__ */ new Map();
var stringifyDocument = (r7) => {
  var t5;
  if ("string" == typeof r7) {
    t5 = sanitizeDocument(r7);
  } else if (r7.loc && u3.get(r7.__key) === r7) {
    t5 = r7.loc.source.body;
  } else {
    t5 = p3.get(r7) || sanitizeDocument(print2(r7));
    p3.set(r7, t5);
  }
  if ("string" != typeof r7 && !r7.loc) {
    r7.loc = {
      start: 0,
      end: t5.length,
      source: {
        body: t5,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return t5;
};
var hashDocument = (r7) => {
  var e6 = phash(stringifyDocument(r7));
  if (r7.definitions) {
    var t5 = getOperationName(r7);
    if (t5) {
      e6 = phash(`
# ${t5}`, e6);
    }
  }
  return e6;
};
var keyDocument = (r7) => {
  var e6;
  var a3;
  if ("string" == typeof r7) {
    e6 = hashDocument(r7);
    a3 = u3.get(e6) || parse5(r7, {
      noLocation: true
    });
  } else {
    e6 = r7.__key || hashDocument(r7);
    a3 = u3.get(e6) || r7;
  }
  if (!a3.loc) {
    stringifyDocument(a3);
  }
  a3.__key = e6;
  u3.set(e6, a3);
  return a3;
};
var createRequest = (r7, e6, t5) => {
  var a3 = e6 || {};
  var n6 = keyDocument(r7);
  var o5 = stringifyVariables(a3);
  var s4 = n6.__key;
  if ("{}" !== o5) {
    s4 = phash(o5, s4);
  }
  return {
    key: s4,
    query: n6,
    variables: a3,
    extensions: t5
  };
};
var getOperationName = (r7) => {
  for (var e6 of r7.definitions) {
    if (e6.kind === e2.OPERATION_DEFINITION) {
      return e6.name ? e6.name.value : void 0;
    }
  }
};
var getOperationType = (r7) => {
  for (var e6 of r7.definitions) {
    if (e6.kind === e2.OPERATION_DEFINITION) {
      return e6.operation;
    }
  }
};
var makeResult = (r7, e6, t5) => {
  if (!("data" in e6 || "errors" in e6 && Array.isArray(e6.errors))) {
    throw new Error("No Content");
  }
  var a3 = "subscription" === r7.kind;
  return {
    operation: r7,
    data: e6.data,
    error: Array.isArray(e6.errors) ? new CombinedError({
      graphQLErrors: e6.errors,
      response: t5
    }) : void 0,
    extensions: e6.extensions ? {
      ...e6.extensions
    } : void 0,
    hasNext: null == e6.hasNext ? a3 : e6.hasNext,
    stale: false
  };
};
var deepMerge = (r7, e6) => {
  if ("object" == typeof r7 && null != r7) {
    if (!r7.constructor || r7.constructor === Object || Array.isArray(r7)) {
      r7 = Array.isArray(r7) ? [...r7] : {
        ...r7
      };
      for (var t5 of Object.keys(e6)) {
        r7[t5] = deepMerge(r7[t5], e6[t5]);
      }
      return r7;
    }
  }
  return e6;
};
var mergeResultPatch = (r7, e6, t5, a3) => {
  var n6 = r7.error ? r7.error.graphQLErrors : [];
  var o5 = !!r7.extensions || !!e6.extensions;
  var s4 = {
    ...r7.extensions,
    ...e6.extensions
  };
  var i6 = e6.incremental;
  if ("path" in e6) {
    i6 = [e6];
  }
  var f5 = {
    data: r7.data
  };
  if (i6) {
    var _loop = function(r8) {
      if (Array.isArray(r8.errors)) {
        n6.push(...r8.errors);
      }
      if (r8.extensions) {
        Object.assign(s4, r8.extensions);
        o5 = true;
      }
      var e7 = "data";
      var t6 = f5;
      var i7 = [];
      if (r8.path) {
        i7 = r8.path;
      } else if (a3) {
        var v6 = a3.find((e8) => e8.id === r8.id);
        if (r8.subPath) {
          i7 = [...v6.path, ...r8.subPath];
        } else {
          i7 = v6.path;
        }
      }
      for (var l6 = 0, c5 = i7.length; l6 < c5; e7 = i7[l6++]) {
        t6 = t6[e7] = Array.isArray(t6[e7]) ? [...t6[e7]] : {
          ...t6[e7]
        };
      }
      if (r8.items) {
        var d5 = +e7 >= 0 ? e7 : 0;
        for (var p5 = 0, u4 = r8.items.length; p5 < u4; p5++) {
          t6[d5 + p5] = deepMerge(t6[d5 + p5], r8.items[p5]);
        }
      } else if (void 0 !== r8.data) {
        t6[e7] = deepMerge(t6[e7], r8.data);
      }
    };
    for (var v5 of i6) {
      _loop(v5);
    }
  } else {
    f5.data = e6.data || r7.data;
    n6 = e6.errors || n6;
  }
  return {
    operation: r7.operation,
    data: f5.data,
    error: n6.length ? new CombinedError({
      graphQLErrors: n6,
      response: t5
    }) : void 0,
    extensions: o5 ? s4 : void 0,
    hasNext: null != e6.hasNext ? e6.hasNext : r7.hasNext,
    stale: false
  };
};
var makeErrorResult = (r7, e6, t5) => ({
  operation: r7,
  data: void 0,
  error: new CombinedError({
    networkError: e6,
    response: t5
  }),
  extensions: void 0,
  hasNext: false,
  stale: false
});
function makeFetchBody(r7) {
  return {
    query: r7.extensions && r7.extensions.persistedQuery && !r7.extensions.persistedQuery.miss ? void 0 : stringifyDocument(r7.query),
    operationName: getOperationName(r7.query),
    variables: r7.variables || void 0,
    extensions: r7.extensions
  };
}
var makeFetchURL = (r7, e6) => {
  var t5 = "query" === r7.kind && r7.context.preferGetMethod;
  if (!t5 || !e6) {
    return r7.context.url;
  }
  var a3 = new URL(r7.context.url);
  for (var n6 in e6) {
    var o5 = e6[n6];
    if (o5) {
      a3.searchParams.set(n6, "object" == typeof o5 ? stringifyVariables(o5) : o5);
    }
  }
  var s4 = a3.toString();
  if (s4.length > 2047 && "force" !== t5) {
    r7.context.preferGetMethod = false;
    return r7.context.url;
  }
  return s4;
};
var serializeBody = (r7, e6) => {
  if (e6 && !("query" === r7.kind && !!r7.context.preferGetMethod)) {
    var t5 = stringifyVariables(e6);
    var a3 = ((r8) => {
      var e7 = /* @__PURE__ */ new Map();
      if (v3 !== NoopConstructor || l3 !== NoopConstructor) {
        i4.clear();
        extract(e7, "variables", r8);
      }
      return e7;
    })(e6.variables);
    if (a3.size) {
      var n6 = new FormData();
      n6.append("operations", t5);
      n6.append("map", stringifyVariables({
        ...[...a3.keys()].map((r8) => [r8])
      }));
      var o5 = 0;
      for (var s4 of a3.values()) {
        n6.append("" + o5++, s4);
      }
      return n6;
    }
    return t5;
  }
};
var makeFetchOptions = (r7, e6) => {
  var t5 = {
    accept: "subscription" === r7.kind ? "text/event-stream, multipart/mixed" : "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed"
  };
  var a3 = ("function" == typeof r7.context.fetchOptions ? r7.context.fetchOptions() : r7.context.fetchOptions) || {};
  if (a3.headers) {
    for (var n6 in a3.headers) {
      t5[n6.toLowerCase()] = a3.headers[n6];
    }
  }
  var o5 = serializeBody(r7, e6);
  if ("string" == typeof o5 && !t5["content-type"]) {
    t5["content-type"] = "application/json";
  }
  return {
    ...a3,
    method: o5 ? "POST" : "GET",
    body: o5,
    headers: t5
  };
};
var y3 = "undefined" != typeof TextDecoder ? new TextDecoder() : null;
var h2 = /boundary="?([^=";]+)"?/i;
var x2 = /data: ?([^\n]+)/;
var toString = (r7) => "Buffer" === r7.constructor.name ? r7.toString() : y3.decode(r7);
async function* streamBody(r7) {
  if (r7.body[Symbol.asyncIterator]) {
    for await (var e6 of r7.body) {
      yield toString(e6);
    }
  } else {
    var t5 = r7.body.getReader();
    var a3;
    try {
      while (!(a3 = await t5.read()).done) {
        yield toString(a3.value);
      }
    } finally {
      t5.cancel();
    }
  }
}
async function* split(r7, e6) {
  var t5 = "";
  var a3;
  for await (var n6 of r7) {
    t5 += n6;
    while ((a3 = t5.indexOf(e6)) > -1) {
      yield t5.slice(0, a3);
      t5 = t5.slice(a3 + e6.length);
    }
  }
}
async function* fetchOperation(r7, e6, t5) {
  var a3 = true;
  var n6 = null;
  var o5;
  try {
    yield await Promise.resolve();
    var s4 = (o5 = await (r7.context.fetch || fetch)(e6, t5)).headers.get("Content-Type") || "";
    var i6;
    if (/multipart\/mixed/i.test(s4)) {
      i6 = async function* parseMultipartMixed(r8, e7) {
        var t6 = r8.match(h2);
        var a4 = "--" + (t6 ? t6[1] : "-");
        var n7 = true;
        var o6;
        for await (var s5 of split(streamBody(e7), "\r\n" + a4)) {
          if (n7) {
            n7 = false;
            var i7 = s5.indexOf(a4);
            if (i7 > -1) {
              s5 = s5.slice(i7 + a4.length);
            } else {
              continue;
            }
          }
          try {
            yield o6 = JSON.parse(s5.slice(s5.indexOf("\r\n\r\n") + 4));
          } catch (r9) {
            if (!o6) {
              throw r9;
            }
          }
          if (o6 && false === o6.hasNext) {
            break;
          }
        }
        if (o6 && false !== o6.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(s4, o5);
    } else if (/text\/event-stream/i.test(s4)) {
      i6 = async function* parseEventStream(r8) {
        var e7;
        for await (var t6 of split(streamBody(r8), "\n\n")) {
          var a4 = t6.match(x2);
          if (a4) {
            var n7 = a4[1];
            try {
              yield e7 = JSON.parse(n7);
            } catch (r9) {
              if (!e7) {
                throw r9;
              }
            }
            if (e7 && false === e7.hasNext) {
              break;
            }
          }
        }
        if (e7 && false !== e7.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(o5);
    } else if (!/text\//i.test(s4)) {
      i6 = async function* parseJSON(r8) {
        yield JSON.parse(await r8.text());
      }(o5);
    } else {
      i6 = async function* parseMaybeJSON(r8) {
        var e7 = await r8.text();
        try {
          var t6 = JSON.parse(e7);
          if (true) {
            console.warn('Found response with content-type "text/plain" but it had a valid "application/json" response.');
          }
          yield t6;
        } catch (r9) {
          throw new Error(e7);
        }
      }(o5);
    }
    var f5;
    for await (var v5 of i6) {
      if (v5.pending && !n6) {
        f5 = v5.pending;
      } else if (v5.pending) {
        f5 = [...f5, ...v5.pending];
      }
      n6 = n6 ? mergeResultPatch(n6, v5, o5, f5) : makeResult(r7, v5, o5);
      a3 = false;
      yield n6;
      a3 = true;
    }
    if (!n6) {
      yield n6 = makeResult(r7, {}, o5);
    }
  } catch (e7) {
    if (!a3) {
      throw e7;
    }
    yield makeErrorResult(r7, o5 && (o5.status < 200 || o5.status >= 300) && o5.statusText ? new Error(o5.statusText) : e7, o5);
  }
}
function makeFetchSource(r7, e6, t5) {
  var a3;
  if ("undefined" != typeof AbortController) {
    t5.signal = (a3 = new AbortController()).signal;
  }
  return onEnd(() => {
    if (a3) {
      a3.abort();
    }
  })(filter2((r8) => !!r8)(fromAsyncIterable(fetchOperation(r7, e6, t5))));
}

// node_modules/.pnpm/@urql+core@4.2.0_graphql@16.8.1/node_modules/@urql/core/dist/urql-core.mjs
var formatNode2 = (r7) => {
  if ("definitions" in r7) {
    var t5 = [];
    for (var n6 of r7.definitions) {
      var a3 = formatNode2(n6);
      t5.push(a3);
    }
    return {
      ...r7,
      definitions: t5
    };
  }
  if ("directives" in r7 && r7.directives && r7.directives.length) {
    var o5 = [];
    var i6 = {};
    for (var s4 of r7.directives) {
      var c5 = s4.name.value;
      if ("_" !== c5[0]) {
        o5.push(s4);
      } else {
        c5 = c5.slice(1);
      }
      i6[c5] = s4;
    }
    r7 = {
      ...r7,
      directives: o5,
      _directives: i6
    };
  }
  if ("selectionSet" in r7) {
    var u4 = [];
    var p5 = r7.kind === e2.OPERATION_DEFINITION;
    if (r7.selectionSet) {
      for (var d5 of r7.selectionSet.selections || []) {
        p5 = p5 || d5.kind === e2.FIELD && "__typename" === d5.name.value && !d5.alias;
        var v5 = formatNode2(d5);
        u4.push(v5);
      }
      if (!p5) {
        u4.push({
          kind: e2.FIELD,
          name: {
            kind: e2.NAME,
            value: "__typename"
          },
          _generated: true
        });
      }
      return {
        ...r7,
        selectionSet: {
          ...r7.selectionSet,
          selections: u4
        }
      };
    }
  }
  return r7;
};
var I2 = /* @__PURE__ */ new Map();
var formatDocument = (e6) => {
  var t5 = keyDocument(e6);
  var n6 = I2.get(t5.__key);
  if (!n6) {
    I2.set(t5.__key, n6 = formatNode2(t5));
    Object.defineProperty(n6, "__key", {
      value: t5.__key,
      enumerable: false
    });
  }
  return n6;
};
var maskTypename = (e6, r7) => {
  if (!e6 || "object" != typeof e6) {
    return e6;
  } else if (Array.isArray(e6)) {
    return e6.map((e7) => maskTypename(e7));
  } else if (e6 && "object" == typeof e6 && (r7 || "__typename" in e6)) {
    var t5 = {};
    for (var n6 in e6) {
      if ("__typename" === n6) {
        Object.defineProperty(t5, "__typename", {
          enumerable: false,
          value: e6.__typename
        });
      } else {
        t5[n6] = maskTypename(e6[n6]);
      }
    }
    return t5;
  } else {
    return e6;
  }
};
function withPromise(e6) {
  var source$ = (r7) => e6(r7);
  source$.toPromise = () => toPromise(take(1)(filter2((e7) => !e7.stale && !e7.hasNext)(source$)));
  source$.then = (e7, r7) => source$.toPromise().then(e7, r7);
  source$.subscribe = (e7) => subscribe2(e7)(source$);
  return source$;
}
function makeOperation(e6, r7, t5) {
  return {
    ...r7,
    kind: e6,
    context: r7.context ? {
      ...r7.context,
      ...t5
    } : t5 || r7.context
  };
}
var noop2 = () => {
};
var fetchExchange = ({ forward: e6, dispatchDebug: r7 }) => (t5) => {
  var n6 = mergeMap((e7) => {
    var n7 = makeFetchBody(e7);
    var o6 = makeFetchURL(e7, n7);
    var i6 = makeFetchOptions(e7, n7);
    r7({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e7,
      data: {
        url: o6,
        fetchOptions: i6
      },
      source: "fetchExchange"
    });
    var s4 = takeUntil(filter2((r8) => "teardown" === r8.kind && r8.key === e7.key)(t5))(makeFetchSource(e7, o6, i6));
    if (true) {
      return onPush((t6) => {
        var n8 = !t6.data ? t6.error : void 0;
        r7({
          type: n8 ? "fetchError" : "fetchSuccess",
          message: `A ${n8 ? "failed" : "successful"} fetch response has been returned.`,
          operation: e7,
          data: {
            url: o6,
            fetchOptions: i6,
            value: n8 || t6
          },
          source: "fetchExchange"
        });
      })(s4);
    }
    return s4;
  })(filter2((e7) => "teardown" !== e7.kind && ("subscription" !== e7.kind || !!e7.context.fetchSubscriptions))(t5));
  var o5 = e6(filter2((e7) => "teardown" === e7.kind || "subscription" === e7.kind && !e7.context.fetchSubscriptions)(t5));
  return merge3([n6, o5]);
};
var composeExchanges = (e6) => ({ client: r7, forward: t5, dispatchDebug: n6 }) => e6.reduceRight((e7, t6) => {
  var a3 = false;
  return t6({
    client: r7,
    forward(r8) {
      if (true) {
        if (a3) {
          throw new Error("forward() must only be called once in each Exchange.");
        }
        a3 = true;
      }
      return share(e7(share(r8)));
    },
    dispatchDebug(e8) {
      n6({
        timestamp: Date.now(),
        source: t6.name,
        ...e8
      });
    }
  });
}, t5);
var fallbackExchange = ({ dispatchDebug: e6 }) => (r7) => {
  if (true) {
    r7 = onPush((r8) => {
      if ("teardown" !== r8.kind && true) {
        var t5 = `No exchange has handled operations of kind "${r8.kind}". Check whether you've added an exchange responsible for these operations.`;
        e6({
          type: "fallbackCatch",
          message: t5,
          operation: r8,
          source: "fallbackExchange"
        });
        console.warn(t5);
      }
    })(r7);
  }
  return filter2((e7) => false)(r7);
};
var C = function Client(e6) {
  if (!e6.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r7 = 0;
  var t5 = /* @__PURE__ */ new Map();
  var n6 = /* @__PURE__ */ new Map();
  var a3 = /* @__PURE__ */ new Set();
  var o5 = [];
  var i6 = {
    url: e6.url,
    fetchSubscriptions: e6.fetchSubscriptions,
    fetchOptions: e6.fetchOptions,
    fetch: e6.fetch,
    preferGetMethod: e6.preferGetMethod,
    requestPolicy: e6.requestPolicy || "cache-first"
  };
  var s4 = makeSubject();
  function nextOperation(e7) {
    if ("mutation" === e7.kind || "teardown" === e7.kind || !a3.has(e7.key)) {
      if ("teardown" === e7.kind) {
        a3.delete(e7.key);
      } else if ("mutation" !== e7.kind) {
        a3.add(e7.key);
      }
      s4.next(e7);
    }
  }
  var c5 = false;
  function dispatchOperation(e7) {
    if (e7) {
      nextOperation(e7);
    }
    if (!c5) {
      c5 = true;
      while (c5 && (e7 = o5.shift())) {
        nextOperation(e7);
      }
      c5 = false;
    }
  }
  var makeResultSource = (r8) => {
    var i7 = takeUntil(filter2((e7) => "teardown" === e7.kind && e7.key === r8.key)(s4.source))(filter2((e7) => e7.operation.kind === r8.kind && e7.operation.key === r8.key && (!e7.operation.context._instance || e7.operation.context._instance === r8.context._instance))(O2));
    if (e6.maskTypename) {
      i7 = map((e7) => ({
        ...e7,
        data: maskTypename(e7.data, true)
      }))(i7);
    }
    if ("query" !== r8.kind) {
      i7 = takeWhile((e7) => !!e7.hasNext, true)(i7);
    } else {
      i7 = switchMap((e7) => {
        var t6 = fromValue(e7);
        return e7.stale || e7.hasNext ? t6 : merge3([t6, map(() => {
          e7.stale = true;
          return e7;
        })(take(1)(filter2((e8) => e8.key === r8.key)(s4.source)))]);
      })(i7);
    }
    if ("mutation" !== r8.kind) {
      i7 = onEnd(() => {
        a3.delete(r8.key);
        t5.delete(r8.key);
        n6.delete(r8.key);
        c5 = false;
        for (var e7 = o5.length - 1; e7 >= 0; e7--) {
          if (o5[e7].key === r8.key) {
            o5.splice(e7, 1);
          }
        }
        nextOperation(makeOperation("teardown", r8, r8.context));
      })(onPush((e7) => {
        if (e7.stale) {
          for (var n7 of o5) {
            if (n7.key === e7.operation.key) {
              a3.delete(n7.key);
              break;
            }
          }
        } else if (!e7.hasNext) {
          a3.delete(r8.key);
        }
        t5.set(r8.key, e7);
      })(i7));
    } else {
      i7 = onStart(() => {
        nextOperation(r8);
      })(i7);
    }
    return share(i7);
  };
  var u4 = this instanceof Client ? this : Object.create(Client.prototype);
  var p5 = Object.assign(u4, {
    suspense: !!e6.suspense,
    operations$: s4.source,
    reexecuteOperation(e7) {
      if ("teardown" === e7.kind) {
        dispatchOperation(e7);
      } else if ("mutation" === e7.kind || n6.has(e7.key)) {
        var r8 = false;
        for (var t6 = 0; t6 < o5.length; t6++) {
          r8 = r8 || o5[t6].key === e7.key;
        }
        if (!r8) {
          a3.delete(e7.key);
        }
        o5.push(e7);
        Promise.resolve().then(dispatchOperation);
      }
    },
    createRequestOperation(e7, t6, n7) {
      if (!n7) {
        n7 = {};
      }
      var a4;
      if ("teardown" !== e7 && (a4 = getOperationType(t6.query)) !== e7) {
        throw new Error(`Expected operation of type "${e7}" but found "${a4}"`);
      }
      return makeOperation(e7, t6, {
        _instance: "mutation" === e7 ? r7 = r7 + 1 | 0 : void 0,
        ...i6,
        ...n7,
        requestPolicy: n7.requestPolicy || i6.requestPolicy,
        suspense: n7.suspense || false !== n7.suspense && p5.suspense
      });
    },
    executeRequestOperation(e7) {
      if ("mutation" === e7.kind) {
        return withPromise(makeResultSource(e7));
      }
      return withPromise(lazy(() => {
        var r8 = n6.get(e7.key);
        if (!r8) {
          n6.set(e7.key, r8 = makeResultSource(e7));
        }
        r8 = onStart(() => {
          dispatchOperation(e7);
        })(r8);
        var a4 = t5.get(e7.key);
        if ("query" === e7.kind && a4 && (a4.stale || a4.hasNext)) {
          return switchMap(fromValue)(merge3([r8, filter2((r9) => r9 === t5.get(e7.key))(fromValue(a4))]));
        } else {
          return r8;
        }
      }));
    },
    executeQuery(e7, r8) {
      var t6 = p5.createRequestOperation("query", e7, r8);
      return p5.executeRequestOperation(t6);
    },
    executeSubscription(e7, r8) {
      var t6 = p5.createRequestOperation("subscription", e7, r8);
      return p5.executeRequestOperation(t6);
    },
    executeMutation(e7, r8) {
      var t6 = p5.createRequestOperation("mutation", e7, r8);
      return p5.executeRequestOperation(t6);
    },
    readQuery(e7, r8, t6) {
      var n7 = null;
      subscribe2((e8) => {
        n7 = e8;
      })(p5.query(e7, r8, t6)).unsubscribe();
      return n7;
    },
    query: (e7, r8, t6) => p5.executeQuery(createRequest(e7, r8), t6),
    subscription: (e7, r8, t6) => p5.executeSubscription(createRequest(e7, r8), t6),
    mutation: (e7, r8, t6) => p5.executeMutation(createRequest(e7, r8), t6)
  });
  var d5 = noop2;
  if (true) {
    var { next: l6, source: x3 } = makeSubject();
    p5.subscribeToDebugTarget = (e7) => subscribe2(e7)(x3);
    d5 = l6;
  }
  var g3 = composeExchanges(e6.exchanges);
  var O2 = share(g3({
    client: p5,
    dispatchDebug: d5,
    forward: fallbackExchange({
      dispatchDebug: d5
    })
  })(s4.source));
  publish(O2);
  return p5;
};
var j2 = C;

// node_modules/.pnpm/urql@4.0.6_graphql@16.8.1_react@18.2.0/node_modules/urql/dist/urql.es.js
var r5 = __toESM(require_react());
var c4 = {};
var v4 = r5.createContext(c4);
var f4 = v4.Provider;
var l4 = v4.Consumer;
v4.displayName = "UrqlContext";
var useClient = () => {
  var e6 = r5.useContext(v4);
  if (e6 === c4 && true) {
    var t5 = "No client has been specified using urql's Provider. please create a client and add a Provider.";
    console.error(t5);
    throw new Error(t5);
  }
  return e6;
};
var d4 = {
  fetching: false,
  stale: false,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};
var areOperationsEqual = (e6, r7) => e6 === r7 || !(!e6 || !r7 || e6.key !== r7.key);
var computeNextState = (e6, r7) => {
  var t5 = {
    ...e6,
    ...r7,
    data: void 0 !== r7.data || r7.error ? r7.data : e6.data,
    fetching: !!r7.fetching,
    stale: !!r7.stale
  };
  return ((e7, r8) => {
    for (var t6 in e7) {
      if (!(t6 in r8)) {
        return true;
      }
    }
    for (var a3 in r8) {
      if ("operation" === a3 ? !areOperationsEqual(e7[a3], r8[a3]) : e7[a3] !== r8[a3]) {
        return true;
      }
    }
    return false;
  })(e6, t5) ? t5 : e6;
};
var hasDepsChanged = (e6, r7) => {
  for (var t5 = 0, a3 = r7.length; t5 < a3; t5++) {
    if (e6[t5] !== r7[t5]) {
      return true;
    }
  }
  return false;
};
var p4 = r5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function deferDispatch(e6, r7) {
  if (p4 && p4.ReactCurrentOwner && p4.ReactCurrentOwner.current) {
    Promise.resolve(r7).then(e6);
  } else {
    e6(r7);
  }
}
function useMutation(i6) {
  var s4 = r5.useRef(true);
  var o5 = useClient();
  var [c5, v5] = r5.useState(d4);
  var f5 = r5.useCallback((r7, c6) => {
    deferDispatch(v5, {
      ...d4,
      fetching: true
    });
    return toPromise(take(1)(filter2((e6) => !e6.hasNext)(onPush((e6) => {
      if (s4.current) {
        deferDispatch(v5, {
          fetching: false,
          stale: e6.stale,
          data: e6.data,
          error: e6.error,
          extensions: e6.extensions,
          operation: e6.operation
        });
      }
    })(o5.executeMutation(createRequest(i6, r7), c6 || {})))));
  }, [o5, i6, v5]);
  r5.useEffect(() => {
    s4.current = true;
    return () => {
      s4.current = false;
    };
  }, []);
  return [c5, f5];
}
function useRequest(t5, a3) {
  var n6 = r5.useRef(void 0);
  return r5.useMemo(() => {
    var r7 = createRequest(t5, a3);
    if (void 0 !== n6.current && n6.current.key === r7.key) {
      return n6.current;
    } else {
      n6.current = r7;
      return r7;
    }
  }, [t5, a3]);
}
var getCacheForClient = (e6) => {
  if (!e6._react) {
    var r7 = /* @__PURE__ */ new Set();
    var t5 = /* @__PURE__ */ new Map();
    if (e6.operations$) {
      subscribe2((e7) => {
        if ("teardown" === e7.kind && r7.has(e7.key)) {
          r7.delete(e7.key);
          t5.delete(e7.key);
        }
      })(e6.operations$);
    }
    e6._react = {
      get: (e7) => t5.get(e7),
      set(e7, a3) {
        r7.delete(e7);
        t5.set(e7, a3);
      },
      dispose(e7) {
        r7.add(e7);
      }
    };
  }
  return e6._react;
};
var isSuspense = (e6, r7) => r7 && void 0 !== r7.suspense ? !!r7.suspense : e6.suspense;
function useQuery(e6) {
  var t5 = useClient();
  var a3 = getCacheForClient(t5);
  var n6 = isSuspense(t5, e6.context);
  var c5 = useRequest(e6.query, e6.variables);
  var v5 = r5.useMemo(() => {
    if (e6.pause) {
      return null;
    }
    var r7 = t5.executeQuery(c5, {
      requestPolicy: e6.requestPolicy,
      ...e6.context
    });
    return n6 ? onPush((e7) => {
      a3.set(c5.key, e7);
    })(r7) : r7;
  }, [a3, t5, c5, n6, e6.pause, e6.requestPolicy, e6.context]);
  var f5 = r5.useCallback((e7, r7) => {
    if (!e7) {
      return {
        fetching: false
      };
    }
    var t6 = a3.get(c5.key);
    if (!t6) {
      var n7;
      var u4 = subscribe2((e8) => {
        t6 = e8;
        if (n7) {
          n7(t6);
        }
      })(takeWhile(() => r7 && !n7 || !t6)(e7));
      if (null == t6 && r7) {
        var o5 = new Promise((e8) => {
          n7 = e8;
        });
        a3.set(c5.key, o5);
        throw o5;
      } else {
        u4.unsubscribe();
      }
    } else if (r7 && null != t6 && "then" in t6) {
      throw t6;
    }
    return t6 || {
      fetching: true
    };
  }, [a3, c5]);
  var l6 = [t5, c5, e6.requestPolicy, e6.context, e6.pause];
  var [p5, h3] = r5.useState(() => [v5, computeNextState(d4, f5(v5, n6)), l6]);
  var y4 = p5[1];
  if (v5 !== p5[0] && hasDepsChanged(p5[2], l6)) {
    h3([v5, y4 = computeNextState(p5[1], f5(v5, n6)), l6]);
  }
  r5.useEffect(() => {
    var e7 = p5[0];
    var r7 = p5[2][1];
    var t6 = false;
    var updateResult = (e8) => {
      t6 = true;
      deferDispatch(h3, (r8) => {
        var t7 = computeNextState(r8[1], e8);
        return r8[1] !== t7 ? [r8[0], t7, r8[2]] : r8;
      });
    };
    if (e7) {
      var n7 = subscribe2(updateResult)(onEnd(() => {
        updateResult({
          fetching: false
        });
      })(e7));
      if (!t6) {
        updateResult({
          fetching: true
        });
      }
      return () => {
        a3.dispose(r7.key);
        n7.unsubscribe();
      };
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [a3, p5[0], p5[2][1]]);
  var x3 = r5.useCallback((r7) => {
    var i6 = {
      requestPolicy: e6.requestPolicy,
      ...e6.context,
      ...r7
    };
    deferDispatch(h3, (e7) => [n6 ? onPush((e8) => {
      a3.set(c5.key, e8);
    })(t5.executeQuery(c5, i6)) : t5.executeQuery(c5, i6), e7[1], l6]);
  }, [t5, a3, c5, n6, e6.requestPolicy, e6.context, e6.pause]);
  return [y4, x3];
}

// node_modules/.pnpm/lru-cache@7.18.3/node_modules/lru-cache/index.mjs
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var hasAbortController = typeof AbortController === "function";
var AC = hasAbortController ? AbortController : class AbortController2 {
  constructor() {
    this.signal = new AS();
  }
  abort(reason = new Error("This operation was aborted")) {
    this.signal.reason = this.signal.reason || reason;
    this.signal.aborted = true;
    this.signal.dispatchEvent({
      type: "abort",
      target: this.signal
    });
  }
};
var hasAbortSignal = typeof AbortSignal === "function";
var hasACAbortSignal = typeof AC.AbortSignal === "function";
var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal2 {
  constructor() {
    this.reason = void 0;
    this.aborted = false;
    this._listeners = [];
  }
  dispatchEvent(e6) {
    if (e6.type === "abort") {
      this.aborted = true;
      this.onabort(e6);
      this._listeners.forEach((f5) => f5(e6), this);
    }
  }
  onabort() {
  }
  addEventListener(ev, fn2) {
    if (ev === "abort") {
      this._listeners.push(fn2);
    }
  }
  removeEventListener(ev, fn2) {
    if (ev === "abort") {
      this._listeners = this._listeners.filter((f5) => f5 !== fn2);
    }
  }
};
var warned = /* @__PURE__ */ new Set();
var deprecatedOption = (opt, instead) => {
  const code2 = `LRU_CACHE_OPTION_${opt}`;
  if (shouldWarn(code2)) {
    warn(code2, `${opt} option`, `options.${instead}`, LRUCache);
  }
};
var deprecatedMethod = (method, instead) => {
  const code2 = `LRU_CACHE_METHOD_${method}`;
  if (shouldWarn(code2)) {
    const { prototype } = LRUCache;
    const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, method);
    warn(code2, `${method} method`, `cache.${instead}()`, get2);
  }
};
var deprecatedProperty = (field2, instead) => {
  const code2 = `LRU_CACHE_PROPERTY_${field2}`;
  if (shouldWarn(code2)) {
    const { prototype } = LRUCache;
    const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, field2);
    warn(code2, `${field2} property`, `cache.${instead}`, get2);
  }
};
var emitWarning = (...a3) => {
  typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a3) : console.error(...a3);
};
var shouldWarn = (code2) => !warned.has(code2);
var warn = (code2, what, instead, fn2) => {
  warned.add(code2);
  const msg2 = `The ${what} is deprecated. Please use ${instead} instead.`;
  emitWarning(msg2, "DeprecationWarning", code2, fn2);
};
var isPosInt = (n6) => n6 && n6 === Math.floor(n6) && n6 > 0 && isFinite(n6);
var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size3) {
    super(size3);
    this.fill(0);
  }
};
var Stack = class {
  constructor(max2) {
    if (max2 === 0) {
      return [];
    }
    const UintArray = getUintArray(max2);
    this.heap = new UintArray(max2);
    this.length = 0;
  }
  push(n6) {
    this.heap[this.length++] = n6;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  constructor(options = {}) {
    const {
      max: max2 = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      maxEntrySize = 0,
      sizeCalculation,
      fetchMethod,
      fetchContext,
      noDeleteOnFetchRejection,
      noDeleteOnStaleGet,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort
    } = options;
    const { length: length2, maxAge, stale } = options instanceof _LRUCache ? {} : options;
    if (max2 !== 0 && !isPosInt(max2)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max2 ? getUintArray(max2) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max2);
    }
    this.max = max2;
    this.maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.maxSize;
    this.sizeCalculation = sizeCalculation || length2;
    if (this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize) {
        throw new TypeError(
          "cannot set sizeCalculation without setting maxSize or maxEntrySize"
        );
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    this.fetchMethod = fetchMethod || null;
    if (this.fetchMethod && typeof this.fetchMethod !== "function") {
      throw new TypeError(
        "fetchMethod must be a function if specified"
      );
    }
    this.fetchContext = fetchContext;
    if (!this.fetchMethod && fetchContext !== void 0) {
      throw new TypeError(
        "cannot set fetchContext without fetchMethod"
      );
    }
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyList = new Array(max2).fill(null);
    this.valList = new Array(max2).fill(null);
    this.next = new UintArray(max2);
    this.prev = new UintArray(max2);
    this.head = 0;
    this.tail = 0;
    this.free = new Stack(max2);
    this.initialFill = 1;
    this.size = 0;
    if (typeof dispose === "function") {
      this.dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.disposeAfter = disposeAfter;
      this.disposed = [];
    } else {
      this.disposeAfter = null;
      this.disposed = null;
    }
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError(
            "maxSize must be a positive integer if specified"
          );
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError(
          "maxEntrySize must be a positive integer if specified"
        );
      }
      this.initializeSizeTracking();
    }
    this.allowStale = !!allowStale || !!stale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || maxAge || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          "ttl must be a positive integer if specified"
        );
      }
      this.initializeTTLTracking();
    }
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        "At least one of max, maxSize, or ttl is required"
      );
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code2 = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code2)) {
        warned.add(code2);
        const msg2 = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg2, "UnboundedCacheWarning", code2, _LRUCache);
      }
    }
    if (stale) {
      deprecatedOption("stale", "allowStale");
    }
    if (maxAge) {
      deprecatedOption("maxAge", "ttl");
    }
    if (length2) {
      deprecatedOption("length", "sizeCalculation");
    }
  }
  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
  }
  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max);
    this.starts = new ZeroArray(this.max);
    this.setItemTTL = (index2, ttl, start2 = perf.now()) => {
      this.starts[index2] = ttl !== 0 ? start2 : 0;
      this.ttls[index2] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t5 = setTimeout(() => {
          if (this.isStale(index2)) {
            this.delete(this.keyList[index2]);
          }
        }, ttl + 1);
        if (t5.unref) {
          t5.unref();
        }
      }
    };
    this.updateItemAge = (index2) => {
      this.starts[index2] = this.ttls[index2] !== 0 ? perf.now() : 0;
    };
    this.statusTTL = (status, index2) => {
      if (status) {
        status.ttl = this.ttls[index2];
        status.start = this.starts[index2];
        status.now = cachedNow || getNow();
        status.remainingTTL = status.now + status.ttl - status.start;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n6 = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n6;
        const t5 = setTimeout(
          () => cachedNow = 0,
          this.ttlResolution
        );
        if (t5.unref) {
          t5.unref();
        }
      }
      return n6;
    };
    this.getRemainingTTL = (key) => {
      const index2 = this.keyMap.get(key);
      if (index2 === void 0) {
        return 0;
      }
      return this.ttls[index2] === 0 || this.starts[index2] === 0 ? Infinity : this.starts[index2] + this.ttls[index2] - (cachedNow || getNow());
    };
    this.isStale = (index2) => {
      return this.ttls[index2] !== 0 && this.starts[index2] !== 0 && (cachedNow || getNow()) - this.starts[index2] > this.ttls[index2];
    };
  }
  updateItemAge(_index) {
  }
  statusTTL(_status, _index) {
  }
  setItemTTL(_index, _ttl, _start) {
  }
  isStale(_index) {
    return false;
  }
  initializeSizeTracking() {
    this.calculatedSize = 0;
    this.sizes = new ZeroArray(this.max);
    this.removeItemSize = (index2) => {
      this.calculatedSize -= this.sizes[index2];
      this.sizes[index2] = 0;
    };
    this.requireSize = (k2, v5, size3, sizeCalculation) => {
      if (this.isBackgroundFetch(v5)) {
        return 0;
      }
      if (!isPosInt(size3)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size3 = sizeCalculation(v5, k2);
          if (!isPosInt(size3)) {
            throw new TypeError(
              "sizeCalculation return invalid (expect positive integer)"
            );
          }
        } else {
          throw new TypeError(
            "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
          );
        }
      }
      return size3;
    };
    this.addItemSize = (index2, size3, status) => {
      this.sizes[index2] = size3;
      if (this.maxSize) {
        const maxSize = this.maxSize - this.sizes[index2];
        while (this.calculatedSize > maxSize) {
          this.evict(true);
        }
      }
      this.calculatedSize += this.sizes[index2];
      if (status) {
        status.entrySize = size3;
        status.totalCalculatedSize = this.calculatedSize;
      }
    };
  }
  removeItemSize(_index) {
  }
  addItemSize(_index, _size) {
  }
  requireSize(_k, _v, size3, sizeCalculation) {
    if (size3 || sizeCalculation) {
      throw new TypeError(
        "cannot set size without setting maxSize or maxEntrySize on cache"
      );
    }
  }
  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i6 = this.tail; true; ) {
        if (!this.isValidIndex(i6)) {
          break;
        }
        if (allowStale || !this.isStale(i6)) {
          yield i6;
        }
        if (i6 === this.head) {
          break;
        } else {
          i6 = this.prev[i6];
        }
      }
    }
  }
  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i6 = this.head; true; ) {
        if (!this.isValidIndex(i6)) {
          break;
        }
        if (allowStale || !this.isStale(i6)) {
          yield i6;
        }
        if (i6 === this.tail) {
          break;
        } else {
          i6 = this.next[i6];
        }
      }
    }
  }
  isValidIndex(index2) {
    return index2 !== void 0 && this.keyMap.get(this.keyList[index2]) === index2;
  }
  *entries() {
    for (const i6 of this.indexes()) {
      if (this.valList[i6] !== void 0 && this.keyList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield [this.keyList[i6], this.valList[i6]];
      }
    }
  }
  *rentries() {
    for (const i6 of this.rindexes()) {
      if (this.valList[i6] !== void 0 && this.keyList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield [this.keyList[i6], this.valList[i6]];
      }
    }
  }
  *keys() {
    for (const i6 of this.indexes()) {
      if (this.keyList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield this.keyList[i6];
      }
    }
  }
  *rkeys() {
    for (const i6 of this.rindexes()) {
      if (this.keyList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield this.keyList[i6];
      }
    }
  }
  *values() {
    for (const i6 of this.indexes()) {
      if (this.valList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield this.valList[i6];
      }
    }
  }
  *rvalues() {
    for (const i6 of this.rindexes()) {
      if (this.valList[i6] !== void 0 && !this.isBackgroundFetch(this.valList[i6])) {
        yield this.valList[i6];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(fn2, getOptions3) {
    for (const i6 of this.indexes()) {
      const v5 = this.valList[i6];
      const value2 = this.isBackgroundFetch(v5) ? v5.__staleWhileFetching : v5;
      if (value2 === void 0)
        continue;
      if (fn2(value2, this.keyList[i6], this)) {
        return this.get(this.keyList[i6], getOptions3);
      }
    }
  }
  forEach(fn2, thisp = this) {
    for (const i6 of this.indexes()) {
      const v5 = this.valList[i6];
      const value2 = this.isBackgroundFetch(v5) ? v5.__staleWhileFetching : v5;
      if (value2 === void 0)
        continue;
      fn2.call(thisp, value2, this.keyList[i6], this);
    }
  }
  rforEach(fn2, thisp = this) {
    for (const i6 of this.rindexes()) {
      const v5 = this.valList[i6];
      const value2 = this.isBackgroundFetch(v5) ? v5.__staleWhileFetching : v5;
      if (value2 === void 0)
        continue;
      fn2.call(thisp, value2, this.keyList[i6], this);
    }
  }
  get prune() {
    deprecatedMethod("prune", "purgeStale");
    return this.purgeStale;
  }
  purgeStale() {
    let deleted = false;
    for (const i6 of this.rindexes({ allowStale: true })) {
      if (this.isStale(i6)) {
        this.delete(this.keyList[i6]);
        deleted = true;
      }
    }
    return deleted;
  }
  dump() {
    const arr = [];
    for (const i6 of this.indexes({ allowStale: true })) {
      const key = this.keyList[i6];
      const v5 = this.valList[i6];
      const value2 = this.isBackgroundFetch(v5) ? v5.__staleWhileFetching : v5;
      if (value2 === void 0)
        continue;
      const entry = { value: value2 };
      if (this.ttls) {
        entry.ttl = this.ttls[i6];
        const age = perf.now() - this.starts[i6];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.sizes) {
        entry.size = this.sizes[i6];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  dispose(_v, _k, _reason) {
  }
  set(k2, v5, {
    ttl = this.ttl,
    start: start2,
    noDisposeOnSet = this.noDisposeOnSet,
    size: size3 = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
    status
  } = {}) {
    size3 = this.requireSize(k2, v5, size3, sizeCalculation);
    if (this.maxEntrySize && size3 > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k2);
      return this;
    }
    let index2 = this.size === 0 ? void 0 : this.keyMap.get(k2);
    if (index2 === void 0) {
      index2 = this.newIndex();
      this.keyList[index2] = k2;
      this.valList[index2] = v5;
      this.keyMap.set(k2, index2);
      this.next[this.tail] = index2;
      this.prev[index2] = this.tail;
      this.tail = index2;
      this.size++;
      this.addItemSize(index2, size3, status);
      if (status) {
        status.set = "add";
      }
      noUpdateTTL = false;
    } else {
      this.moveToTail(index2);
      const oldVal = this.valList[index2];
      if (v5 !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k2, "set");
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k2, "set"]);
            }
          }
        }
        this.removeItemSize(index2);
        this.valList[index2] = v5;
        this.addItemSize(index2, size3, status);
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking();
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index2, ttl, start2);
    }
    this.statusTTL(status, index2);
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
    return this;
  }
  newIndex() {
    if (this.size === 0) {
      return this.tail;
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false);
    }
    if (this.free.length !== 0) {
      return this.free.pop();
    }
    return this.initialFill++;
  }
  pop() {
    if (this.size) {
      const val = this.valList[this.head];
      this.evict(true);
      return val;
    }
  }
  evict(free) {
    const head = this.head;
    const k2 = this.keyList[head];
    const v5 = this.valList[head];
    if (this.isBackgroundFetch(v5)) {
      v5.__abortController.abort(new Error("evicted"));
    } else {
      this.dispose(v5, k2, "evict");
      if (this.disposeAfter) {
        this.disposed.push([v5, k2, "evict"]);
      }
    }
    this.removeItemSize(head);
    if (free) {
      this.keyList[head] = null;
      this.valList[head] = null;
      this.free.push(head);
    }
    this.head = this.next[head];
    this.keyMap.delete(k2);
    this.size--;
    return head;
  }
  has(k2, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
    const index2 = this.keyMap.get(k2);
    if (index2 !== void 0) {
      if (!this.isStale(index2)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index2);
        }
        if (status)
          status.has = "hit";
        this.statusTTL(status, index2);
        return true;
      } else if (status) {
        status.has = "stale";
        this.statusTTL(status, index2);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  // like get(), but without any LRU updating or TTL expiration
  peek(k2, { allowStale = this.allowStale } = {}) {
    const index2 = this.keyMap.get(k2);
    if (index2 !== void 0 && (allowStale || !this.isStale(index2))) {
      const v5 = this.valList[index2];
      return this.isBackgroundFetch(v5) ? v5.__staleWhileFetching : v5;
    }
  }
  backgroundFetch(k2, index2, options, context) {
    const v5 = index2 === void 0 ? void 0 : this.valList[index2];
    if (this.isBackgroundFetch(v5)) {
      return v5;
    }
    const ac = new AC();
    if (options.signal) {
      options.signal.addEventListener(
        "abort",
        () => ac.abort(options.signal.reason)
      );
    }
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v6, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v6 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      if (this.valList[index2] === p5) {
        if (v6 === void 0) {
          if (p5.__staleWhileFetching) {
            this.valList[index2] = p5.__staleWhileFetching;
          } else {
            this.delete(k2);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k2, v6, fetchOpts.options);
        }
      }
      return v6;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      if (this.valList[index2] === p5) {
        const del = !noDelete || p5.__staleWhileFetching === void 0;
        if (del) {
          this.delete(k2);
        } else if (!allowStaleAborted) {
          this.valList[index2] = p5.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && p5.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return p5.__staleWhileFetching;
      } else if (p5.__returned === p5) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      this.fetchMethod(k2, v5, fetchOpts).then((v6) => res(v6), rej);
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res();
          if (options.allowStaleOnFetchAbort) {
            res = (v6) => cb(v6, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p5 = new Promise(pcall).then(cb, eb);
    p5.__abortController = ac;
    p5.__staleWhileFetching = v5;
    p5.__returned = null;
    if (index2 === void 0) {
      this.set(k2, p5, { ...fetchOpts.options, status: void 0 });
      index2 = this.keyMap.get(k2);
    } else {
      this.valList[index2] = p5;
    }
    return p5;
  }
  isBackgroundFetch(p5) {
    return p5 && typeof p5 === "object" && typeof p5.then === "function" && Object.prototype.hasOwnProperty.call(
      p5,
      "__staleWhileFetching"
    ) && Object.prototype.hasOwnProperty.call(p5, "__returned") && (p5.__returned === p5 || p5.__returned === null);
  }
  // this takes the union of get() and set() opts, because it does both
  async fetch(k2, {
    // get options
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    noDeleteOnStaleGet = this.noDeleteOnStaleGet,
    // set options
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size: size3 = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
    // fetch exclusive options
    noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
    allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
    ignoreFetchAbort = this.ignoreFetchAbort,
    allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
    fetchContext = this.fetchContext,
    forceRefresh = false,
    status,
    signal
  } = {}) {
    if (!this.fetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size: size3,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = this.keyMap.get(k2);
    if (index2 === void 0) {
      if (status)
        status.fetch = "miss";
      const p5 = this.backgroundFetch(k2, index2, options, fetchContext);
      return p5.__returned = p5;
    } else {
      const v5 = this.valList[index2];
      if (this.isBackgroundFetch(v5)) {
        const stale = allowStale && v5.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v5.__staleWhileFetching : v5.__returned = v5;
      }
      const isStale = this.isStale(index2);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.moveToTail(index2);
        if (updateAgeOnGet) {
          this.updateItemAge(index2);
        }
        this.statusTTL(status, index2);
        return v5;
      }
      const p5 = this.backgroundFetch(k2, index2, options, fetchContext);
      const hasStale = p5.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = hasStale && isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p5.__staleWhileFetching : p5.__returned = p5;
    }
  }
  get(k2, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    noDeleteOnStaleGet = this.noDeleteOnStaleGet,
    status
  } = {}) {
    const index2 = this.keyMap.get(k2);
    if (index2 !== void 0) {
      const value2 = this.valList[index2];
      const fetching = this.isBackgroundFetch(value2);
      this.statusTTL(status, index2);
      if (this.isStale(index2)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k2);
          }
          if (status)
            status.returnedStale = allowStale;
          return allowStale ? value2 : void 0;
        } else {
          if (status) {
            status.returnedStale = allowStale && value2.__staleWhileFetching !== void 0;
          }
          return allowStale ? value2.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value2.__staleWhileFetching;
        }
        this.moveToTail(index2);
        if (updateAgeOnGet) {
          this.updateItemAge(index2);
        }
        return value2;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  connect(p5, n6) {
    this.prev[n6] = p5;
    this.next[p5] = n6;
  }
  moveToTail(index2) {
    if (index2 !== this.tail) {
      if (index2 === this.head) {
        this.head = this.next[index2];
      } else {
        this.connect(this.prev[index2], this.next[index2]);
      }
      this.connect(this.tail, index2);
      this.tail = index2;
    }
  }
  get del() {
    deprecatedMethod("del", "delete");
    return this.delete;
  }
  delete(k2) {
    let deleted = false;
    if (this.size !== 0) {
      const index2 = this.keyMap.get(k2);
      if (index2 !== void 0) {
        deleted = true;
        if (this.size === 1) {
          this.clear();
        } else {
          this.removeItemSize(index2);
          const v5 = this.valList[index2];
          if (this.isBackgroundFetch(v5)) {
            v5.__abortController.abort(new Error("deleted"));
          } else {
            this.dispose(v5, k2, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v5, k2, "delete"]);
            }
          }
          this.keyMap.delete(k2);
          this.keyList[index2] = null;
          this.valList[index2] = null;
          if (index2 === this.tail) {
            this.tail = this.prev[index2];
          } else if (index2 === this.head) {
            this.head = this.next[index2];
          } else {
            this.next[this.prev[index2]] = this.next[index2];
            this.prev[this.next[index2]] = this.prev[index2];
          }
          this.size--;
          this.free.push(index2);
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
    return deleted;
  }
  clear() {
    for (const index2 of this.rindexes({ allowStale: true })) {
      const v5 = this.valList[index2];
      if (this.isBackgroundFetch(v5)) {
        v5.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = this.keyList[index2];
        this.dispose(v5, k2, "delete");
        if (this.disposeAfter) {
          this.disposed.push([v5, k2, "delete"]);
        }
      }
    }
    this.keyMap.clear();
    this.valList.fill(null);
    this.keyList.fill(null);
    if (this.ttls) {
      this.ttls.fill(0);
      this.starts.fill(0);
    }
    if (this.sizes) {
      this.sizes.fill(0);
    }
    this.head = 0;
    this.tail = 0;
    this.initialFill = 1;
    this.free.length = 0;
    this.calculatedSize = 0;
    this.size = 0;
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
  }
  get reset() {
    deprecatedMethod("reset", "clear");
    return this.clear;
  }
  get length() {
    deprecatedProperty("length", "size");
    return this.size;
  }
  static get AbortController() {
    return AC;
  }
  static get AbortSignal() {
    return AS;
  }
};
var lru_cache_default = LRUCache;

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/link2Icon/dist/keystar-ui-icon-icons-link2Icon.esm.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime());
var link2Icon = (0, import_jsx_runtime64.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime64.jsx)("path", {
    d: "M9 17H7A5 5 0 0 1 7 7h2M15 7h2a5 5 0 1 1 0 10h-2M8 12h8"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/link2OffIcon/dist/keystar-ui-icon-icons-link2OffIcon.esm.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime());
var link2OffIcon = (0, import_jsx_runtime65.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime65.jsx)("path", {
    d: "M9 17H7A5 5 0 0 1 7 7M15 7h2a5 5 0 0 1 4 8M8 12h4M2 2l20 20"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/pencilIcon/dist/keystar-ui-icon-icons-pencilIcon.esm.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime());
var pencilIcon = (0, import_jsx_runtime66.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime66.jsx)("path", {
    d: "m18 2 4 4M7.5 20.5 19 9l-4-4L3.5 16.5 2 22z"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/undo2Icon/dist/keystar-ui-icon-icons-undo2Icon.esm.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime());
var undo2Icon = (0, import_jsx_runtime67.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime67.jsx)("path", {
    d: "M9 14 4 9l5-5"
  }), (0, import_jsx_runtime67.jsx)("path", {
    d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/sheetIcon/dist/keystar-ui-icon-icons-sheetIcon.esm.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime());
var sheetIcon = (0, import_jsx_runtime68.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime68.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime68.jsx)("path", {
    d: "M3 9h18M3 15h18M9 9v12M15 9v12"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/tableIcon/dist/keystar-ui-icon-icons-tableIcon.esm.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime());
var tableIcon = (0, import_jsx_runtime69.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime69.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime69.jsx)("path", {
    d: "M3 9h18M3 15h18M12 3v18"
  })]
});

// node_modules/.pnpm/compute-scroll-into-view@3.1.0/node_modules/compute-scroll-into-view/dist/index.js
var t4 = (t5) => "object" == typeof t5 && null != t5 && 1 === t5.nodeType;
var e4 = (t5, e6) => (!e6 || "hidden" !== t5) && ("visible" !== t5 && "clip" !== t5);
var n5 = (t5, n6) => {
  if (t5.clientHeight < t5.scrollHeight || t5.clientWidth < t5.scrollWidth) {
    const o5 = getComputedStyle(t5, null);
    return e4(o5.overflowY, n6) || e4(o5.overflowX, n6) || ((t6) => {
      const e6 = ((t7) => {
        if (!t7.ownerDocument || !t7.ownerDocument.defaultView)
          return null;
        try {
          return t7.ownerDocument.defaultView.frameElement;
        } catch (t8) {
          return null;
        }
      })(t6);
      return !!e6 && (e6.clientHeight < t6.scrollHeight || e6.clientWidth < t6.scrollWidth);
    })(t5);
  }
  return false;
};
var o3 = (t5, e6, n6, o5, l6, r7, i6, s4) => r7 < t5 && i6 > e6 || r7 > t5 && i6 < e6 ? 0 : r7 <= t5 && s4 <= n6 || i6 >= e6 && s4 >= n6 ? r7 - t5 - o5 : i6 > e6 && s4 < n6 || r7 < t5 && s4 > n6 ? i6 - e6 + l6 : 0;
var l5 = (t5) => {
  const e6 = t5.parentElement;
  return null == e6 ? t5.getRootNode().host || null : e6;
};
var r6 = (e6, r7) => {
  var i6, s4, d5, h3;
  if ("undefined" == typeof document)
    return [];
  const { scrollMode: c5, block: f5, inline: u4, boundary: a3, skipOverflowHiddenElements: g3 } = r7, p5 = "function" == typeof a3 ? a3 : (t5) => t5 !== a3;
  if (!t4(e6))
    throw new TypeError("Invalid target");
  const m2 = document.scrollingElement || document.documentElement, w2 = [];
  let W2 = e6;
  for (; t4(W2) && p5(W2); ) {
    if (W2 = l5(W2), W2 === m2) {
      w2.push(W2);
      break;
    }
    null != W2 && W2 === document.body && n5(W2) && !n5(document.documentElement) || null != W2 && n5(W2, g3) && w2.push(W2);
  }
  const b2 = null != (s4 = null == (i6 = window.visualViewport) ? void 0 : i6.width) ? s4 : innerWidth, H2 = null != (h3 = null == (d5 = window.visualViewport) ? void 0 : d5.height) ? h3 : innerHeight, { scrollX: y4, scrollY: M2 } = window, { height: v5, width: E2, top: x3, right: C2, bottom: I3, left: R2 } = e6.getBoundingClientRect(), { top: T, right: B2, bottom: F, left: V } = ((t5) => {
    const e7 = window.getComputedStyle(t5);
    return { top: parseFloat(e7.scrollMarginTop) || 0, right: parseFloat(e7.scrollMarginRight) || 0, bottom: parseFloat(e7.scrollMarginBottom) || 0, left: parseFloat(e7.scrollMarginLeft) || 0 };
  })(e6);
  let k2 = "start" === f5 || "nearest" === f5 ? x3 - T : "end" === f5 ? I3 + F : x3 + v5 / 2 - T + F, D2 = "center" === u4 ? R2 + E2 / 2 - V + B2 : "end" === u4 ? C2 + B2 : R2 - V;
  const L2 = [];
  for (let t5 = 0; t5 < w2.length; t5++) {
    const e7 = w2[t5], { height: n6, width: l6, top: r8, right: i7, bottom: s5, left: d6 } = e7.getBoundingClientRect();
    if ("if-needed" === c5 && x3 >= 0 && R2 >= 0 && I3 <= H2 && C2 <= b2 && x3 >= r8 && I3 <= s5 && R2 >= d6 && C2 <= i7)
      return L2;
    const h4 = getComputedStyle(e7), a4 = parseInt(h4.borderLeftWidth, 10), g4 = parseInt(h4.borderTopWidth, 10), p6 = parseInt(h4.borderRightWidth, 10), W3 = parseInt(h4.borderBottomWidth, 10);
    let T2 = 0, B3 = 0;
    const F2 = "offsetWidth" in e7 ? e7.offsetWidth - e7.clientWidth - a4 - p6 : 0, V2 = "offsetHeight" in e7 ? e7.offsetHeight - e7.clientHeight - g4 - W3 : 0, S2 = "offsetWidth" in e7 ? 0 === e7.offsetWidth ? 0 : l6 / e7.offsetWidth : 0, X2 = "offsetHeight" in e7 ? 0 === e7.offsetHeight ? 0 : n6 / e7.offsetHeight : 0;
    if (m2 === e7)
      T2 = "start" === f5 ? k2 : "end" === f5 ? k2 - H2 : "nearest" === f5 ? o3(M2, M2 + H2, H2, g4, W3, M2 + k2, M2 + k2 + v5, v5) : k2 - H2 / 2, B3 = "start" === u4 ? D2 : "center" === u4 ? D2 - b2 / 2 : "end" === u4 ? D2 - b2 : o3(y4, y4 + b2, b2, a4, p6, y4 + D2, y4 + D2 + E2, E2), T2 = Math.max(0, T2 + M2), B3 = Math.max(0, B3 + y4);
    else {
      T2 = "start" === f5 ? k2 - r8 - g4 : "end" === f5 ? k2 - s5 + W3 + V2 : "nearest" === f5 ? o3(r8, s5, n6, g4, W3 + V2, k2, k2 + v5, v5) : k2 - (r8 + n6 / 2) + V2 / 2, B3 = "start" === u4 ? D2 - d6 - a4 : "center" === u4 ? D2 - (d6 + l6 / 2) + F2 / 2 : "end" === u4 ? D2 - i7 + p6 + F2 : o3(d6, i7, l6, a4, p6 + F2, D2, D2 + E2, E2);
      const { scrollLeft: t6, scrollTop: h5 } = e7;
      T2 = 0 === X2 ? 0 : Math.max(0, Math.min(h5 + T2 / X2, e7.scrollHeight - n6 / X2 + V2)), B3 = 0 === S2 ? 0 : Math.max(0, Math.min(t6 + B3 / S2, e7.scrollWidth - l6 / S2 + F2)), k2 += h5 - T2, D2 += t6 - B3;
    }
    L2.push({ el: e7, top: T2, left: B3 });
  }
  return L2;
};

// node_modules/.pnpm/scroll-into-view-if-needed@3.1.0/node_modules/scroll-into-view-if-needed/dist/index.js
var o4 = (t5) => false === t5 ? { block: "end", inline: "nearest" } : ((t6) => t6 === Object(t6) && 0 !== Object.keys(t6).length)(t5) ? t5 : { block: "start", inline: "nearest" };
function e5(e6, r7) {
  if (!e6.isConnected || !((t5) => {
    let o5 = t5;
    for (; o5 && o5.parentNode; ) {
      if (o5.parentNode === document)
        return true;
      o5 = o5.parentNode instanceof ShadowRoot ? o5.parentNode.host : o5.parentNode;
    }
    return false;
  })(e6))
    return;
  const n6 = ((t5) => {
    const o5 = window.getComputedStyle(t5);
    return { top: parseFloat(o5.scrollMarginTop) || 0, right: parseFloat(o5.scrollMarginRight) || 0, bottom: parseFloat(o5.scrollMarginBottom) || 0, left: parseFloat(o5.scrollMarginLeft) || 0 };
  })(e6);
  if (((t5) => "object" == typeof t5 && "function" == typeof t5.behavior)(r7))
    return r7.behavior(r6(e6, r7));
  const l6 = "boolean" == typeof r7 || null == r7 ? void 0 : r7.behavior;
  for (const { el: a3, top: i6, left: s4 } of r6(e6, o4(r7))) {
    const t5 = i6 - n6.top + n6.bottom, o5 = s4 - n6.left + n6.right;
    a3.scroll({ top: t5, left: o5, behavior: l6 });
  }
}

// node_modules/.pnpm/slate-history@0.86.0_slate@0.91.4/node_modules/slate-history/dist/index.es.js
var History = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(value2) {
    return isPlainObject(value2) && Array.isArray(value2.redos) && Array.isArray(value2.undos) && (value2.redos.length === 0 || Operation.isOperationList(value2.redos[0].operations)) && (value2.undos.length === 0 || Operation.isOperationList(value2.undos[0].operations));
  }
};
var SAVING = /* @__PURE__ */ new WeakMap();
var MERGING = /* @__PURE__ */ new WeakMap();
var HistoryEditor = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(value2) {
    return History.isHistory(value2.history) && Editor.isEditor(value2);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(editor) {
    return MERGING.get(editor);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(editor) {
    return SAVING.get(editor);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(editor) {
    editor.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(editor) {
    editor.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(editor, fn2) {
    var prev2 = HistoryEditor.isMerging(editor);
    MERGING.set(editor, false);
    fn2();
    MERGING.set(editor, prev2);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(editor, fn2) {
    var prev2 = HistoryEditor.isSaving(editor);
    SAVING.set(editor, false);
    fn2();
    SAVING.set(editor, prev2);
  }
};
var withHistory = (editor) => {
  var e6 = editor;
  var {
    apply
  } = e6;
  e6.history = {
    undos: [],
    redos: []
  };
  e6.redo = () => {
    var {
      history
    } = e6;
    var {
      redos
    } = history;
    if (redos.length > 0) {
      var batch = redos[redos.length - 1];
      if (batch.selectionBefore) {
        Transforms.setSelection(e6, batch.selectionBefore);
      }
      HistoryEditor.withoutSaving(e6, () => {
        Editor.withoutNormalizing(e6, () => {
          for (var op of batch.operations) {
            e6.apply(op);
          }
        });
      });
      history.redos.pop();
      history.undos.push(batch);
    }
  };
  e6.undo = () => {
    var {
      history
    } = e6;
    var {
      undos
    } = history;
    if (undos.length > 0) {
      var batch = undos[undos.length - 1];
      HistoryEditor.withoutSaving(e6, () => {
        Editor.withoutNormalizing(e6, () => {
          var inverseOps = batch.operations.map(Operation.inverse).reverse();
          for (var op of inverseOps) {
            e6.apply(op);
          }
          if (batch.selectionBefore) {
            Transforms.setSelection(e6, batch.selectionBefore);
          }
        });
      });
      history.redos.push(batch);
      history.undos.pop();
    }
  };
  e6.apply = (op) => {
    var {
      operations,
      history
    } = e6;
    var {
      undos
    } = history;
    var lastBatch = undos[undos.length - 1];
    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];
    var save = HistoryEditor.isSaving(e6);
    var merge4 = HistoryEditor.isMerging(e6);
    if (save == null) {
      save = shouldSave(op);
    }
    if (save) {
      if (merge4 == null) {
        if (lastBatch == null) {
          merge4 = false;
        } else if (operations.length !== 0) {
          merge4 = true;
        } else {
          merge4 = shouldMerge(op, lastOp);
        }
      }
      if (lastBatch && merge4) {
        lastBatch.operations.push(op);
      } else {
        var batch = {
          operations: [op],
          selectionBefore: e6.selection
        };
        undos.push(batch);
      }
      while (undos.length > 100) {
        undos.shift();
      }
      history.redos = [];
    }
    apply(op);
  };
  return e6;
};
var shouldMerge = (op, prev2) => {
  if (prev2 && op.type === "insert_text" && prev2.type === "insert_text" && op.offset === prev2.offset + prev2.text.length && Path.equals(op.path, prev2.path)) {
    return true;
  }
  if (prev2 && op.type === "remove_text" && prev2.type === "remove_text" && op.offset + op.text.length === prev2.offset && Path.equals(op.path, prev2.path)) {
    return true;
  }
  return false;
};
var shouldSave = (op, prev2) => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};

// node_modules/.pnpm/js-base64@3.7.5/node_modules/js-base64/base64.mjs
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a3) => {
  let tab = {};
  a3.forEach((c5, i6) => tab[c5] = i6);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s4) => s4.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u32, c0, c1, c22, asc = "";
  const pad = bin.length % 3;
  for (let i6 = 0; i6 < bin.length; ) {
    if ((c0 = bin.charCodeAt(i6++)) > 255 || (c1 = bin.charCodeAt(i6++)) > 255 || (c22 = bin.charCodeAt(i6++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c22;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i6 = 0, l6 = u8a.length; i6 < l6; i6 += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i6, i6 + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r22;
  for (let i6 = 0; i6 < asc.length; ) {
    u24 = b64tab[asc.charAt(i6++)] << 18 | b64tab[asc.charAt(i6++)] << 12 | (r1 = b64tab[asc.charAt(i6++)]) << 6 | (r22 = b64tab[asc.charAt(i6++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r22 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a3) => _U8Afrom(Buffer.from(a3, "base64")) : (a3) => _U8Afrom(_atob(a3).split("").map((c5) => c5.charCodeAt(0)));
var toUint8Array = (a3) => _toUint8Array(_unURI(a3));
var _unURI = (a3) => _tidyB64(a3.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/panelLeftOpenIcon/dist/keystar-ui-icon-icons-panelLeftOpenIcon.esm.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime());
var panelLeftOpenIcon = (0, import_jsx_runtime70.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime70.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime70.jsx)("path", {
    d: "M9 3v18M14 9l3 3-3 3"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/panelLeftCloseIcon/dist/keystar-ui-icon-icons-panelLeftCloseIcon.esm.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime());
var panelLeftCloseIcon = (0, import_jsx_runtime71.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime71.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime71.jsx)("path", {
    d: "M9 3v18M16 15l-3-3 3-3"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/panelRightOpenIcon/dist/keystar-ui-icon-icons-panelRightOpenIcon.esm.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime());
var panelRightOpenIcon = (0, import_jsx_runtime72.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime72.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime72.jsx)("path", {
    d: "M15 3v18M10 15l-3-3 3-3"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/panelRightCloseIcon/dist/keystar-ui-icon-icons-panelRightCloseIcon.esm.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime());
var panelRightCloseIcon = (0, import_jsx_runtime73.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime73.jsx)("rect", {
    width: 18,
    height: 18,
    x: 3,
    y: 3,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime73.jsx)("path", {
    d: "M15 3v18M8 9l3 3-3 3"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/badge/dist/keystar-ui-badge.esm.js
var import_react71 = __toESM(require_react());
var import_jsx_runtime74 = __toESM(require_jsx_runtime());
var Badge = (0, import_react71.forwardRef)(function Badge2(props, forwardedRef) {
  const {
    children,
    tone = "neutral",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  const bg = tone === "neutral" ? "surfaceSecondary" : tone;
  const fg = tone === "neutral" ? void 0 : tone;
  const slots = (0, import_react71.useMemo)(() => ({
    icon: {
      color: fg
    },
    text: {
      trim: false,
      color: fg,
      weight: "medium"
    }
  }), [fg]);
  return (0, import_jsx_runtime74.jsx)(Flex, {
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    ref: forwardedRef,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    // appearance
    backgroundColor: bg,
    borderRadius: "full",
    height: "element.small",
    minWidth: 0,
    paddingX: "regular",
    alignItems: "center",
    flexShrink: 0,
    gap: "small",
    inline: true,
    children: (0, import_jsx_runtime74.jsx)(SlotProvider, {
      slots,
      children: isReactText(children) ? (0, import_jsx_runtime74.jsx)(Text, {
        children
      }) : children
    })
  });
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/nav-list/dist/keystar-ui-nav-list.esm.js
var import_react72 = __toESM(require_react());
var import_jsx_runtime75 = __toESM(require_jsx_runtime());
var listBlockGutter = tokenSchema.size.space.large;
var itemIndicatorGutter = tokenSchema.size.space.regular;
var itemIndicatorWidth = tokenSchema.size.space.small;
var itemContentGutter = tokenSchema.size.space.medium;
var textInsetStart = `calc(${itemIndicatorWidth} + ${itemIndicatorGutter} + ${itemContentGutter})`;
var NavList = (0, import_react72.forwardRef)(function NavList2(props, forwardedRef) {
  const {
    children,
    ...otherProps
  } = props;
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const styleProps = useStyleProps(otherProps);
  const dividerStyles = useDividerStyles();
  const currentItem = useCurrentItem(domRef);
  (0, import_react72.useEffect)(() => {
    if (currentItem) {
      currentItem.scrollIntoView({
        block: "center"
      });
    }
  }, [currentItem]);
  const slots = (0, import_react72.useMemo)(() => ({
    divider: {
      "aria-hidden": true,
      elementType: "li",
      size: "medium",
      UNSAFE_className: dividerStyles
    }
  }), [dividerStyles]);
  return (0, import_jsx_runtime75.jsx)(Flex, {
    elementType: "nav",
    ref: domRef,
    direction: "column",
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps, {
      labelable: true
    }),
    children: (0, import_jsx_runtime75.jsx)(Flex, {
      direction: "column",
      elementType: "ul",
      flex: "1 0 0",
      children: (0, import_jsx_runtime75.jsx)(SlotProvider, {
        slots,
        children
      })
    })
  });
});
function useDividerStyles() {
  return css({
    marginBlock: listBlockGutter,
    marginInlineStart: textInsetStart,
    width: `calc(40% - ${textInsetStart} - ${itemContentGutter})`,
    // FIXME: magic numbers
    minWidth: 80,
    maxWidth: 240
  });
}
function useCurrentItem(ref) {
  let [currentItem, setCurrentItem] = (0, import_react72.useState)(null);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    let el = ref.current && ref.current.querySelector("[aria-current]");
    if (el) {
      setCurrentItem(el);
    }
  }, [ref]);
  return currentItem;
}
var NavItem = (0, import_react72.forwardRef)(function NavItem2(props, forwardedRef) {
  const {
    "aria-current": ariaCurrent,
    children,
    href,
    ...otherProps
  } = props;
  const styles2 = useStyles();
  const domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, domRef);
  const slots = (0, import_react72.useMemo)(() => ({
    text: {
      color: "inherit",
      UNSAFE_className: styles2.text
    }
  }), [styles2.text]);
  return (0, import_jsx_runtime75.jsx)("li", {
    children: (0, import_jsx_runtime75.jsx)(FocusRing, {
      children: (0, import_jsx_runtime75.jsx)("a", {
        ref: domRef,
        "aria-current": ariaCurrent,
        href,
        className: classNames(styles2.anchor),
        ...linkProps,
        ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
        children: (0, import_jsx_runtime75.jsx)("div", {
          className: classNames(styles2.content),
          children: (0, import_jsx_runtime75.jsx)(SlotProvider, {
            slots,
            children: isReactText(children) ? (0, import_jsx_runtime75.jsx)(Text, {
              children
            }) : children
          })
        })
      })
    })
  });
});
function useStyles() {
  const ringColor = tokenSchema.color.alias.focusRing;
  const ringWidth = tokenSchema.size.alias.focusRing;
  const anchor = css({
    color: tokenSchema.color.foreground.neutral,
    display: "flex",
    gap: itemIndicatorGutter,
    paddingBlock: tokenSchema.size.space.xsmall,
    outline: 0,
    // selected indicator
    "&::before": {
      borderRadius: itemIndicatorWidth,
      content: '""',
      insetInlineStart: tokenSchema.size.space.xsmall,
      marginBlock: tokenSchema.size.space.xsmall,
      position: "relative",
      width: itemIndicatorWidth
    },
    // interaction
    "&:hover": {
      color: tokenSchema.color.foreground.neutralEmphasis
    },
    // selection
    "&[aria-current]": {
      color: tokenSchema.color.foreground.neutralEmphasis,
      "&::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis
      }
    }
  });
  const content = css({
    alignItems: "center",
    borderRadius: tokenSchema.size.radius.regular,
    display: "flex",
    flex: 1,
    flexShrink: 0,
    gap: tokenSchema.size.space.regular,
    minHeight: tokenSchema.size.element.regular,
    minWidth: 0,
    paddingInline: tokenSchema.size.space.medium,
    paddingBlock: tokenSchema.size.space.small,
    position: "relative",
    // focus ring
    [`&::after`]: {
      borderRadius: tokenSchema.size.radius.regular,
      content: '""',
      insetBlock: 1,
      insetInline: -1,
      margin: 1,
      position: "absolute",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      })
    },
    [`.${anchor}[data-focus=visible] &::after`]: {
      boxShadow: `0 0 0 ${ringWidth} ${ringColor}`,
      margin: 0
    },
    [`.${anchor}[aria-current] &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered
    },
    [`.${anchor}:hover &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundHovered
    },
    [`.${anchor}:active &`]: {
      backgroundColor: tokenSchema.color.alias.backgroundPressed
    }
  });
  const text3 = css({
    fontWeight: tokenSchema.typography.fontWeight.medium,
    [`.${anchor}[aria-current] &`]: {
      fontWeight: tokenSchema.typography.fontWeight.semibold
    }
  });
  return {
    anchor,
    content,
    text: text3
  };
}
function NavGroup(props) {
  const {
    children,
    id,
    title,
    ...otherProps
  } = props;
  const headingId = $bdb11010cef70236$export$f680877a34711e37(id);
  const groupStyles = useGroupStyles();
  const headingStyles = useHeadingStyles2();
  return (0, import_jsx_runtime75.jsxs)("li", {
    className: classNames(groupStyles),
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    children: [(0, import_jsx_runtime75.jsx)(Text, {
      elementType: "h3",
      id: headingId,
      UNSAFE_className: headingStyles,
      children: title
    }), (0, import_jsx_runtime75.jsx)(Box, {
      elementType: "ul",
      flexShrink: 0,
      "aria-labelledby": headingId,
      children
    })]
  });
}
function useGroupStyles() {
  return css({
    "&:not(:first-child)": {
      marginBlockStart: listBlockGutter
    },
    "&:not(:last-child)": {
      marginBlockEnd: listBlockGutter
    }
  });
}
function useHeadingStyles2() {
  return css({
    color: tokenSchema.color.foreground.neutralSecondary,
    fontSize: tokenSchema.typography.text.small.size,
    fontWeight: tokenSchema.typography.fontWeight.medium,
    paddingBlock: tokenSchema.size.space.regular,
    paddingInlineEnd: itemContentGutter,
    paddingInlineStart: textInsetStart,
    textTransform: "uppercase"
  });
}

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/cloud-image-preview-bac85559.esm.js
var import_react73 = __toESM(require_react());
var import_jsx_runtime76 = __toESM(require_jsx_runtime());
var import_is_hotkey2 = __toESM(require_lib());
var import_slugify = __toESM(require_slugify());
var import_sanitize_url2 = __toESM(require_dist());
var import_mdast_util_from_markdown = __toESM(require_mdast_util_from_markdown());
var import_from_markdown = __toESM(require_from_markdown());
var import_micromark_extension_gfm_autolink_literal = __toESM(require_micromark_extension_gfm_autolink_literal());
var import_from_markdown2 = __toESM(require_from_markdown2());
var import_micromark_extension_gfm_strikethrough = __toESM(require_micromark_extension_gfm_strikethrough());
var import_cookie = __toESM(require_cookie());
var RouterContext = (0, import_react73.createContext)(null);
function RouterProvider(props) {
  const [url, setUrl] = (0, import_react73.useState)(() => window.location.href);
  const router = (0, import_react73.useMemo)(() => {
    function navigate(url2, replace2) {
      const newUrl = new URL(url2, window.location.href);
      if (newUrl.origin !== window.location.origin || !newUrl.pathname.startsWith("/keystatic")) {
        window.location.assign(newUrl);
        return;
      }
      window.history[replace2 ? "replaceState" : "pushState"](null, "", newUrl);
      (0, import_react73.startTransition)(() => {
        setUrl(newUrl.toString());
      });
    }
    const replaced = location.pathname.replace(/^\/keystatic\/?/, "");
    const params = replaced === "" ? [] : replaced.split("/").map(decodeURIComponent);
    const parsedUrl = new URL(url);
    return {
      href: parsedUrl.pathname + parsedUrl.search,
      replace(path2) {
        navigate(path2, true);
      },
      push(path2) {
        navigate(path2, false);
      },
      params
    };
  }, [url]);
  (0, import_react73.useEffect)(() => {
    const handleNavigate = () => {
      (0, import_react73.startTransition)(() => {
        setUrl(window.location.href);
      });
    };
    window.addEventListener("popstate", handleNavigate);
    return () => {
      window.removeEventListener("popstate", handleNavigate);
    };
  }, []);
  return (0, import_jsx_runtime76.jsx)(RouterContext.Provider, {
    value: router,
    children: props.children
  });
}
function useRouter() {
  const router = (0, import_react73.useContext)(RouterContext);
  if (router == null) {
    throw new Error("useRouter must be used within a RouterProvider");
  }
  return router;
}
function fixPath(path2) {
  return path2.replace(/^\.?\/+/, "").replace(/\/*$/, "");
}
var collectionPath = /\/\*\*?(?:$|\/)/;
function getConfiguredCollectionPath(config2, collection2) {
  var _collectionConfig$pat;
  const collectionConfig = config2.collections[collection2];
  const path2 = (_collectionConfig$pat = collectionConfig.path) !== null && _collectionConfig$pat !== void 0 ? _collectionConfig$pat : `${collection2}/*/`;
  if (!collectionPath.test(path2)) {
    throw new Error(`Collection path must end with /* or /** or include /*/ or /**/ but ${collection2} has ${path2}`);
  }
  return path2;
}
function getCollectionPath(config2, collection2) {
  const configuredPath = getConfiguredCollectionPath(config2, collection2);
  const path2 = fixPath(configuredPath.replace(/\*\*?.*$/, ""));
  return path2;
}
function getCollectionFormat(config2, collection2) {
  var _collectionConfig$for;
  const collectionConfig = config2.collections[collection2];
  return getFormatInfo((_collectionConfig$for = collectionConfig.format) !== null && _collectionConfig$for !== void 0 ? _collectionConfig$for : "yaml", collectionConfig.schema, getConfiguredCollectionPath(config2, collection2));
}
function getSingletonFormat(config2, singleton2) {
  var _singletonConfig$form, _singletonConfig$path;
  const singletonConfig = config2.singletons[singleton2];
  return getFormatInfo((_singletonConfig$form = singletonConfig.format) !== null && _singletonConfig$form !== void 0 ? _singletonConfig$form : "yaml", singletonConfig.schema, (_singletonConfig$path = singletonConfig.path) !== null && _singletonConfig$path !== void 0 ? _singletonConfig$path : `${singleton2}/`);
}
function getCollectionItemPath(config2, collection2, slug) {
  const basePath = getCollectionPath(config2, collection2);
  const suffix = getCollectionItemSlugSuffix(config2, collection2);
  return `${basePath}/${slug}${suffix}`;
}
function getEntryDataFilepath(dir, formatInfo) {
  return `${dir}${formatInfo.dataLocation === "index" ? "/index" : ""}${getDataFileExtension(formatInfo)}`;
}
function getSlugGlobForCollection(config2, collection2) {
  const collectionPath2 = getConfiguredCollectionPath(config2, collection2);
  return collectionPath2.includes("**") ? "**" : "*";
}
function getCollectionItemSlugSuffix(config2, collection2) {
  const configuredPath = getConfiguredCollectionPath(config2, collection2);
  const path2 = fixPath(configuredPath.replace(/^[^*]+\*\*?/, ""));
  return path2 ? `/${path2}` : "";
}
function getSingletonPath(config2, singleton2) {
  var _singleton$path, _singleton$path2;
  if ((_singleton$path = config2.singletons[singleton2].path) !== null && _singleton$path !== void 0 && _singleton$path.includes("*")) {
    throw new Error(`Singleton paths cannot include * but ${singleton2} has ${config2.singletons[singleton2].path}`);
  }
  return fixPath((_singleton$path2 = config2.singletons[singleton2].path) !== null && _singleton$path2 !== void 0 ? _singleton$path2 : singleton2);
}
function getDataFileExtension(formatInfo) {
  return formatInfo.contentField ? formatInfo.contentField.config.contentExtension : "." + formatInfo.data;
}
function getFormatInfo(format2, schema, path2) {
  var _format$data;
  const dataLocation = path2.endsWith("/") ? "index" : "outer";
  if (typeof format2 === "string") {
    return {
      dataLocation,
      contentField: void 0,
      data: format2
    };
  }
  let contentField;
  if (format2.contentField) {
    const field2 = schema[format2.contentField];
    assert((field2 === null || field2 === void 0 ? void 0 : field2.kind) === "form", `${format2.contentField} is not a form field`);
    assert(field2.formKind === "content", `${format2.contentField} is not a content field`);
    contentField = {
      key: format2.contentField,
      config: field2
    };
  }
  return {
    data: (_format$data = format2.data) !== null && _format$data !== void 0 ? _format$data : "yaml",
    contentField,
    dataLocation
  };
}
function getPathPrefix(storage) {
  if (storage.kind === "local" || !storage.pathPrefix) {
    return void 0;
  }
  return fixPath(storage.pathPrefix) + "/";
}
async function sha1(content) {
  const hashBuffer = await crypto.subtle.digest("SHA-1", content);
  return bytesToHex(new Uint8Array(hashBuffer));
}
var textEncoder$2 = new TextEncoder();
function blobSha(contents) {
  const blobPrefix = textEncoder$2.encode("blob " + contents.length + "\0");
  const array = new Uint8Array(blobPrefix.byteLength + contents.byteLength);
  array.set(blobPrefix, 0);
  array.set(contents, blobPrefix.byteLength);
  return sha1(array);
}
function getTreeNodeAtPath(root, path2) {
  const parts = path2.split("/");
  let node3 = root.get(parts[0]);
  for (const part of parts.slice(1)) {
    if (!node3)
      return void 0;
    if (!node3.children)
      return void 0;
    node3 = node3.children.get(part);
  }
  return node3;
}
function getNodeAtPath(tree2, path2) {
  let node3 = tree2;
  for (const part of path2.split("/")) {
    if (!node3.has(part)) {
      node3.set(part, /* @__PURE__ */ new Map());
    }
    const innerNode = node3.get(part);
    assert(innerNode instanceof Map, "expected tree");
    node3 = innerNode;
  }
  return node3;
}
function getFilename(path2) {
  return path2.replace(/.*\//, "");
}
function getDirname(path2) {
  return path2.replace(/\/[^/]+$/, "");
}
function toTreeChanges(changes) {
  const changesRoot = /* @__PURE__ */ new Map();
  for (const deletion of changes.deletions) {
    const parentTree = getNodeAtPath(changesRoot, getDirname(deletion));
    parentTree.set(getFilename(deletion), "delete");
  }
  for (const addition of changes.additions) {
    const parentTree = getNodeAtPath(changesRoot, getDirname(addition.path));
    parentTree.set(getFilename(addition.path), addition.contents);
  }
  return changesRoot;
}
var SPACE_CHAR_CODE = 32;
var space2 = new Uint8Array([SPACE_CHAR_CODE]);
var nullchar = new Uint8Array([0]);
var tree = textEncoder$2.encode("tree ");
function treeSha(children) {
  const entries = [...children].map(([name2, node3]) => ({
    name: name2,
    sha: node3.entry.sha,
    mode: node3.entry.mode
  }));
  entries.sort((a3, b2) => {
    const aName = a3.mode === "040000" ? a3.name + "/" : a3.name;
    const bName = b2.mode === "040000" ? b2.name + "/" : b2.name;
    return aName === bName ? 0 : aName < bName ? -1 : 1;
  });
  const treeObject = entries.flatMap((entry) => {
    const mode = textEncoder$2.encode(entry.mode.replace(/^0/, ""));
    const name2 = textEncoder$2.encode(entry.name);
    const sha = hexToBytes(entry.sha);
    return [mode, space2, name2, nullchar, sha];
  });
  return sha1(concatBytes([tree, textEncoder$2.encode(treeObject.reduce((sum, val) => sum + val.byteLength, 0).toString()), nullchar, ...treeObject]));
}
function concatBytes(byteArrays) {
  const totalLength = byteArrays.reduce((sum, arr) => sum + arr.byteLength, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of byteArrays) {
    result.set(arr, offset);
    offset += arr.byteLength;
  }
  return result;
}
function hexToBytes(str) {
  const bytes = new Uint8Array(str.length / 2);
  for (var i6 = 0; i6 < bytes.byteLength; i6 += 1) {
    const start2 = i6 * 2;
    bytes[i6] = parseInt(str.slice(start2, start2 + 2), 16);
  }
  return bytes;
}
async function createTreeNodeEntry(path2, children) {
  const sha = await treeSha(children);
  return {
    path: path2,
    mode: "040000",
    type: "tree",
    sha
  };
}
async function createBlobNodeEntry(path2, contents) {
  const sha = "sha" in contents ? contents.sha : await blobSha(contents);
  return {
    path: path2,
    mode: "100644",
    type: "blob",
    sha,
    size: contents.byteLength
  };
}
async function updateTreeWithChanges(tree2, changes) {
  var _await$updateTree;
  const newTree = (_await$updateTree = await updateTree(tree2, toTreeChanges(changes), [])) !== null && _await$updateTree !== void 0 ? _await$updateTree : /* @__PURE__ */ new Map();
  return {
    entries: treeToEntries(newTree),
    sha: await treeSha(newTree !== null && newTree !== void 0 ? newTree : /* @__PURE__ */ new Map())
  };
}
function treeToEntries(tree2) {
  return [...tree2.values()].flatMap((x3) => x3.children ? [x3.entry, ...treeToEntries(x3.children)] : [x3.entry]);
}
async function updateTree(tree2, changedTree, path2) {
  const newTree = new Map(tree2);
  for (const [key, value2] of changedTree) {
    if (value2 === "delete") {
      newTree.delete(key);
    }
    if (value2 instanceof Map) {
      var _newTree$get$children, _newTree$get;
      const existingChildren = (_newTree$get$children = (_newTree$get = newTree.get(key)) === null || _newTree$get === void 0 ? void 0 : _newTree$get.children) !== null && _newTree$get$children !== void 0 ? _newTree$get$children : /* @__PURE__ */ new Map();
      const children = await updateTree(existingChildren, value2, path2.concat(key));
      if (children === void 0) {
        newTree.delete(key);
        continue;
      }
      const entry = await createTreeNodeEntry(path2.concat(key).join("/"), children);
      newTree.set(key, {
        entry,
        children
      });
    }
    if (value2 instanceof Uint8Array || typeof value2 === "object" && "sha" in value2) {
      const entry = await createBlobNodeEntry(path2.concat(key).join("/"), value2);
      newTree.set(key, {
        entry
      });
    }
  }
  if (newTree.size === 0) {
    return void 0;
  }
  return newTree;
}
function treeEntriesToTreeNodes(entries) {
  const root = /* @__PURE__ */ new Map();
  const getChildrenAtPath = (parts) => {
    var _node;
    if (parts.length === 0) {
      return root;
    }
    let node3 = root.get(parts[0]);
    for (const part of parts.slice(1)) {
      if (!node3)
        return void 0;
      if (!node3.children)
        return void 0;
      node3 = node3.children.get(part);
    }
    return (_node = node3) === null || _node === void 0 ? void 0 : _node.children;
  };
  for (const entry of entries) {
    const split2 = entry.path.split("/");
    const children = getChildrenAtPath(split2.slice(0, -1));
    if (children) {
      children.set(split2[split2.length - 1], {
        entry,
        children: entry.type === "tree" ? /* @__PURE__ */ new Map() : void 0
      });
    }
  }
  return root;
}
var LOADING = Symbol("loading");
function isThenable(value2) {
  return value2 && typeof value2.then === "function";
}
function useData(func) {
  const [state, setState] = (0, import_react73.useState)({
    kind: "loading"
  });
  let stateToReturn = state;
  const result = (0, import_react73.useMemo)(() => {
    try {
      const result2 = func();
      if (isThenable(result2)) {
        result2.then(() => {
        }, () => {
        });
      }
      return {
        kind: "result",
        result: result2
      };
    } catch (error3) {
      return {
        kind: "error",
        error: error3
      };
    }
  }, [func]);
  const resultState = (0, import_react73.useMemo)(() => {
    if (result.kind === "error" && (state.kind !== "error" || state.error !== result.error)) {
      return {
        kind: "error",
        error: result.error
      };
    }
    if (result.kind === "result" && !isThenable(result.result) && result.result !== LOADING && (state.kind !== "loaded" || state.data !== result.result)) {
      return {
        kind: "loaded",
        data: result.result
      };
    }
  }, [result, state]);
  if (resultState && resultState !== state) {
    stateToReturn = resultState;
    setState(resultState);
  }
  (0, import_react73.useEffect)(() => {
    if (result.kind === "result" && isThenable(result.result)) {
      setState({
        kind: "loading"
      });
      let isActive = true;
      result.result.then((result2) => {
        if (result2 === LOADING || !isActive)
          return;
        setState({
          kind: "loaded",
          data: result2
        });
      }, (error3) => {
        if (!isActive)
          return;
        setState({
          kind: "error",
          error: error3
        });
      });
      return () => {
        isActive = false;
      };
    }
  }, [result]);
  return stateToReturn;
}
function mapDataState(state, func) {
  if (state.kind === "error" || state.kind === "loading") {
    return state;
  }
  return {
    kind: "loaded",
    data: func(state.data)
  };
}
function mergeDataStates(input) {
  const entries = Object.entries(input);
  for (const [, value2] of entries) {
    if (value2.kind === "error") {
      return {
        kind: "error",
        error: value2.error
      };
    }
  }
  for (const [, value2] of entries) {
    if (value2.kind === "loading") {
      return {
        kind: "loading"
      };
    }
  }
  return {
    kind: "loaded",
    data: Object.fromEntries(entries.map(([key, val]) => {
      return [key, val.data];
    }))
  };
}
function collectDirectoriesUsedInSchemaInner(schema, directories, seenSchemas) {
  if (seenSchemas.has(schema)) {
    return;
  }
  seenSchemas.add(schema);
  if (schema.kind === "array") {
    return collectDirectoriesUsedInSchemaInner(schema.element, directories, seenSchemas);
  }
  if (schema.kind === "child") {
    return;
  }
  if (schema.kind === "form") {
    if (schema.formKind === "asset" && schema.directory !== void 0) {
      directories.add(fixPath(schema.directory));
    }
    if (schema.formKind === "content" && schema.directories !== void 0) {
      for (const directory of schema.directories) {
        directories.add(fixPath(directory));
      }
    }
    return;
  }
  if (schema.kind === "object") {
    for (const field2 of Object.values(schema.fields)) {
      collectDirectoriesUsedInSchemaInner(field2, directories, seenSchemas);
    }
    return;
  }
  if (schema.kind === "conditional") {
    for (const innerSchema of Object.values(schema.values)) {
      collectDirectoriesUsedInSchemaInner(innerSchema, directories, seenSchemas);
    }
    return;
  }
  assertNever(schema);
}
function collectDirectoriesUsedInSchema(schema) {
  const directories = /* @__PURE__ */ new Set();
  collectDirectoriesUsedInSchemaInner(schema, directories, /* @__PURE__ */ new Set());
  return directories;
}
function getDirectoriesForTreeKey(schema, directory, slug, format2) {
  const directories = [fixPath(directory)];
  if (format2.dataLocation === "outer") {
    directories.push(fixPath(directory) + getDataFileExtension(format2));
  }
  const toAdd = slug === void 0 ? "" : `/${slug}`;
  for (const directory2 of collectDirectoriesUsedInSchema(schema)) {
    directories.push(directory2 + toAdd);
  }
  return directories;
}
function getTreeKey(directories, tree2) {
  return directories.map((d5) => {
    var _getTreeNodeAtPath;
    return (_getTreeNodeAtPath = getTreeNodeAtPath(tree2, d5)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
  }).join("-");
}
var pkgJson = {
  name: "@keystatic/core",
  version: "0.2.4",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/Thinkmill/keystatic/",
    directory: "packages/keystatic"
  },
  exports: {
    "./ui": {
      types: "./ui/dist/keystatic-core-ui.cjs.js",
      node: {
        "react-server": {
          module: "./ui/dist/keystatic-core-ui.node.react-server.esm.js",
          "default": "./ui/dist/keystatic-core-ui.node.react-server.cjs.js"
        },
        module: "./ui/dist/keystatic-core-ui.node.esm.js",
        "default": "./ui/dist/keystatic-core-ui.node.cjs.js"
      },
      "react-server": {
        module: "./ui/dist/keystatic-core-ui.react-server.esm.js",
        "default": "./ui/dist/keystatic-core-ui.react-server.cjs.js"
      },
      module: "./ui/dist/keystatic-core-ui.esm.js",
      "default": "./ui/dist/keystatic-core-ui.cjs.js"
    },
    ".": {
      types: "./dist/keystatic-core.cjs.js",
      node: {
        "react-server": {
          module: "./dist/keystatic-core.node.react-server.esm.js",
          "default": "./dist/keystatic-core.node.react-server.cjs.js"
        },
        module: "./dist/keystatic-core.node.esm.js",
        "default": "./dist/keystatic-core.node.cjs.js"
      },
      "react-server": {
        module: "./dist/keystatic-core.react-server.esm.js",
        "default": "./dist/keystatic-core.react-server.cjs.js"
      },
      module: "./dist/keystatic-core.esm.js",
      "default": "./dist/keystatic-core.cjs.js"
    },
    "./api/utils": {
      types: "./api/utils/dist/keystatic-core-api-utils.cjs.js",
      node: {
        "react-server": {
          module: "./api/utils/dist/keystatic-core-api-utils.node.react-server.esm.js",
          "default": "./api/utils/dist/keystatic-core-api-utils.node.react-server.cjs.js"
        },
        module: "./api/utils/dist/keystatic-core-api-utils.node.esm.js",
        "default": "./api/utils/dist/keystatic-core-api-utils.node.cjs.js"
      },
      "react-server": {
        module: "./api/utils/dist/keystatic-core-api-utils.react-server.esm.js",
        "default": "./api/utils/dist/keystatic-core-api-utils.react-server.cjs.js"
      },
      module: "./api/utils/dist/keystatic-core-api-utils.esm.js",
      "default": "./api/utils/dist/keystatic-core-api-utils.cjs.js"
    },
    "./renderer": {
      types: "./renderer/dist/keystatic-core-renderer.cjs.js",
      node: {
        "react-server": {
          module: "./renderer/dist/keystatic-core-renderer.node.react-server.esm.js",
          "default": "./renderer/dist/keystatic-core-renderer.node.react-server.cjs.js"
        },
        module: "./renderer/dist/keystatic-core-renderer.node.esm.js",
        "default": "./renderer/dist/keystatic-core-renderer.node.cjs.js"
      },
      "react-server": {
        module: "./renderer/dist/keystatic-core-renderer.react-server.esm.js",
        "default": "./renderer/dist/keystatic-core-renderer.react-server.cjs.js"
      },
      module: "./renderer/dist/keystatic-core-renderer.esm.js",
      "default": "./renderer/dist/keystatic-core-renderer.cjs.js"
    },
    "./api/generic": {
      types: "./api/generic/dist/keystatic-core-api-generic.cjs.js",
      node: {
        "react-server": {
          module: "./api/generic/dist/keystatic-core-api-generic.node.react-server.esm.js",
          "default": "./api/generic/dist/keystatic-core-api-generic.node.react-server.cjs.js"
        },
        module: "./api/generic/dist/keystatic-core-api-generic.node.esm.js",
        "default": "./api/generic/dist/keystatic-core-api-generic.node.cjs.js"
      },
      "react-server": {
        module: "./api/generic/dist/keystatic-core-api-generic.react-server.esm.js",
        "default": "./api/generic/dist/keystatic-core-api-generic.react-server.cjs.js"
      },
      module: "./api/generic/dist/keystatic-core-api-generic.esm.js",
      "default": "./api/generic/dist/keystatic-core-api-generic.cjs.js"
    },
    "./reader": {
      types: "./reader/dist/keystatic-core-reader.cjs.js",
      node: {
        "react-server": {
          module: "./reader/dist/keystatic-core-reader.node.react-server.esm.js",
          "default": "./reader/dist/keystatic-core-reader.node.react-server.cjs.js"
        },
        module: "./reader/dist/keystatic-core-reader.node.esm.js",
        "default": "./reader/dist/keystatic-core-reader.node.cjs.js"
      },
      "react-server": {
        module: "./reader/dist/keystatic-core-reader.react-server.esm.js",
        "default": "./reader/dist/keystatic-core-reader.react-server.cjs.js"
      },
      module: "./reader/dist/keystatic-core-reader.esm.js",
      "default": "./reader/dist/keystatic-core-reader.cjs.js"
    },
    "./reader/github": {
      types: "./reader/github/dist/keystatic-core-reader-github.cjs.js",
      node: {
        "react-server": {
          module: "./reader/github/dist/keystatic-core-reader-github.node.react-server.esm.js",
          "default": "./reader/github/dist/keystatic-core-reader-github.node.react-server.cjs.js"
        },
        module: "./reader/github/dist/keystatic-core-reader-github.node.esm.js",
        "default": "./reader/github/dist/keystatic-core-reader-github.node.cjs.js"
      },
      "react-server": {
        module: "./reader/github/dist/keystatic-core-reader-github.react-server.esm.js",
        "default": "./reader/github/dist/keystatic-core-reader-github.react-server.cjs.js"
      },
      module: "./reader/github/dist/keystatic-core-reader-github.esm.js",
      "default": "./reader/github/dist/keystatic-core-reader-github.cjs.js"
    },
    "./component-blocks": {
      types: "./component-blocks/dist/keystatic-core-component-blocks.cjs.js",
      node: {
        "react-server": {
          module: "./component-blocks/dist/keystatic-core-component-blocks.node.react-server.esm.js",
          "default": "./component-blocks/dist/keystatic-core-component-blocks.node.react-server.cjs.js"
        },
        module: "./component-blocks/dist/keystatic-core-component-blocks.node.esm.js",
        "default": "./component-blocks/dist/keystatic-core-component-blocks.node.cjs.js"
      },
      "react-server": {
        module: "./component-blocks/dist/keystatic-core-component-blocks.react-server.esm.js",
        "default": "./component-blocks/dist/keystatic-core-component-blocks.react-server.cjs.js"
      },
      module: "./component-blocks/dist/keystatic-core-component-blocks.esm.js",
      "default": "./component-blocks/dist/keystatic-core-component-blocks.cjs.js"
    },
    "./form/fields/markdoc": {
      types: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.cjs.js",
      node: {
        "react-server": {
          module: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.react-server.esm.js",
          "default": "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.react-server.cjs.js"
        },
        module: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.esm.js",
        "default": "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.cjs.js"
      },
      "react-server": {
        module: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.react-server.esm.js",
        "default": "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.react-server.cjs.js"
      },
      module: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.esm.js",
      "default": "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.cjs.js"
    },
    "./package.json": "./package.json"
  },
  main: "dist/keystatic-core.cjs.js",
  module: "dist/keystatic-core.esm.js",
  files: [
    "dist",
    "api",
    "reader",
    "renderer",
    "ui",
    "form",
    "component-blocks"
  ],
  scripts: {
    setup: "ts-gql build && tsx scripts/l10n.ts && tsx scripts/build-prism.ts",
    build: "pnpm run setup && next build",
    dev: "next dev",
    start: "next start"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@braintree/sanitize-url": "^6.0.2",
    "@emotion/css": "^11.9.0",
    "@emotion/weak-memoize": "^0.3.0",
    "@floating-ui/react": "^0.24.0",
    "@internationalized/string": "^3.1.1",
    "@keystar/ui": "^0.4.4",
    "@markdoc/markdoc": "^0.3.0",
    "@react-aria/focus": "^3.14.3",
    "@react-aria/i18n": "^3.8.0",
    "@react-aria/interactions": "^3.19.1",
    "@react-aria/overlays": "^3.18.1",
    "@react-aria/selection": "^3.17.1",
    "@react-aria/utils": "^3.21.1",
    "@react-aria/visually-hidden": "^3.8.6",
    "@react-stately/collections": "^3.10.2",
    "@react-stately/list": "^3.10.0",
    "@react-stately/overlays": "^3.6.3",
    "@react-stately/utils": "^3.8.0",
    "@react-types/shared": "^3.21.0",
    "@sindresorhus/slugify": "^1.1.2",
    "@ts-gql/tag": "^0.7.0",
    "@types/node": "16.11.13",
    "@types/react": "^18.2.8",
    "@types/react-dom": "^18.0.11",
    "@urql/core": "^4.1.3",
    "@urql/exchange-auth": "^2.1.6",
    "@urql/exchange-graphcache": "^6.3.3",
    "@urql/exchange-persisted": "^4.1.0",
    cookie: "^0.5.0",
    emery: "^1.4.1",
    "escape-string-regexp": "^4.0.0",
    "fast-deep-equal": "^3.1.3",
    graphql: "^16.6.0",
    "idb-keyval": "^6.2.1",
    ignore: "^5.2.4",
    "iron-webcrypto": "^0.10.1",
    "is-hotkey": "^0.2.0",
    "js-base64": "^3.7.5",
    "js-yaml": "^4.1.0",
    "lru-cache": "^7.14.1",
    "match-sorter": "^6.3.1",
    "mdast-util-from-markdown": "^0.8.5",
    "mdast-util-gfm-autolink-literal": "^0.1.3",
    "mdast-util-gfm-strikethrough": "^0.2.3",
    "micromark-extension-gfm-autolink-literal": "0.5.7",
    "micromark-extension-gfm-strikethrough": "0.6.5",
    minimatch: "^7.1.0",
    "prosemirror-commands": "^1.5.1",
    "prosemirror-history": "^1.3.0",
    "prosemirror-keymap": "^1.2.1",
    "prosemirror-model": "^1.19.0",
    "prosemirror-state": "^1.4.2",
    "prosemirror-tables": "^1.3.4",
    "prosemirror-transform": "^1.7.1",
    "prosemirror-view": "^1.30.2",
    "scroll-into-view-if-needed": "^3.0.3",
    slate: "^0.91.4",
    "slate-history": "^0.86.0",
    "slate-react": "^0.91.9",
    urql: "^4.0.0",
    zod: "^3.20.2"
  },
  devDependencies: {
    "@testing-library/user-event": "^14.4.3",
    "@ts-gql/compiler": "^0.16.1",
    "@ts-gql/eslint-plugin": "^0.8.5",
    "@ts-gql/next": "^17.0.0",
    "@types/cookie": "^0.5.1",
    "@types/is-hotkey": "^0.1.7",
    "@types/js-yaml": "^4.0.5",
    "@types/prismjs": "^1.26.0",
    "@types/signal-exit": "^3.0.1",
    eslint: "^8.18.0",
    "fast-glob": "^3.2.12",
    "jest-diff": "^29.0.1",
    outdent: "^0.8.0",
    "pretty-format": "^29.0.1",
    prismjs: "^1.29.0",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    "react-element-to-jsx-string": "^15.0.0",
    "resize-observer-polyfill": "^1.5.1",
    "signal-exit": "^3.0.7",
    "slate-hyperscript": "^0.77.0",
    tsx: "^3.8.0",
    typescript: "^5.2.2"
  },
  peerDependencies: {
    react: "^18.2.0",
    "react-dom": "^18.2.0"
  },
  preconstruct: {
    entrypoints: [
      "index.ts",
      "api/generic.ts",
      "api/utils.ts",
      "reader/index.ts",
      "reader/github.ts",
      "renderer.tsx",
      "ui.tsx",
      "form/fields/markdoc/index.tsx",
      "component-blocks/index.tsx"
    ]
  },
  "ts-gql": {
    schema: "./github.graphql",
    mode: "no-transform",
    addTypename: false,
    scalars: {
      GitObjectID: "string"
    }
  },
  imports: {
    "#react-cache-in-react-server": {
      "react-server": "./src/reader/react-server-cache.ts",
      "default": "./src/reader/noop-cache.ts"
    },
    "#sha1": {
      node: "./src/sha1/node.ts",
      "default": "./src/sha1/webcrypto.ts"
    },
    "#webcrypto": {
      node: "./src/api/webcrypto/node.ts",
      "default": "./src/api/webcrypto/default.ts"
    },
    "#api-handler": {
      node: "./src/api/api-node.ts",
      "default": "./src/api/api-noop.ts"
    },
    "#field-ui/*": {
      "react-server": "./src/form/fields/empty-field-ui.tsx",
      "default": "./src/form/fields/*/ui.tsx"
    },
    "#component-block-primitives": {
      "react-server": "./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx",
      "default": "./src/form/fields/document/DocumentEditor/primitives/index.tsx"
    },
    "#cloud-image-preview": {
      "react-server": "./src/component-blocks/blank-for-react-server.tsx",
      "default": "./src/component-blocks/cloud-image-preview.tsx"
    }
  }
};
function object(fields, opts) {
  return {
    ...opts,
    kind: "object",
    fields
  };
}
function pluralize(count, options) {
  const {
    singular,
    plural = singular + "s",
    inclusive = true
  } = options;
  const variant = count === 1 ? singular : plural;
  return inclusive ? `${count} ${variant}` : variant;
}
function getBranchPrefix(config2) {
  return config2.storage.kind !== "local" ? config2.storage.branchPrefix : void 0;
}
function isGitHubConfig(config2) {
  return config2.storage.kind === "github";
}
function isLocalConfig(config2) {
  return config2.storage.kind === "local";
}
function isCloudConfig(config2) {
  var _config$cloud;
  if (config2.storage.kind !== "cloud")
    return false;
  if (!((_config$cloud = config2.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) || !config2.cloud.project.includes("/")) {
    throw new Error(`Keystatic is set to \`storage: { kind: 'cloud' }\` but \`cloud.project\` isn't set.
config({
  storage: { kind: 'cloud' },
  cloud: { project: 'team/project' },
})`);
  }
  return true;
}
function getSplitCloudProject(config2) {
  var _config$cloud2;
  if (!((_config$cloud2 = config2.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project))
    return void 0;
  const [team, project] = config2.cloud.project.split("/");
  return {
    team,
    project
  };
}
function getRepoPath(config2) {
  return `${config2.mainOwner}/${config2.mainRepo}`;
}
function getRepoUrl(config2) {
  return `https://github.com/${getRepoPath(config2)}`;
}
function getSlugFromState(collectionConfig, state) {
  const value2 = state[collectionConfig.slugField];
  const field2 = collectionConfig.schema[collectionConfig.slugField];
  if (field2.kind !== "form" || field2.formKind !== "slug") {
    throw new Error(`slugField is not a slug field`);
  }
  return field2.serializeWithSlug(value2).slug;
}
function getEntriesInCollectionWithTreeKey(config2, collection2, rootTree) {
  var _getTreeNodeAtPath$ch, _getTreeNodeAtPath;
  const collectionConfig = config2.collections[collection2];
  const schema = object(collectionConfig.schema);
  const formatInfo = getCollectionFormat(config2, collection2);
  const extension = getDataFileExtension(formatInfo);
  const glob = getSlugGlobForCollection(config2, collection2);
  const collectionPath2 = getCollectionPath(config2, collection2);
  const directory = (_getTreeNodeAtPath$ch = (_getTreeNodeAtPath = getTreeNodeAtPath(rootTree, collectionPath2)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.children) !== null && _getTreeNodeAtPath$ch !== void 0 ? _getTreeNodeAtPath$ch : /* @__PURE__ */ new Map();
  const entries = [];
  const directoriesUsedInSchema = [...collectDirectoriesUsedInSchema(schema)];
  const suffix = getCollectionItemSlugSuffix(config2, collection2);
  const possibleEntries = new Map(directory);
  if (glob === "**") {
    const handleDirectory = (dir, prefix3) => {
      for (const [key, entry] of dir) {
        if (entry.children) {
          possibleEntries.set(`${prefix3}${key}`, entry);
          handleDirectory(entry.children, `${prefix3}${key}/`);
        } else {
          possibleEntries.set(`${prefix3}${key}`, entry);
        }
      }
    };
    handleDirectory(directory, "");
  }
  for (const [key, entry] of possibleEntries) {
    if (formatInfo.dataLocation === "index") {
      var _actualEntry$children;
      const actualEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config2, collection2, key));
      if (!(actualEntry !== null && actualEntry !== void 0 && (_actualEntry$children = actualEntry.children) !== null && _actualEntry$children !== void 0 && _actualEntry$children.has("index" + extension)))
        continue;
      entries.push({
        key: getTreeKey([actualEntry.entry.path, ...directoriesUsedInSchema.map((x3) => `${x3}/${key}`)], rootTree),
        slug: key
      });
    } else {
      if (suffix) {
        const newEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config2, collection2, key) + extension);
        if (!newEntry || newEntry.children)
          continue;
        entries.push({
          key: getTreeKey([entry.entry.path, getCollectionItemPath(config2, collection2, key), ...directoriesUsedInSchema.map((x3) => `${x3}/${key}`)], rootTree),
          slug: key
        });
      }
      if (entry.children || !key.endsWith(extension))
        continue;
      const slug = key.slice(0, -extension.length);
      entries.push({
        key: getTreeKey([entry.entry.path, getCollectionItemPath(config2, collection2, slug), ...directoriesUsedInSchema.map((x3) => `${x3}/${slug}`)], rootTree),
        slug
      });
    }
  }
  return entries;
}
var KEYSTATIC_CLOUD_API_URL = "https://api.keystatic.cloud";
var KEYSTATIC_CLOUD_HEADERS = {
  "x-keystatic-version": pkgJson.version
};
var textEncoder$1 = new TextEncoder();
async function redirectToCloudAuth(from2, config2) {
  var _config$cloud3;
  if (!((_config$cloud3 = config2.cloud) !== null && _config$cloud3 !== void 0 && _config$cloud3.project)) {
    throw new Error("Not a cloud config");
  }
  const code_verifier = fromUint8Array(crypto.getRandomValues(new Uint8Array(32)), true);
  const code_challenge = fromUint8Array(new Uint8Array(await crypto.subtle.digest("SHA-256", textEncoder$1.encode(code_verifier))), true);
  const state = fromUint8Array(crypto.getRandomValues(new Uint8Array(32)), true);
  localStorage.setItem("keystatic-cloud-state", JSON.stringify({
    state,
    from: from2,
    code_verifier
  }));
  const url = new URL(`${KEYSTATIC_CLOUD_API_URL}/oauth/authorize`);
  url.searchParams.set("state", state);
  url.searchParams.set("client_id", config2.cloud.project);
  url.searchParams.set("redirect_uri", `${window.location.origin}/keystatic/cloud/oauth/callback`);
  url.searchParams.set("response_type", "code");
  url.searchParams.set("code_challenge_method", "S256");
  url.searchParams.set("code_challenge", code_challenge);
  url.searchParams.set("keystatic_version", pkgJson.version);
  window.location.href = url.toString();
}
var storedTokenSchema = z.object({
  token: z.string(),
  project: z.string(),
  validUntil: z.number().transform((val) => new Date(val))
});
function getSyncAuth(config2) {
  if (typeof document === "undefined") {
    return null;
  }
  if (config2.storage.kind === "github") {
    const cookies = (0, import_cookie.parse)(document.cookie);
    const accessToken = cookies["keystatic-gh-access-token"];
    if (!accessToken) {
      return null;
    }
    return {
      accessToken
    };
  }
  if (config2.storage.kind === "cloud") {
    return getCloudAuth(config2);
  }
  return null;
}
function getCloudAuth(config2) {
  var _config$cloud;
  if (!((_config$cloud = config2.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project))
    return null;
  const unparsedTokenData = localStorage.getItem("keystatic-cloud-access-token");
  let tokenData;
  try {
    tokenData = storedTokenSchema.parse(JSON.parse(unparsedTokenData));
  } catch (err) {
    return null;
  }
  if (!tokenData || tokenData.validUntil < /* @__PURE__ */ new Date() || tokenData.project !== config2.cloud.project) {
    return null;
  }
  return {
    accessToken: tokenData.token
  };
}
async function getAuth(config2) {
  const token2 = getSyncAuth(config2);
  if (config2.storage.kind === "github" && !token2) {
    try {
      const res = await fetch("/api/keystatic/github/refresh-token", {
        method: "POST"
      });
      if (res.status === 200) {
        const cookies = (0, import_cookie.parse)(document.cookie);
        const accessToken = cookies["keystatic-gh-access-token"];
        if (accessToken) {
          return {
            accessToken
          };
        }
      }
    } catch {
    }
    return null;
  }
  return token2;
}
var SidebarFooter_viewer = lib_default2`
  fragment SidebarFooter_viewer on User {
    id
    name
    login
    avatarUrl
    databaseId
  }
`;
var ViewerContext = (0, import_react73.createContext)(void 0);
function useViewer() {
  return (0, import_react73.useContext)(ViewerContext);
}
function parseRepoConfig(repo) {
  if (typeof repo === "string") {
    const [owner, name2] = repo.split("/");
    return {
      owner,
      name: name2
    };
  }
  return repo;
}
function serializeRepoConfig(repo) {
  if (typeof repo === "string") {
    return repo;
  }
  return `${repo.owner}/${repo.name}`;
}
function assertValidRepoConfig(repo) {
  if (typeof repo === "string") {
    if (!repo.includes("/")) {
      throw new Error(`Invalid repo config: ${repo}. It must be in the form owner/name`);
    }
  }
  if (typeof repo === "object") {
    if (!repo.owner && !repo.name) {
      throw new Error(`Invalid repo config: owner and name are missing`);
    }
    if (!repo.owner) {
      throw new Error(`Invalid repo config: owner is missing`);
    }
    if (!repo.name) {
      throw new Error(`Invalid repo config: name is missing`);
    }
  }
}
function scopeEntriesWithPathPrefix(tree2, config2) {
  const prefix3 = getPathPrefix(config2.storage);
  if (!prefix3)
    return tree2;
  const newEntries = [];
  for (const entry of tree2.entries.values()) {
    if (entry.path.startsWith(prefix3)) {
      newEntries.push({
        ...entry,
        path: entry.path.slice(prefix3.length)
      });
    }
  }
  return {
    entries: new Map(newEntries.map((entry) => [entry.path, entry])),
    tree: treeEntriesToTreeNodes(newEntries)
  };
}
function fetchLocalTree(sha) {
  if (treeCache.has(sha)) {
    return treeCache.get(sha);
  }
  const promise = fetch("/api/keystatic/tree", {
    headers: {
      "no-cors": "1"
    }
  }).then((x3) => x3.json()).then(async (entries) => hydrateTreeCacheWithEntries(entries));
  treeCache.set(sha, promise);
  return promise;
}
function useSetTreeSha() {
  return (0, import_react73.useContext)(SetTreeShaContext);
}
var SetTreeShaContext = (0, import_react73.createContext)(() => {
  throw new Error("SetTreeShaContext not set");
});
function LocalAppShellProvider(props) {
  const [currentTreeSha, setCurrentTreeSha] = (0, import_react73.useState)("initial");
  const tree2 = useData((0, import_react73.useCallback)(() => fetchLocalTree(currentTreeSha), [currentTreeSha]));
  const allTreeData = (0, import_react73.useMemo)(() => ({
    unscopedDefault: tree2,
    scoped: {
      default: tree2,
      current: tree2,
      merged: mergeDataStates({
        default: tree2,
        current: tree2
      })
    }
  }), [tree2]);
  const changedData = (0, import_react73.useMemo)(() => {
    if (allTreeData.scoped.merged.kind !== "loaded") {
      return {
        collections: /* @__PURE__ */ new Map(),
        singletons: /* @__PURE__ */ new Set()
      };
    }
    return getChangedData(props.config, allTreeData.scoped.merged.data);
  }, [allTreeData, props.config]);
  return (0, import_jsx_runtime76.jsx)(SetTreeShaContext.Provider, {
    value: setCurrentTreeSha,
    children: (0, import_jsx_runtime76.jsx)(ChangedContext.Provider, {
      value: changedData,
      children: (0, import_jsx_runtime76.jsx)(TreeContext.Provider, {
        value: allTreeData,
        children: props.children
      })
    })
  });
}
var cloudInfoSchema = z.object({
  user: z.object({
    name: z.string(),
    email: z.string(),
    avatarUrl: z.string().optional()
  }),
  project: z.object({
    name: z.string()
  }),
  team: z.object({
    name: z.string(),
    slug: z.string(),
    images: z.boolean()
  })
});
var CloudInfo = (0, import_react73.createContext)(null);
function useCloudInfo() {
  const context = (0, import_react73.useContext)(CloudInfo);
  return context === "unauthorized" ? null : context;
}
function useRawCloudInfo() {
  return (0, import_react73.useContext)(CloudInfo);
}
function CloudInfoProvider(props) {
  const data = useData((0, import_react73.useCallback)(async () => {
    var _props$config$cloud, _getCloudAuth;
    if (!((_props$config$cloud = props.config.cloud) !== null && _props$config$cloud !== void 0 && _props$config$cloud.project))
      throw new Error("no cloud project set");
    const token2 = (_getCloudAuth = getCloudAuth(props.config)) === null || _getCloudAuth === void 0 ? void 0 : _getCloudAuth.accessToken;
    if (!token2) {
      return "unauthorized";
    }
    const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/v1/info`, {
      headers: {
        ...KEYSTATIC_CLOUD_HEADERS,
        Authorization: `Bearer ${token2}`
      }
    });
    if (res.status === 401)
      return "unauthorized";
    return cloudInfoSchema.parse(await res.json());
  }, [props.config]));
  return (0, import_jsx_runtime76.jsx)(CloudInfo.Provider, {
    value: data.kind === "loaded" ? data.data : null,
    children: props.children
  });
}
var GitHubAppShellDataContext = (0, import_react73.createContext)(null);
function GitHubAppShellDataProvider(props) {
  const [state] = useQuery({
    query: props.config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
    variables: props.config.storage.kind === "github" ? parseRepoConfig(props.config.storage.repo) : {
      name: "repo-name",
      owner: "repo-owner"
    }
  });
  return (0, import_jsx_runtime76.jsx)(GitHubAppShellDataContext.Provider, {
    value: state,
    children: (0, import_jsx_runtime76.jsx)(ViewerContext.Provider, {
      value: state.data && "viewer" in state.data ? state.data.viewer : void 0,
      children: props.children
    })
  });
}
var writePermissions = /* @__PURE__ */ new Set(["WRITE", "ADMIN", "MAINTAIN"]);
function GitHubAppShellProvider(props) {
  var _repo, _repo3, _defaultBranchRef$tar, _currentBranchRef$tar, _currentBranchRef$tar2, _currentBranchRef$tar3, _repo5, _repo8, _repo9, _currentBranchRef$ass, _repo15, _repo16, _repo17, _data$repository3, _data$repository4, _repo18;
  const router = useRouter();
  const {
    data,
    error: error3
  } = (0, import_react73.useContext)(GitHubAppShellDataContext);
  let repo = data === null || data === void 0 ? void 0 : data.repository;
  if (repo && "viewerPermission" in repo && repo.viewerPermission && !writePermissions.has(repo.viewerPermission) && "forks" in repo) {
    var _repo$forks$nodes$, _repo$forks;
    repo = (_repo$forks$nodes$ = (_repo$forks = repo.forks) === null || _repo$forks === void 0 || (_repo$forks = _repo$forks.nodes) === null || _repo$forks === void 0 ? void 0 : _repo$forks[0]) !== null && _repo$forks$nodes$ !== void 0 ? _repo$forks$nodes$ : repo;
  }
  const defaultBranchRef = (_repo = repo) === null || _repo === void 0 || (_repo = _repo.refs) === null || _repo === void 0 || (_repo = _repo.nodes) === null || _repo === void 0 ? void 0 : _repo.find((x3) => {
    var _repo2;
    return (x3 === null || x3 === void 0 ? void 0 : x3.name) === ((_repo2 = repo) === null || _repo2 === void 0 || (_repo2 = _repo2.defaultBranchRef) === null || _repo2 === void 0 ? void 0 : _repo2.name);
  });
  const currentBranchRef = (_repo3 = repo) === null || _repo3 === void 0 || (_repo3 = _repo3.refs) === null || _repo3 === void 0 || (_repo3 = _repo3.nodes) === null || _repo3 === void 0 ? void 0 : _repo3.find((x3) => (x3 === null || x3 === void 0 ? void 0 : x3.name) === props.currentBranch);
  const defaultBranchTreeSha = (_defaultBranchRef$tar = defaultBranchRef === null || defaultBranchRef === void 0 ? void 0 : defaultBranchRef.target.tree.oid) !== null && _defaultBranchRef$tar !== void 0 ? _defaultBranchRef$tar : null;
  const currentBranchTreeSha = (_currentBranchRef$tar = currentBranchRef === null || currentBranchRef === void 0 ? void 0 : currentBranchRef.target.tree.oid) !== null && _currentBranchRef$tar !== void 0 ? _currentBranchRef$tar : null;
  const baseCommit = (_currentBranchRef$tar2 = currentBranchRef === null || currentBranchRef === void 0 || (_currentBranchRef$tar3 = currentBranchRef.target) === null || _currentBranchRef$tar3 === void 0 ? void 0 : _currentBranchRef$tar3.oid) !== null && _currentBranchRef$tar2 !== void 0 ? _currentBranchRef$tar2 : null;
  const defaultBranchTree = useGitHubTreeData(defaultBranchTreeSha, props.config);
  const currentBranchTree = useGitHubTreeData(currentBranchTreeSha, props.config);
  const allTreeData = (0, import_react73.useMemo)(() => {
    const scopedDefault = mapDataState(defaultBranchTree, (tree2) => scopeEntriesWithPathPrefix(tree2, props.config));
    const scopedCurrent = mapDataState(currentBranchTree, (tree2) => scopeEntriesWithPathPrefix(tree2, props.config));
    return {
      unscopedDefault: currentBranchTree,
      scoped: {
        default: scopedDefault,
        current: scopedCurrent,
        merged: mergeDataStates({
          default: scopedDefault,
          current: scopedCurrent
        })
      }
    };
  }, [currentBranchTree, defaultBranchTree, props.config]);
  const changedData = (0, import_react73.useMemo)(() => {
    if (allTreeData.scoped.merged.kind !== "loaded") {
      return {
        collections: /* @__PURE__ */ new Map(),
        singletons: /* @__PURE__ */ new Set()
      };
    }
    return getChangedData(props.config, allTreeData.scoped.merged.data);
  }, [allTreeData, props.config]);
  (0, import_react73.useEffect)(() => {
    var _error$response, _repo4;
    if ((error3 === null || error3 === void 0 || (_error$response = error3.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
      if (isGitHubConfig(props.config)) {
        window.location.href = `/api/keystatic/github/login?from=${router.params.join("/")}`;
      } else {
        redirectToCloudAuth(router.params.join("/"), props.config);
      }
    }
    if (!((_repo4 = repo) !== null && _repo4 !== void 0 && _repo4.id) && error3 !== null && error3 !== void 0 && error3.graphQLErrors.some((err) => {
      var _err$originalError, _err$originalError2;
      return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === "NOT_FOUND" || (err === null || err === void 0 || (_err$originalError2 = err.originalError) === null || _err$originalError2 === void 0 ? void 0 : _err$originalError2.type) === "FORBIDDEN";
    })) {
      window.location.href = `/api/keystatic/github/repo-not-found?from=${router.params.join("/")}`;
    }
  }, [error3, router, (_repo5 = repo) === null || _repo5 === void 0 ? void 0 : _repo5.id, props.config]);
  const baseInfo = (0, import_react73.useMemo)(() => {
    var _repo$id, _repo6, _repo$isPrivate, _repo7;
    return {
      baseCommit: baseCommit || "",
      repositoryId: (_repo$id = (_repo6 = repo) === null || _repo6 === void 0 ? void 0 : _repo6.id) !== null && _repo$id !== void 0 ? _repo$id : "",
      isPrivate: (_repo$isPrivate = (_repo7 = repo) === null || _repo7 === void 0 ? void 0 : _repo7.isPrivate) !== null && _repo$isPrivate !== void 0 ? _repo$isPrivate : true
    };
  }, [baseCommit, (_repo8 = repo) === null || _repo8 === void 0 ? void 0 : _repo8.id, (_repo9 = repo) === null || _repo9 === void 0 ? void 0 : _repo9.isPrivate]);
  const pullRequestNumber = currentBranchRef === null || currentBranchRef === void 0 || (_currentBranchRef$ass = currentBranchRef.associatedPullRequests.nodes) === null || _currentBranchRef$ass === void 0 || (_currentBranchRef$ass = _currentBranchRef$ass[0]) === null || _currentBranchRef$ass === void 0 ? void 0 : _currentBranchRef$ass.number;
  const branchInfo = (0, import_react73.useMemo)(() => {
    var _repo$defaultBranchRe, _repo10, _repo$id2, _repo11, _repo$refs$nodes$map$, _repo12, _repo13, _repo14, _data$repository$owne, _data$repository, _data$repository$name, _data$repository2;
    return {
      defaultBranch: (_repo$defaultBranchRe = (_repo10 = repo) === null || _repo10 === void 0 || (_repo10 = _repo10.defaultBranchRef) === null || _repo10 === void 0 ? void 0 : _repo10.name) !== null && _repo$defaultBranchRe !== void 0 ? _repo$defaultBranchRe : "",
      currentBranch: props.currentBranch,
      baseCommit: baseCommit || "",
      repositoryId: (_repo$id2 = (_repo11 = repo) === null || _repo11 === void 0 ? void 0 : _repo11.id) !== null && _repo$id2 !== void 0 ? _repo$id2 : "",
      allBranches: (_repo$refs$nodes$map$ = (_repo12 = repo) === null || _repo12 === void 0 || (_repo12 = _repo12.refs) === null || _repo12 === void 0 || (_repo12 = _repo12.nodes) === null || _repo12 === void 0 ? void 0 : _repo12.map((x3) => x3 === null || x3 === void 0 ? void 0 : x3.name).filter(isDefined)) !== null && _repo$refs$nodes$map$ !== void 0 ? _repo$refs$nodes$map$ : [],
      pullRequestNumber,
      branchNameToId: new Map((_repo13 = repo) === null || _repo13 === void 0 || (_repo13 = _repo13.refs) === null || _repo13 === void 0 || (_repo13 = _repo13.nodes) === null || _repo13 === void 0 ? void 0 : _repo13.filter(isDefined).map((x3) => [x3.name, x3.id])),
      branchNameToBaseCommit: new Map((_repo14 = repo) === null || _repo14 === void 0 || (_repo14 = _repo14.refs) === null || _repo14 === void 0 || (_repo14 = _repo14.nodes) === null || _repo14 === void 0 ? void 0 : _repo14.flatMap((x3) => x3 !== null && x3 !== void 0 && x3.target ? [[x3.name, x3.target.oid]] : [])),
      mainOwner: (_data$repository$owne = data === null || data === void 0 || (_data$repository = data.repository) === null || _data$repository === void 0 ? void 0 : _data$repository.owner.login) !== null && _data$repository$owne !== void 0 ? _data$repository$owne : "",
      mainRepo: (_data$repository$name = data === null || data === void 0 || (_data$repository2 = data.repository) === null || _data$repository2 === void 0 ? void 0 : _data$repository2.name) !== null && _data$repository$name !== void 0 ? _data$repository$name : ""
    };
  }, [(_repo15 = repo) === null || _repo15 === void 0 || (_repo15 = _repo15.defaultBranchRef) === null || _repo15 === void 0 ? void 0 : _repo15.name, (_repo16 = repo) === null || _repo16 === void 0 ? void 0 : _repo16.id, (_repo17 = repo) === null || _repo17 === void 0 || (_repo17 = _repo17.refs) === null || _repo17 === void 0 ? void 0 : _repo17.nodes, props.currentBranch, baseCommit, pullRequestNumber, data === null || data === void 0 || (_data$repository3 = data.repository) === null || _data$repository3 === void 0 ? void 0 : _data$repository3.owner.login, data === null || data === void 0 || (_data$repository4 = data.repository) === null || _data$repository4 === void 0 ? void 0 : _data$repository4.name]);
  return (0, import_jsx_runtime76.jsx)(RepoWithWriteAccessContext.Provider, {
    value: repo && (props.config.storage.kind === "cloud" || "viewerPermission" in repo && (_repo18 = repo) !== null && _repo18 !== void 0 && _repo18.viewerPermission && writePermissions.has(repo.viewerPermission)) ? {
      name: repo.name,
      owner: repo.owner.login
    } : null,
    children: (0, import_jsx_runtime76.jsx)(AppShellErrorContext.Provider, {
      value: error3,
      children: (0, import_jsx_runtime76.jsx)(BranchInfoContext.Provider, {
        value: branchInfo,
        children: (0, import_jsx_runtime76.jsx)(BaseInfoContext.Provider, {
          value: baseInfo,
          children: (0, import_jsx_runtime76.jsx)(ChangedContext.Provider, {
            value: changedData,
            children: (0, import_jsx_runtime76.jsx)(TreeContext.Provider, {
              value: allTreeData,
              children: props.children
            })
          })
        })
      })
    })
  });
}
var AppShellErrorContext = (0, import_react73.createContext)(void 0);
var BaseInfoContext = (0, import_react73.createContext)({
  baseCommit: "",
  repositoryId: "",
  isPrivate: true
});
var ChangedContext = (0, import_react73.createContext)({
  collections: /* @__PURE__ */ new Map(),
  singletons: /* @__PURE__ */ new Set()
});
var TreeContext = (0, import_react73.createContext)({
  unscopedDefault: {
    kind: "loading"
  },
  scoped: {
    current: {
      kind: "loading"
    },
    default: {
      kind: "loading"
    },
    merged: {
      kind: "loading"
    }
  }
});
function useTree() {
  return (0, import_react73.useContext)(TreeContext).scoped;
}
function useCurrentUnscopedTree() {
  return (0, import_react73.useContext)(TreeContext).unscopedDefault;
}
function useChanged() {
  return (0, import_react73.useContext)(ChangedContext);
}
function useBaseCommit() {
  return (0, import_react73.useContext)(BaseInfoContext).baseCommit;
}
function useIsRepoPrivate() {
  return (0, import_react73.useContext)(BaseInfoContext).isPrivate;
}
function useRepositoryId() {
  return (0, import_react73.useContext)(BaseInfoContext).repositoryId;
}
var Ref_base = lib_default2`
  fragment Ref_base on Ref {
    id
    name
    target {
      __typename
      id
      oid
      ... on Commit {
        tree {
          id
          oid
        }
      }
    }
    associatedPullRequests(states: [OPEN], first: 1) {
      nodes {
        id
        number
      }
    }
  }
`;
var BaseRepo = lib_default2`
  fragment Repo_base on Repository {
    id
    isPrivate
    owner {
      id
      login
    }
    name
    defaultBranchRef {
      id
      name
    }
    refs(refPrefix: "refs/heads/", first: 100) {
      nodes {
        ...Ref_base
      }
    }
  }
  ${Ref_base}
`;
var CloudAppShellQuery = lib_default2`
  query CloudAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_base
    }
  }
  ${BaseRepo}
`;
var Repo_ghDirect = lib_default2`
  fragment Repo_ghDirect on Repository {
    id
    ...Repo_base
    viewerPermission
  }
  ${BaseRepo}
`;
var Repo_primary = lib_default2`
  fragment Repo_primary on Repository {
    id
    ...Repo_ghDirect
    forks(affiliations: [OWNER], first: 1) {
      nodes {
        ...Repo_ghDirect
      }
    }
  }
  ${Repo_ghDirect}
`;
var GitHubAppShellQuery = lib_default2`
  query GitHubAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_primary
    }
    viewer {
      ...SidebarFooter_viewer
    }
  }
  ${Repo_primary}
  ${SidebarFooter_viewer}
`;
var treeCache = new lru_cache_default({
  max: 40
});
async function hydrateTreeCacheWithEntries(entries) {
  const data = {
    entries: new Map(entries.map((entry) => [entry.path, entry])),
    tree: treeEntriesToTreeNodes(entries)
  };
  const sha = await treeSha(data.tree);
  treeCache.set(sha, data);
  return data;
}
function fetchGitHubTreeData(sha, config2) {
  const cached = treeCache.get(sha);
  if (cached)
    return cached;
  const promise = getAuth(config2).then((auth) => {
    if (!auth)
      throw new Error("Not authorized");
    return fetch(config2.storage.kind === "github" ? `https://api.github.com/repos/${serializeRepoConfig(config2.storage.repo)}/git/trees/${sha}?recursive=1` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/trees/${sha}`, {
      headers: {
        Authorization: `Bearer ${auth.accessToken}`,
        ...config2.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
      }
    }).then((x3) => x3.json());
  }).then((res) => hydrateTreeCacheWithEntries(res.tree.map(({
    url,
    ...rest
  }) => rest)));
  treeCache.set(sha, promise);
  return promise;
}
function useGitHubTreeData(sha, config2) {
  return useData((0, import_react73.useCallback)(() => sha ? fetchGitHubTreeData(sha, config2) : LOADING, [sha, config2]));
}
var RepoWithWriteAccessContext = (0, import_react73.createContext)(null);
var BranchInfoContext = (0, import_react73.createContext)({
  currentBranch: "",
  allBranches: [],
  defaultBranch: "",
  pullRequestNumber: void 0,
  branchNameToId: /* @__PURE__ */ new Map(),
  branchNameToBaseCommit: /* @__PURE__ */ new Map(),
  mainOwner: "",
  mainRepo: ""
});
function useBranchInfo() {
  return (0, import_react73.useContext)(BranchInfoContext);
}
function getChangedData(config2, trees) {
  var _config$collections, _config$singletons;
  return {
    collections: new Map(Object.keys((_config$collections = config2.collections) !== null && _config$collections !== void 0 ? _config$collections : {}).map((collection2) => {
      const currentBranch = new Map(getEntriesInCollectionWithTreeKey(config2, collection2, trees.current.tree).map((x3) => [x3.slug, x3.key]));
      const defaultBranch = new Map(getEntriesInCollectionWithTreeKey(config2, collection2, trees.default.tree).map((x3) => [x3.slug, x3.key]));
      const changed = /* @__PURE__ */ new Set();
      const added = /* @__PURE__ */ new Set();
      for (const [key, entry] of currentBranch) {
        const defaultBranchEntry = defaultBranch.get(key);
        if (defaultBranchEntry === void 0) {
          added.add(key);
          continue;
        }
        if (entry !== defaultBranchEntry) {
          changed.add(key);
        }
      }
      const removed = new Set([...defaultBranch.keys()].filter((key) => !currentBranch.has(key)));
      return [collection2, {
        removed,
        added,
        changed,
        totalCount: currentBranch.size
      }];
    })),
    singletons: new Set(Object.keys((_config$singletons = config2.singletons) !== null && _config$singletons !== void 0 ? _config$singletons : {}).filter((singleton2) => {
      var _getTreeNodeAtPath, _getTreeNodeAtPath2;
      const singletonPath = getSingletonPath(config2, singleton2);
      return ((_getTreeNodeAtPath = getTreeNodeAtPath(trees.current.tree, singletonPath)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha) !== ((_getTreeNodeAtPath2 = getTreeNodeAtPath(trees.default.tree, singletonPath)) === null || _getTreeNodeAtPath2 === void 0 ? void 0 : _getTreeNodeAtPath2.entry.sha);
    }))
  };
}
var SIDE_PANEL_ID = "keystatic-side-panel";
var MAIN_PANEL_ID = "keystatic-main-panel";
var View = (props) => {
  return (0, import_jsx_runtime76.jsx)(Box, {
    height: "100%",
    minHeight: 0,
    minWidth: 0,
    ...props
  });
};
var ScrollView = (props) => {
  let {
    isDisabled,
    ...otherProps
  } = props;
  return (0, import_jsx_runtime76.jsx)(View, {
    "data-scrollable": isDisabled ? void 0 : true,
    UNSAFE_className: css({
      "&[data-scrollable]": {
        overflowY: "auto",
        WebkitOverflowScrolling: "touch"
      }
    }),
    ...otherProps
  });
};
var NAVIGATION_DIVIDER_KEY = "---";
function config(config2) {
  return config2;
}
function collection(collection2) {
  return collection2;
}
function singleton(collection2) {
  return collection2;
}
var ConfigContext = (0, import_react73.createContext)(null);
function useConfig() {
  const config2 = (0, import_react73.useContext)(ConfigContext);
  if (!config2) {
    throw new Error("ConfigContext.Provider not found");
  }
  return config2;
}
var AppStateContext = (0, import_react73.createContext)({
  basePath: "/keystatic"
});
function useAppState() {
  const appState = (0, import_react73.useContext)(AppStateContext);
  if (!appState) {
    throw new Error("AppStateContext.Provider not found");
  }
  return appState;
}
var ContentPanelContext = (0, import_react73.createContext)("mobile");
var ContentPanelProvider = ContentPanelContext.Provider;
function useContentPanelSize() {
  return (0, import_react73.useContext)(ContentPanelContext);
}
function useContentPanelQuery(options) {
  const sizes = ["mobile", "tablet", "desktop", "wide"];
  const size3 = useContentPanelSize();
  const startIndex = "above" in options ? sizes.indexOf(options.above) + 1 : 0;
  const endIndex = "below" in options ? sizes.indexOf(options.below) - 1 : sizes.length - 1;
  const range = sizes.slice(startIndex, endIndex + 1);
  return range.includes(size3);
}
function useContentPanelState(ref) {
  let [contentSize, setContentSize] = (0, import_react73.useState)("mobile");
  const onResize = () => {
    setContentSize((size3) => {
      let contentPane = ref.current;
      if (!contentPane) {
        return size3;
      }
      if (contentPane.offsetWidth >= breakpoints.wide) {
        return "wide";
      }
      if (contentPane.offsetWidth >= breakpoints.desktop) {
        return "desktop";
      }
      if (contentPane.offsetWidth >= breakpoints.tablet) {
        return "tablet";
      }
      return "mobile";
    });
  };
  $9daab02d461809db$export$683480f191c0e3ea({
    ref,
    onResize
  });
  return contentSize;
}
function useNavItems() {
  var _config$ui;
  let {
    basePath
  } = useAppState();
  let config2 = useConfig();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  let changeMap = useChanged();
  const collectionKeys = Object.keys(config2.collections || {});
  const singletonKeys = Object.keys(config2.singletons || {});
  const items = ((_config$ui = config2.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.navigation) || {
    ...!!collectionKeys.length && {
      [stringFormatter.format("collections")]: collectionKeys
    },
    ...!!singletonKeys.length && {
      [stringFormatter.format("singletons")]: singletonKeys
    }
  };
  const options = {
    basePath,
    changeMap,
    config: config2
  };
  if (Array.isArray(items)) {
    return items.map((key) => populateItemData(key, options));
  }
  return Object.entries(items).map(([section, keys]) => ({
    title: section,
    children: keys.map((key) => populateItemData(key, options))
  }));
}
function populateItemData(key, options) {
  let {
    basePath,
    changeMap,
    config: config2
  } = options;
  if (key === NAVIGATION_DIVIDER_KEY) {
    return {
      isDivider: true
    };
  }
  if (config2.collections && key in config2.collections) {
    const href = `${basePath}/collection/${encodeURIComponent(key)}`;
    const changes = changeMap.collections.get(key);
    const changed = changes ? changes.changed.size + changes.added.size + changes.removed.size : 0;
    const label = config2.collections[key].label;
    return {
      key,
      href,
      label,
      changed,
      entryCount: changes === null || changes === void 0 ? void 0 : changes.totalCount
    };
  }
  if (config2.singletons && key in config2.singletons) {
    const href = `${basePath}/singleton/${encodeURIComponent(key)}`;
    const changed = changeMap.singletons.has(key);
    const label = config2.singletons[key].label;
    return {
      key,
      href,
      label,
      changed
    };
  }
  throw new Error(`Unknown navigation key: "${key}".`);
}
function useBrand() {
  var _config$ui, _config$ui2;
  let {
    colorScheme
  } = useProvider();
  let config2 = useConfig();
  let prefersDark = useMediaQuery("(prefers-color-scheme: dark)");
  let brandMark = (0, import_jsx_runtime76.jsx)(ZapLogo, {});
  let brandName = "Keystatic";
  if ((_config$ui = config2.ui) !== null && _config$ui !== void 0 && (_config$ui = _config$ui.brand) !== null && _config$ui !== void 0 && _config$ui.mark) {
    let BrandMark = config2.ui.brand.mark;
    let resolvedColorScheme = colorScheme === "auto" ? prefersDark ? "dark" : "light" : colorScheme;
    brandMark = (0, import_jsx_runtime76.jsx)(BrandMark, {
      colorScheme: resolvedColorScheme
    });
  }
  if ("repo" in config2.storage) {
    brandName = serializeRepoConfig(config2.storage.repo);
  }
  if (config2.cloud) {
    brandName = config2.cloud.project;
  }
  if ((_config$ui2 = config2.ui) !== null && _config$ui2 !== void 0 && (_config$ui2 = _config$ui2.brand) !== null && _config$ui2 !== void 0 && _config$ui2.name) {
    brandName = config2.ui.brand.name;
  }
  return {
    brandMark,
    brandName
  };
}
function ZapLogo() {
  let id = "brand-mark-gradient";
  let size3 = 24;
  return (0, import_jsx_runtime76.jsxs)("svg", {
    width: size3,
    height: size3,
    viewBox: "0 0 32 32",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [(0, import_jsx_runtime76.jsx)("path", {
      d: "M18 8L14 24L12 32L30 14L18 8Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime76.jsx)("path", {
      d: "M2 18L20 0L18 8L2 18Z",
      fill: "currentColor"
    }), (0, import_jsx_runtime76.jsx)("path", {
      d: "M18 8L2 18L14 24L18 8Z",
      fill: `url(#${id})`
    }), (0, import_jsx_runtime76.jsx)("defs", {
      children: (0, import_jsx_runtime76.jsxs)("linearGradient", {
        id,
        x1: "2",
        y1: "18",
        x2: "20",
        y2: "14",
        gradientUnits: "userSpaceOnUse",
        children: [(0, import_jsx_runtime76.jsx)("stop", {
          stopColor: "currentColor",
          stopOpacity: "0.2"
        }), (0, import_jsx_runtime76.jsx)("stop", {
          offset: "1",
          stopColor: "currentColor"
        })]
      })
    })]
  });
}
var SidebarContext = (0, import_react73.createContext)(null);
function useSidebar() {
  let context = (0, import_react73.useContext)(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be within a SidebarProvider");
  }
  return context;
}
var breakpointNames2 = typedKeys(breakpoints);
function SidebarProvider(props) {
  const matchedBreakpoints = useBreakpoint();
  const state = $fc909762b330b746$export$61c6a8c84e605fb6({
    defaultOpen: matchedBreakpoints.includes("desktop")
  });
  let breakpointIndex = breakpointNames2.indexOf(matchedBreakpoints[0]);
  let previousIndex = usePrevious(breakpointIndex) || 0;
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => {
    let larger = previousIndex < breakpointIndex;
    if (larger && breakpointIndex >= 2) {
      state.open();
    } else if (breakpointIndex < 2) {
      state.close();
    }
  }, [matchedBreakpoints]);
  return (0, import_jsx_runtime76.jsx)(SidebarContext.Provider, {
    value: state,
    children: props.children
  });
}
function SidebarPanel(props) {
  return (0, import_jsx_runtime76.jsx)(Flex, {
    backgroundColor: "surface",
    direction: "column",
    height: "100%",
    children: (0, import_jsx_runtime76.jsx)(SidebarNav, {
      ...props
    })
  });
}
function SidebarHeader() {
  let {
    brandMark,
    brandName
  } = useBrand();
  return (0, import_jsx_runtime76.jsxs)(Flex, {
    alignItems: "center",
    borderBottom: "muted",
    gap: "regular",
    height: "element.large",
    paddingX: "xlarge",
    UNSAFE_className: css({
      // let consumers use "currentColor" in SVG for their brand mark
      color: tokenSchema.color.foreground.neutralEmphasis,
      // ensure that the brand mark doesn't get squashed
      "& :first-child": {
        flexShrink: 0
      }
    }),
    children: [brandMark, (0, import_jsx_runtime76.jsx)(Text, {
      color: "inherit",
      weight: "medium",
      truncate: true,
      children: brandName
    })]
  });
}
function SidebarDialog(props) {
  const state = useSidebar();
  const router = useRouter();
  $4f58c5f72bcf79f7$export$496315a1608d9602(() => {
    state.close();
  }, [router.href]);
  let dialogRef = (0, import_react73.useRef)(null);
  let {
    modalProps,
    underlayProps
  } = $8ac8429251c45e4b$export$dbc0f175b25fb0fb({
    isDismissable: true
  }, state, dialogRef);
  return (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, {
    children: [(0, import_jsx_runtime76.jsx)(Blanket, {
      ...underlayProps,
      isOpen: state.isOpen,
      zIndex: 10
    }), (0, import_jsx_runtime76.jsxs)("div", {
      "data-visible": state.isOpen,
      id: SIDE_PANEL_ID,
      ref: dialogRef,
      ...modalProps,
      // styles
      className: css({
        backgroundColor: tokenSchema.color.background.surface,
        boxShadow: `${tokenSchema.size.shadow.large} ${tokenSchema.color.shadow.regular}`,
        display: "flex",
        flexDirection: "column",
        inset: 0,
        insetInlineEnd: "auto",
        // ensure that there's always enough of gutter for the user to press
        // and exit the sidebar
        maxWidth: `calc(100% - ${tokenSchema.size.element.medium})`,
        minWidth: tokenSchema.size.scale[3e3],
        outline: 0,
        pointerEvents: "none",
        position: "fixed",
        transform: "translateX(-100%)",
        visibility: "hidden",
        zIndex: 10,
        // exit animation
        transition: [transition("transform", {
          easing: "easeIn",
          duration: "short"
          // delay: 'short',
        }), transition("visibility", {
          delay: "regular",
          duration: 0,
          easing: "linear"
        })].join(", "),
        "&[data-visible=true]": {
          transform: "translateX(0)",
          // enter animation
          transition: transition("transform", {
            easing: "easeOut"
          }),
          pointerEvents: "auto",
          visibility: "visible"
        }
      }),
      children: [(0, import_jsx_runtime76.jsx)(SidebarHeader, {}), (0, import_jsx_runtime76.jsx)(SidebarNav, {
        ...props
      }), (0, import_jsx_runtime76.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, {
        onDismiss: state.close
      })]
    })]
  });
}
function SidebarNav(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  const navItems = useNavItems();
  const isCurrent = useIsCurrent();
  return (0, import_jsx_runtime76.jsx)("div", {
    className: css({
      flex: 1,
      overflowY: "auto",
      paddingBlock: tokenSchema.size.space.large,
      paddingInlineEnd: tokenSchema.size.space.large,
      WebkitOverflowScrolling: "touch"
    }),
    children: (0, import_jsx_runtime76.jsxs)(NavList, {
      children: [(0, import_jsx_runtime76.jsx)(NavItem, {
        href: props.hrefBase,
        "aria-current": isCurrent(props.hrefBase, {
          exact: true
        }),
        children: stringFormatter.format("dashboard")
      }), navItems.map((item2) => renderItemOrGroup(item2, isCurrent))]
    })
  });
}
function useIsCurrent() {
  const router = useRouter();
  return (0, import_react73.useCallback)((href, {
    exact = false
  } = {}) => {
    if (exact) {
      return href === router.href ? "page" : void 0;
    }
    return href === router.href || router.href.startsWith(`${href}/`) ? "page" : void 0;
  }, [router.href]);
}
var dividerCount = 0;
function renderItemOrGroup(itemOrGroup, isCurrent) {
  if ("isDivider" in itemOrGroup) {
    return (0, import_jsx_runtime76.jsx)(Divider, {}, dividerCount++);
  }
  if ("children" in itemOrGroup) {
    return (0, import_jsx_runtime76.jsx)(NavGroup, {
      title: itemOrGroup.title,
      children: itemOrGroup.children.map((child) => renderItemOrGroup(child, isCurrent))
    }, itemOrGroup.title);
  }
  let changeElement = (() => {
    if (!itemOrGroup.changed) {
      return null;
    }
    return typeof itemOrGroup.changed === "number" ? (0, import_jsx_runtime76.jsxs)(Badge, {
      tone: "accent",
      marginStart: "auto",
      children: [(0, import_jsx_runtime76.jsx)(Text, {
        children: itemOrGroup.changed
      }), (0, import_jsx_runtime76.jsx)(Text, {
        visuallyHidden: true,
        children: pluralize(itemOrGroup.changed, {
          singular: "change",
          plural: "changes",
          inclusive: false
        })
      })]
    }) : (0, import_jsx_runtime76.jsx)(StatusLight, {
      tone: "accent",
      marginStart: "auto",
      "aria-label": "Changed",
      role: "status"
    });
  })();
  return (0, import_jsx_runtime76.jsxs)(NavItem, {
    href: itemOrGroup.href,
    "aria-current": isCurrent(itemOrGroup.href),
    children: [(0, import_jsx_runtime76.jsx)(Text, {
      truncate: true,
      title: itemOrGroup.label,
      children: itemOrGroup.label
    }), changeElement]
  }, itemOrGroup.key);
}
var PageContext = (0, import_react73.createContext)({
  containerWidth: "medium"
});
var PageRoot = ({
  children,
  containerWidth = "medium"
}) => {
  return (0, import_jsx_runtime76.jsx)(PageContext.Provider, {
    value: {
      containerWidth
    },
    children: (0, import_jsx_runtime76.jsx)(Flex, {
      elementType: "main",
      direction: "column",
      id: MAIN_PANEL_ID,
      flex: true,
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children
    })
  });
};
var PageHeader = ({
  children
}) => {
  const sidebarState = useSidebar();
  const menuButtonRef = (0, import_react73.useRef)(null);
  const {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let icon = sidebarState.isOpen ? panelLeftCloseIcon : panelLeftOpenIcon;
  if (direction === "rtl") {
    icon = sidebarState.isOpen ? panelRightCloseIcon : panelRightOpenIcon;
  }
  return (0, import_jsx_runtime76.jsx)(Box, {
    borderBottom: "muted",
    elementType: "header",
    height: {
      mobile: "element.large",
      tablet: "element.xlarge"
    },
    flexShrink: 0,
    children: (0, import_jsx_runtime76.jsx)(Box, {
      minHeight: 0,
      minWidth: 0,
      paddingX: {
        mobile: "medium",
        tablet: "xlarge",
        desktop: "xxlarge"
      },
      children: (0, import_jsx_runtime76.jsxs)(Flex, {
        alignItems: "center",
        gap: {
          mobile: "small",
          tablet: "regular"
        },
        height: {
          mobile: "element.large",
          tablet: "element.xlarge"
        },
        children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
          prominence: "low",
          "aria-label": "Open app navigation",
          "aria-pressed": sidebarState.isOpen,
          isHidden: sidebarState.isOpen ? {
            above: "tablet"
          } : void 0,
          onPress: sidebarState.toggle,
          ref: menuButtonRef,
          UNSAFE_className: css({
            marginInlineStart: `calc(${tokenSchema.size.space.regular} * -1)`
          }),
          children: (0, import_jsx_runtime76.jsx)(Icon, {
            src: icon
          })
        }), children]
      })
    })
  });
};
var PageBody = ({
  children,
  isScrollable
}) => {
  return (0, import_jsx_runtime76.jsx)(ScrollView, {
    isDisabled: !isScrollable,
    children: (0, import_jsx_runtime76.jsx)(
      PageContainer,
      {
        paddingY: "xxlarge",
        children
      }
    )
  });
};
var PageContainer = (props) => {
  const {
    containerWidth
  } = (0, import_react73.useContext)(PageContext);
  const maxWidth = containerWidth === "none" ? void 0 : `container.${containerWidth}`;
  return (0, import_jsx_runtime76.jsx)(Box, {
    minHeight: 0,
    minWidth: 0,
    maxWidth,
    paddingX: {
      mobile: "medium",
      tablet: "xlarge",
      desktop: "xxlarge"
    },
    ...props
  });
};
var FieldDataError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "FieldDataError";
  }
};
function assertRequired(value2, validation, label) {
  if (value2 === null && validation !== null && validation !== void 0 && validation.isRequired) {
    throw new FieldDataError(`${label} is required`);
  }
}
function basicFormFieldWithSimpleReaderParse(config2) {
  return {
    kind: "form",
    Input: config2.Input,
    defaultValue: config2.defaultValue,
    parse: config2.parse,
    serialize: config2.serialize,
    validate: config2.validate,
    reader: {
      parse(value2) {
        return config2.validate(config2.parse(value2));
      }
    }
  };
}
var arrayValuesToElementKeys = /* @__PURE__ */ new WeakMap();
var counter = 0;
function getKeysForArrayValue(value2) {
  if (!arrayValuesToElementKeys.has(value2)) {
    arrayValuesToElementKeys.set(value2, Array.from({
      length: value2.length
    }, getNewArrayElementKey));
  }
  return arrayValuesToElementKeys.get(value2);
}
function setKeysForArrayValue(value2, elementIds) {
  arrayValuesToElementKeys.set(value2, elementIds);
}
function getNewArrayElementKey() {
  return (counter++).toString();
}
var getInitialPropsValue = _getInitialPropsValue;
function _getInitialPropsValue(schema) {
  switch (schema.kind) {
    case "form":
      return schema.defaultValue();
    case "child":
      return schema.options.kind === "block" ? [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }] : null;
    case "conditional": {
      const defaultValue = schema.discriminant.defaultValue();
      return {
        discriminant: defaultValue,
        value: getInitialPropsValue(schema.values[defaultValue.toString()])
      };
    }
    case "object": {
      const obj = {};
      for (const key of Object.keys(schema.fields)) {
        obj[key] = getInitialPropsValue(schema.fields[key]);
      }
      return obj;
    }
    case "array": {
      return [];
    }
  }
  assertNever(schema);
}
function getInitialPropsValueFromInitializer(schema, initializer) {
  switch (schema.kind) {
    case "form":
      return initializer === void 0 ? schema.defaultValue() : initializer;
    case "child":
      return initializer !== null && initializer !== void 0 ? initializer : schema.options.kind === "block" ? [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }] : null;
    case "conditional": {
      const defaultValue = initializer === void 0 ? schema.discriminant.defaultValue() : initializer.discriminant;
      return {
        discriminant: defaultValue,
        value: getInitialPropsValueFromInitializer(schema.values[defaultValue.toString()], initializer === void 0 ? void 0 : initializer.value)
      };
    }
    case "object": {
      const obj = {};
      for (const key of Object.keys(schema.fields)) {
        obj[key] = getInitialPropsValueFromInitializer(schema.fields[key], initializer === void 0 ? void 0 : initializer[key]);
      }
      return obj;
    }
    case "array": {
      return (initializer !== null && initializer !== void 0 ? initializer : []).map((x3) => getInitialPropsValueFromInitializer(schema.element, x3.value));
    }
  }
  assertNever(schema);
}
function updateValue(schema, currentValue, updater) {
  if (updater === void 0)
    return currentValue;
  switch (schema.kind) {
    case "form":
      return updater;
    case "child":
      return updater;
    case "conditional": {
      return {
        discriminant: updater.discriminant,
        value: updater.discriminant === currentValue.discriminant ? updateValue(schema.values[updater.discriminant.toString()], currentValue.value, updater.value) : getInitialPropsValueFromInitializer(schema.values[updater.discriminant.toString()], updater.value)
      };
    }
    case "object": {
      const obj = {};
      for (const key of Object.keys(schema.fields)) {
        obj[key] = updateValue(schema.fields[key], currentValue[key], updater[key]);
      }
      return obj;
    }
    case "array": {
      const currentArrVal = currentValue;
      const newVal = updater;
      const uniqueKeys = /* @__PURE__ */ new Set();
      for (const x3 of newVal) {
        if (x3.key !== void 0) {
          if (uniqueKeys.has(x3.key)) {
            throw new Error("Array elements must have unique keys");
          }
          uniqueKeys.add(x3.key);
        }
      }
      const keys = newVal.map((x3) => {
        if (x3.key !== void 0)
          return x3.key;
        let elementKey = getNewArrayElementKey();
        while (uniqueKeys.has(elementKey)) {
          elementKey = getNewArrayElementKey();
        }
        uniqueKeys.add(elementKey);
        return elementKey;
      });
      const prevKeys = getKeysForArrayValue(currentArrVal);
      const prevValuesByKey = new Map(currentArrVal.map((value2, i6) => {
        return [prevKeys[i6], value2];
      }));
      const val = newVal.map((x3, i6) => {
        const id = keys[i6];
        if (prevValuesByKey.has(id)) {
          return updateValue(schema.element, prevValuesByKey.get(id), x3.value);
        }
        return getInitialPropsValueFromInitializer(schema.element, x3.value);
      });
      setKeysForArrayValue(val, keys);
      return val;
    }
  }
  assertNever(schema);
}
function getValueAtPropPath(value2, inputPath) {
  const path2 = [...inputPath];
  while (path2.length) {
    const key = path2.shift();
    value2 = value2[key];
  }
  return value2;
}
function traverseProps(schema, value2, visitor, path2 = []) {
  if (schema.kind === "form" || schema.kind === "child") {
    visitor(schema, value2, path2);
    return;
  }
  if (schema.kind === "object") {
    for (const [key, childProp] of Object.entries(schema.fields)) {
      traverseProps(childProp, value2[key], visitor, [...path2, key]);
    }
    visitor(schema, value2, path2);
    return;
  }
  if (schema.kind === "array") {
    for (const [idx, val] of value2.entries()) {
      traverseProps(schema.element, val, visitor, path2.concat(idx));
    }
    return visitor(schema, value2, path2);
  }
  if (schema.kind === "conditional") {
    const discriminant = value2.discriminant;
    visitor(schema, discriminant, path2.concat("discriminant"));
    traverseProps(schema.values[discriminant.toString()], value2.value, visitor, path2.concat("value"));
    visitor(schema, value2, path2);
    return;
  }
  assertNever(schema);
}
function transformProps(schema, value2, visitors, path2 = []) {
  if (schema.kind === "form" || schema.kind === "child") {
    if (visitors[schema.kind]) {
      return visitors[schema.kind](schema, value2, path2);
    }
    return value2;
  }
  if (schema.kind === "object") {
    const val = Object.fromEntries(Object.entries(schema.fields).map(([key, val2]) => {
      return [key, transformProps(val2, value2[key], visitors, [...path2, key])];
    }));
    if (visitors.object) {
      return visitors[schema.kind](schema, val, path2);
    }
    return val;
  }
  if (schema.kind === "array") {
    const val = value2.map((val2, idx) => transformProps(schema.element, val2, visitors, path2.concat(idx)));
    if (visitors.array) {
      return visitors[schema.kind](schema, val, path2);
    }
    return val;
  }
  if (schema.kind === "conditional") {
    const discriminant = transformProps(schema.discriminant, value2.discriminant, visitors, path2.concat("discriminant"));
    const conditionalVal = transformProps(schema.values[discriminant.toString()], value2.value, visitors, path2.concat("value"));
    const val = {
      discriminant,
      value: conditionalVal
    };
    if (visitors.conditional) {
      return visitors[schema.kind](schema, val, path2);
    }
    return val;
  }
  assertNever(schema);
}
function replaceValueAtPropPath(schema, value2, newValue, path2) {
  if (path2.length === 0) {
    return newValue;
  }
  const [key, ...newPath] = path2;
  if (schema.kind === "object") {
    return {
      ...value2,
      [key]: replaceValueAtPropPath(schema.fields[key], value2[key], newValue, newPath)
    };
  }
  if (schema.kind === "conditional") {
    const conditionalValue = value2;
    assert(key === "value");
    return {
      discriminant: conditionalValue.discriminant,
      value: replaceValueAtPropPath(schema.values[key], conditionalValue.value, newValue, newPath)
    };
  }
  if (schema.kind === "array") {
    const prevVal = value2;
    const newVal = [...prevVal];
    setKeysForArrayValue(newVal, getKeysForArrayValue(prevVal));
    newVal[key] = replaceValueAtPropPath(schema.element, newVal[key], newValue, newPath);
    return newVal;
  }
  assert(schema.kind !== "form" && schema.kind !== "child");
  assertNever(schema);
}
var currentlyActiveMarks = /* @__PURE__ */ new Set();
var currentlyDisabledMarks = /* @__PURE__ */ new Set();
var currentLink = null;
function addMarkToChildren(mark, cb) {
  const wasPreviouslyActive = currentlyActiveMarks.has(mark);
  currentlyActiveMarks.add(mark);
  try {
    return cb();
  } finally {
    if (!wasPreviouslyActive) {
      currentlyActiveMarks.delete(mark);
    }
  }
}
function setLinkForChildren(href, cb) {
  if (currentLink !== null) {
    return cb();
  }
  currentLink = href;
  try {
    return cb();
  } finally {
    currentLink = null;
  }
}
function addMarksToChildren(marks, cb) {
  const marksToRemove = /* @__PURE__ */ new Set();
  for (const mark of marks) {
    if (!currentlyActiveMarks.has(mark)) {
      marksToRemove.add(mark);
    }
    currentlyActiveMarks.add(mark);
  }
  try {
    return cb();
  } finally {
    for (const mark of marksToRemove) {
      currentlyActiveMarks.delete(mark);
    }
  }
}
function forceDisableMarkForChildren(mark, cb) {
  const wasPreviouslyDisabled = currentlyDisabledMarks.has(mark);
  currentlyDisabledMarks.add(mark);
  try {
    return cb();
  } finally {
    if (!wasPreviouslyDisabled) {
      currentlyDisabledMarks.delete(mark);
    }
  }
}
function getInlineNodes(text3) {
  const node3 = {
    text: text3
  };
  for (const mark of currentlyActiveMarks) {
    if (!currentlyDisabledMarks.has(mark)) {
      node3[mark] = true;
    }
  }
  if (currentLink !== null) {
    return [{
      text: ""
    }, {
      type: "link",
      href: currentLink,
      children: [node3]
    }, {
      text: ""
    }];
  }
  return [node3];
}
var VariableChildFields = class extends Error {
  constructor() {
    super("There are a variable number of child fields");
  }
};
function findSingleChildField(schema) {
  try {
    const result = _findConstantChildFields(schema, [], /* @__PURE__ */ new Set());
    if (result.length === 1) {
      return result[0];
    }
    return;
  } catch (err) {
    if (err instanceof VariableChildFields) {
      return;
    }
    throw err;
  }
}
function _findConstantChildFields(schema, path2, seenSchemas) {
  if (seenSchemas.has(schema)) {
    return [];
  }
  seenSchemas.add(schema);
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        relativePath: path2,
        options: schema.options,
        kind: "child"
      }];
    case "conditional": {
      if (couldContainChildField(schema)) {
        throw new VariableChildFields();
      }
      return [];
    }
    case "array": {
      if (schema.asChildTag) {
        const child = _findConstantChildFields(schema.element, [], seenSchemas);
        if (child.length > 1) {
          return [];
        }
        return [{
          kind: "array",
          asChildTag: schema.asChildTag,
          field: schema,
          relativePath: path2,
          child: child[0]
        }];
      }
      if (couldContainChildField(schema)) {
        throw new VariableChildFields();
      }
      return [];
    }
    case "object": {
      const paths = [];
      for (const [key, value2] of Object.entries(schema.fields)) {
        paths.push(..._findConstantChildFields(value2, path2.concat(key), seenSchemas));
      }
      return paths;
    }
  }
}
function couldContainChildField(schema, seen = /* @__PURE__ */ new Set()) {
  if (seen.has(schema)) {
    return false;
  }
  seen.add(schema);
  switch (schema.kind) {
    case "form":
      return false;
    case "child":
      return true;
    case "conditional":
      return Object.values(schema.values).some((value2) => couldContainChildField(value2, seen));
    case "object":
      return Object.keys(schema.fields).some((key) => couldContainChildField(schema.fields[key], seen));
    case "array":
      return couldContainChildField(schema.element, seen);
  }
}
function inlineNodeFromMarkdoc(node3) {
  if (node3.type === "inline") {
    return inlineChildrenFromMarkdoc(node3.children);
  }
  if (node3.type === "link") {
    return setLinkForChildren(node3.attributes.href, () => inlineChildrenFromMarkdoc(node3.children));
  }
  if (node3.type === "text") {
    return getInlineNodes(node3.attributes.content);
  }
  if (node3.type === "strong") {
    return addMarkToChildren("bold", () => inlineChildrenFromMarkdoc(node3.children));
  }
  if (node3.type === "code") {
    return addMarkToChildren("code", () => getInlineNodes(node3.attributes.content));
  }
  if (node3.type === "em") {
    return addMarkToChildren("italic", () => inlineChildrenFromMarkdoc(node3.children));
  }
  if (node3.type === "s") {
    return addMarkToChildren("strikethrough", () => inlineChildrenFromMarkdoc(node3.children));
  }
  if (node3.type === "tag") {
    if (node3.tag === "u") {
      return addMarkToChildren("underline", () => inlineChildrenFromMarkdoc(node3.children));
    }
    if (node3.tag === "kbd") {
      return addMarkToChildren("keyboard", () => inlineChildrenFromMarkdoc(node3.children));
    }
    if (node3.tag === "sub") {
      return addMarkToChildren("subscript", () => inlineChildrenFromMarkdoc(node3.children));
    }
    if (node3.tag === "sup") {
      return addMarkToChildren("superscript", () => inlineChildrenFromMarkdoc(node3.children));
    }
  }
  if (node3.type === "softbreak") {
    return getInlineNodes(" ");
  }
  if (node3.type === "hardbreak") {
    return getInlineNodes("\n");
  }
  if (node3.tag === "component-inline-prop" && Array.isArray(node3.attributes.propPath) && node3.attributes.propPath.every((x3) => typeof x3 === "string" || typeof x3 === "number")) {
    return {
      type: "component-inline-prop",
      children: inlineFromMarkdoc(node3.children),
      propPath: node3.attributes.propPath
    };
  }
  throw new Error(`Unknown inline node type: ${node3.type}`);
}
function inlineChildrenFromMarkdoc(nodes) {
  return nodes.flatMap(inlineNodeFromMarkdoc);
}
function inlineFromMarkdoc(nodes) {
  const transformedNodes = nodes.flatMap(inlineNodeFromMarkdoc);
  const nextNodes = [];
  let lastNode;
  for (const [idx, node3] of transformedNodes.entries()) {
    var _lastNode;
    if (node3.type === void 0 && node3.text === "" && ((_lastNode = lastNode) === null || _lastNode === void 0 ? void 0 : _lastNode.type) === void 0 && idx !== transformedNodes.length - 1) {
      continue;
    }
    nextNodes.push(node3);
    lastNode = node3;
  }
  if (!nextNodes.length) {
    nextNodes.push({
      text: ""
    });
  }
  return nextNodes;
}
function fromMarkdoc(node3, componentBlocks) {
  const nodes = node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks));
  if (nodes.length === 0) {
    return [{
      type: "paragraph",
      children: [{
        text: ""
      }]
    }];
  }
  if (nodes[nodes.length - 1].type !== "paragraph") {
    nodes.push({
      type: "paragraph",
      children: [{
        text: ""
      }]
    });
  }
  return nodes;
}
function fromMarkdocNode(node3, componentBlocks) {
  if (node3.type === "blockquote") {
    return {
      type: "blockquote",
      children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
    };
  }
  if (node3.type === "fence") {
    const {
      language,
      content,
      ...rest
    } = node3.attributes;
    return {
      type: "code",
      children: [{
        text: content.replace(/\n$/, "")
      }],
      ...typeof language === "string" ? {
        language
      } : {},
      ...rest
    };
  }
  if (node3.type === "heading") {
    return {
      ...node3.attributes,
      level: node3.attributes.level,
      type: "heading",
      children: inlineFromMarkdoc(node3.children)
    };
  }
  if (node3.type === "list") {
    return {
      type: node3.attributes.ordered ? "ordered-list" : "unordered-list",
      children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
    };
  }
  if (node3.type === "item") {
    var _node$children$;
    const children = [{
      type: "list-item-content",
      children: node3.children.length ? inlineFromMarkdoc([node3.children[0]]) : [{
        text: ""
      }]
    }];
    if (((_node$children$ = node3.children[1]) === null || _node$children$ === void 0 ? void 0 : _node$children$.type) === "list") {
      const list2 = node3.children[1];
      children.push({
        type: list2.attributes.ordered ? "ordered-list" : "unordered-list",
        children: list2.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
      });
    }
    return {
      type: "list-item",
      children
    };
  }
  if (node3.type === "paragraph") {
    if (node3.children.length === 1 && node3.children[0].type === "inline" && node3.children[0].children.length === 1 && node3.children[0].children[0].type === "image") {
      var _image$attributes$tit;
      const image2 = node3.children[0].children[0];
      return {
        type: "image",
        src: decodeURI(image2.attributes.src),
        alt: image2.attributes.alt,
        title: (_image$attributes$tit = image2.attributes.title) !== null && _image$attributes$tit !== void 0 ? _image$attributes$tit : "",
        children: [{
          text: ""
        }]
      };
    }
    const children = inlineFromMarkdoc(node3.children);
    if (children.length === 1 && children[0].type === "component-inline-prop") {
      return children[0];
    }
    return {
      type: "paragraph",
      children,
      textAlign: node3.attributes.textAlign
    };
  }
  if (node3.type === "hr") {
    return {
      type: "divider",
      children: [{
        text: ""
      }]
    };
  }
  if (node3.type === "table") {
    return {
      type: "table",
      children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
    };
  }
  if (node3.type === "tbody") {
    return {
      type: "table-body",
      children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
    };
  }
  if (node3.type === "thead") {
    if (!node3.children.length)
      return [];
    return {
      type: "table-head",
      children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
    };
  }
  if (node3.type === "tr") {
    return {
      type: "table-row",
      children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
    };
  }
  if (node3.type === "td") {
    return {
      type: "table-cell",
      children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
    };
  }
  if (node3.type === "th") {
    return {
      type: "table-cell",
      header: true,
      children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
    };
  }
  if (node3.type === "tag") {
    if (node3.tag === "table") {
      return fromMarkdocNode(node3.children[0], componentBlocks);
    }
    if (node3.tag === "layout") {
      return {
        type: "layout",
        layout: node3.attributes.layout,
        children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
      };
    }
    if (node3.tag === "layout-area") {
      return {
        type: "layout-area",
        children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
      };
    }
    if (node3.tag === "component-block") {
      return {
        type: "component-block",
        component: node3.attributes.component,
        props: node3.attributes.props,
        children: node3.children.length === 0 ? [{
          type: "component-inline-prop",
          children: [{
            text: ""
          }]
        }] : node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
      };
    }
    if (node3.tag === "component-block-prop" && Array.isArray(node3.attributes.propPath) && node3.attributes.propPath.every((x3) => typeof x3 === "string" || typeof x3 === "number")) {
      return {
        type: "component-block-prop",
        children: node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks)),
        propPath: node3.attributes.propPath
      };
    }
    if (node3.tag) {
      const componentBlock = componentBlocks[node3.tag];
      if (componentBlock) {
        const singleChildField = findSingleChildField({
          kind: "object",
          fields: componentBlock.schema
        });
        if (singleChildField) {
          const newAttributes = JSON.parse(JSON.stringify(node3.attributes));
          const children = [];
          toChildrenAndProps$1(node3.children, children, newAttributes, singleChildField, [], componentBlocks);
          return {
            type: "component-block",
            component: node3.tag,
            props: newAttributes,
            children
          };
        }
        return {
          type: "component-block",
          component: node3.tag,
          props: node3.attributes,
          children: node3.children.length === 0 ? [{
            type: "component-inline-prop",
            children: [{
              text: ""
            }]
          }] : node3.children.flatMap((x3) => fromMarkdocNode(x3, componentBlocks))
        };
      }
    }
    throw new Error(`Unknown tag: ${node3.tag}`);
  }
  return inlineNodeFromMarkdoc(node3);
}
function toChildrenAndProps$1(fromMarkdoc2, resultingChildren, value2, singleChildField, parentPropPath, componentBlocks) {
  if (singleChildField.kind === "child") {
    const children = fromMarkdoc2.flatMap((x3) => fromMarkdocNode(x3, componentBlocks));
    resultingChildren.push({
      type: `component-${singleChildField.options.kind}-prop`,
      propPath: [...parentPropPath, ...singleChildField.relativePath],
      children
    });
  }
  if (singleChildField.kind === "array") {
    const arr = [];
    for (let [idx, child] of fromMarkdoc2.entries()) {
      if (child.type === "paragraph") {
        child = child.children[0].children[0];
      }
      if (child.type !== "tag") {
        throw new Error(`expected tag ${singleChildField.asChildTag}, found type: ${child.type}`);
      }
      if (child.tag !== singleChildField.asChildTag) {
        throw new Error(`expected tag ${singleChildField.asChildTag}, found tag: ${child.tag}`);
      }
      const attributes = JSON.parse(JSON.stringify(child.attributes));
      if (singleChildField.child) {
        toChildrenAndProps$1(child.children, resultingChildren, attributes, singleChildField.child, [...parentPropPath, ...singleChildField.relativePath, idx], componentBlocks);
      }
      arr.push(attributes);
    }
    const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];
    const parent = getValueAtPropPath(value2, singleChildField.relativePath.slice(0, -1));
    parent[key] = arr;
  }
}
function areArraysEqual(a3, b2) {
  return a3.length === b2.length && a3.every((x3, i6) => x3 === b2[i6]);
}
function normalizeTextBasedOnInlineMarksAndSoftBreaks([node3, path2], editor, inlineMarks2, softBreaks) {
  const marksToRemove = Object.keys(node3).filter((x3) => x3 !== "text" && x3 !== "insertMenu" && inlineMarks2[x3] !== true);
  if (marksToRemove.length) {
    Transforms.unsetNodes(editor, marksToRemove, {
      at: path2
    });
    return true;
  }
  if (!softBreaks) {
    const hasSoftBreaks = node3.text.includes("\n");
    if (hasSoftBreaks) {
      const [parentNode] = Editor.parent(editor, path2);
      if (parentNode.type !== "code") {
        for (const position2 of Editor.positions(editor, {
          at: path2
        })) {
          const character2 = Node3.get(editor, position2.path).text[position2.offset];
          if (character2 === "\n") {
            Transforms.delete(editor, {
              at: position2
            });
            return true;
          }
        }
      }
    }
  }
  return false;
}
function normalizeInlineBasedOnLinks([node3, path2], editor, links) {
  if (node3.type === "link" && !links) {
    Transforms.insertText(editor, ` (${node3.href})`, {
      at: Editor.end(editor, path2)
    });
    Transforms.unwrapNodes(editor, {
      at: path2
    });
    return true;
  }
  return false;
}
function normalizeElementBasedOnDocumentFeatures([node3, path2], editor, {
  formatting,
  dividers,
  layouts,
  links,
  images,
  tables
}) {
  if (node3.type === "heading" && (!formatting.headings.levels.length || !formatting.headings.levels.includes(node3.level)) || node3.type === "ordered-list" && !formatting.listTypes.ordered || node3.type === "unordered-list" && !formatting.listTypes.unordered || node3.type === "code" && !formatting.blockTypes.code || node3.type === "blockquote" && !formatting.blockTypes.blockquote || node3.type === "image" && !images || node3.type === "table" && !tables || node3.type === "layout" && (layouts.length === 0 || !layouts.some((layout) => areArraysEqual(layout, node3.layout)))) {
    Transforms.unwrapNodes(editor, {
      at: path2
    });
    return true;
  }
  if ((node3.type === "paragraph" || node3.type === "heading") && (!formatting.alignment.center && node3.textAlign === "center" || !formatting.alignment.end && node3.textAlign === "end" || "textAlign" in node3 && node3.textAlign !== "center" && node3.textAlign !== "end")) {
    Transforms.unsetNodes(editor, "textAlign", {
      at: path2
    });
    return true;
  }
  if (node3.type === "divider" && !dividers) {
    Transforms.removeNodes(editor, {
      at: path2
    });
    return true;
  }
  return normalizeInlineBasedOnLinks([node3, path2], editor, links);
}
function withDocumentFeaturesNormalization(documentFeatures, editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([node3, path2]) => {
    if (Text2.isText(node3)) {
      normalizeTextBasedOnInlineMarksAndSoftBreaks([node3, path2], editor, documentFeatures.formatting.inlineMarks, documentFeatures.formatting.softBreaks);
    } else if (Element2.isElement(node3)) {
      normalizeElementBasedOnDocumentFeatures([node3, path2], editor, documentFeatures);
    }
    normalizeNode([node3, path2]);
  };
  return editor;
}
function getSrcPrefix(publicPath, slug) {
  return typeof publicPath === "string" ? `${publicPath.replace(/\/*$/, "")}/${slug === void 0 ? "" : slug + "/"}` : "";
}
function deserializeFiles(nodes, componentBlocks, files, otherFiles, mode, documentFeatures, slug) {
  return nodes.map((node3) => {
    if (node3.type === "component-block") {
      const componentBlock = componentBlocks[node3.component];
      if (!componentBlock)
        return node3;
      const schema = object(componentBlock.schema);
      return {
        ...node3,
        props: deserializeProps(schema, node3.props, files, otherFiles, mode, slug)
      };
    }
    if (node3.type === "image" && typeof node3.src === "string" && mode === "edit") {
      var _ref;
      const prefix3 = getSrcPrefixForImageBlock(documentFeatures, slug);
      const filename = node3.src.slice(prefix3.length);
      const content = (_ref = typeof documentFeatures.images === "object" && typeof documentFeatures.images.directory === "string" ? otherFiles.get(fixPath(documentFeatures.images.directory)) : files) === null || _ref === void 0 ? void 0 : _ref.get(filename);
      if (!content) {
        return {
          type: "paragraph",
          children: [{
            text: `Missing image ${filename}`
          }]
        };
      }
      return {
        type: "image",
        src: {
          filename,
          content
        },
        alt: node3.alt,
        title: node3.title,
        children: [{
          text: ""
        }]
      };
    }
    if (typeof node3.type === "string") {
      const children = deserializeFiles(node3.children, componentBlocks, files, otherFiles, mode, documentFeatures, slug);
      return {
        ...node3,
        children
      };
    }
    return node3;
  });
}
function deserializeProps(schema, value2, files, otherFiles, mode, slug) {
  return transformProps(schema, value2, {
    form: (schema2, value3) => {
      if (schema2.formKind === "asset") {
        var _otherFiles$get;
        if (mode === "read") {
          return schema2.reader.parse(value3);
        }
        const filename = schema2.filename(value3, {
          slug,
          suggestedFilenamePrefix: void 0
        });
        return schema2.parse(value3, {
          asset: filename ? schema2.directory ? (_otherFiles$get = otherFiles.get(schema2.directory)) === null || _otherFiles$get === void 0 ? void 0 : _otherFiles$get.get(filename) : files.get(filename) : void 0,
          slug
        });
      }
      if (schema2.formKind === "content") {
        throw new Error("Not implemented");
      }
      if (mode === "read") {
        return schema2.reader.parse(value3);
      }
      return schema2.parse(value3, void 0);
    }
  });
}
function getSrcPrefixForImageBlock(documentFeatures, slug) {
  return getSrcPrefix(typeof documentFeatures.images === "object" ? documentFeatures.images.publicPath : void 0, slug);
}
function serializeProps(rootValue, rootSchema, slugField, slug, shouldSuggestFilenamePrefix) {
  const extraFiles = [];
  return {
    value: transformProps(rootSchema, rootValue, {
      form(schema, value2, propPath) {
        if (propPath.length === 1 && slugField === propPath[0]) {
          if (schema.formKind !== "slug") {
            throw new Error("slugField is a not a slug field");
          }
          return schema.serializeWithSlug(value2).value;
        }
        if (schema.formKind === "asset") {
          const {
            asset,
            value: forYaml
          } = schema.serialize(value2, {
            suggestedFilenamePrefix: shouldSuggestFilenamePrefix ? getPropPathPortion(propPath, rootSchema, rootValue) : void 0,
            slug
          });
          if (asset) {
            extraFiles.push({
              path: asset.filename,
              contents: asset.content,
              parent: schema.directory
            });
          }
          return forYaml;
        }
        if (schema.formKind === "content") {
          const {
            other,
            external,
            content,
            value: forYaml
          } = schema.serialize(value2, {
            slug
          });
          if (content) {
            extraFiles.push({
              path: getPropPathPortion(propPath, rootSchema, rootValue) + schema.contentExtension,
              contents: content,
              parent: void 0
            });
          }
          for (const [key, contents] of other) {
            extraFiles.push({
              path: getPropPathPortion(propPath, rootSchema, rootValue) + "/" + key,
              contents,
              parent: void 0
            });
          }
          const allowedDirectories = new Set(schema.directories);
          for (const [directory, contents] of external) {
            if (!allowedDirectories.has(directory)) {
              throw new Error(`Invalid directory ${directory} in content field serialization`);
            }
            for (const [filename, fileContents] of contents) {
              extraFiles.push({
                path: filename,
                contents: fileContents,
                parent: directory
              });
            }
          }
          return forYaml;
        }
        return schema.serialize(value2).value;
      },
      object(_schema, value2) {
        return Object.fromEntries(Object.entries(value2).filter(([_2, val]) => val !== void 0));
      },
      array(_schema, value2) {
        return value2.map((val) => val === void 0 ? null : val);
      },
      child() {
        return void 0;
      }
    }),
    extraFiles
  };
}
function getPropPathPortion(path2, schema, value2) {
  const end = [];
  for (const portion of path2) {
    if (schema.kind === "array") {
      value2 = value2[portion];
      if (schema.slugField && schema.element.kind === "object") {
        const slug = getSlugFromState({
          schema: schema.element.fields,
          slugField: schema.slugField
        }, value2);
        end.push(slug);
      } else {
        end.push(portion);
      }
      schema = schema.element;
      continue;
    }
    end.push(portion);
    if (schema.kind === "object") {
      value2 = value2[portion];
      schema = schema.fields[portion];
      continue;
    }
    if (schema.kind === "conditional") {
      if (portion === "discriminant") {
        schema = schema.discriminant;
      } else if (portion === "value") {
        schema = schema.values[value2.discriminant];
      }
      value2 = value2[portion];
      continue;
    }
    throw new Error(`unexpected ${schema.kind}`);
  }
  return end.join("/");
}
function toInline(nodes) {
  return new ast_default.Node("inline", {}, nodes.flatMap(toMarkdocInline));
}
var markToMarkdoc = {
  bold: {
    type: "strong"
  },
  code: {
    type: "code"
  },
  italic: {
    type: "em"
  },
  underline: {
    type: "tag",
    tag: "u"
  },
  keyboard: {
    type: "tag",
    tag: "kbd"
  },
  strikethrough: {
    type: "s"
  },
  subscript: {
    type: "tag",
    tag: "sub"
  },
  superscript: {
    type: "tag",
    tag: "sup"
  }
};
function toMarkdocInline(node3) {
  if (node3.type === "link") {
    return new ast_default.Node("link", {
      href: node3.href
    }, node3.children.flatMap(toMarkdocInline));
  }
  if (node3.type !== void 0) {
    throw new Error(`unexpected inline node type: ${node3.type}`);
  }
  const marks = Object.keys(node3).filter((mark) => mark !== "text" && mark !== "code").sort();
  let markdocNode = node3.code ? new ast_default.Node("code", {
    content: node3.text
  }, []) : new ast_default.Node("text", {
    content: node3.text
  });
  for (const mark of marks) {
    const config2 = markToMarkdoc[mark];
    if (config2) {
      markdocNode = new ast_default.Node(config2.type, {}, [markdocNode], config2.tag);
    }
  }
  return markdocNode;
}
function toMarkdocDocument(nodes, _config) {
  const extraFiles = [];
  const config2 = {
    ..._config,
    extraFiles
  };
  const node3 = new ast_default.Node("document", {}, nodes.flatMap((x3) => toMarkdoc(x3, config2)));
  return {
    node: node3,
    extraFiles
  };
}
function toChildrenAndProps(childrenAsMarkdoc, resultingChildren, value2, singleChildField) {
  if (singleChildField.kind === "child") {
    const child = childrenAsMarkdoc.find((x3) => areArraysEqual(x3.propPath, singleChildField.relativePath));
    if (child) {
      resultingChildren.push(...child.children);
    }
    return;
  }
  if (singleChildField.kind === "array") {
    const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];
    const parent = getValueAtPropPath(value2, singleChildField.relativePath.slice(0, -1));
    const valueAtPropPath = parent[key];
    delete parent[key];
    const childNodes = /* @__PURE__ */ new Map();
    for (const child of childrenAsMarkdoc) {
      const innerPropPath = child.propPath.slice(singleChildField.relativePath.length + 1);
      const num = child.propPath[singleChildField.relativePath.length];
      if (childNodes.get(num) === void 0) {
        childNodes.set(num, []);
      }
      childNodes.get(num).push({
        children: child.children,
        propPath: innerPropPath
      });
    }
    resultingChildren.push(...valueAtPropPath.map((x3, i6) => {
      var _childNodes$get;
      const newChildrenAsMarkdoc = (_childNodes$get = childNodes.get(i6)) !== null && _childNodes$get !== void 0 ? _childNodes$get : [];
      const children = [];
      toChildrenAndProps(newChildrenAsMarkdoc, children, x3, singleChildField.child);
      return new ast_default.Node("tag", x3, children, singleChildField.asChildTag);
    }));
  }
}
function toMarkdoc(node3, config2) {
  if (node3.type === "paragraph") {
    const markdocNode = new ast_default.Node("paragraph", node3.textAlign ? {
      textAlign: node3.textAlign
    } : {}, [toInline(node3.children)]);
    if (node3.textAlign) {
      markdocNode.annotations.push({
        name: "textAlign",
        value: node3.textAlign,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  if (node3.type === "image") {
    config2.extraFiles.push({
      contents: node3.src.content,
      path: node3.src.filename,
      parent: typeof config2.documentFeatures.images === "object" && typeof config2.documentFeatures.images.directory === "string" ? fixPath(config2.documentFeatures.images.directory) : void 0
    });
    return new ast_default.Node("paragraph", {}, [new ast_default.Node("inline", {}, [new ast_default.Node("image", {
      src: encodeURI(`${getSrcPrefixForImageBlock(config2.documentFeatures, config2.slug)}${node3.src.filename}`),
      alt: node3.alt,
      title: node3.title
    })])]);
  }
  if (node3.type === "code") {
    const extraAttributes = {};
    const {
      children,
      language,
      type: type2,
      ...rest
    } = node3;
    const schema = typeof config2.documentFeatures.formatting.blockTypes.code === "object" ? config2.documentFeatures.formatting.blockTypes.code.schema : void 0;
    if (schema && Object.keys(schema.fields).length > 0) {
      const serialized = serializeProps(getInitialPropsValueFromInitializer(schema, rest), schema, void 0, config2.slug, false);
      Object.assign(extraAttributes, serialized.value);
      config2.extraFiles.push(...serialized.extraFiles);
    }
    let content = children[0].text + "\n";
    const markdocNode = new ast_default.Node("fence", {
      content,
      language,
      ...extraAttributes
    }, [new ast_default.Node("text", {
      content
    })]);
    for (const [key, value2] of Object.entries(extraAttributes)) {
      markdocNode.annotations.push({
        name: key,
        value: value2,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  const _toMarkdoc = (node4) => toMarkdoc(node4, config2);
  if (node3.type === "blockquote") {
    return new ast_default.Node("blockquote", {}, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "divider") {
    return new ast_default.Node("hr");
  }
  if (node3.type === "table") {
    const head = node3.children.find((x3) => x3.type === "table-head");
    return new ast_default.Node("tag", {}, [new ast_default.Node("table", {}, [new ast_default.Node("thead", {}, head ? head.children.map(_toMarkdoc) : []), _toMarkdoc(node3.children.find((x3) => x3.type === "table-body"))])], "table");
  }
  if (node3.type === "table-body") {
    return new ast_default.Node("tbody", {}, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "table-row") {
    return new ast_default.Node("tr", {}, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "table-cell") {
    return new ast_default.Node(node3.header ? "th" : "td", {}, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "heading") {
    const extraAttributes = {};
    if (node3.textAlign) {
      extraAttributes.textAlign = node3.textAlign;
    }
    const {
      children,
      level,
      textAlign,
      type: type2,
      ...rest
    } = node3;
    const schema = config2.documentFeatures.formatting.headings.schema;
    if (Object.keys(schema.fields).length > 0) {
      Object.assign(extraAttributes, serializeProps(getInitialPropsValueFromInitializer(schema, rest), schema, void 0, config2.slug, false).value);
    }
    const markdocNode = new ast_default.Node("heading", {
      level: node3.level,
      ...extraAttributes
    }, [toInline(node3.children)]);
    for (const [key, value2] of Object.entries(extraAttributes)) {
      markdocNode.annotations.push({
        name: key,
        value: value2,
        type: "attribute"
      });
    }
    return markdocNode;
  }
  if (node3.type === "ordered-list") {
    return new ast_default.Node("list", {
      ordered: true
    }, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "unordered-list") {
    return new ast_default.Node("list", {
      ordered: false
    }, node3.children.map(_toMarkdoc));
  }
  if (node3.type === "layout") {
    return new ast_default.Node("tag", {
      layout: node3.layout
    }, node3.children.map(_toMarkdoc), "layout");
  }
  if (node3.type === "layout-area") {
    return new ast_default.Node("tag", {}, node3.children.flatMap(_toMarkdoc), "layout-area");
  }
  if (node3.type === "component-block") {
    const isVoid = node3.children.length === 1 && node3.children[0].type === "component-inline-prop" && node3.children[0].propPath === void 0;
    const componentBlock = config2.componentBlocks[node3.component];
    const childrenAsMarkdoc = [];
    for (const child of node3.children) {
      if ((child.type === "component-block-prop" || child.type === "component-inline-prop") && child.propPath !== void 0) {
        childrenAsMarkdoc.push({
          type: child.type,
          propPath: child.propPath,
          children: child.type === "component-block-prop" ? child.children.flatMap(_toMarkdoc) : [toInline(child.children)]
        });
      }
    }
    let attributes = node3.props;
    if (componentBlock) {
      const serialized = serializeProps(node3.props, {
        kind: "object",
        fields: componentBlock.schema
      }, void 0, config2.slug, false);
      attributes = serialized.value;
      config2.extraFiles.push(...serialized.extraFiles);
      const singleChildField = findSingleChildField({
        kind: "object",
        fields: componentBlock.schema
      });
      if (singleChildField) {
        const children2 = [];
        toChildrenAndProps(childrenAsMarkdoc, children2, attributes, singleChildField);
        return new ast_default.Node("tag", attributes, children2, node3.component);
      }
    }
    const children = isVoid ? [] : childrenAsMarkdoc.map((x3) => new ast_default.Node("tag", {
      propPath: x3.propPath
    }, x3.children, x3.type));
    return new ast_default.Node("tag", attributes, children, node3.component);
  }
  if (node3.type === "component-block-prop" || node3.type === "component-inline-prop") {
    return new ast_default.Node("tag", {
      propPath: node3.propPath
    }, node3.type === "component-inline-prop" ? [toInline(node3.children)] : node3.children.flatMap(_toMarkdoc), node3.type);
  }
  if (node3.type === "list-item") {
    const listItemContent = node3.children[0];
    if (listItemContent.type !== "list-item-content") {
      throw new Error("list item content must contain a list-item-content");
    }
    const inline4 = toInline(listItemContent.children);
    const children = [inline4];
    const nestedList = node3.children[1];
    if (nestedList) {
      children.push(toMarkdoc(nestedList, config2));
    }
    return new ast_default.Node("item", {}, children);
  }
  if (node3.type === "list-item-content") {
    throw new Error("list-item-content in unexpected position");
  }
  debugger;
  throw new Error(`unexpected node type: ${node3.type}`);
}
function validateText(val, min, max2, fieldLabel, slugInfo) {
  if (val.length < min) {
    if (min === 1) {
      return `${fieldLabel} must not be empty`;
    } else {
      return `${fieldLabel} must be at least ${min} characters long`;
    }
  }
  if (val.length > max2) {
    return `${fieldLabel} must be no longer than ${max2} characters`;
  }
  if (slugInfo) {
    if (val === "") {
      return `${fieldLabel} must not be empty`;
    }
    if (val === "..") {
      return `${fieldLabel} must not be ..`;
    }
    if (val === ".") {
      return `${fieldLabel} must not be .`;
    }
    if (slugInfo.glob === "**") {
      const split2 = val.split("/");
      if (split2.some((s4) => s4 === "..")) {
        return `${fieldLabel} must not contain ..`;
      }
      if (split2.some((s4) => s4 === ".")) {
        return `${fieldLabel} must not be .`;
      }
    }
    if ((slugInfo.glob === "*" ? /[\\/]/ : /[\\]/).test(val)) {
      return `${fieldLabel} must not contain slashes`;
    }
    if (/^\s|\s$/.test(val)) {
      return `${fieldLabel} must not start or end with spaces`;
    }
    if (slugInfo.slugs.has(val)) {
      return `${fieldLabel} must be unique`;
    }
  }
}
function AddToPathProvider(props) {
  const path2 = (0, import_react73.useContext)(PathContext);
  return (0, import_jsx_runtime76.jsx)(PathContext.Provider, {
    value: (0, import_react73.useMemo)(() => path2.concat(props.part), [path2, props.part]),
    children: props.children
  });
}
var SlugFieldContext = (0, import_react73.createContext)(void 0);
var SlugFieldProvider = SlugFieldContext.Provider;
var PathContext = (0, import_react73.createContext)([]);
var PathContextProvider = PathContext.Provider;
function TextFieldInput(props) {
  const TextFieldComponent = props.multiline ? TextArea : TextField;
  const [blurred, setBlurred] = (0, import_react73.useState)(false);
  const slugContext = (0, import_react73.useContext)(SlugFieldContext);
  const path2 = (0, import_react73.useContext)(PathContext);
  return (0, import_jsx_runtime76.jsx)(TextFieldComponent, {
    label: props.label,
    description: props.description,
    autoFocus: props.autoFocus,
    value: props.value,
    onChange: props.onChange,
    onBlur: () => setBlurred(true),
    errorMessage: props.forceValidation || blurred ? validateText(props.value, props.min, props.max, props.label, path2.length === 1 && (slugContext === null || slugContext === void 0 ? void 0 : slugContext.field) === path2[0] ? slugContext : void 0) : void 0
  });
}
function parseAsNormalField(value2) {
  if (value2 === void 0) {
    return "";
  }
  if (typeof value2 !== "string") {
    throw new FieldDataError("Must be a string");
  }
  return value2;
}
var emptySet = /* @__PURE__ */ new Set();
function text2({
  label,
  defaultValue = "",
  validation: {
    length: {
      max: max2 = Infinity,
      min = 0
    } = {}
  } = {},
  description,
  multiline = false
}) {
  function validate3(value2, slugField) {
    const message = validateText(value2, min, max2, label, slugField);
    if (message !== void 0) {
      throw new FieldDataError(message);
    }
    return value2;
  }
  return {
    kind: "form",
    formKind: "slug",
    Input(props) {
      return (0, import_jsx_runtime76.jsx)(TextFieldInput, {
        label,
        description,
        min,
        max: max2,
        multiline,
        ...props
      });
    },
    defaultValue() {
      return typeof defaultValue === "string" ? defaultValue : defaultValue();
    },
    parse(value2, args) {
      if ((args === null || args === void 0 ? void 0 : args.slug) !== void 0) {
        return args.slug;
      }
      return parseAsNormalField(value2);
    },
    serialize(value2) {
      return {
        value: value2 === "" ? void 0 : value2
      };
    },
    serializeWithSlug(value2) {
      return {
        slug: value2,
        value: void 0
      };
    },
    reader: {
      parse(value2) {
        const parsed = parseAsNormalField(value2);
        return validate3(parsed, void 0);
      },
      parseWithSlug(_value, args) {
        validate3(parseAsNormalField(args.slug), {
          glob: args.glob,
          slugs: emptySet
        });
        return null;
      }
    },
    validate(value2, args) {
      return validate3(value2, args === null || args === void 0 ? void 0 : args.slugField);
    }
  };
}
function ObjectFieldInput({
  schema,
  autoFocus,
  fields,
  forceValidation
}) {
  const firstFocusable = autoFocus ? findFocusableObjectFieldKey(schema) : void 0;
  const inner = (0, import_jsx_runtime76.jsx)(Flex, {
    gap: "xlarge",
    direction: "column",
    children: Object.entries(fields).map(([key, propVal]) => (0, import_jsx_runtime76.jsx)(AddToPathProvider, {
      part: key,
      children: (0, import_jsx_runtime76.jsx)(InnerFormValueContentFromPreviewProps, {
        forceValidation,
        autoFocus: key === firstFocusable,
        ...propVal
      })
    }, key))
  });
  const id = (0, import_react73.useId)();
  if (!schema.label) {
    return inner;
  }
  const labelId = `${id}-label`;
  const descriptionId = `${id}-description`;
  return (0, import_jsx_runtime76.jsxs)(Flex, {
    role: "group",
    gap: "medium",
    marginY: "large",
    "aria-labelledby": labelId,
    "aria-describedby": schema.description ? descriptionId : void 0,
    direction: "column",
    children: [(0, import_jsx_runtime76.jsx)(Text, {
      color: "neutral",
      size: "medium",
      weight: "medium",
      id: labelId,
      children: schema.label
    }), !!schema.description && (0, import_jsx_runtime76.jsx)(Text, {
      id: descriptionId,
      size: "regular",
      color: "neutralSecondary",
      children: schema.description
    }), inner]
  });
}
function findFocusableObjectFieldKey(schema) {
  for (const [key, innerProp] of Object.entries(schema.fields)) {
    const childFocusable = canFieldBeFocused(innerProp);
    if (childFocusable) {
      return key;
    }
  }
  return void 0;
}
function canFieldBeFocused(schema) {
  if (schema.kind === "array" || schema.kind === "conditional" || schema.kind === "form") {
    return true;
  }
  if (schema.kind === "child") {
    return false;
  }
  if (schema.kind === "object") {
    for (const innerProp of Object.values(schema.fields)) {
      if (canFieldBeFocused(innerProp)) {
        return true;
      }
    }
    return false;
  }
  assertNever(schema);
}
function ConditionalFieldInput({
  schema,
  autoFocus,
  discriminant,
  onChange,
  value: value2,
  forceValidation
}) {
  const schemaDiscriminant = schema.discriminant;
  return (0, import_jsx_runtime76.jsxs)(Flex, {
    gap: "xlarge",
    direction: "column",
    children: [(0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsx)(AddToPathProvider, {
      part: "discriminant",
      children: (0, import_jsx_runtime76.jsx)(schemaDiscriminant.Input, {
        autoFocus: !!autoFocus,
        value: discriminant,
        onChange,
        forceValidation
      })
    }), [autoFocus, schemaDiscriminant, discriminant, onChange, forceValidation]), (0, import_jsx_runtime76.jsx)(AddToPathProvider, {
      part: "value",
      children: (0, import_jsx_runtime76.jsx)(InnerFormValueContentFromPreviewProps, {
        forceValidation,
        ...value2
      })
    })]
  });
}
function castToMemoizedInfoForSchema(val) {
  return val;
}
function getOrInsert(map2, key, val) {
  if (!map2.has(key)) {
    map2.set(key, val(key));
  }
  return map2.get(key);
}
var childFieldData = /* @__PURE__ */ new WeakMap();
function storeChildFieldData(value2) {
  let key = {};
  childFieldData.set(key, value2);
  return key;
}
function getChildFieldData(props) {
  const val = childFieldData.get(props._);
  if (!val) {
    throw new Error("expected child field data to exist");
  }
  return val;
}
function createGetPreviewProps(rootSchema, rootOnChange, getChildFieldElement) {
  const memoizedInfoForSchema = castToMemoizedInfoForSchema({
    form(schema, onChange) {
      return (newVal) => onChange(() => newVal);
    },
    array(schema, onChange) {
      return {
        rawOnChange: onChange,
        inner: /* @__PURE__ */ new Map(),
        onChange(updater) {
          onChange((value2) => updateValue(schema, value2, updater));
        }
      };
    },
    child(schema, onChange) {
      return (newVal) => onChange(() => newVal);
    },
    conditional(schema, onChange) {
      return {
        onChange: (discriminant, value2) => onChange((val) => updateValue(schema, val, {
          discriminant,
          value: value2
        })),
        onChangeForValue: (cb) => onChange((val) => ({
          discriminant: val.discriminant,
          value: cb(val.value)
        }))
      };
    },
    object(schema, onChange) {
      return {
        onChange: (updater) => {
          onChange((value2) => updateValue(schema, value2, updater));
        },
        innerOnChanges: Object.fromEntries(Object.keys(schema.fields).map((key) => {
          return [key, (newVal) => {
            onChange((val) => ({
              ...val,
              [key]: newVal(val[key])
            }));
          }];
        }))
      };
    }
  });
  const previewPropsFactories = {
    form(schema, value2, onChange) {
      return {
        value: value2,
        onChange,
        schema
      };
    },
    child(schema, value2, onChange, path2) {
      return {
        element: getChildFieldElement(path2),
        schema,
        _: storeChildFieldData({
          value: value2,
          onChange
        })
      };
    },
    object(schema, value2, memoized, path2, getInnerProp) {
      const fields = {};
      for (const key of Object.keys(schema.fields)) {
        fields[key] = getInnerProp(schema.fields[key], value2[key], memoized.innerOnChanges[key], key);
      }
      const previewProps = {
        fields,
        onChange: memoized.onChange,
        schema
      };
      return previewProps;
    },
    array(schema, value2, memoized, path2, getInnerProp) {
      const arrayValue = value2;
      const keys = getKeysForArrayValue(arrayValue);
      const unusedKeys = new Set(getKeysForArrayValue(value2));
      const props = {
        elements: arrayValue.map((val, i6) => {
          const key = keys[i6];
          unusedKeys.delete(key);
          const element2 = getOrInsert(memoized.inner, key, () => {
            const onChange = (val2) => {
              memoized.rawOnChange((prev2) => {
                const keys2 = getKeysForArrayValue(prev2);
                const index2 = keys2.indexOf(key);
                const newValue = [...prev2];
                newValue[index2] = val2(newValue[index2]);
                setKeysForArrayValue(newValue, keys2);
                return newValue;
              });
            };
            const element3 = getInnerProp(schema.element, val, onChange, key);
            return {
              element: element3,
              elementWithKey: {
                ...element3,
                key
              },
              onChange
            };
          });
          const currentInnerProp = getInnerProp(schema.element, val, element2.onChange, key);
          if (element2.element !== currentInnerProp) {
            element2.element = currentInnerProp;
            element2.elementWithKey = {
              ...currentInnerProp,
              key
            };
          }
          return element2.elementWithKey;
        }),
        schema,
        onChange: memoized.onChange
      };
      for (const key of unusedKeys) {
        memoized.inner.delete(key);
      }
      return props;
    },
    conditional(schema, value2, memoized, path2, getInnerProp) {
      const props = {
        discriminant: value2.discriminant,
        onChange: memoized.onChange,
        value: getInnerProp(schema.values[value2.discriminant.toString()], value2.value, memoized.onChangeForValue, "value"),
        schema
      };
      return props;
    }
  };
  function getPreviewPropsForProp(schema, value2, memoedThing, path2, getInnerProp) {
    return previewPropsFactories[schema.kind](schema, value2, memoedThing, path2, getInnerProp);
  }
  function getInitialMemoState(schema, value2, onChange, path2) {
    const innerState = /* @__PURE__ */ new Map();
    const memoizedInfo = memoizedInfoForSchema[schema.kind](schema, onChange);
    const state = {
      value: value2,
      inner: innerState,
      props: getPreviewPropsForProp(schema, value2, memoizedInfo, path2, (schema2, value3, onChange2, key) => {
        const state2 = getInitialMemoState(schema2, value3, onChange2, path2.concat(key));
        innerState.set(key, state2);
        return state2.props;
      }),
      schema,
      cached: memoizedInfo
    };
    return state;
  }
  function getUpToDateProps(schema, value2, onChange, memoState2, path2) {
    if (memoState2.schema !== schema) {
      Object.assign(memoState2, getInitialMemoState(schema, value2, onChange, path2));
      return memoState2.props;
    }
    if (memoState2.value === value2) {
      return memoState2.props;
    }
    memoState2.value = value2;
    const unusedKeys = new Set(memoState2.inner.keys());
    memoState2.props = getPreviewPropsForProp(schema, value2, memoState2.cached, path2, (schema2, value3, onChange2, innerMemoStateKey) => {
      unusedKeys.delete(innerMemoStateKey);
      if (!memoState2.inner.has(innerMemoStateKey)) {
        const innerState = getInitialMemoState(schema2, value3, onChange2, path2.concat(innerMemoStateKey));
        memoState2.inner.set(innerMemoStateKey, innerState);
        return innerState.props;
      }
      return getUpToDateProps(schema2, value3, onChange2, memoState2.inner.get(innerMemoStateKey), path2.concat(innerMemoStateKey));
    });
    for (const key of unusedKeys) {
      memoState2.inner.delete(key);
    }
    return memoState2.props;
  }
  let memoState;
  return (value2) => {
    if (memoState === void 0) {
      memoState = getInitialMemoState(rootSchema, value2, rootOnChange, []);
      return memoState.props;
    }
    return getUpToDateProps(rootSchema, value2, rootOnChange, memoState, []);
  };
}
var previewPropsToValueConverter = {
  child(props) {
    const childFieldData2 = getChildFieldData(props);
    return childFieldData2.value;
  },
  form(props) {
    return props.value;
  },
  array(props) {
    const values2 = props.elements.map((x3) => previewPropsToValue(x3));
    setKeysForArrayValue(values2, props.elements.map((x3) => x3.key));
    return values2;
  },
  conditional(props) {
    return {
      discriminant: props.discriminant,
      value: previewPropsToValue(props.value)
    };
  },
  object(props) {
    return Object.fromEntries(Object.entries(props.fields).map(([key, val]) => [key, previewPropsToValue(val)]));
  }
};
function previewPropsToValue(props) {
  return previewPropsToValueConverter[props.schema.kind](props);
}
var valueToUpdaters = {
  child(value2) {
    return value2 !== null && value2 !== void 0 ? value2 : void 0;
  },
  form(value2) {
    return value2;
  },
  array(value2, schema) {
    const keys = getKeysForArrayValue(value2);
    return value2.map((x3, i6) => ({
      key: keys[i6],
      value: valueToUpdater(x3, schema.element)
    }));
  },
  conditional(value2, schema) {
    return {
      discriminant: value2.discriminant,
      value: valueToUpdater(value2.value, schema.values[value2.discriminant.toString()])
    };
  },
  object(value2, schema) {
    return Object.fromEntries(Object.entries(schema.fields).map(([key, schema2]) => [key, valueToUpdater(value2[key], schema2)]));
  }
};
function valueToUpdater(value2, schema) {
  return valueToUpdaters[schema.kind](value2, schema);
}
function setValueToPreviewProps(value2, props) {
  if (isKind(props, "child")) {
    const {
      onChange
    } = getChildFieldData(props);
    onChange(value2);
    return;
  }
  if (isKind(props, "form") || isKind(props, "object") || isKind(props, "array")) {
    props.onChange(valueToUpdater(value2, props.schema));
    return;
  }
  if (isKind(props, "conditional")) {
    const updater = valueToUpdater(value2, props.schema);
    props.onChange(updater.discriminant, updater.value);
    return;
  }
  assertNever(props);
}
function isKind(props, kind) {
  return props.schema.kind === kind;
}
function validateArrayLength(schema, val, path2) {
  var _schema$validation, _schema$validation2;
  if (((_schema$validation = schema.validation) === null || _schema$validation === void 0 || (_schema$validation = _schema$validation.length) === null || _schema$validation === void 0 ? void 0 : _schema$validation.min) !== void 0 && val.length < schema.validation.length.min) {
    return new PropValidationError(new FieldDataError(`Must have at least ${schema.validation.length.min} element${schema.validation.length.min === 1 ? "" : "s"}`), path2, schema);
  }
  if (((_schema$validation2 = schema.validation) === null || _schema$validation2 === void 0 || (_schema$validation2 = _schema$validation2.length) === null || _schema$validation2 === void 0 ? void 0 : _schema$validation2.max) !== void 0 && val.length > schema.validation.length.max) {
    return new PropValidationError(new FieldDataError(`Must have at most ${schema.validation.length.max} element${schema.validation.length.max === 1 ? "" : "s"}}`), path2, schema);
  }
}
var PropValidationError = class extends Error {
  constructor(cause, path2, schema) {
    super(`field error at ${path2.join(".")}`, {
      cause
    });
    this.path = path2;
    this.schema = schema;
    this.cause = cause;
  }
};
function toFormFieldStoredValue(val) {
  if (val === null) {
    return void 0;
  }
  return val;
}
var isArray = Array.isArray;
function parseProps(schema, _value, path2, pathWithArrayFieldSlugs, parseFormField, validateArrayFieldLength) {
  let value2 = toFormFieldStoredValue(_value);
  if (schema.kind === "form") {
    try {
      return parseFormField(schema, value2, path2, pathWithArrayFieldSlugs);
    } catch (err) {
      throw new PropValidationError(err, path2, schema);
    }
  }
  if (schema.kind === "child") {
    return null;
  }
  if (schema.kind === "conditional") {
    if (value2 === void 0) {
      return getInitialPropsValue(schema);
    }
    try {
      if (typeof value2 !== "object" || value2 === null || isArray(value2)) {
        throw new FieldDataError("Must be an object");
      }
      for (const key of Object.keys(value2)) {
        if (key !== "discriminant" && key !== "value") {
          throw new FieldDataError(`Must only contain keys "discriminant" and "value", not "${key}"`);
        }
      }
    } catch (err) {
      throw new PropValidationError(err, path2, schema);
    }
    const parsedDiscriminant = parseProps(schema.discriminant, value2.discriminant, path2.concat("discriminant"), pathWithArrayFieldSlugs.concat("discriminant"), parseFormField, validateArrayFieldLength);
    return {
      discriminant: parsedDiscriminant,
      value: parseProps(schema.values[parsedDiscriminant], value2.value, path2.concat("value"), pathWithArrayFieldSlugs.concat("value"), parseFormField, validateArrayFieldLength)
    };
  }
  if (schema.kind === "object") {
    if (value2 === void 0) {
      value2 = {};
    }
    try {
      if (typeof value2 !== "object" || value2 === null || isArray(value2)) {
        throw new FieldDataError("Must be an object");
      }
      const allowedKeysSet = new Set(Object.keys(schema.fields));
      for (const key of Object.keys(value2)) {
        if (!allowedKeysSet.has(key)) {
          throw new FieldDataError(`Key on object value "${key}" is not allowed`);
        }
      }
    } catch (err) {
      throw new PropValidationError(err, path2, schema);
    }
    const val = {};
    const errors = [];
    for (const key of Object.keys(schema.fields)) {
      let individualVal = value2[key];
      try {
        const propVal = parseProps(schema.fields[key], individualVal, path2.concat(key), pathWithArrayFieldSlugs.concat(key), parseFormField, validateArrayFieldLength);
        val[key] = propVal;
      } catch (err) {
        errors.push(err);
      }
    }
    if (errors.length) {
      throw new AggregateError(errors);
    }
    return val;
  }
  if (schema.kind === "array") {
    if (value2 === void 0) {
      return [];
    }
    try {
      if (!isArray(value2)) {
        throw new FieldDataError("Must be an array");
      }
    } catch (err) {
      throw new PropValidationError(err, path2, schema);
    }
    const errors = [];
    try {
      if (validateArrayFieldLength) {
        const error3 = validateArrayLength(schema, value2, path2);
        if (error3 !== void 0) {
          errors.push(error3);
        }
      }
      return value2.map((innerVal, i6) => {
        try {
          let slug = i6.toString();
          if (schema.slugField && typeof innerVal === "object" && innerVal !== null && !isArray(innerVal)) {
            if (schema.element.kind !== "object") {
              throw new Error("slugField on array fields requires the an object field element");
            }
            const slugField = schema.element.fields[schema.slugField];
            if (!slugField) {
              throw new Error(`slugField "${schema.slugField}" does not exist on object field`);
            }
            if (slugField.kind !== "form") {
              throw new Error(`slugField "${schema.slugField}" is not a form field`);
            }
            if (slugField.formKind !== "slug") {
              throw new Error(`slugField "${schema.slugField}" is not a slug field`);
            }
            let parsedSlugFieldValue;
            try {
              parsedSlugFieldValue = slugField.parse(toFormFieldStoredValue(innerVal[schema.slugField]), void 0);
            } catch (err) {
              throw new AggregateError([err]);
            }
            slug = slugField.serializeWithSlug(parsedSlugFieldValue).slug;
          }
          return parseProps(schema.element, innerVal, path2.concat(i6), pathWithArrayFieldSlugs.concat(slug), parseFormField, validateArrayFieldLength);
        } catch (err) {
          errors.push(err);
        }
      });
    } finally {
      if (errors.length) {
        throw new AggregateError(errors);
      }
    }
  }
  assertNever(schema);
}
function flattenErrors(error3) {
  if (error3 instanceof AggregateError) {
    return error3.errors.flatMap(flattenErrors);
  }
  return [error3];
}
function formatFormDataError(error3) {
  const flatErrors = flattenErrors(error3);
  return flatErrors.map((error4) => {
    if (error4 instanceof PropValidationError) {
      const path2 = error4.path.join(".");
      return `${path2}: ${error4.cause instanceof FieldDataError ? error4.cause.message : `Unexpected error: ${error4.cause}`}`;
    }
    return `Unexpected error: ${error4}`;
  }).join("\n");
}
function toFormattedFormDataError(error3) {
  const formatted = formatFormDataError(error3);
  return new Error(`Field validation failed:
` + formatted);
}
function clientSideValidateProp(schema, value2, slugField) {
  try {
    validateValueWithSchema(schema, value2, slugField);
    return true;
  } catch (error3) {
    console.warn(toFormattedFormDataError(error3));
    return false;
  }
}
function validateValueWithSchema(schema, value2, slugField, path2 = []) {
  switch (schema.kind) {
    case "child": {
      return;
    }
    case "form": {
      try {
        if (slugField && path2[path2.length - 1] === (slugField === null || slugField === void 0 ? void 0 : slugField.field)) {
          schema.validate(value2, {
            slugField: {
              slugs: slugField.slugs,
              glob: slugField.glob
            }
          });
          return;
        }
        schema.validate(value2, void 0);
      } catch (err) {
        throw new PropValidationError(err, path2, schema);
      }
      return;
    }
    case "conditional": {
      schema.discriminant.validate(value2.discriminant);
      validateValueWithSchema(schema.values[value2.discriminant], value2.value, void 0, path2.concat("value"));
      return;
    }
    case "object": {
      const errors = [];
      for (const [key, childProp] of Object.entries(schema.fields)) {
        try {
          validateValueWithSchema(childProp, value2[key], key === (slugField === null || slugField === void 0 ? void 0 : slugField.field) ? slugField : void 0, path2.concat(key));
        } catch (err) {
          errors.push(err);
        }
      }
      if (errors.length > 0) {
        throw new AggregateError(errors);
      }
      return;
    }
    case "array": {
      let slugInfo;
      if (schema.slugField !== void 0 && schema.element.kind === "object") {
        const innerSchema = schema.element.fields;
        const {
          slugField: slugField2
        } = schema;
        slugInfo = {
          slugField: slugField2,
          slugs: value2.map((val2) => getSlugFromState({
            schema: innerSchema,
            slugField: slugField2
          }, val2))
        };
      }
      const errors = [];
      const val = value2;
      const error3 = validateArrayLength(schema, value2, path2);
      if (error3 !== void 0) {
        errors.push(error3);
      }
      for (const [idx, innerVal] of val.entries()) {
        try {
          validateValueWithSchema(schema.element, innerVal, slugInfo === void 0 ? void 0 : {
            field: slugInfo.slugField,
            slugs: new Set(slugInfo.slugs.filter((_2, i6) => idx !== i6)),
            glob: "*"
          }, path2.concat(idx));
        } catch (err) {
          errors.push(err);
        }
      }
      if (errors.length > 0) {
        throw new AggregateError(errors);
      }
      return;
    }
  }
}
function focusWithPreviousSelection(editor) {
  const selection = window.getSelection();
  if (selection) {
    selection.removeAllRanges();
    selection.addRange(ReactEditor.toDOMRange(editor, editor.selection));
  }
  ReactEditor.focus(editor);
}
var blockElementSpacing = css({
  marginBlock: "0.75em",
  "&:first-child": {
    marginBlockStart: 0
  },
  "&:last-child": {
    marginBlockEnd: 0
  }
});
var ForceValidationContext = import_react73.default.createContext(false);
ForceValidationContext.Provider;
function useElementWithSetNodes(editor, element2) {
  const [state, setState] = (0, import_react73.useState)({
    element: element2,
    elementWithChanges: element2
  });
  if (state.element !== element2) {
    setState({
      element: element2,
      elementWithChanges: element2
    });
  }
  const elementRef = (0, import_react73.useRef)(element2);
  (0, import_react73.useEffect)(() => {
    elementRef.current = element2;
  });
  const setNodes = (0, import_react73.useCallback)((changesOrCallback) => {
    const currentElement = elementRef.current;
    const changes = typeof changesOrCallback === "function" ? changesOrCallback(currentElement) : changesOrCallback;
    Transforms.setNodes(editor, changes, {
      at: ReactEditor.findPath(editor, currentElement)
    });
    setState({
      element: currentElement,
      elementWithChanges: {
        ...currentElement,
        ...changes
      }
    });
  }, [editor]);
  return [state.elementWithChanges, setNodes];
}
function useEventCallback(callback) {
  const callbackRef = (0, import_react73.useRef)(callback);
  const cb = (0, import_react73.useCallback)((...args) => {
    return callbackRef.current(...args);
  }, []);
  (0, import_react73.useEffect)(() => {
    callbackRef.current = callback;
  });
  return cb;
}
function insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes) {
  var _pathRefForEmptyNodeA;
  let pathRefForEmptyNodeAtCursor;
  const entry = Editor.above(editor, {
    match: (node3) => node3.type === "heading" || node3.type === "paragraph"
  });
  if (entry && Node3.string(entry[0]) === "") {
    pathRefForEmptyNodeAtCursor = Editor.pathRef(editor, entry[1]);
  }
  Transforms.insertNodes(editor, nodes);
  let path2 = (_pathRefForEmptyNodeA = pathRefForEmptyNodeAtCursor) === null || _pathRefForEmptyNodeA === void 0 ? void 0 : _pathRefForEmptyNodeA.unref();
  if (path2) {
    Transforms.removeNodes(editor, {
      at: path2
    });
    ReactEditor.focus(editor);
  }
}
function ArrayFieldInput(props) {
  const labelId = (0, import_react73.useId)();
  const descriptionId = (0, import_react73.useId)();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  const [modalState, setModalState] = (0, import_react73.useState)({
    state: "closed"
  });
  const onModalChange = (0, import_react73.useCallback)((cb) => {
    setModalState((state) => {
      if (state.state === "open") {
        return {
          state: "open",
          forceValidation: state.forceValidation,
          value: cb(state.value),
          index: state.index
        };
      }
      return state;
    });
  }, [setModalState]);
  const formId = (0, import_react73.useId)();
  const modalStateIndex = modalState.state === "open" ? modalState.index : void 0;
  const slugInfo = (0, import_react73.useMemo)(() => {
    if (props.schema.slugField === void 0 || modalState.state !== "open" || props.schema.element.kind !== "object") {
      return;
    }
    const val = previewPropsToValue(props);
    const schema = props.schema.element.fields;
    const slugField = props.schema.slugField;
    const slugs = new Set(val.filter((x3, i6) => i6 !== modalStateIndex).map((x3) => getSlugFromState({
      schema,
      slugField
    }, x3)));
    return {
      slugs,
      field: slugField,
      glob: "*"
    };
  }, [modalStateIndex, props, modalState.state]);
  return (0, import_jsx_runtime76.jsxs)(Flex, {
    elementType: "section",
    gap: "medium",
    role: "group",
    "aria-labelledby": labelId,
    "aria-describedby": props.schema.description ? descriptionId : void 0,
    direction: "column",
    children: [(0, import_jsx_runtime76.jsx)(FieldLabel, {
      elementType: "h3",
      id: labelId,
      children: props.schema.label
    }), props.schema.description && (0, import_jsx_runtime76.jsx)(Text, {
      id: descriptionId,
      size: "small",
      color: "neutralSecondary",
      children: props.schema.description
    }), (0, import_jsx_runtime76.jsx)(ActionButton, {
      autoFocus: props.autoFocus,
      onPress: () => {
        setModalState({
          state: "open",
          value: getInitialPropsValue(props.schema.element),
          forceValidation: false,
          index: void 0
        });
      },
      alignSelf: "start",
      children: stringFormatter.format("add")
    }), (0, import_jsx_runtime76.jsx)(ArrayFieldListView, {
      ...props,
      labelId,
      onOpenItem: (idx) => {
        console.log(previewPropsToValue(props.elements[idx]));
        setModalState({
          state: "open",
          value: previewPropsToValue(props.elements[idx]),
          forceValidation: false,
          index: idx
        });
      }
    }), (0, import_jsx_runtime76.jsx)(ArrayFieldValidationMessages, {
      ...props
    }), (0, import_jsx_runtime76.jsx)(DialogContainer, {
      onDismiss: () => {
        setModalState({
          state: "closed"
        });
      },
      children: (() => {
        if (modalState.state !== "open" || props.schema.element.kind === "child") {
          return;
        }
        return (0, import_jsx_runtime76.jsxs)(Dialog, {
          children: [(0, import_jsx_runtime76.jsx)(Heading, {
            children: "Edit item"
          }), (0, import_jsx_runtime76.jsx)(Content, {
            children: (0, import_jsx_runtime76.jsx)(Flex, {
              id: formId,
              elementType: "form",
              onSubmit: (event) => {
                if (event.target !== event.currentTarget)
                  return;
                event.preventDefault();
                if (modalState.state !== "open")
                  return;
                if (!clientSideValidateProp(props.schema.element, modalState.value, void 0)) {
                  setModalState((state) => ({
                    ...state,
                    forceValidation: true
                  }));
                  return;
                }
                if (modalState.index === void 0) {
                  props.onChange([...props.elements.map((x3) => ({
                    key: x3.key
                  })), {
                    key: void 0,
                    value: valueToUpdater(modalState.value, props.schema.element)
                  }]);
                } else {
                  setValueToPreviewProps(modalState.value, props.elements[modalState.index]);
                }
                setModalState({
                  state: "closed"
                });
              },
              direction: "column",
              gap: "xxlarge",
              children: (0, import_jsx_runtime76.jsx)(ArrayFieldItemModalContent, {
                onChange: onModalChange,
                schema: props.schema.element,
                value: modalState.value,
                slugField: slugInfo
              })
            })
          }), (0, import_jsx_runtime76.jsxs)(ButtonGroup, {
            children: [(0, import_jsx_runtime76.jsx)(Button, {
              onPress: () => {
                setModalState({
                  state: "closed"
                });
              },
              children: stringFormatter.format("cancel")
            }), (0, import_jsx_runtime76.jsx)(Button, {
              form: formId,
              prominence: "high",
              type: "submit",
              children: modalState.index === void 0 ? stringFormatter.format("add") : "Done"
            })]
          })]
        });
      })()
    })]
  });
}
function ArrayFieldValidationMessages(props) {
  var _props$schema$validat, _props$schema$validat2;
  return (0, import_jsx_runtime76.jsx)(import_jsx_runtime76.Fragment, {
    children: props.forceValidation && (((_props$schema$validat = props.schema.validation) === null || _props$schema$validat === void 0 || (_props$schema$validat = _props$schema$validat.length) === null || _props$schema$validat === void 0 ? void 0 : _props$schema$validat.min) !== void 0 && props.elements.length < props.schema.validation.length.min ? (0, import_jsx_runtime76.jsxs)(FieldMessage, {
      children: ["Must have at least ", props.schema.validation.length.min, " item", props.schema.validation.length.min === 1 ? "" : "s"]
    }) : ((_props$schema$validat2 = props.schema.validation) === null || _props$schema$validat2 === void 0 || (_props$schema$validat2 = _props$schema$validat2.length) === null || _props$schema$validat2 === void 0 ? void 0 : _props$schema$validat2.max) !== void 0 && props.elements.length > props.schema.validation.length.max ? (0, import_jsx_runtime76.jsxs)(FieldMessage, {
      children: ["Must have at most ", props.schema.validation.length.max, " item", props.schema.validation.length.max === 1 ? "" : "s"]
    }) : void 0)
  });
}
function ArrayFieldListView(props) {
  let onMove = (keys, target) => {
    const targetIndex = props.elements.findIndex((x3) => x3.key === target.key);
    if (targetIndex === -1)
      return;
    const allKeys = props.elements.map((x3) => ({
      key: x3.key
    }));
    const indexToMoveTo = target.dropPosition === "before" ? targetIndex : targetIndex + 1;
    const indices = keys.map((key) => allKeys.findIndex((x3) => x3.key === key));
    props.onChange(move(allKeys, indices, indexToMoveTo));
  };
  const dragType = (0, import_react73.useMemo)(() => Math.random().toString(36), []);
  let {
    dragAndDropHooks
  } = useDragAndDrop({
    getItems(keys) {
      return [...keys].map((key) => {
        key = JSON.stringify(key);
        return {
          [dragType]: key,
          "text/plain": key
        };
      });
    },
    getAllowedDropOperations() {
      return ["move", "cancel"];
    },
    async onDrop(e6) {
      if (e6.target.type !== "root" && e6.target.dropPosition !== "on") {
        let keys = [];
        for (let item2 of e6.items) {
          if (item2.kind === "text") {
            let key;
            if (item2.types.has(dragType)) {
              key = JSON.parse(await item2.getText(dragType));
              keys.push(key);
            } else if (item2.types.has("text/plain")) {
              key = await item2.getText("text/plain");
              keys = key.split("\n").map((val) => val.replaceAll('"', ""));
            }
          }
        }
        onMove(keys, e6.target);
      }
    },
    getDropOperation(target) {
      if (target.type === "root" || target.dropPosition === "on") {
        return "cancel";
      }
      return "move";
    }
  });
  const onRemoveKey = useEventCallback((key) => {
    props.onChange(props.elements.map((x3) => ({
      key: x3.key
    })).filter((val) => val.key !== key));
  });
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  return (0, import_jsx_runtime76.jsx)(_ListView, {
    "aria-labelledby": props.labelId,
    items: props.elements,
    dragAndDropHooks,
    height: props.elements.length ? void 0 : "scale.2000",
    renderEmptyState: () => (0, import_jsx_runtime76.jsxs)(Flex, {
      direction: "column",
      gap: "large",
      alignItems: "center",
      justifyContent: "center",
      height: "100%",
      padding: "regular",
      children: [(0, import_jsx_runtime76.jsx)(Text, {
        elementType: "h3",
        align: "center",
        color: "neutralSecondary",
        size: "large",
        weight: "medium",
        children: "Empty list"
      }), (0, import_jsx_runtime76.jsx)(Text, {
        align: "center",
        color: "neutralTertiary",
        children: "Add the first item to see it here."
      })]
    }),
    onAction: (key) => {
      const idx = props.elements.findIndex((x3) => x3.key === key);
      if (idx === -1)
        return;
      props.onOpenItem(idx);
    },
    children: (item2) => {
      var _props$schema$itemLab, _props$schema;
      const label = ((_props$schema$itemLab = (_props$schema = props.schema).itemLabel) === null || _props$schema$itemLab === void 0 ? void 0 : _props$schema$itemLab.call(_props$schema, item2)) || `Item ${props.elements.indexOf(item2) + 1}`;
      return (0, import_jsx_runtime76.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: label,
        children: [(0, import_jsx_runtime76.jsx)(Text, {
          children: label
        }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
          placement: "start",
          children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
            onPress: () => {
              onRemoveKey(item2.key);
            },
            children: (0, import_jsx_runtime76.jsx)(Icon, {
              src: trash2Icon
            })
          }), (0, import_jsx_runtime76.jsx)(Tooltip, {
            tone: "critical",
            children: stringFormatter.format("delete")
          })]
        })]
      }, item2.key);
    }
  });
}
function move(items, indices, toIndex) {
  toIndex -= indices.filter((index2) => index2 < toIndex).length;
  let moves = indices.map((from2) => ({
    from: from2,
    to: toIndex++
  }));
  for (let i6 = 0; i6 < moves.length; i6++) {
    let a3 = moves[i6].from;
    for (let j3 = i6; j3 < moves.length; j3++) {
      let b2 = moves[j3].from;
      if (b2 > a3) {
        moves[j3].from--;
      }
    }
  }
  for (let i6 = 0; i6 < moves.length; i6++) {
    let a3 = moves[i6];
    for (let j3 = moves.length - 1; j3 > i6; j3--) {
      let b2 = moves[j3];
      if (b2.from < a3.to) {
        a3.to++;
      } else {
        b2.from++;
      }
    }
  }
  let copy2 = items.slice();
  for (let move2 of moves) {
    let [item2] = copy2.splice(move2.from, 1);
    copy2.splice(move2.to, 0, item2);
  }
  return copy2;
}
function ArrayFieldItemModalContent(props) {
  const previewProps = (0, import_react73.useMemo)(() => createGetPreviewProps(props.schema, props.onChange, () => void 0), [props.schema, props.onChange])(props.value);
  return (0, import_jsx_runtime76.jsx)(FormValueContentFromPreviewProps, {
    slugField: props.slugField,
    autoFocus: true,
    ...previewProps
  });
}
var tableCellChildren = ["paragraph", "code", "heading", "ordered-list", "unordered-list", "divider", "image"];
var blockquoteChildren = [...tableCellChildren, "table"];
var paragraphLike = [...blockquoteChildren, "blockquote"];
var insideOfLayouts = [...paragraphLike, "component-block"];
function blockContainer(args) {
  return {
    kind: "blocks",
    allowedChildren: new Set(args.allowedChildren),
    blockToWrapInlinesIn: args.allowedChildren[0],
    invalidPositionHandleMode: args.invalidPositionHandleMode
  };
}
function inlineContainer(args) {
  return {
    kind: "inlines",
    invalidPositionHandleMode: args.invalidPositionHandleMode
  };
}
var editorSchema = {
  editor: blockContainer({
    allowedChildren: [...insideOfLayouts, "layout"],
    invalidPositionHandleMode: "move"
  }),
  layout: blockContainer({
    allowedChildren: ["layout-area"],
    invalidPositionHandleMode: "move"
  }),
  "layout-area": blockContainer({
    allowedChildren: insideOfLayouts,
    invalidPositionHandleMode: "unwrap"
  }),
  blockquote: blockContainer({
    allowedChildren: blockquoteChildren,
    invalidPositionHandleMode: "move"
  }),
  paragraph: inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  code: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  divider: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  heading: inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  "component-block": blockContainer({
    allowedChildren: ["component-block-prop", "component-inline-prop"],
    invalidPositionHandleMode: "move"
  }),
  "component-inline-prop": inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  "component-block-prop": blockContainer({
    allowedChildren: insideOfLayouts,
    invalidPositionHandleMode: "unwrap"
  }),
  "ordered-list": blockContainer({
    allowedChildren: ["list-item"],
    invalidPositionHandleMode: "move"
  }),
  "unordered-list": blockContainer({
    allowedChildren: ["list-item"],
    invalidPositionHandleMode: "move"
  }),
  "list-item": blockContainer({
    allowedChildren: ["list-item-content", "ordered-list", "unordered-list"],
    invalidPositionHandleMode: "unwrap"
  }),
  "list-item-content": inlineContainer({
    invalidPositionHandleMode: "unwrap"
  }),
  image: inlineContainer({
    invalidPositionHandleMode: "move"
  }),
  table: blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-head", "table-body"]
  }),
  "table-body": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-row"]
  }),
  "table-row": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-cell"]
  }),
  "table-cell": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: tableCellChildren
  }),
  "table-head": blockContainer({
    invalidPositionHandleMode: "move",
    allowedChildren: ["table-row"]
  })
};
var inlineContainerTypes = new Set(Object.entries(editorSchema).filter(([, value2]) => value2.kind === "inlines").map(([type2]) => type2));
function isInlineContainer(node3) {
  return node3.type !== void 0 && inlineContainerTypes.has(node3.type);
}
var blockTypes = new Set(Object.keys(editorSchema).filter((x3) => x3 !== "editor"));
function isBlock(node3) {
  return blockTypes.has(node3.type);
}
function getWholeDocumentFeaturesForChildField(editorDocumentFeatures, options) {
  var _options$formatting, _options$formatting2, _options$formatting3, _options$formatting4, _options$formatting5, _options$formatting6, _options$formatting7;
  const inlineMarksFromOptions = (_options$formatting = options.formatting) === null || _options$formatting === void 0 ? void 0 : _options$formatting.inlineMarks;
  const inlineMarks2 = Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((_mark) => {
    const mark = _mark;
    return [mark, inlineMarksFromOptions === "inherit" || (inlineMarksFromOptions === null || inlineMarksFromOptions === void 0 ? void 0 : inlineMarksFromOptions[mark]) === "inherit" ? editorDocumentFeatures.formatting.inlineMarks[mark] : false];
  }));
  const headingLevels = (_options$formatting2 = options.formatting) === null || _options$formatting2 === void 0 ? void 0 : _options$formatting2.headingLevels;
  return {
    formatting: {
      inlineMarks: inlineMarks2,
      softBreaks: ((_options$formatting3 = options.formatting) === null || _options$formatting3 === void 0 ? void 0 : _options$formatting3.softBreaks) === "inherit" && editorDocumentFeatures.formatting.softBreaks,
      alignment: {
        center: editorDocumentFeatures.formatting.alignment.center && ((_options$formatting4 = options.formatting) === null || _options$formatting4 === void 0 ? void 0 : _options$formatting4.alignment) === "inherit",
        end: editorDocumentFeatures.formatting.alignment.end && ((_options$formatting5 = options.formatting) === null || _options$formatting5 === void 0 ? void 0 : _options$formatting5.alignment) === "inherit"
      },
      blockTypes: ((_options$formatting6 = options.formatting) === null || _options$formatting6 === void 0 ? void 0 : _options$formatting6.blockTypes) === "inherit" ? editorDocumentFeatures.formatting.blockTypes : {
        blockquote: false,
        code: false
      },
      headings: headingLevels === "inherit" ? editorDocumentFeatures.formatting.headings : {
        levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level) => headingLevels.includes(level)) : [],
        schema: editorDocumentFeatures.formatting.headings.schema
      },
      listTypes: ((_options$formatting7 = options.formatting) === null || _options$formatting7 === void 0 ? void 0 : _options$formatting7.listTypes) === "inherit" ? editorDocumentFeatures.formatting.listTypes : {
        ordered: false,
        unordered: false
      }
    },
    dividers: options.dividers === "inherit" ? editorDocumentFeatures.dividers : false,
    images: options.images === "inherit" && editorDocumentFeatures.images,
    layouts: [],
    links: options.links === "inherit" && editorDocumentFeatures.links,
    tables: options.tables === "inherit" && editorDocumentFeatures.tables
  };
}
function getDocumentFeaturesForChildField(editorDocumentFeatures, options) {
  var _options$formatting8, _options$formatting10, _options$formatting11, _options$formatting12, _options$formatting13, _options$formatting14;
  const inlineMarksFromOptions = (_options$formatting8 = options.formatting) === null || _options$formatting8 === void 0 ? void 0 : _options$formatting8.inlineMarks;
  const inlineMarks2 = inlineMarksFromOptions === "inherit" ? "inherit" : Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((mark) => {
    return [mark, !!(inlineMarksFromOptions || {})[mark]];
  }));
  if (options.kind === "inline") {
    var _options$formatting9;
    return {
      kind: "inline",
      inlineMarks: inlineMarks2,
      documentFeatures: {
        links: options.links === "inherit"
      },
      softBreaks: ((_options$formatting9 = options.formatting) === null || _options$formatting9 === void 0 ? void 0 : _options$formatting9.softBreaks) === "inherit"
    };
  }
  const headingLevels = (_options$formatting10 = options.formatting) === null || _options$formatting10 === void 0 ? void 0 : _options$formatting10.headingLevels;
  return {
    kind: "block",
    inlineMarks: inlineMarks2,
    softBreaks: ((_options$formatting11 = options.formatting) === null || _options$formatting11 === void 0 ? void 0 : _options$formatting11.softBreaks) === "inherit",
    documentFeatures: {
      layouts: [],
      dividers: options.dividers === "inherit" ? editorDocumentFeatures.dividers : false,
      formatting: {
        alignment: ((_options$formatting12 = options.formatting) === null || _options$formatting12 === void 0 ? void 0 : _options$formatting12.alignment) === "inherit" ? editorDocumentFeatures.formatting.alignment : {
          center: false,
          end: false
        },
        blockTypes: ((_options$formatting13 = options.formatting) === null || _options$formatting13 === void 0 ? void 0 : _options$formatting13.blockTypes) === "inherit" ? editorDocumentFeatures.formatting.blockTypes : {
          blockquote: false,
          code: false
        },
        headings: headingLevels === "inherit" ? editorDocumentFeatures.formatting.headings : {
          levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level) => headingLevels.includes(level)) : [],
          schema: editorDocumentFeatures.formatting.headings.schema
        },
        listTypes: ((_options$formatting14 = options.formatting) === null || _options$formatting14 === void 0 ? void 0 : _options$formatting14.listTypes) === "inherit" ? editorDocumentFeatures.formatting.listTypes : {
          ordered: false,
          unordered: false
        }
      },
      links: options.links === "inherit",
      images: options.images === "inherit" ? editorDocumentFeatures.images : false,
      tables: options.tables === "inherit"
    },
    componentBlocks: options.componentBlocks === "inherit"
  };
}
function getSchemaAtPropPathInner(path2, value2, schema) {
  if (path2.length === 0) {
    return schema;
  }
  if (schema.kind === "child" || schema.kind === "form") {
    return;
  }
  if (schema.kind === "conditional") {
    const key = path2.shift();
    if (key === "discriminant") {
      return getSchemaAtPropPathInner(path2, value2.discriminant, schema.discriminant);
    }
    if (key === "value") {
      const propVal = schema.values[value2.discriminant];
      return getSchemaAtPropPathInner(path2, value2.value, propVal);
    }
    return;
  }
  if (schema.kind === "object") {
    const key = path2.shift();
    return getSchemaAtPropPathInner(path2, value2[key], schema.fields[key]);
  }
  if (schema.kind === "array") {
    const index2 = path2.shift();
    return getSchemaAtPropPathInner(path2, value2[index2], schema.element);
  }
  assertNever(schema);
}
function getSchemaAtPropPath(path2, value2, props) {
  return getSchemaAtPropPathInner([...path2], value2, {
    kind: "object",
    fields: props
  });
}
function getAncestorSchemas(rootSchema, path2, value2) {
  const ancestors = [];
  const currentPath = [...path2];
  let currentProp = rootSchema;
  let currentValue = value2;
  while (currentPath.length) {
    ancestors.push(currentProp);
    const key = currentPath.shift();
    if (currentProp.kind === "array") {
      currentProp = currentProp.element;
      currentValue = currentValue[key];
    } else if (currentProp.kind === "conditional") {
      currentProp = currentProp.values[value2.discriminant];
      currentValue = currentValue.value;
    } else if (currentProp.kind === "object") {
      currentValue = currentValue[key];
      currentProp = currentProp.fields[key];
    } else if (currentProp.kind === "child" || currentProp.kind === "form") {
      throw new Error(`unexpected prop "${key}"`);
    } else {
      assertNever(currentProp);
    }
  }
  return ancestors;
}
function getPlaceholderTextForPropPath(propPath, fields, formProps) {
  const field2 = getSchemaAtPropPath(propPath, formProps, fields);
  if ((field2 === null || field2 === void 0 ? void 0 : field2.kind) === "child" && (field2.options.kind === "block" && field2.options.editIn !== "modal" || field2.options.kind === "inline")) {
    return field2.options.placeholder;
  }
  return "";
}
function cloneDescendent(node3) {
  if (Element2.isElement(node3)) {
    return {
      ...node3,
      children: node3.children.map(cloneDescendent)
    };
  }
  return {
    ...node3
  };
}
var allMarks = ["bold", "italic", "underline", "strikethrough", "code", "superscript", "subscript", "keyboard"];
var isElementActive = (editor, format2) => {
  const [match3] = Editor.nodes(editor, {
    match: (n6) => n6.type === format2
  });
  return !!match3;
};
function clearFormatting(editor) {
  Transforms.unwrapNodes(editor, {
    match: (node3) => node3.type === "heading" || node3.type === "blockquote" || node3.type === "code"
  });
  Transforms.unsetNodes(editor, allMarks, {
    match: Text2.isText
  });
}
function moveChildren(editor, parent, to, shouldMoveNode = () => true) {
  const parentPath = Path.isPath(parent) ? parent : parent[1];
  const parentNode = Path.isPath(parent) ? Node3.get(editor, parentPath) : parent[0];
  if (!isBlock(parentNode))
    return;
  for (let i6 = parentNode.children.length - 1; i6 >= 0; i6--) {
    if (shouldMoveNode(parentNode.children[i6], i6)) {
      const childPath = [...parentPath, i6];
      Transforms.moveNodes(editor, {
        at: childPath,
        to
      });
    }
  }
}
function EditorAfterButIgnoringingPointsWithNoContent(editor, at, {
  distance = 1
} = {}) {
  const anchor = Editor.point(editor, at, {
    edge: "end"
  });
  const focus = Editor.end(editor, []);
  const range = {
    anchor,
    focus
  };
  let d5 = 0;
  let target;
  for (const p5 of Editor.positions(editor, {
    at: range
  })) {
    if (d5 > distance) {
      break;
    }
    const node3 = Node3.get(editor, p5.path);
    if (node3.text.length === p5.offset) {
      continue;
    }
    if (d5 !== 0) {
      target = p5;
    }
    d5++;
  }
  return target;
}
function nodeTypeMatcher(...args) {
  if (args.length === 1) {
    const type2 = args[0];
    return (node3) => node3.type === type2;
  }
  const set = new Set(args);
  return (node3) => typeof node3.type === "string" && set.has(node3.type);
}
function getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) {
  const ancestorComponentProp = Editor.above(editor, {
    match: nodeTypeMatcher("component-block-prop", "component-inline-prop")
  });
  if (ancestorComponentProp) {
    const propPath = ancestorComponentProp[0].propPath;
    const ancestorComponent = Editor.parent(editor, ancestorComponentProp[1]);
    if (ancestorComponent[0].type === "component-block") {
      const component = ancestorComponent[0].component;
      const componentBlock = componentBlocks[component];
      if (componentBlock && propPath) {
        const childField = getSchemaAtPropPath(propPath, ancestorComponent[0].props, componentBlock.schema);
        if ((childField === null || childField === void 0 ? void 0 : childField.kind) === "child") {
          return getDocumentFeaturesForChildField(editorDocumentFeatures, childField.options);
        }
      }
    }
  }
}
var isListType2 = (type2) => type2 === "ordered-list" || type2 === "unordered-list";
var isListNode = (node3) => isListType2(node3.type);
function getAncestorList(editor) {
  if (editor.selection) {
    const listItem = Editor.above(editor, {
      match: nodeTypeMatcher("list-item")
    });
    const list2 = Editor.above(editor, {
      match: isListNode
    });
    if (listItem && list2) {
      return {
        isInside: true,
        listItem,
        list: list2
      };
    }
  }
  return {
    isInside: false
  };
}
function withList(editor) {
  const {
    insertBreak,
    normalizeNode,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const ancestorList = getAncestorList(editor);
      if (ancestorList.isInside && Range.isCollapsed(editor.selection) && Editor.isStart(editor, editor.selection.anchor, ancestorList.list[1])) {
        Transforms.unwrapNodes(editor, {
          match: isListNode,
          split: true
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const [listItem] = Editor.nodes(editor, {
      match: (node3) => node3.type === "list-item",
      mode: "lowest"
    });
    if (listItem && Node3.string(listItem[0]) === "") {
      Transforms.unwrapNodes(editor, {
        match: isListNode,
        split: true
      });
      return;
    }
    insertBreak();
  };
  editor.normalizeNode = (entry) => {
    const [node3, path2] = entry;
    if (Element2.isElement(node3) || Editor.isEditor(node3)) {
      const isElementBeingNormalizedAList = isListNode(node3);
      for (const [childNode, childPath] of Node3.children(editor, path2)) {
        const index2 = childPath[childPath.length - 1];
        if (isListNode(childNode)) {
          var _node$children;
          if (((_node$children = node3.children[childPath[childPath.length - 1] + 1]) === null || _node$children === void 0 ? void 0 : _node$children.type) === childNode.type) {
            const siblingNodePath = Path.next(childPath);
            moveChildren(editor, siblingNodePath, [...childPath, childNode.children.length]);
            Transforms.removeNodes(editor, {
              at: siblingNodePath
            });
            return;
          }
          if (isElementBeingNormalizedAList) {
            const previousChild = node3.children[index2 - 1];
            if (Element2.isElement(previousChild)) {
              Transforms.moveNodes(editor, {
                at: childPath,
                to: [...Path.previous(childPath), previousChild.children.length - 1]
              });
            } else {
              Transforms.unwrapNodes(editor, {
                at: childPath
              });
            }
            return;
          }
        }
        if (node3.type === "list-item" && childNode.type !== "list-item-content" && index2 === 0 && isBlock(childNode)) {
          if (path2[path2.length - 1] !== 0) {
            const previousChild = Node3.get(editor, Path.previous(path2));
            if (Element2.isElement(previousChild)) {
              Transforms.moveNodes(editor, {
                at: path2,
                to: [...Path.previous(path2), previousChild.children.length]
              });
              return;
            }
          }
          Transforms.unwrapNodes(editor, {
            at: childPath
          });
          return;
        }
        if (node3.type === "list-item" && childNode.type === "list-item-content" && index2 !== 0) {
          Transforms.splitNodes(editor, {
            at: childPath
          });
          return;
        }
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var ToolbarStateContext = import_react73.default.createContext(null);
function useToolbarState() {
  const toolbarState = (0, import_react73.useContext)(ToolbarStateContext);
  if (!toolbarState) {
    throw new Error("ToolbarStateProvider must be used to use useToolbarState");
  }
  return toolbarState;
}
var createToolbarState = (editor, componentBlocks, editorDocumentFeatures) => {
  const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) || {
    kind: "block",
    inlineMarks: "inherit",
    documentFeatures: {
      dividers: true,
      formatting: {
        alignment: {
          center: true,
          end: true
        },
        blockTypes: {
          blockquote: true,
          code: editorDocumentFeatures.formatting.blockTypes.code
        },
        headings: editorDocumentFeatures.formatting.headings,
        listTypes: {
          ordered: true,
          unordered: true
        }
      },
      layouts: editorDocumentFeatures.layouts,
      links: true,
      images: editorDocumentFeatures.images,
      tables: true
    },
    softBreaks: true,
    componentBlocks: true
  };
  let [maybeCodeBlockEntry] = Editor.nodes(editor, {
    match: (node3) => node3.type !== "code" && isBlock(node3)
  });
  const editorMarks = Editor.marks(editor) || {};
  const marks = Object.fromEntries(allMarks.map((mark) => [mark, {
    isDisabled: locationDocumentFeatures.inlineMarks !== "inherit" && !locationDocumentFeatures.inlineMarks[mark] || !maybeCodeBlockEntry,
    isSelected: !!editorMarks[mark]
  }]));
  if (editor.selection && Range.isExpanded(editor.selection)) {
    for (const node3 of Editor.nodes(editor, {
      match: Text2.isText
    })) {
      for (const key of Object.keys(node3[0])) {
        if (key === "insertMenu" || key === "text") {
          continue;
        }
        if (key in marks) {
          marks[key].isSelected = true;
        }
      }
    }
  }
  let [headingEntry] = Editor.nodes(editor, {
    match: nodeTypeMatcher("heading")
  });
  let [listEntry] = Editor.nodes(editor, {
    match: isListNode
  });
  let [alignableEntry] = Editor.nodes(editor, {
    match: nodeTypeMatcher("paragraph", "heading")
  });
  const listTypeAbove = getListTypeAbove(editor);
  return {
    marks,
    textStyles: {
      selected: headingEntry ? headingEntry[0].level : "normal",
      allowedHeadingLevels: locationDocumentFeatures.kind === "block" && !listEntry ? locationDocumentFeatures.documentFeatures.formatting.headings.levels : []
    },
    code: {
      isSelected: isElementActive(editor, "code"),
      isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)
    },
    lists: {
      ordered: {
        isSelected: isElementActive(editor, "ordered-list") && (listTypeAbove === "none" || listTypeAbove === "ordered-list"),
        isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.listTypes.ordered && !headingEntry)
      },
      unordered: {
        isSelected: isElementActive(editor, "unordered-list") && (listTypeAbove === "none" || listTypeAbove === "unordered-list"),
        isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.listTypes.unordered && !headingEntry)
      }
    },
    alignment: {
      isDisabled: !alignableEntry && !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.alignment),
      selected: (alignableEntry === null || alignableEntry === void 0 ? void 0 : alignableEntry[0].textAlign) || "start"
    },
    blockquote: {
      isDisabled: !(locationDocumentFeatures.kind === "block" && locationDocumentFeatures.documentFeatures.formatting.blockTypes.blockquote),
      isSelected: isElementActive(editor, "blockquote")
    },
    layouts: {
      isSelected: isElementActive(editor, "layout")
    },
    links: {
      isDisabled: !editor.selection || Range.isCollapsed(editor.selection) || !locationDocumentFeatures.documentFeatures.links,
      isSelected: isElementActive(editor, "link")
    },
    editor,
    dividers: {
      isDisabled: locationDocumentFeatures.kind === "inline" || !locationDocumentFeatures.documentFeatures.dividers
    },
    clearFormatting: {
      isDisabled: !(Object.values(marks).some((x3) => x3.isSelected) || !!hasBlockThatClearsOnClearFormatting(editor))
    },
    editorDocumentFeatures
  };
};
function hasBlockThatClearsOnClearFormatting(editor) {
  const [node3] = Editor.nodes(editor, {
    match: (node4) => node4.type === "heading" || node4.type === "code" || node4.type === "blockquote"
  });
  return !!node3;
}
function getListTypeAbove(editor) {
  const listAbove = Editor.above(editor, {
    match: isListNode
  });
  if (!listAbove) {
    return "none";
  }
  return listAbove[0].type;
}
var DocumentEditorConfigContext = (0, import_react73.createContext)(null);
function useDocumentEditorConfig() {
  const context = (0, import_react73.useContext)(DocumentEditorConfigContext);
  if (!context) {
    throw new Error("useDocumentEditorConfig must be used within a DocumentEditorConfigContext.Provider");
  }
  return context;
}
var ToolbarStateProvider = ({
  children,
  componentBlocks,
  editorDocumentFeatures
}) => {
  const editor = useSlate();
  return (0, import_jsx_runtime76.jsx)(DocumentEditorConfigContext.Provider, {
    value: (0, import_react73.useMemo)(() => ({
      componentBlocks,
      documentFeatures: editorDocumentFeatures
    }), [componentBlocks, editorDocumentFeatures]),
    children: (0, import_jsx_runtime76.jsx)(ToolbarStateContext.Provider, {
      value: createToolbarState(editor, componentBlocks, editorDocumentFeatures),
      children
    })
  });
};
var BlockPopoverContext = (0, import_react73.createContext)(null);
function useBlockPopoverContext() {
  const context = (0, import_react73.useContext)(BlockPopoverContext);
  if (!context) {
    throw new Error("useBlockPopoverContext must be used within a BlockPopoverTrigger");
  }
  return context;
}
var typeMatcher = nodeTypeMatcher("code", "component-block", "image", "layout", "link", "table", "heading");
var ActiveBlockPopoverContext = (0, import_react73.createContext)(void 0);
function useActiveBlockPopover() {
  return (0, import_react73.useContext)(ActiveBlockPopoverContext);
}
function ActiveBlockPopoverProvider(props) {
  const nodeWithPopover = Editor.above(props.editor, {
    match: typeMatcher
  });
  return (0, import_jsx_runtime76.jsx)(ActiveBlockPopoverContext.Provider, {
    value: nodeWithPopover === null || nodeWithPopover === void 0 ? void 0 : nodeWithPopover[0],
    children: props.children
  });
}
var BlockPopoverTrigger = ({
  children,
  element: element2
}) => {
  const [trigger2, popover] = children;
  const activePopoverElement = useActiveBlockPopover();
  const triggerRef = (0, import_react73.useRef)(null);
  const state = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: activePopoverElement === element2
  });
  const context = (0, import_react73.useMemo)(() => ({
    state,
    triggerRef
  }), [state, triggerRef]);
  return (0, import_jsx_runtime76.jsxs)(BlockPopoverContext.Provider, {
    value: context,
    children: [(0, import_react73.cloneElement)(trigger2, {
      ref: triggerRef
    }), popover]
  });
};
function BlockPopover(props) {
  const {
    state
  } = useBlockPopoverContext();
  let wrapperRef = (0, import_react73.useRef)(null);
  return (
    /* @ts-expect-error FIXME: resolve ref inconsistencies */
    (0, import_jsx_runtime76.jsx)(Overlay, {
      isOpen: state.isOpen,
      nodeRef: wrapperRef,
      children: (0, import_jsx_runtime76.jsx)(BlockPopoverWrapper, {
        wrapperRef,
        ...props
      })
    })
  );
}
var BlockPopoverWrapper = ({
  children,
  placement: preferredPlacement = "bottom"
}) => {
  let popoverRef = (0, import_react73.useRef)(null);
  let {
    state,
    triggerRef
  } = useBlockPopoverContext();
  let {
    placement,
    popoverProps
  } = useBlockPopover({
    isNonModal: true,
    isKeyboardDismissDisabled: false,
    placement: preferredPlacement,
    triggerRef,
    popoverRef
  }, state);
  return (0, import_jsx_runtime76.jsx)("div", {
    ref: popoverRef,
    ...popoverProps,
    "data-open": state.isOpen,
    "data-placement": placement,
    contentEditable: false,
    className: css({
      backgroundColor: tokenSchema.color.background.surface,
      // TODO: component token?
      borderRadius: tokenSchema.size.radius.medium,
      // TODO: component token?
      border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.emphasis}`,
      boxSizing: "content-box",
      // resolves measurement/scroll issues related to border
      // boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.border.emphasis}`,
      minHeight: tokenSchema.size.element.regular,
      minWidth: tokenSchema.size.element.regular,
      opacity: 0,
      outline: 0,
      pointerEvents: "auto",
      position: "absolute",
      // use filter:drop-shadow instead of box-shadow so the arrow is included
      filter: `drop-shadow(0 1px 4px ${tokenSchema.color.shadow.regular})`,
      // filter bug in safari: https://stackoverflow.com/questions/56478925/safari-drop-shadow-filter-remains-visible-even-with-hidden-element
      willChange: "filter",
      userSelect: "none",
      // placement
      '&[data-placement="top"]': {
        marginBottom: tokenSchema.size.space.regular,
        transform: `translateY(${tokenSchema.size.space.regular})`
      },
      '&[data-placement="bottom"]': {
        marginTop: tokenSchema.size.space.regular,
        transform: `translateY(calc(${tokenSchema.size.space.regular} * -1))`
      },
      '&[data-open="true"]': {
        opacity: 1,
        transform: `translateX(0) translateY(0)`,
        // enter animation
        transition: transition(["opacity", "transform"], {
          easing: "easeOut"
        })
      }
    }),
    children: typeof children === "function" ? children(state.close) : children
  });
};
function useBlockPopover(props, state) {
  var _triggerRef$current2;
  let {
    triggerRef,
    popoverRef,
    isNonModal,
    isKeyboardDismissDisabled,
    ...otherProps
  } = props;
  let [isSticky, setSticky] = (0, import_react73.useState)(false);
  let {
    overlayProps,
    underlayProps
  } = $a11501f3d1d39e6c$export$ea8f71083e90600f({
    isOpen: state.isOpen,
    onClose: state.close,
    shouldCloseOnBlur: true,
    isDismissable: !isNonModal,
    isKeyboardDismissDisabled: false
  }, popoverRef);
  const containerPadding = 8;
  (0, import_react73.useEffect)(() => {
    if (state.isOpen) {
      const checkForStickiness = () => {
        var _popoverRef$current, _triggerRef$current;
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        let popoverRect = (_popoverRef$current = popoverRef.current) === null || _popoverRef$current === void 0 ? void 0 : _popoverRef$current.getBoundingClientRect();
        let triggerRect = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getBoundingClientRect();
        if (popoverRect && triggerRect) {
          setSticky(triggerRect.bottom + popoverRect.height + containerPadding * 2 > vh && triggerRect.top < vh);
        }
      };
      checkForStickiness();
      window.addEventListener("scroll", checkForStickiness);
      return () => {
        checkForStickiness();
        window.removeEventListener("scroll", checkForStickiness);
      };
    }
  }, [popoverRef, triggerRef, state.isOpen]);
  let {
    overlayProps: positionProps,
    arrowProps,
    placement,
    updatePosition
  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1({
    ...otherProps,
    containerPadding,
    shouldFlip: false,
    targetRef: triggerRef,
    overlayRef: popoverRef,
    isOpen: state.isOpen,
    onClose: void 0
  });
  let previousBoundingRect = usePrevious2((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getBoundingClientRect());
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    if (previousBoundingRect) {
      var _triggerRef$current3;
      const currentBoundingRect = (_triggerRef$current3 = triggerRef.current) === null || _triggerRef$current3 === void 0 ? void 0 : _triggerRef$current3.getBoundingClientRect();
      if (currentBoundingRect) {
        const hasChanged = previousBoundingRect.height !== currentBoundingRect.height || previousBoundingRect.width !== currentBoundingRect.width || previousBoundingRect.x !== currentBoundingRect.x || previousBoundingRect.y !== currentBoundingRect.y;
        if (hasChanged) {
          updatePosition();
        }
      }
    }
  }, [previousBoundingRect, triggerRef, updatePosition]);
  if (positionProps.style) {
    positionProps.style.zIndex = 1;
  }
  if (isSticky) {
    positionProps.style = {
      ...positionProps.style,
      // @ts-expect-error
      maxHeight: null,
      position: "fixed",
      // @ts-expect-error
      top: null,
      bottom: containerPadding
    };
  }
  return {
    arrowProps,
    placement,
    popoverProps: $3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, positionProps),
    underlayProps,
    updatePosition
  };
}
function usePrevious2(value2) {
  const ref = (0, import_react73.useRef)();
  (0, import_react73.useEffect)(() => {
    ref.current = value2;
  });
  return ref.current;
}
var BlockWrapper = (props) => {
  let {
    attributes,
    children,
    draggable = false
  } = props;
  return (0, import_jsx_runtime76.jsx)("div", {
    draggable,
    className: blockElementSpacing,
    ...attributes,
    children
  });
};
var NotEditable = (0, import_react73.forwardRef)(function NotEditable2({
  className,
  ...props
}, ref) {
  return (0, import_jsx_runtime76.jsx)("div", {
    ...props,
    ref,
    className: [css({
      userSelect: "none",
      whiteSpace: "initial"
    }), className].join(" "),
    contentEditable: false
  });
});
var ToolbarSeparator = () => {
  return (0, import_jsx_runtime76.jsx)(Divider, {
    orientation: "vertical",
    flexShrink: 0
  });
};
var isLinkActive = (editor) => {
  return isElementActive(editor, "link");
};
var wrapLink = (editor, url) => {
  if (isLinkActive(editor)) {
    Transforms.unwrapNodes(editor, {
      match: (n6) => n6.type === "link"
    });
    return;
  }
  const {
    selection
  } = editor;
  const isCollapsed = selection && Range.isCollapsed(selection);
  if (isCollapsed) {
    Transforms.insertNodes(editor, {
      type: "link",
      href: url,
      children: [{
        text: url
      }]
    });
  } else {
    Transforms.wrapNodes(editor, {
      type: "link",
      href: url,
      children: [{
        text: ""
      }]
    }, {
      split: true
    });
  }
};
var LinkElement = ({
  attributes,
  children,
  element: __elementForGettingPath
}) => {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  const editor = useSlateStatic();
  const [currentElement, setNode] = useElementWithSetNodes(editor, __elementForGettingPath);
  const href = currentElement.href;
  const text3 = Node3.string(currentElement);
  const [dialogOpen, setDialogOpen] = (0, import_react73.useState)(false);
  const activePopoverElement = useActiveBlockPopover();
  const selected = activePopoverElement === __elementForGettingPath;
  (0, import_react73.useEffect)(() => {
    if (selected && !href) {
      setDialogOpen(true);
    }
  }, [href, selected]);
  const unlink = useEventCallback(() => {
    Transforms.unwrapNodes(editor, {
      at: ReactEditor.findPath(editor, __elementForGettingPath)
    });
    ReactEditor.focus(editor);
  });
  return (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, {
    children: [(0, import_jsx_runtime76.jsxs)(BlockPopoverTrigger, {
      element: __elementForGettingPath,
      children: [(0, import_jsx_runtime76.jsx)("a", {
        href,
        ...attributes,
        children
      }), (0, import_jsx_runtime76.jsx)(BlockPopover, {
        placement: "bottom start",
        children: (0, import_jsx_runtime76.jsxs)(Flex, {
          gap: "small",
          padding: "regular",
          children: [(0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => setDialogOpen(true),
              children: (0, import_jsx_runtime76.jsx)(Icon, {
                src: editIcon
              })
            }), (0, import_jsx_runtime76.jsx)(Tooltip, {
              children: stringFormatter.format("edit")
            })]
          }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => {
                window.open(href, "_blank", "noopener,noreferrer");
              },
              children: (0, import_jsx_runtime76.jsx)(Icon, {
                src: externalLinkIcon
              })
            }), (0, import_jsx_runtime76.jsx)(Tooltip, {
              children: (0, import_jsx_runtime76.jsx)(Text, {
                truncate: 3,
                children: href
              })
            })]
          }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
              prominence: "low",
              onPress: unlink,
              children: (0, import_jsx_runtime76.jsx)(Icon, {
                src: unlinkIcon
              })
            }), (0, import_jsx_runtime76.jsx)(Tooltip, {
              children: "Unlink"
            })]
          })]
        })
      })]
    }), (0, import_jsx_runtime76.jsx)(DialogContainer, {
      onDismiss: () => {
        setDialogOpen(false);
        focusWithPreviousSelection(editor);
      },
      children: dialogOpen && (0, import_jsx_runtime76.jsx)(LinkDialog, {
        text: text3,
        href,
        onSubmit: ({
          href: href2
        }) => {
          setNode({
            href: href2
          });
        }
      })
    })]
  });
};
function LinkDialog({
  onSubmit,
  ...props
}) {
  let [href, setHref] = (0, import_react73.useState)(props.href || "");
  let [touched, setTouched] = (0, import_react73.useState)(false);
  let {
    dismiss
  } = useDialogContainer();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  const showInvalidState = touched && !isValidURL(href);
  return (0, import_jsx_runtime76.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime76.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        if (!showInvalidState) {
          dismiss();
          onSubmit({
            href
          });
        }
      },
      children: [(0, import_jsx_runtime76.jsxs)(Heading, {
        children: [props.href ? "Edit" : "Add", " link"]
      }), (0, import_jsx_runtime76.jsx)(Content, {
        children: (0, import_jsx_runtime76.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          children: [(0, import_jsx_runtime76.jsx)(TextField, {
            label: "Text",
            value: props.text,
            isReadOnly: true
          }), (0, import_jsx_runtime76.jsx)(TextField, {
            autoFocus: true,
            isRequired: true,
            onBlur: () => setTouched(true),
            label: "Link",
            onChange: setHref,
            value: href,
            errorMessage: showInvalidState && "Please provide a valid URL."
          })]
        })
      }), (0, import_jsx_runtime76.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime76.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime76.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
var _linkIcon = (0, import_jsx_runtime76.jsx)(Icon, {
  src: linkIcon
});
function LinkButton2() {
  const {
    editor,
    links: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsx)(ActionButton, {
    prominence: "low",
    isDisabled,
    isSelected,
    onPress: () => {
      wrapLink(editor, "");
      ReactEditor.focus(editor);
    },
    children: _linkIcon
  }), [isSelected, isDisabled, editor]);
}
var linkButton = (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime76.jsx)(LinkButton2, {}), (0, import_jsx_runtime76.jsx)(Tooltip, {
    children: (0, import_jsx_runtime76.jsx)(Text, {
      children: "Link"
    })
  })]
});
var values = {
  start: {
    key: "start",
    label: "Align Start",
    icon: (0, import_jsx_runtime76.jsx)(Icon, {
      src: alignLeftIcon
    })
  },
  center: {
    key: "center",
    label: "Align Center",
    icon: (0, import_jsx_runtime76.jsx)(Icon, {
      src: alignCenterIcon
    })
  },
  end: {
    key: "end",
    label: "Align End",
    icon: (0, import_jsx_runtime76.jsx)(Icon, {
      src: alignRightIcon
    })
  }
};
var TextAlignMenu = ({
  alignment
}) => {
  const toolbarState = useToolbarState();
  const items = (0, import_react73.useMemo)(() => [values.start, ...Object.keys(alignment).map((x3) => values[x3])], [alignment]);
  return (0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsxs)(MenuTrigger, {
    children: [(0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime76.jsxs)(ActionButton, {
        prominence: "low",
        children: [values[toolbarState.alignment.selected].icon, (0, import_jsx_runtime76.jsx)(Icon, {
          src: chevronDownIcon
        })]
      }), (0, import_jsx_runtime76.jsx)(Tooltip, {
        children: (0, import_jsx_runtime76.jsx)(Text, {
          children: "Text Alignment"
        })
      })]
    }), (0, import_jsx_runtime76.jsx)(_Menu, {
      selectionMode: "single",
      selectedKeys: [toolbarState.alignment.selected],
      items,
      onAction: (key) => {
        if (key === "start") {
          Transforms.unsetNodes(toolbarState.editor, "textAlign", {
            match: (node3) => node3.type === "paragraph" || node3.type === "heading"
          });
        } else {
          Transforms.setNodes(toolbarState.editor, {
            textAlign: key
          }, {
            match: (node3) => node3.type === "paragraph" || node3.type === "heading"
          });
        }
        ReactEditor.focus(toolbarState.editor);
      },
      children: (item2) => {
        return (0, import_jsx_runtime76.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          children: [(0, import_jsx_runtime76.jsx)(Text, {
            children: item2.label
          }), item2.icon]
        }, item2.key);
      }
    })]
  }), [items, toolbarState.alignment.selected, toolbarState.editor]);
};
var insertBlockquote = (editor) => {
  const isActive = isElementActive(editor, "blockquote");
  if (isActive) {
    Transforms.unwrapNodes(editor, {
      match: (node3) => node3.type === "blockquote"
    });
  } else {
    Transforms.wrapNodes(editor, {
      type: "blockquote",
      children: []
    });
  }
};
var BlockquoteButton = () => {
  const {
    editor,
    blockquote: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsx)(ActionButton, {
    prominence: "low",
    isSelected,
    isDisabled,
    onPress: () => {
      insertBlockquote(editor);
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime76.jsx)(Icon, {
      src: quoteIcon
    })
  }), [editor, isDisabled, isSelected]);
};
var blockquoteButton = (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime76.jsx)(BlockquoteButton, {}), (0, import_jsx_runtime76.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime76.jsx)(Text, {
      children: "Quote"
    }), (0, import_jsx_runtime76.jsx)(Kbd, {
      children: ">⎵"
    })]
  })]
});
function CustomAttributesDialogInner(props) {
  const editor = useSlateStatic();
  const [state, setState] = (0, import_react73.useState)(() => {
    return getInitialPropsValueFromInitializer(props.schema, Object.fromEntries(Object.keys(props.schema.fields).map((key) => [key, props.element[key]])));
  });
  const [forceValidation, setForceValidation] = (0, import_react73.useState)(false);
  const previewProps = (0, import_react73.useMemo)(() => createGetPreviewProps(props.schema, setState, () => void 0), [props.schema])(state);
  let {
    dismiss
  } = useDialogContainer();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  return (0, import_jsx_runtime76.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime76.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        setForceValidation(true);
        if (clientSideValidateProp(props.schema, state, void 0)) {
          dismiss();
          const path2 = ReactEditor.findPath(editor, props.element);
          console.log(state);
          Transforms.setNodes(editor, state, {
            at: path2
          });
        }
      },
      children: [(0, import_jsx_runtime76.jsxs)(Heading, {
        children: [props.nodeLabel, " details"]
      }), (0, import_jsx_runtime76.jsx)(Content, {
        children: (0, import_jsx_runtime76.jsx)(FormValueContentFromPreviewProps, {
          forceValidation,
          autoFocus: true,
          ...previewProps
        })
      }), (0, import_jsx_runtime76.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime76.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime76.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
function CustomAttributesEditButton(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  return (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
      prominence: "low",
      onPress: props.onPress,
      children: (0, import_jsx_runtime76.jsx)(Icon, {
        src: editIcon
      })
    }), (0, import_jsx_runtime76.jsx)(Tooltip, {
      children: stringFormatter.format("edit")
    })]
  });
}
function CustomAttributesDialog(props) {
  const editor = useSlateStatic();
  return (0, import_jsx_runtime76.jsx)(DialogContainer, {
    onDismiss: () => {
      props.onDismiss();
      focusWithPreviousSelection(editor);
    },
    children: props.isOpen && (0, import_jsx_runtime76.jsx)(CustomAttributesDialogInner, {
      element: props.element,
      nodeLabel: props.nodeLabel,
      schema: props.schema
    })
  });
}
function CodeButton() {
  const {
    editor,
    code: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsx)(ActionButton, {
    isSelected,
    isDisabled,
    prominence: "low",
    onPress: () => {
      if (isSelected) {
        Transforms.unwrapNodes(editor, {
          match: (node3) => node3.type === "code"
        });
      } else {
        Transforms.wrapNodes(editor, {
          type: "code",
          children: [{
            text: ""
          }]
        });
      }
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime76.jsx)(Icon, {
      src: codeIcon
    })
  }), [isDisabled, isSelected, editor]);
}
var codeButton = (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime76.jsx)(CodeButton, {}), (0, import_jsx_runtime76.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime76.jsx)(Text, {
      children: "Code block"
    }), (0, import_jsx_runtime76.jsx)(Kbd, {
      children: "```"
    })]
  })]
});
function CodeElement({
  attributes,
  children,
  element: element2
}) {
  var _aliasesToLabel$get;
  const editor = useSlateStatic();
  const triggerRef = (0, import_react73.useRef)(null);
  const [inputValue, setInputValue] = (0, import_react73.useState)(element2.language ? (_aliasesToLabel$get = aliasesToLabel.get(element2.language)) !== null && _aliasesToLabel$get !== void 0 ? _aliasesToLabel$get : element2.language : "Plain text");
  const [dialogOpen, setDialogOpen] = (0, import_react73.useState)(false);
  const {
    documentFeatures
  } = useDocumentEditorConfig();
  const customAttributesSchema = documentFeatures.formatting.blockTypes.code && Object.keys(documentFeatures.formatting.blockTypes.code.schema.fields).length ? documentFeatures.formatting.blockTypes.code.schema : void 0;
  return (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, {
    children: [(0, import_jsx_runtime76.jsx)(BlockWrapper, {
      children: (0, import_jsx_runtime76.jsxs)(BlockPopoverTrigger, {
        element: element2,
        children: [(0, import_jsx_runtime76.jsx)("pre", {
          spellCheck: "false",
          ref: triggerRef,
          children: (0, import_jsx_runtime76.jsx)("code", {
            ...attributes,
            children
          })
        }), (0, import_jsx_runtime76.jsx)(BlockPopover, {
          children: (0, import_jsx_runtime76.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime76.jsx)(_Combobox, {
              "aria-label": "Language",
              width: "scale.2000",
              allowsCustomValue: true,
              inputValue,
              onInputChange: setInputValue,
              onBlur: () => {
                const path2 = ReactEditor.findPath(editor, element2);
                const canonicalName = aliasesToCanonicalName.get(inputValue);
                if (canonicalName !== void 0) {
                  if (canonicalName === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path2
                    });
                    return;
                  }
                  setInputValue(canonicalNameToLabel.get(canonicalName));
                  Transforms.setNodes(editor, {
                    language: canonicalName
                  }, {
                    at: path2
                  });
                  return;
                }
                const nameFromLabel = labelToCanonicalName.get(inputValue);
                if (nameFromLabel !== void 0) {
                  if (nameFromLabel === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path2
                    });
                    return;
                  }
                  Transforms.setNodes(editor, {
                    language: nameFromLabel
                  }, {
                    at: path2
                  });
                  return;
                }
                if (inputValue === "") {
                  Transforms.unsetNodes(editor, "language", {
                    at: path2
                  });
                  setInputValue("Plain text");
                  return;
                }
                if (inputValue !== element2.language) {
                  Transforms.setNodes(editor, {
                    language: inputValue
                  }, {
                    at: path2
                  });
                }
              },
              onSelectionChange: (selection) => {
                const path2 = ReactEditor.findPath(editor, element2);
                if (aliasesToCanonicalName.has(inputValue)) {
                  selection = aliasesToCanonicalName.get(inputValue);
                }
                if (selection === null) {
                  if (inputValue === "") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path2
                    });
                  } else {
                    Transforms.setNodes(editor, {
                      language: inputValue
                    }, {
                      at: path2
                    });
                  }
                } else if (typeof selection === "string") {
                  if (selection === "plain") {
                    Transforms.unsetNodes(editor, "language", {
                      at: path2
                    });
                    setInputValue("Plain text");
                    return;
                  }
                  Transforms.setNodes(editor, {
                    language: selection
                  }, {
                    at: path2
                  });
                  const label = canonicalNameToLabel.get(selection);
                  if (label) {
                    setInputValue(label);
                  }
                }
              },
              selectedKey: element2.language ? aliasesToCanonicalName.get(element2.language) : "plain",
              items: (0, import_react73.useMemo)(() => inputValue === "Plain text" || labelToCanonicalName.has(inputValue) ? languagesWithAliases : matchSorter(languagesWithAliases, inputValue, {
                keys: ["label", "value", "aliases"]
              }), [inputValue]),
              children: (item2) => (0, import_jsx_runtime76.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
                children: item2.label
              }, item2.value)
            }), (0, import_jsx_runtime76.jsx)(ToolbarSeparator, {}), customAttributesSchema !== void 0 && (0, import_jsx_runtime76.jsx)(CustomAttributesEditButton, {
              onPress: () => setDialogOpen(true)
            }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, element2)
                  });
                },
                children: (0, import_jsx_runtime76.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime76.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      })
    }), customAttributesSchema !== void 0 && (0, import_jsx_runtime76.jsx)(CustomAttributesDialog, {
      element: element2,
      isOpen: dialogOpen,
      nodeLabel: "Code block",
      schema: customAttributesSchema,
      onDismiss: () => {
        setDialogOpen(false);
      }
    })]
  });
}
function updateComponentBlockElementProps(editor, componentBlock, prevProps, _newProps, basePath, setElement, ignoreChildFields) {
  Editor.withoutNormalizing(editor, () => {
    const propPathsWithNodesToReplace = /* @__PURE__ */ new Map();
    const schema = {
      kind: "object",
      fields: componentBlock.schema
    };
    const newProps = transformProps(schema, _newProps, {
      child(schema2, value2, path2) {
        if (!ignoreChildFields && schema2.options.kind === "block" && value2) {
          try {
            let prevVal = getValueAtPropPath(prevProps, path2);
            if (prevVal === value2) {
              return null;
            }
          } catch {
          }
          propPathsWithNodesToReplace.set(JSON.stringify(path2), value2.map(cloneDescendent));
        }
        return null;
      }
    });
    setElement({
      props: newProps
    });
    const childPropPaths = findChildPropPathsWithPrevious(newProps, prevProps, schema, [], [], []);
    const getNode = () => Node3.get(editor, basePath);
    const elementForChildren = getNode();
    if (childPropPaths.length === 0) {
      const indexes = elementForChildren.children.map((_2, i6) => i6).reverse();
      for (const idx of indexes) {
        Transforms.removeNodes(editor, {
          at: [...basePath, idx]
        });
      }
      Transforms.insertNodes(editor, {
        type: "component-inline-prop",
        propPath: void 0,
        children: [{
          text: ""
        }]
      }, {
        at: [...basePath, 0]
      });
      return;
    }
    const initialPropPathsToEditorPath = /* @__PURE__ */ new Map();
    for (const [idx, node3] of elementForChildren.children.entries()) {
      assert(node3.type === "component-block-prop" || node3.type === "component-inline-prop");
      initialPropPathsToEditorPath.set(node3.propPath === void 0 ? void 0 : JSON.stringify(node3.propPath), idx);
    }
    const childrenLeftToAdd = new Set(childPropPaths);
    for (const childProp of childPropPaths) {
      if (childProp.prevPath === void 0) {
        continue;
      }
      const stringifiedPath = JSON.stringify(childProp.prevPath);
      const idxInChildren = initialPropPathsToEditorPath.get(stringifiedPath);
      if (idxInChildren !== void 0) {
        const prevNode = elementForChildren.children[idxInChildren];
        assert(prevNode.propPath !== void 0);
        if (!areArraysEqual(childProp.path, prevNode.propPath)) {
          Transforms.setNodes(editor, {
            propPath: childProp.path
          }, {
            at: [...basePath, idxInChildren]
          });
        }
        childrenLeftToAdd.delete(childProp);
        initialPropPathsToEditorPath.delete(stringifiedPath);
      }
    }
    let newIdx = getNode().children.length;
    for (const childProp of childrenLeftToAdd) {
      Transforms.insertNodes(editor, {
        type: `component-${childProp.options.kind}-prop`,
        propPath: childProp.path,
        children: [childProp.options.kind === "block" ? {
          type: "paragraph",
          children: [{
            text: ""
          }]
        } : {
          text: ""
        }]
      }, {
        at: [...basePath, newIdx]
      });
      newIdx++;
    }
    const pathsToRemove = [];
    for (const [, idxInChildren] of initialPropPathsToEditorPath) {
      pathsToRemove.push(Editor.pathRef(editor, [...basePath, idxInChildren]));
    }
    for (const pathRef of pathsToRemove) {
      const path2 = pathRef.unref();
      assert(path2 !== null);
      Transforms.removeNodes(editor, {
        at: path2
      });
    }
    const propPathsToExpectedIndexes = /* @__PURE__ */ new Map();
    for (const [idx, thing] of childPropPaths.entries()) {
      propPathsToExpectedIndexes.set(JSON.stringify(thing.path), idx);
    }
    outer:
      while (true) {
        for (const [idx, childNode] of getNode().children.entries()) {
          assert(childNode.type === "component-block-prop" || childNode.type === "component-inline-prop");
          const expectedIndex = propPathsToExpectedIndexes.get(JSON.stringify(childNode.propPath));
          assert(expectedIndex !== void 0);
          if (idx === expectedIndex)
            continue;
          Transforms.moveNodes(editor, {
            at: [...basePath, idx],
            to: [...basePath, expectedIndex]
          });
          continue outer;
        }
        break;
      }
    for (const [propPath, val] of propPathsWithNodesToReplace) {
      const idx = propPathsToExpectedIndexes.get(propPath);
      if (idx !== void 0) {
        Transforms.removeNodes(editor, {
          at: [...basePath, idx]
        });
        Transforms.insertNodes(editor, {
          type: "component-block-prop",
          propPath: JSON.parse(propPath),
          children: val
        }, {
          at: [...basePath, idx]
        });
      }
    }
  });
}
function findChildPropPathsWithPrevious(value2, prevValue, schema, newPath, prevPath, pathWithKeys) {
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        path: newPath,
        prevPath,
        options: schema.options
      }];
    case "conditional":
      const hasChangedDiscriminant = value2.discriminant === prevValue.discriminant;
      return findChildPropPathsWithPrevious(value2.value, hasChangedDiscriminant ? prevValue.value : getInitialPropsValue(schema.values[value2.discriminant]), schema.values[value2.discriminant], newPath.concat("value"), hasChangedDiscriminant ? void 0 : prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat("value"), hasChangedDiscriminant ? void 0 : pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat("value"));
    case "object": {
      const paths = [];
      for (const key of Object.keys(schema.fields)) {
        paths.push(...findChildPropPathsWithPrevious(value2[key], prevValue[key], schema.fields[key], newPath.concat(key), prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat(key), pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat(key)));
      }
      return paths;
    }
    case "array": {
      const paths = [];
      const prevKeys = getKeysForArrayValue(prevValue);
      const keys = getKeysForArrayValue(value2);
      for (const [i6, val] of value2.entries()) {
        const key = keys[i6];
        const prevIdx = prevKeys.indexOf(key);
        let prevVal;
        if (prevIdx === -1) {
          prevVal = getInitialPropsValue(schema.element);
        } else {
          prevVal = prevValue[prevIdx];
        }
        paths.push(...findChildPropPathsWithPrevious(val, prevVal, schema.element, newPath.concat(i6), prevIdx === -1 ? void 0 : prevPath === null || prevPath === void 0 ? void 0 : prevPath.concat(prevIdx), prevIdx === -1 ? void 0 : pathWithKeys === null || pathWithKeys === void 0 ? void 0 : pathWithKeys.concat(key)));
      }
      return paths;
    }
  }
}
var ChildrenByPathContext = import_react73.default.createContext({});
function ChildFieldEditable({
  path: path2
}) {
  const childrenByPath = (0, import_react73.useContext)(ChildrenByPathContext);
  const child = childrenByPath[JSON.stringify(path2)];
  if (child === void 0) {
    return null;
  }
  return child;
}
function ComponentBlockRender({
  componentBlock,
  element: element2,
  onChange,
  children,
  onRemove
}) {
  const getPreviewProps = (0, import_react73.useMemo)(() => {
    return createGetPreviewProps({
      kind: "object",
      fields: componentBlock.schema
    }, (cb) => onChange(cb, true), (path2) => (0, import_jsx_runtime76.jsx)(ChildFieldEditable, {
      path: path2
    }));
  }, [onChange, componentBlock]);
  const previewProps = getPreviewProps(element2.props);
  const childrenByPath = {};
  let maybeChild;
  let extraChildren = [];
  children.forEach((child) => {
    const propPath = child.props.children.props.element.propPath;
    if (propPath === void 0) {
      maybeChild = child;
    } else {
      const schema = getSchemaAtPropPath(propPath, element2.props, componentBlock.schema);
      if ((schema === null || schema === void 0 ? void 0 : schema.kind) === "child" && schema.options.kind === "block" && schema.options.editIn === "modal") {
        extraChildren.push(child);
        return;
      }
      childrenByPath[JSON.stringify(propPathWithIndiciesToKeys(propPath, element2.props))] = child;
    }
  });
  const ComponentBlockPreview = componentBlock.preview;
  return (0, import_jsx_runtime76.jsxs)(ChildrenByPathContext.Provider, {
    value: childrenByPath,
    children: [(0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsx)(ComponentBlockPreview, {
      onRemove,
      ...previewProps
    }), [ComponentBlockPreview, onRemove, previewProps]), (0, import_jsx_runtime76.jsxs)("span", {
      className: css({
        caretColor: "transparent",
        "& ::selection": {
          backgroundColor: "transparent"
        },
        overflow: "hidden",
        width: 1,
        height: 1,
        position: "absolute"
      }),
      children: [maybeChild, extraChildren]
    })]
  });
}
function propPathWithIndiciesToKeys(propPath, val) {
  return propPath.map((key) => {
    var _val2;
    if (typeof key === "string") {
      var _val;
      val = (_val = val) === null || _val === void 0 ? void 0 : _val[key];
      return key;
    }
    if (!Array.isArray(val)) {
      val = void 0;
      return "";
    }
    const keys = getKeysForArrayValue(val);
    val = (_val2 = val) === null || _val2 === void 0 ? void 0 : _val2[key];
    return keys[key];
  });
}
function ChromefulComponentBlockElement(props) {
  var _props$componentBlock;
  const selected = useSelected();
  const isValid = (0, import_react73.useMemo)(() => clientSideValidateProp({
    kind: "object",
    fields: props.componentBlock.schema
  }, props.elementProps, void 0), [props.componentBlock, props.elementProps]);
  const [editMode, setEditMode] = (0, import_react73.useState)(false);
  const onCloseEditMode = (0, import_react73.useCallback)(() => {
    setEditMode(false);
  }, []);
  const onShowEditMode = (0, import_react73.useCallback)(() => {
    setEditMode(true);
  }, []);
  const ChromefulToolbar = (_props$componentBlock = props.componentBlock.toolbar) !== null && _props$componentBlock !== void 0 ? _props$componentBlock : DefaultToolbarWithChrome;
  return (0, import_jsx_runtime76.jsx)(BlockPrimitive, {
    selected,
    ...props.attributes,
    children: (0, import_jsx_runtime76.jsxs)(Flex, {
      gap: "medium",
      direction: "column",
      children: [(0, import_jsx_runtime76.jsx)(NotEditable, {
        children: (0, import_jsx_runtime76.jsx)(Text, {
          casing: "uppercase",
          color: "neutralSecondary",
          weight: "medium",
          size: "small",
          children: props.componentBlock.label
        })
      }), (0, import_jsx_runtime76.jsxs)(import_react73.Fragment, {
        children: [props.renderedBlock, (0, import_jsx_runtime76.jsx)(ChromefulToolbar, {
          isValid,
          onRemove: props.onRemove,
          props: props.previewProps,
          onShowEditMode
        }), (0, import_jsx_runtime76.jsx)(DialogContainer, {
          onDismiss: () => onCloseEditMode(),
          children: (() => {
            if (!editMode) {
              return;
            }
            return (0, import_jsx_runtime76.jsxs)(Dialog, {
              children: [(0, import_jsx_runtime76.jsxs)(Heading, {
                children: ["Edit ", props.componentBlock.label]
              }), (0, import_jsx_runtime76.jsx)(FormValue, {
                props: props.previewProps,
                onClose: onCloseEditMode
              })]
            });
          })()
        })]
      })]
    })
  });
}
var BlockPrimitive = (0, import_react73.forwardRef)(function BlockPrimitive2({
  children,
  selected,
  ...attributes
}, ref) {
  return (0, import_jsx_runtime76.jsx)("div", {
    ...attributes,
    ref,
    className: css(blockElementSpacing, {
      position: "relative",
      paddingInlineStart: tokenSchema.size.space.xlarge,
      marginBottom: tokenSchema.size.space.xlarge,
      "::before": {
        display: "block",
        content: '" "',
        backgroundColor: selected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle,
        borderRadius: 4,
        width: 4,
        position: "absolute",
        left: 0,
        top: 0,
        bottom: 0,
        zIndex: 1
      }
    }),
    children
  });
});
function DefaultToolbarWithChrome({
  onShowEditMode,
  onRemove,
  isValid
}) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  return (0, import_jsx_runtime76.jsx)(NotEditable, {
    children: (0, import_jsx_runtime76.jsxs)(Flex, {
      direction: "column",
      gap: "medium",
      children: [(0, import_jsx_runtime76.jsxs)(Flex, {
        alignItems: "center",
        gap: "regular",
        UNSAFE_style: {
          userSelect: "none"
        },
        children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
          onPress: () => onShowEditMode(),
          children: stringFormatter.format("edit")
        }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
            prominence: "low",
            onPress: onRemove,
            children: (0, import_jsx_runtime76.jsx)(Icon, {
              src: trash2Icon
            })
          }), (0, import_jsx_runtime76.jsx)(Tooltip, {
            tone: "critical",
            children: stringFormatter.format("delete")
          })]
        })]
      }), !isValid && (0, import_jsx_runtime76.jsx)(FieldMessage, {
        children: "Contains invalid fields. Please edit."
      })]
    })
  });
}
function FormValue({
  onClose,
  props
}) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  const formId = (0, import_react73.useId)();
  const [forceValidation, setForceValidation] = (0, import_react73.useState)(false);
  const [state, setState] = (0, import_react73.useState)(() => previewPropsToValue(props));
  const previewProps = (0, import_react73.useMemo)(() => createGetPreviewProps(props.schema, setState, () => void 0), [props.schema])(state);
  return (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, {
    children: [(0, import_jsx_runtime76.jsx)(Content, {
      children: (0, import_jsx_runtime76.jsx)(Flex, {
        id: formId,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget)
            return;
          event.preventDefault();
          if (!clientSideValidateProp(props.schema, state, void 0)) {
            setForceValidation(true);
          } else {
            console.log(valueToUpdater(state, props.schema));
            setValueToPreviewProps(state, props);
            onClose();
          }
        },
        direction: "column",
        gap: "xxlarge",
        children: (0, import_jsx_runtime76.jsx)(FormValueContentFromPreviewProps, {
          ...previewProps,
          forceValidation
        })
      })
    }), (0, import_jsx_runtime76.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime76.jsx)(Button, {
        onPress: onClose,
        children: stringFormatter.format("cancel")
      }), (0, import_jsx_runtime76.jsx)(Button, {
        form: formId,
        prominence: "high",
        type: "submit",
        children: "Done"
      })]
    })]
  });
}
function ChromelessComponentBlockElement(props) {
  var _props$componentBlock;
  const hasToolbar = props.componentBlock.toolbar !== null;
  const ChromelessToolbar = (_props$componentBlock = props.componentBlock.toolbar) !== null && _props$componentBlock !== void 0 ? _props$componentBlock : DefaultToolbarWithoutChrome;
  return (0, import_jsx_runtime76.jsx)("div", {
    ...props.attributes,
    className: blockElementSpacing,
    children: hasToolbar ? (0, import_jsx_runtime76.jsxs)(BlockPopoverTrigger, {
      element: props.element,
      children: [(0, import_jsx_runtime76.jsx)("div", {
        children: props.renderedBlock
      }), (0, import_jsx_runtime76.jsx)(BlockPopover, {
        children: (0, import_jsx_runtime76.jsx)(ChromelessToolbar, {
          onRemove: props.onRemove,
          props: props.previewProps
        })
      })]
    }) : (0, import_jsx_runtime76.jsx)("div", {
      children: props.renderedBlock
    })
  });
}
function DefaultToolbarWithoutChrome({
  onRemove
}) {
  return (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
      onPress: onRemove,
      margin: "regular",
      children: (0, import_jsx_runtime76.jsx)(Icon, {
        src: trashIcon
      })
    }), (0, import_jsx_runtime76.jsx)(Tooltip, {
      tone: "critical",
      children: "Remove"
    })]
  });
}
function findChildPropPathsForProp(value2, schema, path2) {
  switch (schema.kind) {
    case "form":
      return [];
    case "child":
      return [{
        path: path2,
        options: schema.options
      }];
    case "conditional":
      return findChildPropPathsForProp(value2.value, schema.values[value2.discriminant], path2.concat("value"));
    case "object": {
      const paths = [];
      Object.keys(schema.fields).forEach((key) => {
        paths.push(...findChildPropPathsForProp(value2[key], schema.fields[key], path2.concat(key)));
      });
      return paths;
    }
    case "array": {
      const paths = [];
      value2.forEach((val, i6) => {
        paths.push(...findChildPropPathsForProp(val, schema.element, path2.concat(i6)));
      });
      return paths;
    }
  }
}
function findChildPropPaths(value2, props) {
  const propPaths = findChildPropPathsForProp(value2, {
    kind: "object",
    fields: props
  }, []);
  if (!propPaths.length) {
    return [{
      path: void 0,
      options: {
        kind: "inline",
        placeholder: ""
      }
    }];
  }
  return propPaths;
}
function getAncestorComponentBlock(editor) {
  if (editor.selection) {
    const ancestorEntry = Editor.above(editor, {
      match: (node3) => isBlock(node3) && node3.type !== "paragraph"
    });
    if (ancestorEntry && (ancestorEntry[0].type === "component-block-prop" || ancestorEntry[0].type === "component-inline-prop")) {
      return {
        isInside: true,
        componentBlock: Editor.parent(editor, ancestorEntry[1]),
        prop: ancestorEntry
      };
    }
  }
  return {
    isInside: false
  };
}
var alreadyNormalizedThings = /* @__PURE__ */ new WeakMap();
function normalizeNodeWithinComponentProp([node3, path2], editor, fieldOptions) {
  let alreadyNormalizedNodes = alreadyNormalizedThings.get(fieldOptions);
  if (!alreadyNormalizedNodes) {
    alreadyNormalizedNodes = /* @__PURE__ */ new WeakSet();
    alreadyNormalizedThings.set(fieldOptions, alreadyNormalizedNodes);
  }
  if (alreadyNormalizedNodes.has(node3)) {
    return false;
  }
  let didNormalization = false;
  if (fieldOptions.inlineMarks !== "inherit" && Text2.isText(node3)) {
    didNormalization = normalizeTextBasedOnInlineMarksAndSoftBreaks([node3, path2], editor, fieldOptions.inlineMarks, fieldOptions.softBreaks);
  }
  if (Element2.isElement(node3)) {
    let childrenHasChanged = node3.children.map((node4, i6) => normalizeNodeWithinComponentProp([node4, [...path2, i6]], editor, fieldOptions)).some((x3) => x3);
    if (fieldOptions.kind === "block") {
      if (node3.type === "component-block") {
        if (!fieldOptions.componentBlocks) {
          Transforms.unwrapNodes(editor, {
            at: path2
          });
          didNormalization = true;
        }
      } else {
        didNormalization = normalizeElementBasedOnDocumentFeatures([node3, path2], editor, fieldOptions.documentFeatures) || childrenHasChanged;
      }
    } else {
      didNormalization = normalizeInlineBasedOnLinks([node3, path2], editor, fieldOptions.documentFeatures.links);
    }
  }
  if (didNormalization === false) {
    alreadyNormalizedNodes.add(node3);
  }
  return didNormalization;
}
function canSchemaContainChildField(rootSchema) {
  const queue = /* @__PURE__ */ new Set([rootSchema]);
  for (const schema of queue) {
    if (schema.kind === "form")
      ;
    else if (schema.kind === "child") {
      return true;
    } else if (schema.kind === "array") {
      queue.add(schema.element);
    } else if (schema.kind === "object") {
      for (const innerProp of Object.values(schema.fields)) {
        queue.add(innerProp);
      }
    } else if (schema.kind === "conditional") {
      for (const innerProp of Object.values(schema.values)) {
        queue.add(innerProp);
      }
    } else {
      assertNever(schema);
    }
  }
  return false;
}
function doesSchemaOnlyEverContainASingleChildField(rootSchema) {
  const queue = /* @__PURE__ */ new Set([rootSchema]);
  let hasFoundChildField = false;
  for (const schema of queue) {
    if (schema.kind === "form")
      ;
    else if (schema.kind === "child") {
      if (hasFoundChildField) {
        return false;
      }
      hasFoundChildField = true;
    } else if (schema.kind === "array") {
      if (canSchemaContainChildField(schema.element)) {
        return false;
      }
    } else if (schema.kind === "object") {
      for (const innerProp of Object.values(schema.fields)) {
        queue.add(innerProp);
      }
    } else if (schema.kind === "conditional") {
      for (const innerProp of Object.values(schema.values)) {
        queue.add(innerProp);
      }
    } else {
      assertNever(schema);
    }
  }
  return hasFoundChildField;
}
function findArrayFieldsWithSingleChildField(schema, value2) {
  const propPaths = [];
  traverseProps(schema, value2, (schema2, value3, path2) => {
    if (schema2.kind === "array" && doesSchemaOnlyEverContainASingleChildField(schema2.element)) {
      propPaths.push([path2, schema2]);
    }
  });
  return propPaths;
}
function isEmptyChildFieldNode(element2) {
  const firstChild = element2.children[0];
  return element2.children.length === 1 && (element2.type === "component-inline-prop" && firstChild.type === void 0 && firstChild.text === "" || element2.type === "component-block-prop" && firstChild.type === "paragraph" && firstChild.children.length === 1 && firstChild.children[0].type === void 0 && firstChild.children[0].text === "");
}
function withComponentBlocks(blockComponents, editorDocumentFeatures, editor) {
  const memoizedGetDocumentFeaturesForChildField = weakMemoize((options) => {
    return getDocumentFeaturesForChildField(editorDocumentFeatures, options);
  });
  const {
    normalizeNode,
    deleteBackward,
    insertBreak
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const ancestorComponentBlock = getAncestorComponentBlock(editor);
      if (ancestorComponentBlock.isInside && Range.isCollapsed(editor.selection) && Editor.isStart(editor, editor.selection.anchor, ancestorComponentBlock.prop[1]) && ancestorComponentBlock.prop[1][ancestorComponentBlock.prop[1].length - 1] === 0) {
        Transforms.unwrapNodes(editor, {
          at: ancestorComponentBlock.componentBlock[1]
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const ancestorComponentBlock = getAncestorComponentBlock(editor);
    if (editor.selection && ancestorComponentBlock.isInside) {
      const {
        prop: [componentPropNode, componentPropPath],
        componentBlock: [componentBlockNode, componentBlockPath]
      } = ancestorComponentBlock;
      const isLastProp = componentPropPath[componentPropPath.length - 1] === componentBlockNode.children.length - 1;
      if (componentPropNode.type === "component-block-prop") {
        const [[paragraphNode, paragraphPath]] = Editor.nodes(editor, {
          match: (node3) => node3.type === "paragraph"
        });
        const isLastParagraph = paragraphPath[paragraphPath.length - 1] === componentPropNode.children.length - 1;
        if (Node3.string(paragraphNode) === "" && isLastParagraph) {
          if (isLastProp) {
            Transforms.moveNodes(editor, {
              at: paragraphPath,
              to: Path.next(ancestorComponentBlock.componentBlock[1])
            });
          } else {
            Transforms.move(editor, {
              distance: 1,
              unit: "line"
            });
            Transforms.removeNodes(editor, {
              at: paragraphPath
            });
          }
          return;
        }
      }
      if (componentPropNode.type === "component-inline-prop") {
        Editor.withoutNormalizing(editor, () => {
          const componentBlock = blockComponents[componentBlockNode.component];
          if (componentPropNode.propPath !== void 0 && componentBlock !== void 0) {
            const rootSchema = {
              kind: "object",
              fields: componentBlock.schema
            };
            const ancestorFields = getAncestorSchemas(rootSchema, componentPropNode.propPath, componentBlockNode.props);
            const idx = [...ancestorFields].reverse().findIndex((item2) => item2.kind === "array");
            if (idx !== -1) {
              const arrayFieldIdx = ancestorFields.length - 1 - idx;
              const arrayField = ancestorFields[arrayFieldIdx];
              assert(arrayField.kind === "array");
              const val = getValueAtPropPath(componentBlockNode.props, componentPropNode.propPath.slice(0, arrayFieldIdx));
              if (doesSchemaOnlyEverContainASingleChildField(arrayField.element)) {
                if (Node3.string(componentPropNode) === "" && val.length - 1 === componentPropNode.propPath[arrayFieldIdx]) {
                  Transforms.removeNodes(editor, {
                    at: componentPropPath
                  });
                  if (isLastProp) {
                    Transforms.insertNodes(editor, {
                      type: "paragraph",
                      children: [{
                        text: ""
                      }]
                    }, {
                      at: Path.next(componentBlockPath)
                    });
                    Transforms.select(editor, Path.next(componentBlockPath));
                  } else {
                    Transforms.move(editor, {
                      distance: 1,
                      unit: "line"
                    });
                  }
                } else {
                  insertBreak();
                }
                return;
              }
            }
          }
          Transforms.splitNodes(editor, {
            always: true
          });
          const splitNodePath = Path.next(componentPropPath);
          if (isLastProp) {
            Transforms.moveNodes(editor, {
              at: splitNodePath,
              to: Path.next(componentBlockPath)
            });
          } else {
            moveChildren(editor, splitNodePath, [...Path.next(splitNodePath), 0]);
            Transforms.removeNodes(editor, {
              at: splitNodePath
            });
          }
        });
        return;
      }
    }
    insertBreak();
  };
  editor.normalizeNode = (entry) => {
    const [node3, path2] = entry;
    if (node3.type === "component-inline-prop" && !node3.propPath && (node3.children.length !== 1 || !Text2.isText(node3.children[0]) || node3.children[0].text !== "")) {
      Transforms.removeNodes(editor, {
        at: path2
      });
      return;
    }
    if (node3.type === "component-block") {
      const componentBlock = blockComponents[node3.component];
      if (componentBlock) {
        const rootSchema = {
          kind: "object",
          fields: componentBlock.schema
        };
        const updatedProps = addMissingFields(node3.props, rootSchema);
        if (updatedProps !== node3.props) {
          Transforms.setNodes(editor, {
            props: updatedProps
          }, {
            at: path2
          });
          return;
        }
        for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(rootSchema, node3.props)) {
          if (node3.children.length === 1 && node3.children[0].type === "component-inline-prop" && node3.children[0].propPath === void 0) {
            break;
          }
          const nodesWithin = [];
          for (const [idx, childNode] of node3.children.entries()) {
            if ((childNode.type === "component-block-prop" || childNode.type === "component-inline-prop") && childNode.propPath !== void 0) {
              const subPath = childNode.propPath.concat();
              while (subPath.length) {
                if (typeof subPath.pop() === "number")
                  break;
              }
              if (areArraysEqual(propPath, subPath)) {
                nodesWithin.push([idx, childNode]);
              }
            }
          }
          const arrVal = getValueAtPropPath(node3.props, propPath);
          const prevKeys = getKeysForArrayValue(arrVal);
          const prevKeysSet = new Set(prevKeys);
          const alreadyUsedIndicies = /* @__PURE__ */ new Set();
          const newVal = [];
          const newKeys = [];
          const getNewKey = () => {
            let key = getNewArrayElementKey();
            while (prevKeysSet.has(key)) {
              key = getNewArrayElementKey();
            }
            return key;
          };
          for (const [, node4] of nodesWithin) {
            const idxFromValue = node4.propPath[propPath.length];
            assert(typeof idxFromValue === "number");
            if (arrVal.length <= idxFromValue || alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node4)) {
              newVal.push(getInitialPropsValue(arrayField.element));
              newKeys.push(getNewKey());
            } else {
              alreadyUsedIndicies.add(idxFromValue);
              newVal.push(arrVal[idxFromValue]);
              newKeys.push(alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]);
            }
          }
          setKeysForArrayValue(newVal, newKeys);
          if (!areArraysEqual(arrVal, newVal)) {
            const transformedProps = replaceValueAtPropPath(rootSchema, node3.props, newVal, propPath);
            Transforms.setNodes(editor, {
              props: transformedProps
            }, {
              at: path2
            });
            for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()) {
              const newPropPath = [...nodeWithin.propPath];
              newPropPath[propPath.length] = idx;
              Transforms.setNodes(editor, {
                propPath: newPropPath
              }, {
                at: [...path2, idxInChildrenOfBlock]
              });
            }
            return;
          }
        }
        const missingKeys = new Map(findChildPropPaths(node3.props, componentBlock.schema).map((x3) => [JSON.stringify(x3.path), x3.options.kind]));
        node3.children.forEach((node4) => {
          assert(node4.type === "component-block-prop" || node4.type === "component-inline-prop");
          missingKeys.delete(JSON.stringify(node4.propPath));
        });
        if (missingKeys.size) {
          Transforms.insertNodes(editor, [...missingKeys].map(([prop, kind]) => ({
            type: `component-${kind}-prop`,
            propPath: prop ? JSON.parse(prop) : prop,
            children: [{
              text: ""
            }]
          })), {
            at: [...path2, node3.children.length]
          });
          return;
        }
        const foundProps = /* @__PURE__ */ new Set();
        const stringifiedInlinePropPaths = {};
        findChildPropPaths(node3.props, blockComponents[node3.component].schema).forEach((x3, index2) => {
          stringifiedInlinePropPaths[JSON.stringify(x3.path)] = {
            options: x3.options,
            index: index2
          };
        });
        for (const [index2, childNode] of node3.children.entries()) {
          if (
            // children that are not these will be handled by
            // the generic allowedChildren normalization
            childNode.type !== "component-inline-prop" && childNode.type !== "component-block-prop"
          ) {
            continue;
          }
          const childPath = [...path2, index2];
          const stringifiedPropPath = JSON.stringify(childNode.propPath);
          if (stringifiedInlinePropPaths[stringifiedPropPath] === void 0) {
            Transforms.removeNodes(editor, {
              at: childPath
            });
            return;
          }
          if (foundProps.has(stringifiedPropPath)) {
            Transforms.removeNodes(editor, {
              at: childPath
            });
            return;
          }
          foundProps.add(stringifiedPropPath);
          const propInfo = stringifiedInlinePropPaths[stringifiedPropPath];
          const expectedIndex = propInfo.index;
          if (index2 !== expectedIndex) {
            Transforms.moveNodes(editor, {
              at: childPath,
              to: [...path2, expectedIndex]
            });
            return;
          }
          const expectedChildNodeType = `component-${propInfo.options.kind}-prop`;
          if (childNode.type !== expectedChildNodeType) {
            Transforms.setNodes(editor, {
              type: expectedChildNodeType
            }, {
              at: childPath
            });
            return;
          }
          const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);
          if (normalizeNodeWithinComponentProp([childNode, childPath], editor, documentFeatures)) {
            return;
          }
        }
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
function addMissingFields(value2, schema) {
  if (schema.kind === "child" || schema.kind === "form") {
    return value2;
  }
  if (schema.kind === "conditional") {
    const conditionalValue = value2;
    const updatedInnerValue = addMissingFields(conditionalValue.value, schema.values[conditionalValue.discriminant.toString()]);
    if (updatedInnerValue === conditionalValue.value) {
      return value2;
    }
    return {
      discriminant: conditionalValue.discriminant,
      value: updatedInnerValue
    };
  }
  if (schema.kind === "array") {
    const arrValue = value2;
    const newArrValue = arrValue.map((x3) => addMissingFields(x3, schema.element));
    if (areArraysEqual(arrValue, newArrValue)) {
      return value2;
    }
    return newArrValue;
  }
  if (schema.kind === "object") {
    const objectValue = value2;
    let hasChanged = false;
    const newObjectValue = {};
    for (const [key, innerSchema] of Object.entries(schema.fields)) {
      const innerValue = objectValue[key];
      if (innerValue === void 0) {
        hasChanged = true;
        newObjectValue[key] = getInitialPropsValue(innerSchema);
        continue;
      }
      const newInnerValue = addMissingFields(innerValue, innerSchema);
      if (newInnerValue !== innerValue) {
        hasChanged = true;
      }
      newObjectValue[key] = newInnerValue;
    }
    if (hasChanged) {
      return newObjectValue;
    }
    return value2;
  }
  assertNever(schema);
}
function ComponentInlineProp(props) {
  return (0, import_jsx_runtime76.jsx)("span", {
    ...props.attributes,
    children: props.children
  });
}
function getInitialValue(type2, componentBlock) {
  const props = getInitialPropsValue({
    kind: "object",
    fields: componentBlock.schema
  });
  return {
    type: "component-block",
    component: type2,
    props,
    children: findChildPropPaths(props, componentBlock.schema).map((x3) => ({
      type: `component-${x3.options.kind}-prop`,
      propPath: x3.path,
      children: [x3.options.kind === "block" ? {
        type: "paragraph",
        children: [{
          text: ""
        }]
      } : {
        text: ""
      }]
    }))
  };
}
function insertComponentBlock(editor, componentBlocks, componentBlock) {
  const node3 = getInitialValue(componentBlock, componentBlocks[componentBlock]);
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, node3);
  const componentBlockEntry = Editor.above(editor, {
    match: (node4) => node4.type === "component-block"
  });
  if (componentBlockEntry) {
    const start2 = Editor.start(editor, componentBlockEntry[1]);
    Transforms.setSelection(editor, {
      anchor: start2,
      focus: start2
    });
  }
}
var ComponentBlocksElement = ({
  attributes,
  children,
  element: __elementToGetPath
}) => {
  const editor = useSlateStatic();
  const [currentElement, setElement] = useElementWithSetNodes(editor, __elementToGetPath);
  const blockComponents = useDocumentEditorConfig().componentBlocks;
  const componentBlock = blockComponents[currentElement.component];
  const propsWithChildFields = (0, import_react73.useMemo)(() => {
    if (!componentBlock)
      return;
    const blockChildrenByPath = /* @__PURE__ */ new Map();
    for (const child of currentElement.children) {
      if (child.type === "component-block-prop" && child.propPath) {
        blockChildrenByPath.set(JSON.stringify(child.propPath), child.children);
      }
    }
    if (!blockChildrenByPath.size)
      return currentElement.props;
    return transformProps({
      kind: "object",
      fields: componentBlock.schema
    }, currentElement.props, {
      child(schema, value2, propPath) {
        if (schema.options.kind === "block") {
          const key = JSON.stringify(propPath);
          const children2 = blockChildrenByPath.get(key);
          if (children2) {
            return children2.map(cloneDescendent);
          }
        }
        return value2;
      }
    });
  }, [componentBlock, currentElement]);
  const elementToGetPathRef = (0, import_react73.useRef)({
    __elementToGetPath,
    currentElement,
    propsWithChildFields
  });
  (0, import_react73.useEffect)(() => {
    elementToGetPathRef.current = {
      __elementToGetPath,
      currentElement,
      propsWithChildFields
    };
  });
  const onRemove = useEventCallback(() => {
    const path2 = ReactEditor.findPath(editor, __elementToGetPath);
    Transforms.removeNodes(editor, {
      at: path2
    });
  });
  const onPropsChange = (0, import_react73.useCallback)((cb, ignoreChildFields) => {
    const prevProps = elementToGetPathRef.current.propsWithChildFields;
    updateComponentBlockElementProps(editor, componentBlock, prevProps, cb(prevProps), ReactEditor.findPath(editor, elementToGetPathRef.current.__elementToGetPath), setElement, ignoreChildFields);
  }, [setElement, componentBlock, editor]);
  const getToolbarPreviewProps = (0, import_react73.useMemo)(() => {
    if (!componentBlock) {
      return () => {
        throw new Error("expected component block to exist when called");
      };
    }
    return createGetPreviewProps({
      kind: "object",
      fields: componentBlock.schema
    }, (cb) => onPropsChange(cb, false), () => void 0);
  }, [componentBlock, onPropsChange]);
  if (!componentBlock) {
    return (0, import_jsx_runtime76.jsxs)("div", {
      style: {
        border: "red 4px solid",
        padding: 8
      },
      children: [(0, import_jsx_runtime76.jsx)("pre", {
        contentEditable: false,
        style: {
          userSelect: "none"
        },
        children: `The block "${currentElement.component}" no longer exists.

Props:

${JSON.stringify(currentElement.props, null, 2)}

Content:`
      }), children]
    });
  }
  const toolbarPreviewProps = getToolbarPreviewProps(propsWithChildFields);
  const renderedBlock = (0, import_jsx_runtime76.jsx)(ComponentBlockRender, {
    children,
    componentBlock,
    element: currentElement,
    onChange: onPropsChange,
    onRemove
  });
  return componentBlock.chromeless ? (0, import_jsx_runtime76.jsx)(ChromelessComponentBlockElement, {
    element: __elementToGetPath,
    attributes,
    renderedBlock,
    componentBlock,
    onRemove,
    previewProps: toolbarPreviewProps
  }) : (0, import_jsx_runtime76.jsx)(ChromefulComponentBlockElement, {
    attributes,
    children,
    componentBlock,
    onRemove,
    previewProps: toolbarPreviewProps,
    renderedBlock,
    elementProps: currentElement.props
  });
};
function insertDivider(editor) {
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
    type: "divider",
    children: [{
      text: ""
    }]
  });
  Editor.insertNode(editor, {
    type: "paragraph",
    children: [{
      text: ""
    }]
  });
}
var DividerButton = () => {
  const {
    editor,
    dividers: {
      isDisabled
    }
  } = useToolbarState();
  return (0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsx)(ActionButton, {
    prominence: "low",
    isDisabled,
    onPress: () => {
      insertDivider(editor);
    },
    children: (0, import_jsx_runtime76.jsx)(Icon, {
      src: minusIcon
    })
  }), [editor, isDisabled]);
};
var dividerButton = (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
  delay: 200,
  children: [(0, import_jsx_runtime76.jsx)(DividerButton, {}), (0, import_jsx_runtime76.jsxs)(Tooltip, {
    children: [(0, import_jsx_runtime76.jsx)(Text, {
      children: "Divider"
    }), (0, import_jsx_runtime76.jsx)(Kbd, {
      children: "---"
    })]
  })]
});
function DividerElement({
  attributes,
  children
}) {
  const selected = useSelected();
  return (0, import_jsx_runtime76.jsxs)("div", {
    ...attributes,
    style: {
      caretColor: "transparent"
    },
    children: [(0, import_jsx_runtime76.jsx)("hr", {
      style: {
        backgroundColor: selected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle
      }
    }), children]
  });
}
var LayoutContainer = ({
  attributes,
  children,
  element: element2
}) => {
  const editor = useSlateStatic();
  const layout = element2.layout;
  const layoutOptions = useDocumentEditorConfig().documentFeatures.layouts;
  const currentLayoutIndex = layoutOptions.findIndex((x3) => x3.toString() === layout.toString());
  return (0, import_jsx_runtime76.jsx)("div", {
    className: blockElementSpacing,
    ...attributes,
    children: (0, import_jsx_runtime76.jsxs)(BlockPopoverTrigger, {
      element: element2,
      children: [(0, import_jsx_runtime76.jsx)("div", {
        className: css({
          columnGap: tokenSchema.size.space.regular,
          display: "grid"
        }),
        style: {
          gridTemplateColumns: layout.map((x3) => `${x3}fr`).join(" ")
        },
        children
      }), (0, import_jsx_runtime76.jsx)(BlockPopover, {
        children: (0, import_jsx_runtime76.jsxs)(Flex, {
          padding: "regular",
          gap: "regular",
          children: [(0, import_jsx_runtime76.jsx)(_ActionGroup, {
            selectionMode: "single",
            prominence: "low",
            density: "compact",
            onAction: (key) => {
              const path2 = ReactEditor.findPath(editor, element2);
              const layoutOption = layoutOptions[key];
              Transforms.setNodes(editor, {
                type: "layout",
                layout: layoutOption
              }, {
                at: path2
              });
              ReactEditor.focus(editor);
            },
            selectedKeys: currentLayoutIndex !== -1 ? [currentLayoutIndex.toString()] : [],
            children: layoutOptions.map((layoutOption, i6) => (0, import_jsx_runtime76.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
              children: makeLayoutIcon(layoutOption)
            }, i6))
          }), (0, import_jsx_runtime76.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
            children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
              prominence: "low",
              onPress: () => {
                const path2 = ReactEditor.findPath(editor, element2);
                Transforms.removeNodes(editor, {
                  at: path2
                });
              },
              children: (0, import_jsx_runtime76.jsx)(Icon, {
                src: trash2Icon
              })
            }), (0, import_jsx_runtime76.jsx)(Tooltip, {
              tone: "critical",
              children: "Remove"
            })]
          })]
        })
      })]
    })
  });
};
var LayoutArea = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime76.jsx)("div", {
    className: css({
      borderColor: tokenSchema.color.border.neutral,
      borderRadius: tokenSchema.size.radius.regular,
      borderStyle: "dashed",
      borderWidth: tokenSchema.size.border.regular,
      padding: tokenSchema.size.space.medium
    }),
    ...attributes,
    children
  });
};
var insertLayout = (editor, layout) => {
  insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, [{
    type: "layout",
    layout,
    children: [{
      type: "layout-area",
      children: [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }]
    }]
  }]);
  const layoutEntry = Editor.above(editor, {
    match: (x3) => x3.type === "layout"
  });
  if (layoutEntry) {
    Transforms.select(editor, [...layoutEntry[1], 0]);
  }
};
function makeLayoutIcon(ratios) {
  const size3 = 16;
  const element2 = (0, import_jsx_runtime76.jsx)("div", {
    role: "img",
    className: css({
      display: "grid",
      gridTemplateColumns: ratios.map((r7) => `${r7}fr`).join(" "),
      gap: 2,
      width: size3,
      height: size3
    }),
    children: ratios.map((_2, i6) => {
      return (0, import_jsx_runtime76.jsx)("div", {
        className: css({
          backgroundColor: "currentcolor",
          borderRadius: 1
        })
      }, i6);
    })
  });
  return element2;
}
var layoutsIcon = (0, import_jsx_runtime76.jsx)(Icon, {
  src: columnsIcon
});
var LayoutsButton = ({
  layouts
}) => {
  const {
    editor,
    layouts: {
      isSelected
    }
  } = useToolbarState();
  return (0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
    children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
      prominence: "low",
      isSelected,
      onPress: () => {
        if (isElementActive(editor, "layout")) {
          Transforms.unwrapNodes(editor, {
            match: (node3) => node3.type === "layout"
          });
        } else {
          insertLayout(editor, layouts[0]);
        }
        ReactEditor.focus(editor);
      },
      children: layoutsIcon
    }), (0, import_jsx_runtime76.jsx)(Tooltip, {
      children: "Layouts"
    })]
  }), [editor, isSelected, layouts]);
};
var toggleList = (editor, format2) => {
  const listAbove = getListTypeAbove(editor);
  const isActive = isElementActive(editor, format2) && (listAbove === "none" || listAbove === format2);
  Editor.withoutNormalizing(editor, () => {
    Transforms.unwrapNodes(editor, {
      match: isListNode,
      split: true,
      mode: isActive ? "all" : "lowest"
    });
    if (!isActive) {
      Transforms.wrapNodes(editor, {
        type: format2,
        children: []
      }, {
        match: (x3) => x3.type !== "list-item-content" && isBlock(x3)
      });
    }
  });
};
function ListButtons(props) {
  const {
    editor,
    lists
  } = useToolbarState();
  return (0, import_react73.useMemo)(() => {
    const disabledKeys = [];
    if (lists.ordered.isDisabled)
      disabledKeys.push("ordered");
    if (lists.unordered.isDisabled)
      disabledKeys.push("unordered");
    const selectedKeys = [];
    if (lists.ordered.isSelected)
      selectedKeys.push("ordered");
    if (lists.unordered.isSelected)
      selectedKeys.push("unordered");
    return (0, import_jsx_runtime76.jsx)(_ActionGroup, {
      flexShrink: 0,
      "aria-label": "Lists",
      selectionMode: "single",
      buttonLabelBehavior: "hide",
      density: "compact",
      prominence: "low",
      summaryIcon: (0, import_jsx_runtime76.jsx)(Icon, {
        src: listIcon
      }),
      selectedKeys,
      disabledKeys,
      onAction: (key) => {
        const format2 = `${key}-list`;
        toggleList(editor, format2);
        ReactEditor.focus(editor);
      },
      children: [props.lists.unordered && (0, import_jsx_runtime76.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: "Bullet List (- )",
        children: [(0, import_jsx_runtime76.jsx)(Icon, {
          src: listIcon
        }), (0, import_jsx_runtime76.jsx)(Text, {
          children: "Bullet List"
        }), (0, import_jsx_runtime76.jsx)(Kbd, {
          children: "-⎵"
        })]
      }, "unordered"), props.lists.ordered && (0, import_jsx_runtime76.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: "Numbered List (1.)",
        children: [(0, import_jsx_runtime76.jsx)(Icon, {
          src: listOrderedIcon
        }), (0, import_jsx_runtime76.jsx)(Text, {
          children: "Numbered List"
        }), (0, import_jsx_runtime76.jsx)(Kbd, {
          children: "1.⎵"
        })]
      }, "ordered")].filter((x3) => x3 !== false)
    });
  }, [editor, lists.ordered.isDisabled, lists.ordered.isSelected, lists.unordered.isDisabled, lists.unordered.isSelected, props.lists.ordered, props.lists.unordered]);
}
function nestList(editor) {
  const block5 = Editor.above(editor, {
    match: isBlock
  });
  if (!block5 || block5[0].type !== "list-item-content") {
    return false;
  }
  const listItemPath = Path.parent(block5[1]);
  if (listItemPath[listItemPath.length - 1] === 0) {
    return false;
  }
  const previousListItemPath = Path.previous(listItemPath);
  const previousListItemNode = Node3.get(editor, previousListItemPath);
  if (previousListItemNode.children.length !== 1) {
    Transforms.moveNodes(editor, {
      at: listItemPath,
      to: [...previousListItemPath, previousListItemNode.children.length - 1, previousListItemNode.children[previousListItemNode.children.length - 1].children.length]
    });
    return true;
  }
  const type2 = Editor.parent(editor, Path.parent(block5[1]))[0].type;
  Editor.withoutNormalizing(editor, () => {
    Transforms.wrapNodes(editor, {
      type: type2,
      children: []
    }, {
      at: listItemPath
    });
    Transforms.moveNodes(editor, {
      to: [...previousListItemPath, previousListItemNode.children.length],
      at: listItemPath
    });
  });
  return true;
}
function unnestList(editor) {
  const block5 = Editor.above(editor, {
    match: isBlock
  });
  if (block5 && block5[0].type === "list-item-content") {
    Transforms.unwrapNodes(editor, {
      match: isListNode,
      split: true
    });
    return true;
  }
  return false;
}
function getUploadedFile(accept) {
  return new Promise((resolve3) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = accept;
    let didChange = false;
    input.onchange = () => {
      var _input$files;
      didChange = true;
      const file = (_input$files = input.files) === null || _input$files === void 0 ? void 0 : _input$files[0];
      if (file) {
        file.arrayBuffer().then((buffer) => {
          resolve3({
            content: new Uint8Array(buffer),
            filename: file.name
          });
        });
      }
    };
    const cancelDetector = () => {
      window.removeEventListener("focus", cancelDetector);
      setTimeout(() => {
        var _input$files2;
        if (((_input$files2 = input.files) === null || _input$files2 === void 0 ? void 0 : _input$files2.length) === 0 && !didChange) {
          resolve3(void 0);
        }
      }, 500);
      if ([...document.body.childNodes].includes(input)) {
        document.body.removeChild(input);
      }
    };
    input.addEventListener("click", () => {
      window.addEventListener("focus", cancelDetector, true);
    });
    document.body.appendChild(input);
    input.click();
  });
}
function getUploadedImage() {
  return getUploadedFile("image/*");
}
function useObjectURL(data) {
  const [url, setUrl] = (0, import_react73.useState)(null);
  (0, import_react73.useEffect)(() => {
    if (data) {
      const url2 = URL.createObjectURL(new Blob([data]));
      setUrl(url2);
      return () => URL.revokeObjectURL(url2);
    } else {
      setUrl(null);
    }
  }, [data]);
  return url;
}
function ImageFieldInput(props) {
  var _props$validation;
  const {
    value: value2
  } = props;
  const [blurred, onBlur] = (0, import_react73.useReducer)(() => true, false);
  const isInEditor = useIsInDocumentEditor();
  const objectUrl = useObjectURL(value2 === null ? null : value2.data);
  const labelId = (0, import_react73.useId)();
  const descriptionId = (0, import_react73.useId)();
  return (0, import_jsx_runtime76.jsxs)(Flex, {
    "aria-describedby": props.description ? descriptionId : void 0,
    "aria-labelledby": labelId,
    direction: "column",
    gap: "medium",
    role: "group",
    children: [(0, import_jsx_runtime76.jsx)(FieldLabel, {
      id: labelId,
      elementType: "span",
      children: props.label
    }), props.description && (0, import_jsx_runtime76.jsx)(Text, {
      size: "small",
      color: "neutralSecondary",
      id: descriptionId,
      children: props.description
    }), (0, import_jsx_runtime76.jsxs)(ButtonGroup, {
      children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
        onPress: async () => {
          const image2 = await getUploadedImage();
          if (image2) {
            var _image$filename$match;
            const extension = (_image$filename$match = image2.filename.match(/\.([^.]+$)/)) === null || _image$filename$match === void 0 ? void 0 : _image$filename$match[1];
            if (extension) {
              props.onChange({
                data: image2.content,
                extension,
                filename: image2.filename
              });
            }
          }
        },
        children: "Choose file"
      }), value2 !== null && (0, import_jsx_runtime76.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => {
          props.onChange(null);
          onBlur();
        },
        children: "Remove"
      })]
    }), objectUrl && (0, import_jsx_runtime76.jsx)(Box, {
      alignSelf: "start",
      backgroundColor: "canvas",
      borderRadius: "regular",
      border: "neutral",
      padding: "regular",
      children: (0, import_jsx_runtime76.jsx)("img", {
        src: objectUrl,
        alt: "",
        style: {
          display: "block",
          maxHeight: tokenSchema.size.alias.singleLineWidth,
          maxWidth: "100%"
        }
      })
    }), isInEditor && value2 !== null && (0, import_jsx_runtime76.jsx)(TextField, {
      label: "Filename",
      onChange: (filename) => {
        props.onChange({
          ...value2,
          filename
        });
      },
      value: value2.filename
    }), (props.forceValidation || blurred) && ((_props$validation = props.validation) === null || _props$validation === void 0 ? void 0 : _props$validation.isRequired) && value2 === null && (0, import_jsx_runtime76.jsxs)(FieldMessage, {
      children: [props.label, " is required"]
    })]
  });
}
var ImageElement = ({
  attributes,
  children,
  element: __elementForGettingPath
}) => {
  const [dialogOpen, setDialogOpen] = (0, import_react73.useState)(false);
  const [aspectRatio, setAspectRatio] = (0, import_react73.useState)();
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  const editor = useSlateStatic();
  const [currentElement, setNode] = useElementWithSetNodes(editor, __elementForGettingPath);
  const objectUrl = useObjectURL(currentElement.src.content);
  const activePopoverElement = useActiveBlockPopover();
  const selected = activePopoverElement === __elementForGettingPath;
  return (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, {
    children: [(0, import_jsx_runtime76.jsxs)(BlockWrapper, {
      attributes,
      children: [children, (0, import_jsx_runtime76.jsxs)(BlockPopoverTrigger, {
        element: __elementForGettingPath,
        children: [(0, import_jsx_runtime76.jsx)("div", {
          style: {
            alignItems: "center",
            display: "flex",
            flexDirection: "column"
          },
          children: (0, import_jsx_runtime76.jsx)(NotEditable, {
            children: (0, import_jsx_runtime76.jsx)("img", {
              ...attributes,
              src: objectUrl,
              alt: currentElement.alt,
              "data-selected": selected,
              onLoad: (e6) => {
                const target = e6.target;
                setAspectRatio(target.width / target.height);
              },
              className: css({
                boxSizing: "border-box",
                borderRadius: tokenSchema.size.radius.regular,
                display: "block",
                maxHeight: tokenSchema.size.scale[3600],
                maxWidth: "100%",
                transition: transition("box-shadow"),
                "&[data-selected=true]": {
                  boxShadow: `0 0 0 ${tokenSchema.size.border.regular} ${tokenSchema.color.alias.borderSelected}`
                }
              })
            })
          })
        }), (0, import_jsx_runtime76.jsx)(BlockPopover, {
          hideArrow: true,
          children: (0, import_jsx_runtime76.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime76.jsxs)(Flex, {
              gap: "small",
              children: [(0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: () => setDialogOpen(true),
                  children: (0, import_jsx_runtime76.jsx)(Icon, {
                    src: editIcon
                  })
                }), (0, import_jsx_runtime76.jsx)(Tooltip, {
                  children: stringFormatter.format("edit")
                })]
              }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: async () => {
                    const src = await getUploadedImage();
                    if (src) {
                      setNode({
                        src
                      });
                    }
                  },
                  children: (0, import_jsx_runtime76.jsx)(Icon, {
                    src: fileUpIcon
                  })
                }), (0, import_jsx_runtime76.jsx)(Tooltip, {
                  children: "Choose file"
                })]
              })]
            }), (0, import_jsx_runtime76.jsx)(Divider, {
              orientation: "vertical"
            }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, __elementForGettingPath)
                  });
                },
                children: (0, import_jsx_runtime76.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime76.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      }, aspectRatio)]
    }), (0, import_jsx_runtime76.jsx)(DialogContainer, {
      onDismiss: () => {
        setDialogOpen(false);
        focusWithPreviousSelection(editor);
      },
      children: dialogOpen && (0, import_jsx_runtime76.jsx)(ImageDialog$1, {
        alt: currentElement.alt,
        title: currentElement.title,
        filename: currentElement.src.filename,
        onSubmit: ({
          alt,
          filename,
          title
        }) => {
          setNode({
            alt,
            title,
            src: {
              content: currentElement.src.content,
              filename
            }
          });
        }
      })
    })]
  });
};
function ImageDialog$1(props) {
  const {
    images
  } = useDocumentEditorConfig().documentFeatures;
  if (!images) {
    throw new Error("unexpected image rendered when images are disabled");
  }
  const schema = (0, import_react73.useMemo)(() => object(images.schema), [images]);
  const [state, setState] = (0, import_react73.useState)({
    alt: props.alt,
    title: props.title
  });
  const previewProps = (0, import_react73.useMemo)(() => createGetPreviewProps(schema, setState, () => void 0), [schema])(state);
  const [filenameWithoutExtension, filenameExtension] = splitFilename(props.filename);
  const [forceValidation, setForceValidation] = (0, import_react73.useState)(false);
  let [fileName, setFileName] = (0, import_react73.useState)(filenameWithoutExtension);
  let [fileNameTouched, setFileNameTouched] = (0, import_react73.useState)(false);
  let {
    dismiss
  } = useDialogContainer();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  return (0, import_jsx_runtime76.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime76.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        setForceValidation(true);
        if (fileName && clientSideValidateProp(schema, state, void 0)) {
          dismiss();
          props.onSubmit({
            alt: state.alt,
            title: state.title,
            filename: [fileName, filenameExtension].join(".")
          });
        }
      },
      children: [(0, import_jsx_runtime76.jsx)(Heading, {
        children: "Image details"
      }), (0, import_jsx_runtime76.jsx)(Content, {
        children: (0, import_jsx_runtime76.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          children: [(0, import_jsx_runtime76.jsx)(TextField, {
            label: "File name",
            onChange: setFileName,
            onBlur: () => setFileNameTouched(true),
            value: fileName,
            isRequired: true,
            errorMessage: (fileNameTouched || forceValidation) && !fileName ? "Please provide a file name." : void 0,
            endElement: filenameExtension ? (0, import_jsx_runtime76.jsx)(Flex, {
              alignItems: "center",
              justifyContent: "center",
              paddingEnd: "regular",
              children: (0, import_jsx_runtime76.jsxs)(Text, {
                color: "neutralTertiary",
                children: [".", filenameExtension]
              })
            }) : null
          }), (0, import_jsx_runtime76.jsx)(FormValueContentFromPreviewProps, {
            forceValidation,
            autoFocus: true,
            ...previewProps
          })]
        })
      }), (0, import_jsx_runtime76.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime76.jsx)(Button, {
          onPress: dismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime76.jsx)(Button, {
          prominence: "high",
          type: "submit",
          children: stringFormatter.format("save")
        })]
      })]
    })
  });
}
function splitFilename(filename) {
  const dotIndex = filename.lastIndexOf(".");
  if (dotIndex === -1) {
    return [filename, ""];
  }
  return [filename.substring(0, dotIndex), filename.substring(dotIndex + 1)];
}
var _imageIcon = (0, import_jsx_runtime76.jsx)(Icon, {
  src: imageIcon
});
function ImageButton() {
  const editor = useSlateStatic();
  return (0, import_jsx_runtime76.jsx)(import_jsx_runtime76.Fragment, {
    children: (0, import_jsx_runtime76.jsx)(ActionButton, {
      prominence: "low",
      onPress: async () => {
        const src = await getUploadedImage();
        if (src) {
          Transforms.insertNodes(editor, {
            type: "image",
            src,
            alt: "",
            title: "",
            children: [{
              text: ""
            }]
          });
        }
      },
      children: _imageIcon
    })
  });
}
var imageButton = (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime76.jsx)(ImageButton, {}), (0, import_jsx_runtime76.jsx)(Tooltip, {
    children: (0, import_jsx_runtime76.jsx)(Text, {
      children: "Image"
    })
  })]
});
function withImages(editor) {
  const {
    insertData
  } = editor;
  editor.insertData = (data) => {
    const images = Array.from(data.files).filter((x3) => x3.type.startsWith("image/"));
    if (images.length) {
      Promise.all(images.map(async (file) => ({
        name: file.name,
        data: new Uint8Array(await file.arrayBuffer())
      }))).then((images2) => {
        insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
          type: "image",
          src: {
            content: images2[0].data,
            filename: images2[0].name
          },
          alt: "",
          title: "",
          children: [{
            text: ""
          }]
        });
      });
      return;
    }
    insertData(data);
  };
  return editor;
}
function order(a3, b2) {
  return {
    start: Math.min(a3, b2),
    end: Math.max(a3, b2)
  };
}
function getRelativeRowPath(hasHead, rowIndex) {
  return hasHead ? rowIndex === 0 ? [0, 0] : [1, rowIndex - 1] : [0, rowIndex];
}
function getSelectedTableArea(editor) {
  var _Editor$above, _editor$selection, _Editor$above2, _editor$selection2;
  const anchor = (_Editor$above = Editor.above(editor, {
    match: nodeTypeMatcher("table-cell"),
    at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor.path
  })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];
  const focus = (_Editor$above2 = Editor.above(editor, {
    match: nodeTypeMatcher("table-cell"),
    at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.focus.path
  })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];
  const table3 = Editor.above(editor, {
    match: nodeTypeMatcher("table")
  });
  if (editor.selection && table3 && Element2.isElement(table3[0].children[0]) && anchor && focus && Path.equals(anchor.slice(0, -3), focus.slice(0, -3))) {
    const [start2, end] = Editor.edges(editor, editor.selection);
    return {
      tablePath: table3[1],
      table: table3[0],
      singleCell: Path.equals(anchor, focus) ? Point.equals(Editor.start(editor, anchor), start2) && Point.equals(Editor.end(editor, anchor), end) && !Point.equals(start2, end) ? "selected" : "not-selected" : "many",
      row: order(anchor[anchor.length - 2] + anchor[anchor.length - 3], focus[focus.length - 2] + focus[anchor.length - 3]),
      column: order(anchor[anchor.length - 1], focus[focus.length - 1])
    };
  }
}
var cell = (header) => ({
  type: "table-cell",
  ...header ? {
    header: true
  } : {},
  children: [{
    type: "paragraph",
    children: [{
      text: ""
    }]
  }]
});
function cloneDescendant(node3) {
  if (Text2.isText(node3))
    return {
      ...node3
    };
  return {
    ...node3,
    children: node3.children.map(cloneDescendant)
  };
}
function withTable(editor) {
  const {
    deleteFragment,
    normalizeNode,
    getFragment,
    insertFragment,
    deleteBackward
  } = editor;
  editor.insertFragment = (fragment) => {
    const selectedTableArea = getSelectedTableArea(editor);
    if (!selectedTableArea || fragment.length !== 1 || fragment[0].type !== "table") {
      insertFragment(fragment);
      return;
    }
    const newRows = fragment[0].children.flatMap((child) => child.type === "table-head" || child.type === "table-body" ? child.children : []);
    if (!newRows.every(nodeTypeMatcher("table-row"))) {
      insertFragment(fragment);
      return;
    }
    let {
      row,
      column: column2,
      tablePath,
      table: table3
    } = selectedTableArea;
    const existingBody = selectedTableArea.table.children[selectedTableArea.table.children.length === 1 ? 0 : 1];
    if (newRows[0].type !== "table-row" || existingBody.type !== "table-body" || existingBody.children[0].type !== "table-row") {
      insertFragment(fragment);
      return;
    }
    const hasHead = table3.children[0].type === "table-head";
    if (selectedTableArea.singleCell !== "many") {
      row = {
        start: row.start,
        end: Math.min(row.start + newRows.length - 1, existingBody.children.length - 1 + (hasHead ? 1 : 0))
      };
      column2 = {
        start: column2.start,
        end: Math.min(column2.start + newRows[0].children.length - 1, existingBody.children[0].children.length - 1)
      };
    }
    Editor.withoutNormalizing(editor, () => {
      for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
        const newRow = newRows[(rowIndex - row.start) % newRows.length];
        for (let cellIndex = column2.start; cellIndex <= column2.end; cellIndex++) {
          const relativeCellPath = [...getRelativeRowPath(hasHead, rowIndex), cellIndex];
          const cell2 = Node3.get(table3, relativeCellPath);
          const newCell = newRow.children[(cellIndex - column2.start) % newRow.children.length];
          if (cell2.type !== "table-cell" || newCell.type !== "table-cell") {
            continue;
          }
          const cellPath = [...tablePath, ...relativeCellPath];
          for (const childIdx of [...cell2.children.keys()].reverse()) {
            Transforms.removeNodes(editor, {
              at: [...cellPath, childIdx]
            });
          }
          Transforms.insertNodes(editor, newCell.children.map(cloneDescendant), {
            at: [...cellPath, 0]
          });
        }
      }
      Transforms.setSelection(editor, {
        anchor: Editor.start(editor, [...tablePath, ...getRelativeRowPath(hasHead, row.start), column2.start]),
        focus: Editor.end(editor, [...tablePath, ...getRelativeRowPath(hasHead, row.end), column2.end])
      });
    });
  };
  editor.deleteBackward = (unit) => {
    if (editor.selection && Range.isCollapsed(editor.selection) && editor.selection.anchor.offset === 0) {
      const tableCell = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell")
      });
      if (tableCell && tableCell[0].children[0].type === "paragraph" && tableCell[0].children[0].children[0].type === void 0 && Path.equals(editor.selection.anchor.path, [...tableCell[1], 0, 0])) {
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.getFragment = () => {
    const selectedTableArea = getSelectedTableArea(editor);
    if (selectedTableArea && selectedTableArea.singleCell !== "not-selected") {
      var _table$children$;
      const {
        table: table3
      } = selectedTableArea;
      const first = table3.children[0].type === "table-head" || table3.children[0].type === "table-body" ? table3.children[0] : void 0;
      if (!first) {
        return getFragment();
      }
      const second = ((_table$children$ = table3.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === "table-body" ? table3.children[1] : void 0;
      const body = second || first;
      const hasHead = first.type === "table-head";
      const isSelectionInHead = selectedTableArea.row.start === 0 && !!second;
      const columnLength = selectedTableArea.column.end - selectedTableArea.column.start + 1;
      return [{
        type: "table",
        children: [...isSelectionInHead ? [{
          type: "table-head",
          children: [{
            type: "table-row",
            children: Array.from({
              length: columnLength
            }).map((_2, columnIndex) => first.children[0].children[columnIndex + selectedTableArea.column.start])
          }]
        }] : [], {
          type: "table-body",
          children: Array.from({
            length: selectedTableArea.row.end - selectedTableArea.row.start + (isSelectionInHead ? 0 : 1)
          }).map((_2, rowIndex) => ({
            type: "table-row",
            children: Array.from({
              length: columnLength
            }).map((_3, columnIndex) => body.children[rowIndex + selectedTableArea.row.start - (hasHead && !isSelectionInHead ? 1 : 0)].children[columnIndex + selectedTableArea.column.start])
          }))
        }]
      }];
    }
    return getFragment();
  };
  editor.deleteFragment = (direction) => {
    if (!editor.selection || Range.isCollapsed(editor.selection)) {
      deleteFragment(direction);
      return;
    }
    const selectedTableArea = getSelectedTableArea(editor);
    if (!selectedTableArea || selectedTableArea.singleCell === "not-selected") {
      deleteFragment(direction);
      return;
    }
    const headOrBody = selectedTableArea.table.children[0];
    if (!Element2.isElement(headOrBody) || !Element2.isElement(headOrBody.children[0])) {
      deleteFragment(direction);
      return;
    }
    const maxRowIdx = selectedTableArea.table.children.reduce((sum, headOrBody2) => sum + (headOrBody2.type === "table-head" || headOrBody2.type === "table-body" ? headOrBody2.children.length : 0), 0) - 1;
    const {
      row,
      column: column2,
      tablePath
    } = selectedTableArea;
    const hasWholeColumnSelected = row.start === 0 && row.end === maxRowIdx;
    const hasWholeRowSelected = column2.start === 0 && column2.end === headOrBody.children[0].children.length - 1;
    if (hasWholeColumnSelected && hasWholeRowSelected) {
      Transforms.removeNodes(editor, {
        at: tablePath
      });
      return;
    }
    const hasHead = headOrBody.type === "table-head";
    if (hasWholeRowSelected) {
      Editor.withoutNormalizing(editor, () => {
        for (let i6 = row.end; i6 >= row.start; i6--) {
          if (hasHead) {
            if (i6 === 0) {
              Transforms.removeNodes(editor, {
                at: [...tablePath, 0]
              });
              continue;
            }
            Transforms.removeNodes(editor, {
              at: [...tablePath, 1, i6 - 1]
            });
            continue;
          }
          Transforms.removeNodes(editor, {
            at: [...tablePath, 0, i6]
          });
        }
      });
      return;
    }
    if (hasWholeColumnSelected) {
      Editor.withoutNormalizing(editor, () => {
        for (let i6 = column2.end; i6 >= column2.start; i6--) {
          for (let rowIdx = 0; rowIdx <= maxRowIdx; rowIdx++) {
            Transforms.removeNodes(editor, {
              at: [...tablePath, ...getRelativeRowPath(hasHead, rowIdx), i6]
            });
          }
        }
        const selectionPath = [...tablePath, 0, 0, column2.start];
        const point = Editor.start(editor, column2.start === 0 ? selectionPath : Path.previous(selectionPath));
        Transforms.select(editor, point);
      });
      return;
    }
    const selectionStart = Editor.start(editor, editor.selection).path;
    Editor.withoutNormalizing(editor, () => {
      for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
        for (let cellIndex = column2.start; cellIndex <= column2.end; cellIndex++) {
          const relativeCellPath = [...getRelativeRowPath(hasHead, rowIndex), cellIndex];
          const cell2 = Node3.get(selectedTableArea.table, relativeCellPath);
          if (!Element2.isElement(cell2)) {
            continue;
          }
          const cellPath = [...tablePath, ...relativeCellPath];
          Transforms.insertNodes(editor, {
            type: "paragraph",
            children: [{
              text: ""
            }]
          }, {
            at: [...cellPath, 0]
          });
          for (const childIdx of [...cell2.children.keys()].reverse()) {
            Transforms.removeNodes(editor, {
              at: [...cellPath, childIdx + 1]
            });
          }
        }
      }
      Transforms.select(editor, selectionStart);
    });
  };
  editor.normalizeNode = (entry) => {
    const [node3, path2] = entry;
    if (node3.type === "table-head" && node3.children.length > 1) {
      moveChildren(editor, path2, Path.next(path2), (_2, i6) => i6 !== 0);
      return;
    }
    let didUpdateThings = false;
    for (const parent of ["table-body", "table-head"]) {
      if (node3.type === parent) {
        for (const [rowIdx, row] of node3.children.entries()) {
          if (row.type === "table-row") {
            for (const [cellIdx, cell2] of row.children.entries()) {
              if (cell2.type === "table-cell") {
                const at = [...path2, rowIdx, cellIdx];
                if (cell2.header && parent === "table-body") {
                  Transforms.unsetNodes(editor, "header", {
                    at
                  });
                  didUpdateThings = true;
                }
                if (!cell2.header && parent === "table-head") {
                  Transforms.setNodes(editor, {
                    header: true
                  }, {
                    at
                  });
                  didUpdateThings = true;
                }
              }
            }
          }
        }
      }
    }
    if (didUpdateThings) {
      return;
    }
    if (node3.type === "table") {
      const maxRowCount = node3.children.reduce((max2, node4) => node4.type === "table-head" || node4.type === "table-body" ? node4.children.reduce((max3, node5) => node5.type === "table-row" ? Math.max(max3, node5.children.length) : max3, max2) : max2, 0);
      let didInsert = false;
      for (const [idx, child] of node3.children.entries()) {
        if (child.type === "table-body" || child.type === "table-head") {
          for (const [rowIdx, row] of child.children.entries()) {
            if (row.type === "table-row" && row.children.length !== maxRowCount) {
              Transforms.insertNodes(editor, Array.from({
                length: maxRowCount - row.children.length
              }, () => cell(child.type === "table-head")), {
                at: [...path2, idx, rowIdx, row.children.length]
              });
              didInsert = true;
            }
          }
        }
      }
      if (didInsert) {
        return;
      }
      if (node3.children.length === 1 && node3.children[0].type === "table-head") {
        Transforms.insertNodes(editor, {
          type: "table-body",
          children: Array.from({
            length: node3.children[0].children.length
          }, () => cell(false))
        }, {
          at: [...path2, 1]
        });
        return;
      }
      if (node3.children.length === 2 && node3.children[1].type === "table-head") {
        Transforms.moveNodes(editor, {
          at: [...path2, 1],
          to: [...path2, 0]
        });
        return;
      }
      if (node3.children.length > 2) {
        moveChildren(editor, path2, Path.next(path2), (_2, i6) => i6 !== 0 && i6 !== 1);
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var insertTable = (editor) => {
  Transforms.insertNodes(editor, {
    type: "table",
    children: [{
      type: "table-head",
      children: [{
        type: "table-row",
        children: [cell(true), cell(true), cell(true)]
      }]
    }, {
      type: "table-body",
      children: [{
        type: "table-row",
        children: [cell(false), cell(false), cell(false)]
      }, {
        type: "table-row",
        children: [cell(false), cell(false), cell(false)]
      }]
    }]
  });
};
var SelectedCellsContext = (0, import_react73.createContext)(void 0);
function getSelectedCells(table3, row, column2) {
  var _table$children$;
  const selectedCells = /* @__PURE__ */ new Set();
  const first = table3.children[0].type === "table-head" || table3.children[0].type === "table-body" ? table3.children[0] : void 0;
  if (!first)
    return selectedCells;
  const second = ((_table$children$ = table3.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === "table-body" ? table3.children[1] : void 0;
  for (let rowIndex = row.start; rowIndex <= row.end; rowIndex++) {
    const row2 = second ? rowIndex === 0 ? first.children[0] : second.children[rowIndex - 1] : first.children[rowIndex];
    if (!Element2.isElement(row2))
      continue;
    for (let cellIndex = column2.start; cellIndex <= column2.end; cellIndex++) {
      selectedCells.add(row2.children[cellIndex]);
    }
  }
  return selectedCells;
}
function TableSelectionProvider(props) {
  const editor = useSlate();
  const selectedTableArea = getSelectedTableArea(editor);
  if (selectedTableArea) {
    var _Editor$above, _editor$selection;
    return (0, import_jsx_runtime76.jsx)(SelectedCellsContext.Provider, {
      value: {
        cells: selectedTableArea.singleCell === "not-selected" ? /* @__PURE__ */ new Set() : getSelectedCells(selectedTableArea.table, selectedTableArea.row, selectedTableArea.column),
        table: selectedTableArea.table,
        focus: (_Editor$above = Editor.above(editor, {
          match: nodeTypeMatcher("table-cell"),
          at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus.path
        })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[0]
      },
      children: props.children
    });
  }
  return (0, import_jsx_runtime76.jsx)(SelectedCellsContext.Provider, {
    value: void 0,
    children: props.children
  });
}
var StartElementsContext = (0, import_react73.createContext)({
  top: /* @__PURE__ */ new Map(),
  left: /* @__PURE__ */ new Map()
});
var TableElement = ({
  attributes,
  children,
  element: element2
}) => {
  var _element$children$;
  const editor = useSlateStatic();
  const selectedCellsContext = (0, import_react73.useContext)(SelectedCellsContext);
  const selectedCells = (selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.table) === element2 ? selectedCellsContext : void 0;
  const startElements = (0, import_react73.useMemo)(() => {
    const firstTableChild = element2.children[0];
    if (!Element2.isElement(firstTableChild) || !Element2.isElement(firstTableChild.children[0])) {
      return {
        top: /* @__PURE__ */ new Map(),
        left: /* @__PURE__ */ new Map()
      };
    }
    const top = /* @__PURE__ */ new Map();
    const left = /* @__PURE__ */ new Map();
    for (const [idx, cell2] of firstTableChild.children[0].children.entries()) {
      if (cell2.type !== "table-cell")
        continue;
      top.set(cell2, element2.children.every((headOrBody) => Element2.isElement(headOrBody) ? headOrBody.children.every((row) => Element2.isElement(row) && (selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.cells.has(row.children[idx]))) : false));
    }
    for (const headOrBody of element2.children) {
      if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
        continue;
      }
      for (const row of headOrBody.children) {
        if (row.type !== "table-row" || row.children[0].type !== "table-cell") {
          continue;
        }
        left.set(row.children[0], row.children.every((element3) => selectedCells === null || selectedCells === void 0 ? void 0 : selectedCells.cells.has(element3)));
      }
    }
    return {
      top,
      left
    };
  }, [element2, selectedCells]);
  return (0, import_jsx_runtime76.jsx)(StartElementsContext.Provider, {
    value: startElements,
    children: (0, import_jsx_runtime76.jsx)(SelectedCellsContext.Provider, {
      value: selectedCells,
      children: (0, import_jsx_runtime76.jsx)(BlockWrapper, {
        attributes,
        children: (0, import_jsx_runtime76.jsxs)(BlockPopoverTrigger, {
          element: element2,
          children: [(0, import_jsx_runtime76.jsx)("table", {
            className: css({
              width: "100%",
              tableLayout: "fixed",
              position: "relative",
              borderSpacing: 0,
              "& *::selection": selectedCells !== null && selectedCells !== void 0 && selectedCells.cells.size ? {
                backgroundColor: "transparent"
              } : void 0
            }),
            children
          }), (0, import_jsx_runtime76.jsx)(BlockPopover, {
            children: (0, import_jsx_runtime76.jsxs)(Flex, {
              gap: "regular",
              padding: "regular",
              children: [(0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
                  prominence: "low",
                  isSelected: ((_element$children$ = element2.children[0]) === null || _element$children$ === void 0 ? void 0 : _element$children$.type) === "table-head",
                  onPress: () => {
                    const tablePath = ReactEditor.findPath(editor, element2);
                    Editor.withoutNormalizing(editor, () => {
                      if (element2.children[0].type === "table-head") {
                        Transforms.moveNodes(editor, {
                          at: [...tablePath, 0, 0],
                          to: [...tablePath, 1, 0]
                        });
                        Transforms.removeNodes(editor, {
                          at: [...tablePath, 0]
                        });
                        return;
                      }
                      Transforms.insertNodes(editor, {
                        type: "table-head",
                        children: []
                      }, {
                        at: [...tablePath, 0]
                      });
                      Transforms.moveNodes(editor, {
                        at: [...tablePath, 1, 0],
                        to: [...tablePath, 0, 0]
                      });
                    });
                  },
                  children: (0, import_jsx_runtime76.jsx)(Icon, {
                    src: sheetIcon
                  })
                }), (0, import_jsx_runtime76.jsx)(Tooltip, {
                  children: "Header row"
                })]
              }), (0, import_jsx_runtime76.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
                children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
                  prominence: "low",
                  onPress: () => {
                    Transforms.removeNodes(editor, {
                      at: ReactEditor.findPath(editor, element2)
                    });
                  },
                  children: (0, import_jsx_runtime76.jsx)(Icon, {
                    src: trash2Icon
                  })
                }), (0, import_jsx_runtime76.jsx)(Tooltip, {
                  tone: "critical",
                  children: "Remove"
                })]
              })]
            })
          })]
        })
      })
    })
  });
};
var TableBodyElement = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime76.jsx)("tbody", {
    ...attributes,
    children
  });
};
var TableHeadElement = ({
  attributes,
  children
}) => {
  return (0, import_jsx_runtime76.jsx)("thead", {
    ...attributes,
    children
  });
};
var TableRowElement = ({
  attributes,
  children,
  element: element2
}) => {
  var _useContext, _table$children$index;
  const table3 = (_useContext = (0, import_react73.useContext)(SelectedCellsContext)) === null || _useContext === void 0 ? void 0 : _useContext.table;
  return (0, import_jsx_runtime76.jsx)(RowIndexContext.Provider, {
    value: (_table$children$index = table3 === null || table3 === void 0 ? void 0 : table3.children.indexOf(element2)) !== null && _table$children$index !== void 0 ? _table$children$index : -1,
    children: (0, import_jsx_runtime76.jsx)("tr", {
      ...attributes,
      children
    })
  });
};
var RowIndexContext = (0, import_react73.createContext)(-1);
function TableCellElement({
  attributes,
  children,
  element: element2
}) {
  const editor = useSlateStatic();
  const selectedCellsContext = (0, import_react73.useContext)(SelectedCellsContext);
  const startElements = (0, import_react73.useContext)(StartElementsContext);
  const isSelected = selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.cells.has(element2);
  const size3 = `calc(100% + 2px)`;
  const ElementType = element2.header ? "th" : "td";
  const borderColor = isSelected ? tokenSchema.color.alias.borderSelected : tokenSchema.color.alias.borderIdle;
  return (0, import_jsx_runtime76.jsxs)(ElementType, {
    className: css({
      borderInlineEnd: `1px solid ${borderColor}`,
      borderBottom: `1px solid ${borderColor}`,
      borderTop: startElements.top.has(element2) ? `1px solid ${borderColor}` : void 0,
      borderInlineStart: startElements.left.has(element2) ? `1px solid ${borderColor}` : void 0,
      backgroundColor: selectedCellsContext !== null && selectedCellsContext !== void 0 && selectedCellsContext.cells.has(element2) ? tokenSchema.color.alias.backgroundSelected : element2.header ? tokenSchema.color.scale.slate3 : void 0,
      position: "relative",
      margin: 0,
      padding: tokenSchema.size.space.regular,
      fontWeight: "inherit",
      boxSizing: "border-box",
      textAlign: "start",
      verticalAlign: "top"
    }),
    ...attributes,
    children: [isSelected && (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, {
      children: [(0, import_jsx_runtime76.jsx)("div", {
        contentEditable: false,
        className: css({
          position: "absolute",
          top: -1,
          insetInlineStart: -1,
          background: tokenSchema.color.alias.borderSelected,
          height: size3,
          width: 1
        })
      }), (0, import_jsx_runtime76.jsx)("div", {
        contentEditable: false,
        className: css({
          position: "absolute",
          top: -1,
          insetInlineStart: -1,
          background: tokenSchema.color.alias.borderSelected,
          height: 1,
          width: size3
        })
      })]
    }), startElements.top.has(element2) && (0, import_jsx_runtime76.jsx)(CellSelection, {
      location: "top",
      selected: !!startElements.top.get(element2),
      label: "Select Column",
      onClick: () => {
        const path2 = ReactEditor.findPath(editor, element2);
        const table3 = Editor.above(editor, {
          match: nodeTypeMatcher("table"),
          at: path2
        });
        if (!table3)
          return;
        const lastTableIndex = table3[0].children.length - 1;
        const tableBody = table3[0].children[lastTableIndex];
        if (tableBody.type !== "table-body")
          return;
        const cellIndex = path2[path2.length - 1];
        const endPath = [...table3[1], table3[0].children.length - 1, tableBody.children.length - 1, cellIndex];
        Transforms.select(editor, {
          anchor: Editor.start(editor, path2),
          focus: Editor.end(editor, endPath)
        });
      }
    }), startElements.left.has(element2) && (0, import_jsx_runtime76.jsx)(CellSelection, {
      location: "left",
      selected: !!startElements.left.get(element2),
      label: "Select Row",
      onClick: () => {
        const path2 = ReactEditor.findPath(editor, element2);
        Transforms.select(editor, {
          anchor: Editor.start(editor, Path.parent(path2)),
          focus: Editor.end(editor, Path.parent(path2))
        });
      }
    }), startElements.left.has(element2) && startElements.top.has(element2) && (0, import_jsx_runtime76.jsx)(CellSelection, {
      location: "top-left",
      selected: !!(startElements.top.get(element2) && startElements.left.get(element2)),
      label: "Select Table",
      onClick: () => {
        const path2 = ReactEditor.findPath(editor, element2);
        const table3 = Editor.above(editor, {
          match: nodeTypeMatcher("table"),
          at: path2
        });
        if (!table3)
          return;
        Transforms.select(editor, {
          anchor: Editor.start(editor, table3[1]),
          focus: Editor.end(editor, table3[1])
        });
      }
    }), (0, import_jsx_runtime76.jsx)("div", {
      children
    }), (selectedCellsContext === null || selectedCellsContext === void 0 ? void 0 : selectedCellsContext.focus) === element2 && (0, import_jsx_runtime76.jsx)(CellMenu, {
      cell: element2,
      table: selectedCellsContext.table
    })]
  });
}
function CellSelection(props) {
  const selectedCellsContext = (0, import_react73.useContext)(SelectedCellsContext);
  const editor = useSlateStatic();
  let {
    location: location2,
    selected
  } = props;
  return (0, import_jsx_runtime76.jsxs)("div", {
    contentEditable: false,
    children: [(0, import_jsx_runtime76.jsx)("button", {
      tabIndex: -1,
      type: "button",
      ...toDataAttributes({
        location: location2,
        selected
      }),
      className: css({
        background: tokenSchema.color.scale.slate3,
        border: `1px solid ${tokenSchema.color.alias.borderIdle}`,
        margin: 0,
        padding: 0,
        position: "absolute",
        ":hover": {
          background: tokenSchema.color.scale.slate4
        },
        // ever so slightly larger hit area
        "::before": {
          content: '""',
          inset: -1,
          position: "absolute"
        },
        // location
        "&[data-location=top]": {
          top: -9,
          insetInlineStart: -1,
          width: "calc(100% + 2px)",
          height: 8
        },
        "&[data-location=left]": {
          top: -1,
          insetInlineStart: -9,
          width: 8,
          height: "calc(100% + 2px)"
        },
        "&[data-location=top-left]": {
          top: -9,
          insetInlineStart: -9,
          width: 8,
          height: 8
        },
        "&:not([data-location=top])": {
          borderInlineEnd: "none"
        },
        "&:not([data-location=left])": {
          borderBottom: "none"
        },
        // state
        "&[data-selected=true]": {
          background: tokenSchema.color.scale.indigo8,
          borderColor: tokenSchema.color.alias.borderSelected
        }
      }),
      style: {
        visibility: selectedCellsContext !== null && selectedCellsContext !== void 0 && selectedCellsContext.focus ? "visible" : "hidden"
      },
      "aria-label": props.label,
      onClick: () => {
        ReactEditor.focus(editor);
        props.onClick();
      }
    }), props.selected && (props.location === "top" ? (0, import_jsx_runtime76.jsx)("div", {
      className: css({
        position: "absolute",
        top: -9,
        insetInlineEnd: -1,
        background: tokenSchema.color.alias.borderSelected,
        height: 8,
        width: 1,
        zIndex: 2
      })
    }) : (0, import_jsx_runtime76.jsx)("div", {
      className: css({
        position: "absolute",
        bottom: -1,
        insetInlineStart: -9,
        background: tokenSchema.color.alias.borderSelected,
        height: 1,
        width: 8,
        zIndex: 2
      })
    }))]
  });
}
var cellActions = {
  deleteRow: {
    label: "Delete row",
    action: (editor, cellPath) => {
      const tablePath = cellPath.slice(0, -3);
      const table3 = Node3.get(editor, tablePath);
      if (table3.type !== "table")
        return;
      const hasHead = table3.children[0].type === "table-head";
      const rowPath = Path.parent(cellPath);
      Transforms.removeNodes(editor, {
        at: hasHead && rowPath[cellPath.length - 3] === 0 ? Path.parent(rowPath) : rowPath
      });
    }
  },
  deleteColumn: {
    label: "Delete column",
    action: (editor, path2) => {
      const cellIndex = path2[path2.length - 1];
      const tablePath = path2.slice(0, -3);
      const table3 = Node3.get(editor, tablePath);
      if (table3.type !== "table")
        return;
      Editor.withoutNormalizing(editor, () => {
        for (const [headOrBodyIdx, headOrBody] of table3.children.entries()) {
          if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
            continue;
          }
          for (const idx of headOrBody.children.keys()) {
            Transforms.removeNodes(editor, {
              at: [...tablePath, headOrBodyIdx, idx, cellIndex]
            });
          }
        }
      });
    }
  },
  insertRowBelow: {
    label: "Insert row below",
    action: (editor, path2) => {
      const tableRow = Node3.get(editor, Path.parent(path2));
      const tablePath = path2.slice(0, -3);
      const table3 = Node3.get(editor, tablePath);
      if (tableRow.type !== "table-row" || table3.type !== "table") {
        return;
      }
      const hasHead = table3.children[0].type === "table-head";
      const newRowPath = [...tablePath, hasHead ? 1 : 0, hasHead && path2[path2.length - 3] === 0 ? 0 : path2[path2.length - 2] + 1];
      Editor.withoutNormalizing(editor, () => {
        Transforms.insertNodes(editor, {
          type: "table-row",
          children: tableRow.children.map(() => cell(false))
        }, {
          at: newRowPath
        });
        Transforms.select(editor, [...newRowPath, path2[path2.length - 1]]);
      });
    }
  },
  insertColumnRight: {
    label: "Insert column right",
    action: (editor, path2) => {
      const newCellIndex = path2[path2.length - 1] + 1;
      const tablePath = path2.slice(0, -3);
      const table3 = Node3.get(editor, tablePath);
      if (table3.type !== "table")
        return;
      Editor.withoutNormalizing(editor, () => {
        for (const [headOrBodyIdx, headOrBody] of table3.children.entries()) {
          if (headOrBody.type !== "table-head" && headOrBody.type !== "table-body") {
            continue;
          }
          for (const rowIdx of headOrBody.children.keys()) {
            Transforms.insertNodes(editor, cell(headOrBody.type === "table-head"), {
              at: [...tablePath, headOrBodyIdx, rowIdx, newCellIndex]
            });
          }
        }
        Transforms.select(editor, Editor.start(editor, Path.next(path2)));
      });
    }
  }
};
var _cellActions = cellActions;
function CellMenu(props) {
  const editor = useSlateStatic();
  const gutter = tokenSchema.size.space.small;
  return (0, import_jsx_runtime76.jsx)("div", {
    contentEditable: false,
    className: css({
      top: gutter,
      insetInlineEnd: gutter,
      position: "absolute"
    }),
    children: (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime76.jsxs)(MenuTrigger, {
        align: "end",
        children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
          prominence: "low",
          UNSAFE_className: css({
            borderRadius: tokenSchema.size.radius.small,
            height: "auto",
            minWidth: 0,
            padding: 0,
            // tiny buttons; increase the hit area
            "&::before": {
              content: '""',
              inset: `calc(${gutter} * -1)`,
              position: "absolute"
            }
          }),
          children: (0, import_jsx_runtime76.jsx)(Icon, {
            src: chevronDownIcon
          })
        }), (0, import_jsx_runtime76.jsx)(_Menu, {
          onAction: (key) => {
            if (key in _cellActions) {
              _cellActions[key].action(editor, ReactEditor.findPath(editor, props.cell));
            }
          },
          items: Object.entries(_cellActions).map(([key, item2]) => ({
            ...item2,
            key
          })),
          children: (item2) => (0, import_jsx_runtime76.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
            children: item2.label
          }, item2.key)
        })]
      }), (0, import_jsx_runtime76.jsx)(Tooltip, {
        children: "Options"
      })]
    })
  });
}
var TableButton = () => {
  const {
    editor,
    blockquote: {
      isDisabled,
      isSelected
    }
  } = useToolbarState();
  return (0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsx)(ActionButton, {
    prominence: "low",
    isSelected,
    isDisabled,
    onPress: () => {
      insertTable(editor);
      ReactEditor.focus(editor);
    },
    children: (0, import_jsx_runtime76.jsx)(Icon, {
      src: tableIcon
    })
  }), [editor, isDisabled, isSelected]);
};
var tableButton = (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
  children: [(0, import_jsx_runtime76.jsx)(TableButton, {}), (0, import_jsx_runtime76.jsx)(Tooltip, {
    children: (0, import_jsx_runtime76.jsx)(Text, {
      children: "Table"
    })
  })]
});
function getCellPathInDirection(editor, path2, direction) {
  if (direction === "left" || direction === "right") {
    const row = Editor.above(editor, {
      match: nodeTypeMatcher("table-row"),
      at: path2
    });
    if (!row)
      return;
    const currentCellIdx = path2[path2.length - 1];
    const diff2 = direction === "left" ? -1 : 1;
    const nextCellIdx = currentCellIdx + diff2;
    const nextCell = row[0].children[nextCellIdx];
    if (!nextCell)
      return;
    return [...row[1], nextCellIdx];
  }
  const table3 = Editor.above(editor, {
    match: nodeTypeMatcher("table"),
    at: path2
  });
  if (!table3)
    return;
  const diff = direction === "up" ? -1 : 1;
  const rowIndex = path2[path2.length - 3] + path2[path2.length - 2];
  const nextRowIndex = rowIndex + diff;
  const relativeRowPath = getRelativeRowPath(table3[0].children[0].type === "table-head", nextRowIndex);
  if (!Node3.has(table3[0], relativeRowPath))
    return;
  return [...table3[1], ...relativeRowPath, path2[path2.length - 1]];
}
function Toolbar({
  documentFeatures,
  viewState
}) {
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  let hasComponentBlocksForInsertMenu = false, hasComponentBlocksForToolbar = false;
  for (const componentBlock of Object.values(componentBlocks)) {
    if (componentBlock.toolbarIcon) {
      hasComponentBlocksForToolbar = true;
    }
    if (!componentBlock.toolbarIcon) {
      hasComponentBlocksForInsertMenu = true;
    }
  }
  const hasMarks = Object.values(documentFeatures.formatting.inlineMarks).some((x3) => x3);
  const hasAlignment = documentFeatures.formatting.alignment.center || documentFeatures.formatting.alignment.end;
  const hasLists = documentFeatures.formatting.listTypes.unordered || documentFeatures.formatting.listTypes.ordered;
  return (0, import_jsx_runtime76.jsxs)(ToolbarWrapper, {
    children: [(0, import_jsx_runtime76.jsxs)(ToolbarScrollArea, {
      children: [!!documentFeatures.formatting.headings.levels.length && (0, import_jsx_runtime76.jsx)(HeadingMenu, {
        headingLevels: documentFeatures.formatting.headings.levels
      }), hasMarks && (0, import_jsx_runtime76.jsx)(InlineMarks, {
        marks: documentFeatures.formatting.inlineMarks
      }), (hasAlignment || hasLists) && (0, import_jsx_runtime76.jsxs)(ToolbarGroup, {
        children: [hasAlignment && (0, import_jsx_runtime76.jsx)(TextAlignMenu, {
          alignment: documentFeatures.formatting.alignment
        }), hasLists && (0, import_jsx_runtime76.jsx)(ListButtons, {
          lists: documentFeatures.formatting.listTypes
        })]
      }), (documentFeatures.dividers || documentFeatures.links || !!documentFeatures.images || documentFeatures.formatting.blockTypes.blockquote || documentFeatures.tables || !!documentFeatures.layouts.length || documentFeatures.formatting.blockTypes.code || hasComponentBlocksForToolbar) && (0, import_jsx_runtime76.jsxs)(ToolbarGroup, {
        children: [documentFeatures.dividers && dividerButton, documentFeatures.links && linkButton, documentFeatures.images && imageButton, documentFeatures.formatting.blockTypes.blockquote && blockquoteButton, !!documentFeatures.layouts.length && (0, import_jsx_runtime76.jsx)(LayoutsButton, {
          layouts: documentFeatures.layouts
        }), documentFeatures.formatting.blockTypes.code && codeButton, documentFeatures.tables && tableButton, hasComponentBlocksForInsertMenu && insertBlocksInToolbar]
      }), (0, import_jsx_runtime76.jsx)(Box, {
        flex: true
      })]
    }), (0, import_react73.useMemo)(() => {
      return viewState && (0, import_jsx_runtime76.jsxs)(Flex, {
        gap: "xsmall",
        children: [(0, import_jsx_runtime76.jsx)(ToolbarSeparator, {}), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
          children: [(0, import_jsx_runtime76.jsx)(Button, {
            prominence: "low",
            onPress: () => {
              viewState.toggle();
            },
            children: (0, import_jsx_runtime76.jsx)(Icon, {
              src: viewState.expanded ? minimizeIcon : maximizeIcon
            })
          }), (0, import_jsx_runtime76.jsx)(Tooltip, {
            children: viewState.expanded ? "Collapse" : "Expand"
          })]
        })]
      });
    }, [viewState]), !!hasComponentBlocksForInsertMenu && (0, import_jsx_runtime76.jsx)(InsertBlockMenu, {})]
  });
}
var ToolbarGroup = ({
  children
}) => {
  return (0, import_jsx_runtime76.jsx)(Flex, {
    gap: "regular",
    children
  });
};
var ToolbarContainer = ({
  children
}) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  if (entryLayoutPane === "main") {
    return (0, import_jsx_runtime76.jsx)("div", {
      className: css({
        boxSizing: "border-box",
        display: "flex",
        paddingInline: tokenSchema.size.space.medium,
        minWidth: 0,
        maxWidth: 800,
        marginInline: "auto",
        [breakpointQueries$1.above.mobile]: {
          paddingInline: tokenSchema.size.space.xlarge
        },
        [breakpointQueries$1.above.tablet]: {
          paddingInline: tokenSchema.size.space.xxlarge
        }
      }),
      children
    });
  }
  return (0, import_jsx_runtime76.jsx)("div", {
    className: css({
      display: "flex"
    }),
    children
  });
};
var ToolbarWrapper = ({
  children
}) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime76.jsx)(import_jsx_runtime76.Fragment, {
    children: (0, import_jsx_runtime76.jsx)("div", {
      "data-layout": entryLayoutPane,
      className: css({
        backdropFilter: "blur(8px)",
        backgroundClip: "padding-box",
        backgroundColor: `color-mix(in srgb, transparent, ${tokenSchema.color.background.canvas} 90%)`,
        borderBottom: `${tokenSchema.size.border.regular} solid color-mix(in srgb, transparent, ${tokenSchema.color.foreground.neutral} 10%)`,
        borderStartEndRadius: tokenSchema.size.radius.medium,
        borderStartStartRadius: tokenSchema.size.radius.medium,
        minWidth: 0,
        position: "sticky",
        top: 0,
        zIndex: 2,
        '&[data-layout="main"]': {
          borderRadius: 0
        }
      }),
      children: (0, import_jsx_runtime76.jsx)(ToolbarContainer, {
        children
      })
    })
  });
};
var ToolbarScrollArea = (props) => {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  return (0, import_jsx_runtime76.jsx)(Flex, {
    "data-layout": entryLayoutPane,
    paddingY: "regular",
    paddingX: "medium",
    gap: "large",
    flex: true,
    minWidth: 0,
    UNSAFE_className: css({
      msOverflowStyle: "none",
      scrollbarWidth: "none",
      overflowX: "auto",
      /* for Chrome, Safari, and Opera */
      "&::-webkit-scrollbar": {
        display: "none"
      },
      '&[data-layout="main"]': {
        paddingInline: 0
      }
    }),
    ...props
  });
};
var headingMenuVals = /* @__PURE__ */ new Map([["normal", "normal"], ["1", 1], ["2", 2], ["3", 3], ["4", 4], ["5", 5], ["6", 6]]);
var HeadingMenu = ({
  headingLevels
}) => {
  const {
    editor,
    textStyles
  } = useToolbarState();
  const isDisabled = textStyles.allowedHeadingLevels.length === 0;
  const items = (0, import_react73.useMemo)(() => {
    let resolvedItems = [{
      name: "Paragraph",
      id: "normal"
    }];
    headingLevels.forEach((level) => {
      resolvedItems.push({
        name: `Heading ${level}`,
        id: level.toString()
      });
    });
    return resolvedItems;
  }, [headingLevels]);
  const selected = textStyles.selected.toString();
  return (0, import_react73.useMemo)(() => (0, import_jsx_runtime76.jsx)(_Picker, {
    flexShrink: 0,
    width: "scale.1700",
    prominence: "low",
    "aria-label": "Text block",
    items,
    isDisabled,
    selectedKey: selected,
    onSelectionChange: (selected2) => {
      let key = headingMenuVals.get(selected2);
      if (key === "normal") {
        Editor.withoutNormalizing(editor, () => {
          Transforms.unsetNodes(editor, "level", {
            match: (n6) => n6.type === "heading"
          });
          Transforms.setNodes(editor, {
            type: "paragraph"
          }, {
            match: (n6) => n6.type === "heading"
          });
        });
      } else if (key) {
        Transforms.setNodes(editor, {
          type: "heading",
          level: key
        }, {
          match: (node3) => node3.type === "paragraph" || node3.type === "heading"
        });
      }
      ReactEditor.focus(editor);
    },
    children: (item2) => (0, import_jsx_runtime76.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      children: item2.name
    }, item2.id)
  }), [editor, isDisabled, items, selected]);
};
var insertBlocksInToolbar = (0, import_jsx_runtime76.jsx)(InsertBlocksInToolbar, {});
function InsertBlocksInToolbar() {
  const editor = useSlateStatic();
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  return Object.entries(componentBlocks).filter(([, val]) => val.toolbarIcon).map(([key, item2]) => {
    return (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
        prominence: "low",
        onPress: () => {
          insertComponentBlock(editor, componentBlocks, key);
          ReactEditor.focus(editor);
        },
        children: (0, import_jsx_runtime76.jsx)(Icon, {
          src: item2.toolbarIcon
        })
      }), (0, import_jsx_runtime76.jsx)(Tooltip, {
        children: item2.label
      })]
    }, key);
  });
}
function InsertBlockMenu() {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = useSlateStatic();
  const componentBlocks = useDocumentEditorConfig().componentBlocks;
  return (0, import_jsx_runtime76.jsxs)(MenuTrigger, {
    align: "end",
    children: [(0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime76.jsxs)(ActionButton, {
        marginY: "regular",
        marginEnd: entryLayoutPane === "main" ? void 0 : "medium",
        children: [(0, import_jsx_runtime76.jsx)(Icon, {
          src: plusIcon
        }), (0, import_jsx_runtime76.jsx)(Icon, {
          src: chevronDownIcon
        })]
      }), (0, import_jsx_runtime76.jsxs)(Tooltip, {
        children: [(0, import_jsx_runtime76.jsx)(Text, {
          children: "Insert"
        }), (0, import_jsx_runtime76.jsx)(Kbd, {
          children: "/"
        })]
      })]
    }), (0, import_jsx_runtime76.jsx)(_Menu, {
      onAction: (key) => {
        insertComponentBlock(editor, componentBlocks, key);
      },
      items: Object.entries(componentBlocks).filter(([, val]) => !val.toolbarIcon),
      children: ([key, item2]) => (0, import_jsx_runtime76.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        children: item2.label
      }, key)
    })]
  });
}
var inlineMarks = [{
  key: "bold",
  label: "Bold",
  icon: boldIcon,
  shortcut: `B`
}, {
  key: "italic",
  label: "Italic",
  icon: italicIcon,
  shortcut: `I`
}, {
  key: "underline",
  label: "Underline",
  icon: underlineIcon,
  shortcut: `U`
}, {
  key: "strikethrough",
  label: "Strikethrough",
  icon: strikethroughIcon
}, {
  key: "code",
  label: "Code",
  icon: codeIcon
}, {
  key: "superscript",
  label: "Superscript",
  icon: superscriptIcon
}, {
  key: "subscript",
  label: "Subscript",
  icon: subscriptIcon
}, {
  key: "clearFormatting",
  label: "Clear formatting",
  icon: removeFormattingIcon
}];
function InlineMarks({
  marks: _marksShown
}) {
  const {
    editor,
    clearFormatting: {
      isDisabled
    },
    marks
  } = useToolbarState();
  const marksShown = useMemoStringified(_marksShown);
  const selectedKeys = useMemoStringified(Object.keys(marks).filter((key) => marks[key].isSelected));
  const disabledKeys = useMemoStringified(Object.keys(marks).filter((key) => marks[key].isDisabled).concat(isDisabled ? "clearFormatting" : []));
  return (0, import_react73.useMemo)(() => {
    const items = inlineMarks.filter((item2) => item2.key === "clearFormatting" || marksShown[item2.key]);
    return (0, import_jsx_runtime76.jsx)(_ActionGroup, {
      UNSAFE_className: css({
        minWidth: `calc(${tokenSchema.size.element.medium} * 4)`
      }),
      prominence: "low",
      density: "compact",
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      summaryIcon: (0, import_jsx_runtime76.jsx)(Icon, {
        src: typeIcon
      }),
      items,
      selectionMode: "multiple",
      selectedKeys,
      disabledKeys,
      onAction: (key) => {
        if (key === "clearFormatting") {
          clearFormatting(editor);
        } else {
          var _Editor$marks;
          const mark = key;
          if ((_Editor$marks = Editor.marks(editor)) !== null && _Editor$marks !== void 0 && _Editor$marks[mark]) {
            Editor.removeMark(editor, mark);
          } else {
            Editor.addMark(editor, mark, true);
          }
        }
        ReactEditor.focus(editor);
      },
      children: (item2) => {
        return (0, import_jsx_runtime76.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          children: [(0, import_jsx_runtime76.jsx)(Text, {
            children: item2.label
          }), "shortcut" in item2 && (0, import_jsx_runtime76.jsx)(Kbd, {
            meta: true,
            children: item2.shortcut
          }), (0, import_jsx_runtime76.jsx)(Icon, {
            src: item2.icon
          })]
        }, item2.key);
      }
    });
  }, [disabledKeys, editor, marksShown, selectedKeys]);
}
function useMemoStringified(value2) {
  return (0, import_react73.useMemo)(() => value2, [JSON.stringify(value2)]);
}
var HeadingElement = ({
  attributes,
  children,
  element: element2
}) => {
  const ElementType = `h${element2.level}`;
  const editor = useSlateStatic();
  const {
    documentFeatures
  } = useDocumentEditorConfig();
  const [dialogOpen, setDialogOpen] = (0, import_react73.useState)(false);
  if (Object.keys(documentFeatures.formatting.headings.schema.fields).length === 0) {
    return (0, import_jsx_runtime76.jsx)(ElementType, {
      ...attributes,
      style: {
        textAlign: element2.textAlign
      },
      children
    });
  }
  return (0, import_jsx_runtime76.jsxs)(import_jsx_runtime76.Fragment, {
    children: [(0, import_jsx_runtime76.jsx)(ElementType, {
      style: {
        textAlign: element2.textAlign
      },
      children: (0, import_jsx_runtime76.jsxs)(BlockPopoverTrigger, {
        element: element2,
        children: [(0, import_jsx_runtime76.jsx)("div", {
          children
        }), (0, import_jsx_runtime76.jsx)(BlockPopover, {
          children: (0, import_jsx_runtime76.jsxs)(Flex, {
            gap: "regular",
            padding: "regular",
            children: [(0, import_jsx_runtime76.jsx)(CustomAttributesEditButton, {
              onPress: () => setDialogOpen(true)
            }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
              children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
                prominence: "low",
                onPress: () => {
                  Transforms.removeNodes(editor, {
                    at: ReactEditor.findPath(editor, element2)
                  });
                },
                children: (0, import_jsx_runtime76.jsx)(Icon, {
                  src: trash2Icon
                })
              }), (0, import_jsx_runtime76.jsx)(Tooltip, {
                tone: "critical",
                children: "Remove"
              })]
            })]
          })
        })]
      })
    }), (0, import_jsx_runtime76.jsx)(CustomAttributesDialog, {
      element: element2,
      schema: documentFeatures.formatting.headings.schema,
      isOpen: dialogOpen,
      nodeLabel: "Heading",
      onDismiss: () => setDialogOpen(false)
    })]
  });
};
var renderElement = (props) => {
  switch (props.element.type) {
    case "layout":
      return (0, import_jsx_runtime76.jsx)(LayoutContainer, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "layout-area":
      return (0, import_jsx_runtime76.jsx)(LayoutArea, {
        ...props
      });
    case "code":
      return (0, import_jsx_runtime76.jsx)(CodeElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "component-block": {
      return (0, import_jsx_runtime76.jsx)(ComponentBlocksElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    }
    case "component-inline-prop":
    case "component-block-prop":
      return (0, import_jsx_runtime76.jsx)(ComponentInlineProp, {
        ...props
      });
    case "heading":
      return (0, import_jsx_runtime76.jsx)(HeadingElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "link":
      return (0, import_jsx_runtime76.jsx)(LinkElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "ordered-list":
      return (0, import_jsx_runtime76.jsx)("ol", {
        ...props.attributes,
        children: props.children
      });
    case "unordered-list":
      return (0, import_jsx_runtime76.jsx)("ul", {
        ...props.attributes,
        children: props.children
      });
    case "list-item":
      return (0, import_jsx_runtime76.jsx)("li", {
        ...props.attributes,
        children: props.children
      });
    case "list-item-content":
      return (0, import_jsx_runtime76.jsx)("span", {
        ...props.attributes,
        children: props.children
      });
    case "blockquote":
      return (0, import_jsx_runtime76.jsx)("blockquote", {
        ...props.attributes,
        children: props.children
      });
    case "divider":
      return (0, import_jsx_runtime76.jsx)(DividerElement, {
        ...props
      });
    case "image":
      return (0, import_jsx_runtime76.jsx)(ImageElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table":
      return (0, import_jsx_runtime76.jsx)(TableElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-head":
      return (0, import_jsx_runtime76.jsx)(TableHeadElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-body":
      return (0, import_jsx_runtime76.jsx)(TableBodyElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-row":
      return (0, import_jsx_runtime76.jsx)(TableRowElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    case "table-cell":
      return (0, import_jsx_runtime76.jsx)(TableCellElement, {
        attributes: props.attributes,
        children: props.children,
        element: props.element
      });
    default:
      let {
        textAlign
      } = props.element;
      return (0, import_jsx_runtime76.jsx)("p", {
        style: {
          textAlign
        },
        ...props.attributes,
        children: props.children
      });
  }
};
function getOptions2(toolbarState, componentBlocks) {
  const options = [...Object.keys(componentBlocks).map((key) => ({
    label: componentBlocks[key].label,
    insert: (editor) => {
      insertComponentBlock(editor, componentBlocks, key);
    }
  })), ...toolbarState.textStyles.allowedHeadingLevels.filter((a3) => toolbarState.editorDocumentFeatures.formatting.headings.levels.includes(a3)).map((level) => ({
    label: `Heading ${level}`,
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "heading",
        level,
        children: [{
          text: ""
        }]
      });
    }
  })), !toolbarState.blockquote.isDisabled && toolbarState.editorDocumentFeatures.formatting.blockTypes.blockquote && {
    label: "Blockquote",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "blockquote",
        children: [{
          text: ""
        }]
      });
    }
  }, !toolbarState.code.isDisabled && toolbarState.editorDocumentFeatures.formatting.blockTypes.code && {
    label: "Code block",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "code",
        children: [{
          text: ""
        }]
      });
    }
  }, !!toolbarState.editorDocumentFeatures.images && {
    label: "Image",
    async insert(editor) {
      const image2 = await getUploadedImage();
      if (image2) {
        insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
          type: "image",
          src: image2,
          alt: "",
          title: "",
          children: [{
            text: ""
          }]
        });
      }
    }
  }, !!toolbarState.editorDocumentFeatures.tables && {
    label: "Table",
    insert: insertTable
  }, !toolbarState.dividers.isDisabled && toolbarState.editorDocumentFeatures.dividers && {
    label: "Divider",
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "divider",
        children: [{
          text: ""
        }]
      });
    }
  }, !!toolbarState.editorDocumentFeatures.layouts.length && {
    label: "Layout",
    insert(editor) {
      insertLayout(editor, toolbarState.editorDocumentFeatures.layouts[0]);
    }
  }, !toolbarState.lists.ordered.isDisabled && toolbarState.editorDocumentFeatures.formatting.listTypes.ordered && {
    label: "Numbered List",
    keywords: ["ordered list"],
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "ordered-list",
        children: [{
          text: ""
        }]
      });
    }
  }, !toolbarState.lists.unordered.isDisabled && toolbarState.editorDocumentFeatures.formatting.listTypes.unordered && {
    label: "Bullet List",
    keywords: ["unordered list"],
    insert(editor) {
      insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, {
        type: "unordered-list",
        children: [{
          text: ""
        }]
      });
    }
  }];
  return options.filter((x3) => typeof x3 !== "boolean");
}
function insertOption(editor, text3, option) {
  const path2 = ReactEditor.findPath(editor, text3);
  Transforms.delete(editor, {
    at: {
      focus: Editor.start(editor, path2),
      anchor: Editor.end(editor, path2)
    }
  });
  option.insert(editor);
}
function InsertMenu({
  children,
  text: text3
}) {
  const toolbarState = useToolbarState();
  const {
    editor
  } = toolbarState;
  const {
    componentBlocks
  } = useDocumentEditorConfig();
  const options = matchSorter(getOptions2(toolbarState, componentBlocks), text3.text.slice(1), {
    keys: ["label", "keywords"]
  }).map((option, index2) => ({
    ...option,
    index: index2
  }));
  const stateRef = (0, import_react73.useRef)({
    options,
    text: text3
  });
  (0, import_react73.useEffect)(() => {
    stateRef.current = {
      options,
      text: text3
    };
  });
  const listenerRef = (0, import_react73.useRef)((_event) => {
  });
  (0, import_react73.useEffect)(() => {
    listenerRef.current = (event) => {
      if (event.defaultPrevented)
        return;
      switch (event.key) {
        case "ArrowDown": {
          if (stateRef.current.options.length) {
            event.preventDefault();
            state.selectionManager.setFocused(true);
            state.selectionManager.setFocusedKey((Number(state.selectionManager.focusedKey) === stateRef.current.options.length - 1 ? 0 : Number(state.selectionManager.focusedKey) + 1).toString());
          }
          return;
        }
        case "ArrowUp": {
          if (stateRef.current.options.length) {
            event.preventDefault();
            state.selectionManager.setFocused(true);
            state.selectionManager.setFocusedKey((state.selectionManager.focusedKey === "0" ? stateRef.current.options.length - 1 : Number(state.selectionManager.focusedKey) - 1).toString());
          }
          return;
        }
        case "Enter": {
          const option = stateRef.current.options[Number(state.selectionManager.focusedKey)];
          if (option) {
            insertOption(editor, stateRef.current.text, option);
            event.preventDefault();
          }
          return;
        }
        case "Escape": {
          const path2 = ReactEditor.findPath(editor, stateRef.current.text);
          Transforms.unsetNodes(editor, "insertMenu", {
            at: path2
          });
          event.preventDefault();
          return;
        }
      }
    };
  });
  (0, import_react73.useEffect)(() => {
    const domNode = ReactEditor.toDOMNode(editor, editor);
    let listener = (event) => listenerRef.current(event);
    domNode.addEventListener("keydown", listener);
    return () => {
      domNode.removeEventListener("keydown", listener);
    };
  }, [editor]);
  const triggerRef = (0, import_react73.useRef)(null);
  const overlayState = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: true
  });
  const {
    triggerProps: {
      onPress,
      ...triggerProps
    },
    overlayProps
  } = $628037886ba31236$export$f9d5c8beee7d008d({
    type: "listbox"
  }, overlayState, triggerRef);
  let state = $e72dd72e1c76a225$export$2f645645f7bca764({
    items: options,
    children: (item2) => (0, import_jsx_runtime76.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      children: item2.label
    }, item2.index)
  });
  (0, import_react73.useEffect)(() => {
    if (!state.selectionManager.isFocused && state.collection.size) {
      state.selectionManager.setFocused(true);
      state.selectionManager.setFocusedKey("0");
    }
  }, [state]);
  const scrollableRef = (0, import_react73.useRef)(null);
  (0, import_react73.useEffect)(() => {
    var _scrollableRef$curren;
    const element2 = (_scrollableRef$curren = scrollableRef.current) === null || _scrollableRef$curren === void 0 || (_scrollableRef$curren = _scrollableRef$curren.querySelector('[role="listbox"] [role="presentation"]')) === null || _scrollableRef$curren === void 0 ? void 0 : _scrollableRef$curren.children[state.selectionManager.focusedKey];
    if (element2) {
      e5(element2, {
        scrollMode: "if-needed",
        boundary: scrollableRef.current,
        block: "nearest"
      });
    }
  }, [state.selectionManager.focusedKey]);
  const listboxRef = (0, import_react73.useRef)(null);
  let layout = useListBoxLayout(state);
  return (0, import_jsx_runtime76.jsxs)(import_react73.Fragment, {
    children: [(0, import_jsx_runtime76.jsx)("span", {
      ...triggerProps,
      role: "button",
      className: css({
        color: tokenSchema.color.foreground.accent,
        fontWeight: tokenSchema.typography.fontWeight.medium
      }),
      ref: triggerRef,
      children
    }), (0, import_jsx_runtime76.jsx)(Popover, {
      width: "alias.singleLineWidth",
      placement: "bottom start",
      isNonModal: true,
      hideArrow: true,
      ...overlayProps,
      state: overlayState,
      triggerRef,
      children: (0, import_jsx_runtime76.jsx)("div", {
        className: css({
          overflow: "scroll",
          maxHeight: 300
        }),
        ref: scrollableRef,
        children: (0, import_jsx_runtime76.jsx)(_ListBoxBase, {
          "aria-label": "Insert block",
          state,
          shouldUseVirtualFocus: true,
          layout,
          ref: listboxRef,
          onAction: (key) => {
            insertOption(editor, text3, options[key]);
          }
        })
      })
    })]
  });
}
var nodeListsWithoutInsertMenu = /* @__PURE__ */ new WeakSet();
var nodesWithoutInsertMenu = /* @__PURE__ */ new WeakSet();
function findPathWithInsertMenu(node3, path2) {
  if (Text2.isText(node3)) {
    return node3.insertMenu ? path2 : void 0;
  }
  if (nodeListsWithoutInsertMenu.has(node3.children)) {
    return;
  }
  for (const [index2, child] of node3.children.entries()) {
    if (nodesWithoutInsertMenu.has(child))
      continue;
    let maybePath = findPathWithInsertMenu(child, [...path2, index2]);
    if (maybePath) {
      return maybePath;
    }
    nodesWithoutInsertMenu.add(child);
  }
  nodeListsWithoutInsertMenu.add(node3.children);
}
function removeInsertMenuMarkWhenOutsideOfSelection(editor) {
  var _Editor$marks;
  const path2 = findPathWithInsertMenu(editor, []);
  if (path2 && !((_Editor$marks = Editor.marks(editor)) !== null && _Editor$marks !== void 0 && _Editor$marks.insertMenu) && (!editor.selection || !Path.equals(editor.selection.anchor.path, path2) || !Path.equals(editor.selection.focus.path, path2))) {
    Transforms.unsetNodes(editor, "insertMenu", {
      at: path2
    });
    return true;
  }
  return false;
}
function withInsertMenu(editor) {
  const {
    normalizeNode,
    apply,
    insertText
  } = editor;
  editor.normalizeNode = ([node3, path2]) => {
    if (Text2.isText(node3) && node3.insertMenu) {
      if (node3.text[0] !== "/") {
        Transforms.unsetNodes(editor, "insertMenu", {
          at: path2
        });
        return;
      }
      const whitespaceMatch = /\s/.exec(node3.text);
      if (whitespaceMatch) {
        Transforms.unsetNodes(editor, "insertMenu", {
          at: {
            anchor: {
              path: path2,
              offset: whitespaceMatch.index
            },
            focus: Editor.end(editor, path2)
          },
          match: Text2.isText,
          split: true
        });
        return;
      }
    }
    if (Editor.isEditor(editor) && removeInsertMenuMarkWhenOutsideOfSelection(editor)) {
      return;
    }
    normalizeNode([node3, path2]);
  };
  editor.apply = (op) => {
    apply(op);
    if (op.type === "set_selection") {
      removeInsertMenuMarkWhenOutsideOfSelection(editor);
    }
  };
  editor.insertText = (text3) => {
    insertText(text3);
    if (editor.selection && text3 === "/") {
      const startOfBlock = Editor.start(editor, Editor.above(editor, {
        match: isBlock
      })[1]);
      const before = Editor.before(editor, editor.selection.anchor, {
        unit: "character"
      });
      if (before && (Point.equals(startOfBlock, before) || before.offset !== 0 && /\s/.test(Node3.get(editor, before.path).text[before.offset - 1]))) {
        Transforms.setNodes(editor, {
          insertMenu: true
        }, {
          at: {
            anchor: before,
            focus: editor.selection.anchor
          },
          match: Text2.isText,
          split: true
        });
      }
    }
  };
  return editor;
}
function Placeholder$1({
  placeholder,
  children
}) {
  const [width, setWidth] = (0, import_react73.useState)(0);
  return (0, import_jsx_runtime76.jsxs)("span", {
    className: css({
      position: "relative",
      display: "inline-block",
      width
    }),
    children: [(0, import_jsx_runtime76.jsx)("span", {
      contentEditable: false,
      className: css({
        position: "absolute",
        pointerEvents: "none",
        display: "inline-block",
        left: 0,
        top: 0,
        maxWidth: "100%",
        whiteSpace: "nowrap",
        opacity: "0.5",
        userSelect: "none",
        fontStyle: "normal",
        fontWeight: "normal",
        textDecoration: "none",
        textAlign: "left"
      }),
      children: (0, import_jsx_runtime76.jsx)("span", {
        ref: (node3) => {
          if (node3) {
            const offsetWidth = node3.offsetWidth;
            if (offsetWidth !== width) {
              setWidth(offsetWidth);
            }
          }
        },
        children: placeholder
      })
    }), children]
  });
}
var Leaf2 = ({
  leaf,
  text: text3,
  children,
  attributes
}) => {
  const {
    underline,
    strikethrough,
    bold,
    italic,
    code: code2,
    keyboard,
    superscript,
    subscript,
    placeholder,
    insertMenu,
    ...rest
  } = leaf;
  if (placeholder !== void 0) {
    children = (0, import_jsx_runtime76.jsx)(Placeholder$1, {
      placeholder,
      children
    });
  }
  if (insertMenu) {
    children = (0, import_jsx_runtime76.jsx)(InsertMenu, {
      text: text3,
      children
    });
  }
  if (code2) {
    children = (0, import_jsx_runtime76.jsx)("code", {
      children
    });
  }
  if (bold) {
    children = (0, import_jsx_runtime76.jsx)("strong", {
      children
    });
  }
  if (strikethrough) {
    children = (0, import_jsx_runtime76.jsx)("s", {
      children
    });
  }
  if (italic) {
    children = (0, import_jsx_runtime76.jsx)("em", {
      children
    });
  }
  if (keyboard) {
    children = (0, import_jsx_runtime76.jsx)("kbd", {
      children
    });
  }
  if (superscript) {
    children = (0, import_jsx_runtime76.jsx)("sup", {
      children
    });
  }
  if (subscript) {
    children = (0, import_jsx_runtime76.jsx)("sub", {
      children
    });
  }
  if (underline) {
    children = (0, import_jsx_runtime76.jsx)("u", {
      children
    });
  }
  const prismClassNames = Object.keys(rest).filter((x3) => x3.startsWith("prism_")).map((x3) => styles$1.get(x3.replace("prism_", "")));
  if (prismClassNames.length) {
    const className = prismClassNames.join(" ");
    children = (0, import_jsx_runtime76.jsx)("span", {
      className,
      children
    });
  }
  return (0, import_jsx_runtime76.jsx)("span", {
    ...attributes,
    children
  });
};
var renderLeaf = (props) => {
  return (0, import_jsx_runtime76.jsx)(Leaf2, {
    ...props
  });
};
var styles$1 = new Map([{
  types: ["comment", "prolog", "doctype", "cdata"],
  style: {
    color: tokenSchema.color.foreground.neutralTertiary,
    fontStyle: "italic"
  }
}, {
  types: ["atrule", "attr-name", "class-name", "selector"],
  style: {
    color: tokenSchema.color.scale.amber11
  }
}, {
  types: ["boolean", "constant", "inserted-sign", "entity", "inserted", "number", "regex", "symbol", "variable"],
  style: {
    color: tokenSchema.color.scale.green11
  }
}, {
  types: ["attr-value", "builtin", "char", "constant", "generics", "url"],
  style: {
    color: tokenSchema.color.scale.pink11
  }
}, {
  types: ["string"],
  style: {
    color: tokenSchema.color.scale.indigo9
  }
}, {
  types: ["annotation", "deleted", "deleted-sign", "decorator", "important", "tag"],
  style: {
    color: tokenSchema.color.scale.red11
  }
}, {
  types: ["function", "function-variable", "operator"],
  style: {
    color: tokenSchema.color.scale.purple11
  }
}, {
  types: ["tag", "selector", "keyword"],
  style: {
    color: tokenSchema.color.scale.indigo11
  }
}, {
  types: ["punctuation"],
  style: {
    color: tokenSchema.color.foreground.neutralSecondary
  }
}].flatMap((style) => {
  const className = css(style.style);
  return style.types.map((x3) => [x3, className]);
}));
var codeBlockShortcutPattern = /^```(\w+)? ?$/;
function withCodeBlock(documentFeatures, componentBlocks, editor) {
  const {
    insertBreak,
    normalizeNode,
    insertText
  } = editor;
  function codeBlockShortcut(block5) {
    var _aliasesToCanonicalNa;
    if ((block5 === null || block5 === void 0 ? void 0 : block5[0].type) !== "paragraph" || block5[0].children.length !== 1 || block5[0].children[0].type !== void 0) {
      return false;
    }
    const match3 = codeBlockShortcutPattern.exec(block5[0].children[0].text);
    if (!match3) {
      return false;
    }
    const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);
    if (locationDocumentFeatures && (locationDocumentFeatures.kind === "inline" || !locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)) {
      return false;
    }
    editor.history.undos.push({
      operations: [],
      selectionBefore: editor.selection
    });
    Transforms.select(editor, block5[1]);
    Transforms.delete(editor);
    Transforms.wrapNodes(editor, {
      type: "code",
      ...match3[1] ? {
        language: (_aliasesToCanonicalNa = aliasesToCanonicalName.get(match3[1].toLowerCase())) !== null && _aliasesToCanonicalNa !== void 0 ? _aliasesToCanonicalNa : match3[1]
      } : {},
      children: []
    }, {
      match: (node3) => node3.type === "paragraph"
    });
    return true;
  }
  editor.insertBreak = () => {
    const block5 = Editor.above(editor, {
      match: isBlock
    });
    if ((block5 === null || block5 === void 0 ? void 0 : block5[0].type) === "code" && Text2.isText(block5[0].children[0])) {
      const text3 = block5[0].children[0].text;
      if (text3[text3.length - 1] === "\n" && editor.selection && Range.isCollapsed(editor.selection) && Point.equals(Editor.end(editor, block5[1]), editor.selection.anchor)) {
        insertBreak();
        Transforms.setNodes(editor, {
          type: "paragraph",
          children: []
        });
        Transforms.delete(editor, {
          distance: 1,
          at: {
            path: [...block5[1], 0],
            offset: text3.length - 1
          }
        });
        return;
      }
      editor.insertText("\n");
      return;
    }
    if (editor.selection && Range.isCollapsed(editor.selection) && codeBlockShortcut(block5)) {
      return;
    }
    insertBreak();
  };
  editor.insertText = (text3) => {
    insertText(text3);
    if (text3 === " " && editor.selection && Range.isCollapsed(editor.selection)) {
      codeBlockShortcut(Editor.above(editor, {
        match: isBlock
      }));
    }
  };
  editor.normalizeNode = ([node3, path2]) => {
    if (node3.type === "code" && Element2.isElement(node3)) {
      for (const [index2, childNode] of node3.children.entries()) {
        if (!Text2.isText(childNode)) {
          if (editor.isVoid(childNode)) {
            Transforms.removeNodes(editor, {
              at: [...path2, index2]
            });
          } else {
            Transforms.unwrapNodes(editor, {
              at: [...path2, index2]
            });
          }
          return;
        }
        const marks = Object.keys(childNode).filter((x3) => x3 !== "text");
        if (marks.length) {
          Transforms.unsetNodes(editor, marks, {
            at: [...path2, index2]
          });
          return;
        }
      }
    }
    normalizeNode([node3, path2]);
  };
  return editor;
}
var paragraphElement = () => ({
  type: "paragraph",
  children: [{
    text: ""
  }]
});
function withParagraphs(editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = (entry) => {
    const [node3, path2] = entry;
    if (Editor.isEditor(node3)) {
      let lastNode = node3.children[node3.children.length - 1];
      if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) !== "paragraph") {
        Transforms.insertNodes(editor, paragraphElement(), {
          at: [...path2, node3.children.length]
        });
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
function withLayouts(editor) {
  const {
    normalizeNode,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection && Range.isCollapsed(editor.selection) && // this is just an little optimisation
    // we're only doing things if we're at the start of a layout area
    // and the start of anything will always be offset 0
    // so we'll bailout if we're not at offset 0
    editor.selection.anchor.offset === 0) {
      const [aboveNode, abovePath] = Editor.above(editor, {
        match: (node3) => node3.type === "layout-area"
      }) || [editor, []];
      if (aboveNode.type === "layout-area" && Point.equals(Editor.start(editor, abovePath), editor.selection.anchor)) {
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.normalizeNode = (entry) => {
    const [node3, path2] = entry;
    if (Element2.isElement(node3) && node3.type === "layout") {
      if (node3.layout === void 0) {
        Transforms.unwrapNodes(editor, {
          at: path2
        });
        return;
      }
      if (node3.children.length < node3.layout.length) {
        Transforms.insertNodes(editor, Array.from({
          length: node3.layout.length - node3.children.length
        }).map(() => ({
          type: "layout-area",
          children: [paragraphElement()]
        })), {
          at: [...path2, node3.children.length]
        });
        return;
      }
      if (node3.children.length > node3.layout.length) {
        Array.from({
          length: node3.children.length - node3.layout.length
        }).map((_2, i6) => i6).reverse().forEach((i6) => {
          const layoutAreaToRemovePath = [...path2, i6 + node3.layout.length];
          const child = node3.children[i6 + node3.layout.length];
          moveChildren(editor, layoutAreaToRemovePath, [...path2, node3.layout.length - 1, node3.children[node3.layout.length - 1].children.length], (node4) => node4.type !== "paragraph" || Node3.string(child) !== "");
          Transforms.removeNodes(editor, {
            at: layoutAreaToRemovePath
          });
        });
        return;
      }
    }
    normalizeNode(entry);
  };
  return editor;
}
var markdownLinkPattern = /(^|\s)\[(.+?)\]\((\S+)\)$/;
function withLink(editorDocumentFeatures, componentBlocks, editor) {
  const {
    insertText,
    isInline,
    normalizeNode
  } = editor;
  editor.isInline = (element2) => {
    return element2.type === "link" ? true : isInline(element2);
  };
  if (editorDocumentFeatures.links) {
    editor.insertText = (text3) => {
      insertText(text3);
      if (text3 !== ")" || !editor.selection) {
        return;
      }
      const startOfBlock = Editor.start(editor, Editor.above(editor, {
        match: isBlock
      })[1]);
      const startOfBlockToEndOfShortcutString = Editor.string(editor, {
        anchor: editor.selection.anchor,
        focus: startOfBlock
      });
      const match3 = markdownLinkPattern.exec(startOfBlockToEndOfShortcutString);
      if (!match3) {
        return;
      }
      const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);
      if ((ancestorComponentChildFieldDocumentFeatures === null || ancestorComponentChildFieldDocumentFeatures === void 0 ? void 0 : ancestorComponentChildFieldDocumentFeatures.documentFeatures.links) === false) {
        return;
      }
      const [, maybeWhitespace, linkText, href] = match3;
      editor.history.undos.push({
        operations: [],
        selectionBefore: editor.selection
      });
      const startOfShortcut = match3.index === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {
        distance: match3.index
      });
      const startOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfShortcut, {
        distance: maybeWhitespace === "" ? 1 : 2
      });
      const endOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfLinkText, {
        distance: linkText.length
      });
      Transforms.delete(editor, {
        at: {
          anchor: endOfLinkText,
          focus: editor.selection.anchor
        }
      });
      Transforms.delete(editor, {
        at: {
          anchor: startOfShortcut,
          focus: startOfLinkText
        }
      });
      Transforms.wrapNodes(editor, {
        type: "link",
        href,
        children: []
      }, {
        at: {
          anchor: editor.selection.anchor,
          focus: startOfShortcut
        },
        split: true
      });
      const nextNode = Editor.next(editor);
      if (nextNode) {
        Transforms.select(editor, nextNode[1]);
      }
    };
  }
  editor.normalizeNode = ([node3, path2]) => {
    if (node3.type === "link") {
      if (Node3.string(node3) === "") {
        Transforms.unwrapNodes(editor, {
          at: path2
        });
        return;
      }
      for (const [idx, child] of node3.children.entries()) {
        if (child.type === "link") {
          Transforms.unwrapNodes(editor, {
            at: [...path2, idx]
          });
          return;
        }
      }
    }
    if (isInlineContainer(node3)) {
      let lastMergableLink = null;
      for (const [idx, child] of node3.children.entries()) {
        var _lastMergableLink;
        if (child.type === "link" && child.href === ((_lastMergableLink = lastMergableLink) === null || _lastMergableLink === void 0 ? void 0 : _lastMergableLink.node.href)) {
          const firstLinkPath = [...path2, lastMergableLink.index];
          const secondLinkPath = [...path2, idx];
          const to = [...firstLinkPath, lastMergableLink.node.children.length];
          for (let i6 = child.children.length - 1; i6 >= 0; i6--) {
            const childPath = [...secondLinkPath, i6];
            Transforms.moveNodes(editor, {
              at: childPath,
              to
            });
          }
          Transforms.removeNodes(editor, {
            at: secondLinkPath
          });
          return;
        }
        if (!Text2.isText(child) || child.text !== "") {
          lastMergableLink = null;
        }
        if (child.type === "link") {
          lastMergableLink = {
            index: idx,
            node: child
          };
        }
      }
    }
    normalizeNode([node3, path2]);
  };
  return editor;
}
function createDocumentEditorForNormalization(documentFeatures, componentBlocks) {
  return _createDocumentEditor(createEditor(), documentFeatures, componentBlocks);
}
function _createDocumentEditor(baseEditor, documentFeatures, componentBlocks) {
  return withBlocksSchema(withParagraphs(withLink(documentFeatures, componentBlocks, withList(withTable(withComponentBlocks(componentBlocks, documentFeatures, withVoidElements(withLayouts(withCodeBlock(documentFeatures, componentBlocks, withDocumentFeaturesNormalization(documentFeatures, baseEditor))))))))));
}
function withBlocksSchema(editor) {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([node3, path2]) => {
    if (!Text2.isText(node3) && node3.type !== "link") {
      const nodeType = Editor.isEditor(node3) ? "editor" : node3.type;
      if (typeof nodeType !== "string" || editorSchema[nodeType] === void 0) {
        Transforms.unwrapNodes(editor, {
          at: path2
        });
        return;
      }
      const info = editorSchema[nodeType];
      if (info.kind === "blocks" && node3.children.length !== 0 && node3.children.every((child) => !isBlock(child))) {
        Transforms.wrapNodes(editor, {
          type: info.blockToWrapInlinesIn,
          children: []
        }, {
          at: path2,
          match: (node4) => !isBlock(node4)
        });
        return;
      }
      let didUpdate = false;
      for (const [index2, childNode] of [...node3.children.entries()].reverse()) {
        const childPath = [...path2, index2];
        if (info.kind === "inlines") {
          if (!Text2.isText(childNode) && isBlock(childNode)) {
            handleNodeInInvalidPosition(editor, [childNode, childPath], path2);
            didUpdate = true;
            continue;
          }
        } else {
          if (!isBlock(childNode)) {
            Transforms.wrapNodes(editor, {
              type: info.blockToWrapInlinesIn,
              children: []
            }, {
              at: childPath
            });
            didUpdate = true;
            continue;
          }
          if (!info.allowedChildren.has(childNode.type)) {
            handleNodeInInvalidPosition(editor, [childNode, childPath], path2);
            didUpdate = true;
            continue;
          }
        }
      }
      if (didUpdate) {
        return;
      }
    }
    normalizeNode([node3, path2]);
  };
  return editor;
}
function handleNodeInInvalidPosition(editor, [node3, path2], ancestorPath) {
  const nodeType = node3.type;
  const childNodeInfo = editorSchema[nodeType];
  const ancestorNode = Node3.get(editor, ancestorPath);
  const parentNodeType = Editor.isEditor(ancestorNode) ? "editor" : ancestorNode.type;
  const parentNodeInfo = editorSchema[parentNodeType];
  if (!childNodeInfo || childNodeInfo.invalidPositionHandleMode === "unwrap") {
    if (parentNodeInfo.kind === "blocks" && parentNodeInfo.blockToWrapInlinesIn) {
      Transforms.setNodes(editor, {
        type: parentNodeInfo.blockToWrapInlinesIn,
        ...Object.fromEntries(Object.keys(node3).filter((key) => key !== "type" && key !== "children").map((key) => [key, null]))
        // the Slate types don't understand that null is allowed and it will unset properties with setNodes
      }, {
        at: path2
      });
      return;
    }
    Transforms.unwrapNodes(editor, {
      at: path2
    });
    return;
  }
  const info = editorSchema[ancestorNode.type || "editor"];
  if ((info === null || info === void 0 ? void 0 : info.kind) === "blocks" && info.allowedChildren.has(nodeType)) {
    if (ancestorPath.length === 0) {
      Transforms.moveNodes(editor, {
        at: path2,
        to: [path2[0] + 1]
      });
    } else {
      Transforms.moveNodes(editor, {
        at: path2,
        to: Path.next(ancestorPath)
      });
    }
    return;
  }
  if (Editor.isEditor(ancestorNode)) {
    Transforms.moveNodes(editor, {
      at: path2,
      to: [path2[0] + 1]
    });
    Transforms.unwrapNodes(editor, {
      at: [path2[0] + 1]
    });
    return;
  }
  handleNodeInInvalidPosition(editor, [node3, path2], ancestorPath.slice(0, -1));
}
function withVoidElements(editor) {
  const {
    isVoid
  } = editor;
  editor.isVoid = (node3) => {
    return node3.type === "divider" || node3.type === "image" || isVoid(node3);
  };
  return editor;
}
function withBlockMarkdownShortcuts(documentFeatures, componentBlocks, editor) {
  const {
    insertText
  } = editor;
  const shortcuts2 = /* @__PURE__ */ Object.create(null);
  const editorDocumentFeaturesForNormalizationToCheck = {
    ...documentFeatures
  };
  let addShortcut = (text3, insert, shouldBeEnabledInComponentBlock, type2 = "paragraph") => {
    if (!shouldBeEnabledInComponentBlock(editorDocumentFeaturesForNormalizationToCheck)) {
      return;
    }
    const trigger2 = text3[text3.length - 1];
    if (!shortcuts2[trigger2]) {
      shortcuts2[trigger2] = /* @__PURE__ */ Object.create(null);
    }
    shortcuts2[trigger2][text3] = {
      insert,
      type: type2,
      shouldBeEnabledInComponentBlock
    };
  };
  addShortcut("1. ", () => {
    Transforms.wrapNodes(editor, {
      type: "ordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.ordered);
  addShortcut("- ", () => {
    Transforms.wrapNodes(editor, {
      type: "unordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.unordered);
  addShortcut("* ", () => {
    Transforms.wrapNodes(editor, {
      type: "unordered-list",
      children: []
    }, {
      match: isBlock
    });
  }, (features) => features.formatting.listTypes.unordered);
  documentFeatures.formatting.headings.levels.forEach((level) => {
    addShortcut("#".repeat(level) + " ", () => {
      Transforms.setNodes(editor, {
        type: "heading",
        level
      }, {
        match: (node3) => node3.type === "paragraph" || node3.type === "heading"
      });
    }, (features) => features.formatting.headings.levels.includes(level), "heading-or-paragraph");
  });
  addShortcut("> ", () => {
    Transforms.wrapNodes(editor, {
      type: "blockquote",
      children: []
    }, {
      match: (node3) => node3.type === "paragraph"
    });
  }, (features) => features.formatting.blockTypes.blockquote);
  addShortcut("---", () => {
    insertDivider(editor);
  }, (features) => features.dividers);
  editor.insertText = (text3) => {
    insertText(text3);
    const shortcutsForTrigger = shortcuts2[text3];
    if (shortcutsForTrigger && editor.selection && Range.isCollapsed(editor.selection)) {
      const {
        anchor
      } = editor.selection;
      const block5 = Editor.above(editor, {
        match: isBlock
      });
      if (!block5 || block5[0].type !== "paragraph" && block5[0].type !== "heading") {
        return;
      }
      const start2 = Editor.start(editor, block5[1]);
      const range = {
        anchor,
        focus: start2
      };
      const shortcutText = Editor.string(editor, range);
      const shortcut = shortcutsForTrigger[shortcutText];
      if (!shortcut || shortcut.type === "paragraph" && block5[0].type !== "paragraph") {
        return;
      }
      const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);
      if (locationDocumentFeatures && (locationDocumentFeatures.kind === "inline" || !shortcut.shouldBeEnabledInComponentBlock(locationDocumentFeatures.documentFeatures))) {
        return;
      }
      editor.history.undos.push({
        operations: [],
        selectionBefore: editor.selection
      });
      Transforms.select(editor, range);
      Transforms.delete(editor);
      shortcut.insert();
    }
  };
  return editor;
}
function getDirectBlockquoteParentFromSelection(editor) {
  if (!editor.selection)
    return {
      isInside: false
    };
  const [, parentPath] = Editor.parent(editor, editor.selection);
  if (!parentPath.length) {
    return {
      isInside: false
    };
  }
  const [maybeBlockquoteParent, maybeBlockquoteParentPath] = Editor.parent(editor, parentPath);
  const isBlockquote = maybeBlockquoteParent.type === "blockquote";
  return isBlockquote ? {
    isInside: true,
    path: maybeBlockquoteParentPath
  } : {
    isInside: false
  };
}
function withBlockquote(editor) {
  const {
    insertBreak,
    deleteBackward
  } = editor;
  editor.deleteBackward = (unit) => {
    if (editor.selection) {
      const parentBlockquote = getDirectBlockquoteParentFromSelection(editor);
      if (parentBlockquote.isInside && Range.isCollapsed(editor.selection) && // the selection is at the start of the paragraph
      editor.selection.anchor.offset === 0 && // it's the first paragraph in the panel
      editor.selection.anchor.path[editor.selection.anchor.path.length - 2] === 0) {
        Transforms.unwrapNodes(editor, {
          match: (node3) => node3.type === "blockquote",
          split: true
        });
        return;
      }
    }
    deleteBackward(unit);
  };
  editor.insertBreak = () => {
    const panel = getDirectBlockquoteParentFromSelection(editor);
    if (editor.selection && panel.isInside) {
      const [node3, nodePath] = Editor.node(editor, editor.selection);
      if (Path.isDescendant(nodePath, panel.path) && Node3.string(node3) === "") {
        Transforms.unwrapNodes(editor, {
          match: (node4) => node4.type === "blockquote",
          split: true
        });
        return;
      }
    }
    insertBreak();
  };
  return editor;
}
function withHeading(editor) {
  const {
    insertBreak
  } = editor;
  editor.insertBreak = () => {
    insertBreak();
    const entry = Editor.above(editor, {
      match: (n6) => n6.type === "heading"
    });
    if (!entry || !editor.selection || !Range.isCollapsed(editor.selection)) {
      return;
    }
    const path2 = entry[1];
    if (
      // we want to unwrap the heading when the user inserted a break at the end of the heading
      // when the user inserts a break at the end of a heading, the new heading
      // that we want to unwrap will be empty so the end will be equal to the selection
      Point.equals(Editor.end(editor, path2), editor.selection.anchor)
    ) {
      Transforms.unwrapNodes(editor, {
        at: path2
      });
      return;
    }
    if (!Path.hasPrevious(path2)) {
      return;
    }
    const previousPath = Path.previous(path2);
    const previousNode = Node3.get(editor, previousPath);
    if (previousNode.type === "heading" && previousNode.children.length === 1 && Text2.isText(previousNode.children[0]) && previousNode.children[0].text === "") {
      Transforms.unwrapNodes(editor, {
        at: previousPath
      });
    }
  };
  return editor;
}
var allMarkdownShortcuts = {
  bold: ["**", "__"],
  italic: ["*", "_"],
  strikethrough: ["~~"],
  code: ["`"]
};
function applyMark(editor, mark, shortcutText, startOfStartPoint) {
  editor.history.undos.push({
    operations: [],
    selectionBefore: editor.selection
  });
  const startPointRef = Editor.pointRef(editor, startOfStartPoint);
  Transforms.delete(editor, {
    at: editor.selection.anchor,
    distance: shortcutText.length,
    reverse: true
  });
  Transforms.delete(editor, {
    at: startOfStartPoint,
    distance: shortcutText.length
  });
  Transforms.setNodes(editor, {
    [mark]: true
  }, {
    match: Text2.isText,
    split: true,
    at: {
      anchor: startPointRef.unref(),
      focus: editor.selection.anchor
    }
  });
  editor.removeMark(mark);
}
function withMarks(editorDocumentFeatures, componentBlocks, editor) {
  const {
    insertText,
    insertBreak
  } = editor;
  editor.insertBreak = () => {
    insertBreak();
    const marksAfterInsertBreak = Editor.marks(editor);
    if (!marksAfterInsertBreak || !editor.selection)
      return;
    const parentBlock = Editor.above(editor, {
      match: isBlock
    });
    if (!parentBlock)
      return;
    const point = EditorAfterButIgnoringingPointsWithNoContent(editor, editor.selection.anchor);
    const marksAfterInsertBreakArr = Object.keys(marksAfterInsertBreak);
    if (!point || !Path.isDescendant(point.path, parentBlock[1])) {
      for (const mark of marksAfterInsertBreakArr) {
        editor.removeMark(mark);
      }
      return;
    }
    const textNode = Node3.get(editor, point.path);
    for (const mark of marksAfterInsertBreakArr) {
      if (!textNode[mark]) {
        editor.removeMark(mark);
      }
    }
  };
  const selectedMarkdownShortcuts = {};
  const enabledMarks = editorDocumentFeatures.formatting.inlineMarks;
  Object.keys(allMarkdownShortcuts).forEach((mark) => {
    if (enabledMarks[mark]) {
      selectedMarkdownShortcuts[mark] = allMarkdownShortcuts[mark];
    }
  });
  if (Object.keys(selectedMarkdownShortcuts).length === 0)
    return editor;
  editor.insertText = (text3) => {
    insertText(text3);
    if (editor.selection && Range.isCollapsed(editor.selection)) {
      for (const [mark, shortcuts2] of Object.entries(selectedMarkdownShortcuts)) {
        for (const shortcutText of shortcuts2) {
          if (text3 === shortcutText[shortcutText.length - 1]) {
            const startOfBlock = getStartOfBlock(editor);
            let startOfBlockToEndOfShortcutString = Editor.string(editor, {
              anchor: editor.selection.anchor,
              focus: startOfBlock
            });
            const hasWhitespaceBeforeEndOfShortcut = /\s/.test(startOfBlockToEndOfShortcutString.slice(-shortcutText.length - 1, -shortcutText.length));
            const endOfShortcutContainsExpectedContent = shortcutText === startOfBlockToEndOfShortcutString.slice(-shortcutText.length);
            if (hasWhitespaceBeforeEndOfShortcut || !endOfShortcutContainsExpectedContent) {
              continue;
            }
            const strToMatchOn = startOfBlockToEndOfShortcutString.slice(0, -shortcutText.length - 1);
            for (const [offsetFromStartOfBlock] of [...strToMatchOn].reverse().entries()) {
              const expectedShortcutText = strToMatchOn.slice(offsetFromStartOfBlock, offsetFromStartOfBlock + shortcutText.length);
              if (expectedShortcutText !== shortcutText) {
                continue;
              }
              const startOfStartOfShortcut = offsetFromStartOfBlock === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {
                distance: offsetFromStartOfBlock
              });
              const endOfStartOfShortcut = Editor.after(editor, startOfStartOfShortcut, {
                distance: shortcutText.length
              });
              if (offsetFromStartOfBlock !== 0 && !/\s/.test(Editor.string(editor, {
                anchor: Editor.before(editor, startOfStartOfShortcut, {
                  unit: "character"
                }),
                focus: startOfStartOfShortcut
              }))) {
                continue;
              }
              const contentBetweenShortcuts = Editor.string(editor, {
                anchor: endOfStartOfShortcut,
                focus: editor.selection.anchor
              }).slice(0, -shortcutText.length);
              if (contentBetweenShortcuts === "" || /\s/.test(contentBetweenShortcuts[0])) {
                continue;
              }
              if (mark === "italic" && (contentBetweenShortcuts[0] === "_" || contentBetweenShortcuts[0] === "*")) {
                continue;
              }
              if (mark === "code" && contentBetweenShortcuts === "`") {
                continue;
              }
              const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);
              if (ancestorComponentChildFieldDocumentFeatures && ancestorComponentChildFieldDocumentFeatures.inlineMarks !== "inherit" && ancestorComponentChildFieldDocumentFeatures.inlineMarks[mark] === false) {
                continue;
              }
              applyMark(editor, mark, shortcutText, startOfStartOfShortcut);
              return;
            }
          }
        }
      }
    }
  };
  return editor;
}
function getStartOfBlock(editor) {
  return Editor.start(editor, Editor.above(editor, {
    match: isBlock
  })[1]);
}
function getAlignmentFromElement(element2) {
  const parent = element2.parentElement;
  const attribute = parent === null || parent === void 0 ? void 0 : parent.getAttribute("data-align");
  if (attribute === "center" || attribute === "end") {
    return attribute;
  }
  if (element2 instanceof HTMLElement) {
    const textAlign = element2.style.textAlign;
    if (textAlign === "center") {
      return "center";
    }
    if (textAlign === "right" || textAlign === "end") {
      return "end";
    }
  }
}
var headings = {
  H1: 1,
  H2: 2,
  H3: 3,
  H4: 4,
  H5: 5,
  H6: 6
};
var TEXT_TAGS = {
  CODE: "code",
  DEL: "strikethrough",
  S: "strikethrough",
  STRIKE: "strikethrough",
  EM: "italic",
  I: "italic",
  STRONG: "bold",
  U: "underline",
  SUP: "superscript",
  SUB: "subscript",
  KBD: "keyboard"
};
function marksFromElementAttributes(element2) {
  const marks = /* @__PURE__ */ new Set();
  const style = element2.style;
  const {
    nodeName
  } = element2;
  const markFromNodeName = TEXT_TAGS[nodeName];
  if (markFromNodeName) {
    marks.add(markFromNodeName);
  }
  const {
    fontWeight,
    textDecoration,
    verticalAlign
  } = style;
  if (textDecoration === "underline") {
    marks.add("underline");
  } else if (textDecoration === "line-through") {
    marks.add("strikethrough");
  }
  if (nodeName === "SPAN" && element2.classList.contains("code")) {
    marks.add("code");
  }
  if (nodeName === "B" && fontWeight !== "normal") {
    marks.add("bold");
  } else if (typeof fontWeight === "string" && (fontWeight === "bold" || fontWeight === "bolder" || fontWeight === "1000" || /^[5-9]\d{2}$/.test(fontWeight))) {
    marks.add("bold");
  }
  if (style.fontStyle === "italic") {
    marks.add("italic");
  }
  if (verticalAlign === "super") {
    marks.add("superscript");
  } else if (verticalAlign === "sub") {
    marks.add("subscript");
  }
  return marks;
}
function deserializeHTML(html) {
  const parsed = new DOMParser().parseFromString(html, "text/html");
  return fixNodesForBlockChildren(deserializeNodes(parsed.body.childNodes));
}
function deserializeHTMLNode(el) {
  if (!(el instanceof globalThis.HTMLElement)) {
    const text3 = el.textContent;
    if (!text3) {
      return [];
    }
    return getInlineNodes(text3);
  }
  if (el.nodeName === "BR") {
    return getInlineNodes("\n");
  }
  if (el.nodeName === "IMG") {
    const alt = el.getAttribute("alt");
    return getInlineNodes(alt !== null && alt !== void 0 ? alt : "");
  }
  if (el.nodeName === "HR") {
    return [{
      type: "divider",
      children: [{
        text: ""
      }]
    }];
  }
  const marks = marksFromElementAttributes(el);
  if (el.classList.contains("listtype-quote")) {
    marks.delete("italic");
    return addMarksToChildren(marks, () => [{
      type: "blockquote",
      children: fixNodesForBlockChildren(deserializeNodes(el.childNodes))
    }]);
  }
  return addMarksToChildren(marks, () => {
    const {
      nodeName
    } = el;
    if (nodeName === "A") {
      const href = el.getAttribute("href");
      if (href) {
        return setLinkForChildren(href, () => forceDisableMarkForChildren("underline", () => deserializeNodes(el.childNodes)));
      }
    }
    if (nodeName === "PRE" && el.textContent) {
      return [{
        type: "code",
        children: [{
          text: el.textContent || ""
        }]
      }];
    }
    const deserialized = deserializeNodes(el.childNodes);
    const children = fixNodesForBlockChildren(deserialized);
    if (nodeName === "LI") {
      let nestedList;
      const listItemContent = {
        type: "list-item-content",
        children: children.filter((node3) => {
          if (nestedList === void 0 && (node3.type === "ordered-list" || node3.type === "unordered-list")) {
            nestedList = node3;
            return false;
          }
          return true;
        })
      };
      const listItemChildren = nestedList ? [listItemContent, nestedList] : [listItemContent];
      return [{
        type: "list-item",
        children: listItemChildren
      }];
    }
    if (nodeName === "P") {
      return [{
        type: "paragraph",
        textAlign: getAlignmentFromElement(el),
        children
      }];
    }
    const headingLevel = headings[nodeName];
    if (typeof headingLevel === "number") {
      return [{
        type: "heading",
        level: headingLevel,
        textAlign: getAlignmentFromElement(el),
        children
      }];
    }
    if (nodeName === "BLOCKQUOTE") {
      return [{
        type: "blockquote",
        children
      }];
    }
    if (nodeName === "OL") {
      return [{
        type: "ordered-list",
        children
      }];
    }
    if (nodeName === "UL") {
      return [{
        type: "unordered-list",
        children
      }];
    }
    if (nodeName === "DIV" && !isBlock(children[0])) {
      return [{
        type: "paragraph",
        children
      }];
    }
    return deserialized;
  });
}
function deserializeNodes(nodes) {
  const outputNodes = [];
  for (const node3 of nodes) {
    outputNodes.push(...deserializeHTMLNode(node3));
  }
  return outputNodes;
}
function fixNodesForBlockChildren(deserializedNodes) {
  if (!deserializedNodes.length) {
    return [{
      text: ""
    }];
  }
  if (deserializedNodes.some(isBlock)) {
    const result = [];
    let queuedInlines = [];
    const flushInlines = () => {
      if (queuedInlines.length) {
        result.push({
          type: "paragraph",
          children: queuedInlines
        });
        queuedInlines = [];
      }
    };
    for (const node3 of deserializedNodes) {
      if (isBlock(node3)) {
        flushInlines();
        result.push(node3);
        continue;
      }
      if (Node3.string(node3).trim() !== "") {
        queuedInlines.push(node3);
      }
    }
    flushInlines();
    return result;
  }
  return deserializedNodes;
}
var markdownConfig = {
  mdastExtensions: [import_from_markdown.default, import_from_markdown2.default],
  extensions: [import_micromark_extension_gfm_autolink_literal.default, (0, import_micromark_extension_gfm_strikethrough.default)()]
};
function deserializeMarkdown(markdown) {
  const root = (0, import_mdast_util_from_markdown.default)(markdown, markdownConfig);
  let nodes = root.children;
  if (nodes.length === 1 && nodes[0].type === "paragraph") {
    nodes = nodes[0].children;
  }
  return deserializeChildren(nodes, markdown);
}
function deserializeChildren(nodes, input) {
  const outputNodes = [];
  for (const node3 of nodes) {
    const result = deserializeMarkdownNode(node3, input);
    if (result.length) {
      outputNodes.push(...result);
    }
  }
  if (!outputNodes.length) {
    outputNodes.push({
      text: ""
    });
  }
  return outputNodes;
}
function deserializeMarkdownNode(node3, input) {
  switch (node3.type) {
    case "blockquote": {
      return [{
        type: "blockquote",
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "link": {
      return setLinkForChildren(node3.url, () => deserializeChildren(node3.children, input));
    }
    case "code": {
      return [{
        type: "code",
        children: [{
          text: node3.value
        }]
      }];
    }
    case "paragraph": {
      return [{
        type: "paragraph",
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "heading": {
      return [{
        type: "heading",
        level: node3.depth,
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "list": {
      return [{
        type: node3.ordered ? "ordered-list" : "unordered-list",
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "listItem": {
      return [{
        type: "list-item",
        children: deserializeChildren(node3.children, input)
      }];
    }
    case "thematicBreak": {
      return [{
        type: "divider",
        children: [{
          text: ""
        }]
      }];
    }
    case "break": {
      return getInlineNodes("\n");
    }
    case "delete": {
      return addMarkToChildren("strikethrough", () => deserializeChildren(node3.children, input));
    }
    case "strong": {
      return addMarkToChildren("bold", () => deserializeChildren(node3.children, input));
    }
    case "emphasis": {
      return addMarkToChildren("italic", () => deserializeChildren(node3.children, input));
    }
    case "inlineCode": {
      return addMarkToChildren("code", () => getInlineNodes(node3.value));
    }
    case "text": {
      return getInlineNodes(node3.value);
    }
  }
  return getInlineNodes(input.slice(node3.position.start.offset, node3.position.end.offset));
}
var urlPattern = /https?:\/\//;
function insertFragmentButDifferent(editor, nodes) {
  if (isBlock(nodes[0])) {
    insertNodesButReplaceIfSelectionIsAtEmptyParagraphOrHeading(editor, nodes);
  } else {
    Transforms.insertFragment(editor, nodes);
  }
}
var clipboardFormatKey = "x-keystatic-fragment";
var getDefaultView2 = (value2) => {
  return value2 && value2.ownerDocument && value2.ownerDocument.defaultView || null;
};
var isDOMNode2 = (value2) => {
  const window2 = getDefaultView2(value2);
  return !!window2 && value2 instanceof window2.Node;
};
var isDOMText2 = (value2) => {
  return isDOMNode2(value2) && value2.nodeType === 3;
};
var isDOMElement2 = (value2) => {
  return isDOMNode2(value2) && value2.nodeType === 1;
};
var getPlainText2 = (domNode) => {
  let text3 = "";
  if (isDOMText2(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }
  if (isDOMElement2(domNode)) {
    for (const childNode of Array.from(domNode.childNodes)) {
      text3 += getPlainText2(childNode);
    }
    const display = getComputedStyle(domNode).getPropertyValue("display");
    if (display === "block" || display === "list" || domNode.tagName === "BR") {
      text3 += "\n";
    }
  }
  return text3;
};
function setFragmentData(e6, data) {
  const {
    selection
  } = e6;
  if (!selection) {
    return;
  }
  const [start2, end] = Range.edges(selection);
  const startVoid = Editor.void(e6, {
    at: start2.path
  });
  const endVoid = Editor.void(e6, {
    at: end.path
  });
  if (Range.isCollapsed(selection) && !startVoid) {
    return;
  }
  const domRange = ReactEditor.toDOMRange(e6, selection);
  let contents = domRange.cloneContents();
  let attach = contents.childNodes[0];
  contents.childNodes.forEach((node3) => {
    if (node3.textContent && node3.textContent.trim() !== "") {
      attach = node3;
    }
  });
  if (endVoid) {
    const [voidNode] = endVoid;
    const r7 = domRange.cloneRange();
    const domNode = ReactEditor.toDOMNode(e6, voidNode);
    r7.setEndAfter(domNode);
    contents = r7.cloneContents();
  }
  if (startVoid) {
    attach = contents.querySelector("[data-slate-spacer]");
  }
  Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
    const isNewline = zw.getAttribute("data-slate-zero-width") === "n";
    zw.textContent = isNewline ? "\n" : "";
  });
  if (isDOMText2(attach)) {
    const span = attach.ownerDocument.createElement("span");
    span.style.whiteSpace = "pre";
    span.appendChild(attach);
    contents.appendChild(span);
    attach = span;
  }
  const fragment = e6.getFragment();
  const string = JSON.stringify(fragment, (key, val) => {
    if (val instanceof Uint8Array) {
      return {
        [bytesName]: fromUint8Array(val)
      };
    }
    return val;
  });
  const encoded = window.btoa(encodeURIComponent(string));
  attach.setAttribute("data-keystatic-fragment", encoded);
  data.setData(`application/${clipboardFormatKey}`, encoded);
  const div = contents.ownerDocument.createElement("div");
  div.appendChild(contents);
  div.setAttribute("hidden", "true");
  contents.ownerDocument.body.appendChild(div);
  data.setData("text/html", div.innerHTML);
  data.setData("text/plain", getPlainText2(div));
  contents.ownerDocument.body.removeChild(div);
}
var catchSlateFragment2 = /data-keystatic-fragment="(.+?)"/m;
var getSlateFragmentAttribute2 = (dataTransfer) => {
  const htmlData = dataTransfer.getData("text/html");
  const [, fragment] = htmlData.match(catchSlateFragment2) || [];
  return fragment;
};
var bytesName = "$$keystaticUint8Array$$";
function withPasting(editor) {
  const {
    insertTextData
  } = editor;
  editor.setFragmentData = (data) => {
    setFragmentData(editor, data);
  };
  editor.insertFragmentData = (data) => {
    const fragment = data.getData(`application/${clipboardFormatKey}`) || getSlateFragmentAttribute2(data);
    if (fragment) {
      const decoded = decodeURIComponent(window.atob(fragment));
      const parsed = JSON.parse(decoded, (key, val) => typeof val === "object" && val !== null && bytesName in val && typeof val[bytesName] === "string" ? toUint8Array(val[bytesName]) : val);
      editor.insertFragment(parsed);
      return true;
    }
    return false;
  };
  editor.insertTextData = (data) => {
    const blockAbove = Editor.above(editor, {
      match: isBlock
    });
    if ((blockAbove === null || blockAbove === void 0 ? void 0 : blockAbove[0].type) === "code") {
      const plain2 = data.getData("text/plain");
      editor.insertText(plain2);
      return true;
    }
    let vsCodeEditorData = data.getData("vscode-editor-data");
    if (vsCodeEditorData) {
      try {
        const vsCodeData = JSON.parse(vsCodeEditorData);
        if ((vsCodeData === null || vsCodeData === void 0 ? void 0 : vsCodeData.mode) === "markdown" || (vsCodeData === null || vsCodeData === void 0 ? void 0 : vsCodeData.mode) === "mdx") {
          const plain2 = data.getData("text/plain");
          if (plain2) {
            const fragment = deserializeMarkdown(plain2);
            insertFragmentButDifferent(editor, fragment);
            return true;
          }
        }
      } catch (err) {
        console.log(err);
      }
    }
    const plain = data.getData("text/plain");
    if (
      // isValidURL is a bit more permissive than a user might expect
      // so for pasting, we'll constrain it to starting with https:// or http://
      urlPattern.test(plain) && isValidURL(plain) && editor.selection && !Range.isCollapsed(editor.selection) && // we only want to turn the selected text into a link if the selection is within the same block
      Editor.above(editor, {
        match: (node3) => isBlock(node3) && !isBlock(node3.children[0])
      }) && // and there is only text(potentially with marks) in the selection
      // no other links
      Editor.nodes(editor, {
        match: (node3) => node3.type === "link"
      }).next().done
    ) {
      Transforms.wrapNodes(editor, {
        type: "link",
        href: plain,
        children: []
      }, {
        split: true
      });
      return true;
    }
    const html = data.getData("text/html");
    if (html) {
      const fragment = deserializeHTML(html);
      insertFragmentButDifferent(editor, fragment);
      return true;
    }
    if (plain) {
      const fragment = deserializeMarkdown(plain);
      insertFragmentButDifferent(editor, fragment);
      return true;
    }
    return insertTextData(data);
  };
  return editor;
}
var shortcuts = {
  "...": "…",
  "-->": "→",
  "->": "→",
  "<-": "←",
  "<--": "←",
  "--": "–"
};
function withShortcuts(editor) {
  const {
    insertText
  } = editor;
  editor.insertText = (text3) => {
    insertText(text3);
    if (text3 === " " && editor.selection && Range.isCollapsed(editor.selection)) {
      const selectionPoint = editor.selection.anchor;
      const ancestorBlock = Editor.above(editor, {
        match: isBlock
      });
      if (ancestorBlock) {
        Object.keys(shortcuts).forEach((shortcut) => {
          const pointBefore = Editor.before(editor, selectionPoint, {
            unit: "character",
            distance: shortcut.length + 1
          });
          if (pointBefore && Path.isDescendant(pointBefore.path, ancestorBlock[1])) {
            const range = {
              anchor: selectionPoint,
              focus: pointBefore
            };
            const str = Editor.string(editor, range);
            if (str.slice(0, shortcut.length) === shortcut) {
              editor.history.undos.push({
                operations: [],
                selectionBefore: editor.selection
              });
              Transforms.select(editor, range);
              editor.insertText(shortcuts[shortcut] + " ");
            }
          }
        });
      }
    }
  };
  return editor;
}
function withSoftBreaks(editor) {
  editor.insertSoftBreak = () => {
    Transforms.insertText(editor, "\n");
  };
  return editor;
}
var HOTKEYS2 = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline"
};
function isMarkActive(editor, mark) {
  const marks = Editor.marks(editor);
  if (marks !== null && marks !== void 0 && marks[mark]) {
    return true;
  }
  for (const entry of Editor.nodes(editor, {
    match: Text2.isText
  })) {
    if (entry[0][mark]) {
      return true;
    }
  }
  return false;
}
var arrowKeyToDirection = /* @__PURE__ */ new Map([["ArrowUp", "up"], ["ArrowDown", "down"], ["ArrowLeft", "left"], ["ArrowRight", "right"]]);
var getKeyDownHandler = (editor, documentFeatures) => (event) => {
  if (event.defaultPrevented)
    return;
  for (const hotkey in HOTKEYS2) {
    if (documentFeatures.formatting.inlineMarks[HOTKEYS2[hotkey]] && (0, import_is_hotkey2.default)(hotkey, event.nativeEvent)) {
      event.preventDefault();
      const mark = HOTKEYS2[hotkey];
      const isActive = isMarkActive(editor, mark);
      if (isActive) {
        Editor.removeMark(editor, mark);
      } else {
        Editor.addMark(editor, mark, true);
      }
      return;
    }
  }
  if ((0, import_is_hotkey2.default)("mod+\\", event.nativeEvent)) {
    clearFormatting(editor);
    return;
  }
  if (documentFeatures.links && (0, import_is_hotkey2.default)("mod+k", event.nativeEvent)) {
    event.preventDefault();
    wrapLink(editor, "");
    return;
  }
  if (event.key === "Tab") {
    const didAction = event.shiftKey ? unnestList(editor) : nestList(editor);
    if (didAction) {
      event.preventDefault();
      return;
    }
  }
  if (event.key === "Tab" && editor.selection) {
    const layoutArea = Editor.above(editor, {
      match: (node3) => node3.type === "layout-area" || node3.type === "table-cell"
    });
    if (layoutArea) {
      const layoutAreaToEnter = event.shiftKey ? Editor.before(editor, layoutArea[1], {
        unit: "block"
      }) : Editor.after(editor, layoutArea[1], {
        unit: "block"
      });
      Transforms.setSelection(editor, {
        anchor: layoutAreaToEnter,
        focus: layoutAreaToEnter
      });
      event.preventDefault();
    }
  }
  if ((0, import_is_hotkey2.default)("mod+a", event)) {
    const parentTable = Editor.above(editor, {
      match: nodeTypeMatcher("table")
    });
    if (parentTable) {
      Transforms.select(editor, parentTable[1]);
      event.preventDefault();
      return;
    }
  }
  const direction = arrowKeyToDirection.get(event.key);
  const {
    selection
  } = editor;
  if (direction && selection) {
    const selectedTableArea = getSelectedTableArea(editor);
    if (selectedTableArea) {
      var _Editor$above, _Editor$above2;
      const focusCellPath = (_Editor$above = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell"),
        at: selection.focus.path
      })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];
      const anchorCellPath = (_Editor$above2 = Editor.above(editor, {
        match: nodeTypeMatcher("table-cell"),
        at: selection.anchor.path
      })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];
      if (!focusCellPath || !anchorCellPath)
        return;
      const newCellPath = getCellPathInDirection(editor, focusCellPath, direction);
      if (newCellPath) {
        if (selectedTableArea.singleCell === "not-selected") {
          if (direction !== "up" && direction !== "down")
            return;
          const [node3, offset] = ReactEditor.toDOMPoint(editor, selection.focus);
          const blockElement = Editor.above(editor, {
            match: isBlock,
            at: selection.focus.path
          });
          if (!blockElement)
            return;
          if (direction === "up" && blockElement[1].slice(focusCellPath.length).some((idx) => idx !== 0)) {
            return;
          }
          if (direction === "down") {
            const [parentNode] = Editor.parent(editor, blockElement[1]);
            if (parentNode.children.length - 1 !== blockElement[1][blockElement[1].length - 1]) {
              return;
            }
            for (const [node4, path2] of Node3.ancestors(editor, blockElement[1], {
              reverse: true
            })) {
              if (node4.type === "table-cell")
                break;
              const [parentNode2] = Editor.parent(editor, path2);
              if (parentNode2.children.length - 1 === path2[path2.length - 1]) {
                continue;
              }
              return;
            }
          }
          const domNodeForBlockElement = ReactEditor.toDOMNode(editor, blockElement[0]);
          const rangeOfWholeBlock = document.createRange();
          rangeOfWholeBlock.selectNodeContents(domNodeForBlockElement);
          const rectsOfRangeOfWholeBlock = Array.from(rangeOfWholeBlock.getClientRects());
          const newRange = document.createRange();
          newRange.setStart(node3, offset);
          newRange.setEnd(node3, offset);
          const rangeRects = Array.from(newRange.getClientRects());
          const lastRangeRect = rangeRects[rangeRects.length - 1];
          const key = direction === "up" ? "top" : "bottom";
          const expected = key === "top" ? Math.min(...rectsOfRangeOfWholeBlock.map((x3) => x3.top)) : Math.max(...rectsOfRangeOfWholeBlock.map((x3) => x3.bottom));
          if (lastRangeRect[key] === expected) {
            const focus = Editor[direction === "up" ? "end" : "start"](editor, newCellPath);
            Transforms.select(editor, {
              focus,
              anchor: event.shiftKey ? selection.anchor : focus
            });
            event.preventDefault();
          }
          return;
        }
        if (!event.shiftKey)
          return;
        if (Path.equals(newCellPath, anchorCellPath)) {
          Transforms.select(editor, newCellPath);
        } else {
          Transforms.select(editor, {
            anchor: selection.anchor,
            focus: Editor.start(editor, newCellPath)
          });
        }
        event.preventDefault();
      }
    }
  }
};
function createDocumentEditor(documentFeatures, componentBlocks) {
  return withPasting(withImages(withSoftBreaks(withInsertMenu(withShortcuts(withHeading(withBlockquote(withMarks(documentFeatures, componentBlocks, withBlockMarkdownShortcuts(documentFeatures, componentBlocks, _createDocumentEditor(withHistory(withReact(createEditor())), documentFeatures, componentBlocks))))))))));
}
function DocumentEditor({
  onChange,
  value: value2,
  componentBlocks,
  documentFeatures,
  ...props
}) {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = (0, import_react73.useMemo)(() => createDocumentEditor(documentFeatures, componentBlocks), [documentFeatures, componentBlocks]);
  return (0, import_jsx_runtime76.jsx)("div", {
    "data-layout": entryLayoutPane,
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      minWidth: 0,
      '&[data-layout="main"]': {
        flex: 1,
        display: "flex",
        flexDirection: "column"
      },
      '&:not([data-layout="main"])': {
        border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
        borderRadius: tokenSchema.size.radius.medium
      }
    }), "keystar-document-editor"),
    children: (0, import_jsx_runtime76.jsxs)(DocumentEditorProvider, {
      componentBlocks,
      documentFeatures,
      editor,
      value: value2,
      onChange: (value3) => {
        onChange === null || onChange === void 0 || onChange(value3);
        const selection = window.getSelection();
        if (selection && !ReactEditor.isFocused(editor)) {
          const editorNode = ReactEditor.toDOMNode(editor, editor);
          if (selection.anchorNode === editorNode) {
            ReactEditor.focus(editor);
          }
        }
      },
      children: [
        (0, import_react73.useMemo)(() => onChange !== void 0 && (0, import_jsx_runtime76.jsx)(Toolbar, {
          documentFeatures
        }), [documentFeatures, onChange]),
        (0, import_jsx_runtime76.jsx)(DocumentEditorEditable, {
          ...props,
          readOnly: onChange === void 0
        }),
        // for debugging
        false
      ]
    })
  });
}
var IsInEditorContext = (0, import_react73.createContext)(false);
function useIsInDocumentEditor() {
  return (0, import_react73.useContext)(IsInEditorContext);
}
function DocumentEditorProvider({
  children,
  editor,
  onChange,
  value: value2,
  componentBlocks,
  documentFeatures
}) {
  const identity3 = (0, import_react73.useMemo)(() => Math.random().toString(36), [editor]);
  return (0, import_jsx_runtime76.jsx)(IsInEditorContext.Provider, {
    value: true,
    children: (0, import_jsx_runtime76.jsx)(
      Slate,
      {
        editor,
        value: value2,
        onChange: (value3) => {
          onChange(value3);
          const selection = window.getSelection();
          if (selection && !ReactEditor.isFocused(editor)) {
            const editorNode = ReactEditor.toDOMNode(editor, editor);
            if (selection.anchorNode === editorNode) {
              ReactEditor.focus(editor);
            }
          }
        },
        children: (0, import_jsx_runtime76.jsx)(TableSelectionProvider, {
          children: (0, import_jsx_runtime76.jsx)(ToolbarStateProvider, {
            componentBlocks,
            editorDocumentFeatures: documentFeatures,
            children
          })
        })
      },
      identity3
    )
  });
}
function getPrismTokenLength(token2) {
  if (typeof token2 === "string") {
    return token2.length;
  } else if (Array.isArray(token2.content)) {
    return token2.content.reduce((l6, t5) => l6 + getPrismTokenLength(t5), 0);
  } else {
    return getPrismTokenLength(token2.content);
  }
}
function DocumentEditorEditable(props) {
  const containerSize = useContentPanelSize();
  const entryLayoutPane = useEntryLayoutSplitPaneContext();
  const editor = useSlate();
  const {
    componentBlocks,
    documentFeatures
  } = useDocumentEditorConfig();
  const onKeyDown = (0, import_react73.useMemo)(() => getKeyDownHandler(editor, documentFeatures), [editor, documentFeatures]);
  return (0, import_jsx_runtime76.jsx)(ActiveBlockPopoverProvider, {
    editor,
    children: (0, import_jsx_runtime76.jsx)(Prose, {
      size: entryLayoutPane === "main" ? "medium" : "regular",
      children: (0, import_jsx_runtime76.jsx)(Editable, {
        placeholder: 'Start writing or press "/" for commands...',
        decorate: (0, import_react73.useCallback)(([node3, path2]) => {
          let decorations = [];
          if (node3.type === "component-block") {
            if (node3.children.length === 1 && Element2.isElement(node3.children[0]) && node3.children[0].type === "component-inline-prop" && node3.children[0].propPath === void 0) {
              return decorations;
            }
            node3.children.forEach((child, index2) => {
              if (Node3.string(child) === "" && Element2.isElement(child) && (child.type === "component-block-prop" || child.type === "component-inline-prop") && child.propPath !== void 0) {
                const start2 = Editor.start(editor, [...path2, index2]);
                const placeholder = getPlaceholderTextForPropPath(child.propPath, componentBlocks[node3.component].schema, node3.props);
                if (placeholder) {
                  decorations.push({
                    placeholder,
                    anchor: start2,
                    focus: start2
                  });
                }
              }
            });
          }
          if (node3.type === "code" && node3.children.length === 1 && node3.children[0].type === void 0 && node3.language && node3.language in Prism.languages) {
            let consumeTokens = function(start2, tokens2) {
              for (const token2 of tokens2) {
                const length2 = getPrismTokenLength(token2);
                const end = start2 + length2;
                if (typeof token2 !== "string") {
                  decorations.push({
                    ["prism_" + token2.type]: true,
                    anchor: {
                      path: textPath,
                      offset: start2
                    },
                    focus: {
                      path: textPath,
                      offset: end
                    }
                  });
                  consumeTokens(start2, Array.isArray(token2.content) ? token2.content : [token2.content]);
                }
                start2 = end;
              }
            };
            const textPath = [...path2, 0];
            const tokens = Prism.tokenize(node3.children[0].text, Prism.languages[node3.language]);
            consumeTokens(0, tokens);
          }
          return decorations;
        }, [editor, componentBlocks]),
        onKeyDown,
        renderElement,
        renderLeaf,
        ...props,
        ...toDataAttributes({
          container: containerSize,
          layout: entryLayoutPane
        }),
        className: classNames(editableStyles, props.className)
      })
    })
  });
}
var styles = {
  flex: 1,
  height: "auto",
  minHeight: tokenSchema.size.scale[2e3],
  minWidth: 0,
  padding: tokenSchema.size.space.medium,
  '&[data-layout="main"]': {
    boxSizing: "border-box",
    height: "100%",
    padding: 0,
    paddingTop: tokenSchema.size.space.medium,
    minHeight: 0,
    minWidth: 0,
    maxWidth: 800,
    marginInline: "auto",
    [breakpointQueries$1.above.mobile]: {
      padding: tokenSchema.size.space.xlarge
    },
    [breakpointQueries$1.above.tablet]: {
      padding: tokenSchema.size.space.xxlarge
    },
    '&[data-container="wide"]': {
      padding: tokenSchema.size.scale[600]
    }
  }
};
var editableStyles = css({
  ...styles,
  a: {
    color: tokenSchema.color.foreground.accent
  }
});
var emptyObj = {};
var i$1 = 0;
function newKey$1() {
  return i$1++;
}
function InnerChildFieldInput(props) {
  const outerConfig = useDocumentEditorConfig();
  const [state, setState] = (0, import_react73.useState)(() => ({
    key: newKey$1(),
    value: props.value
  }));
  const documentFeatures = (0, import_react73.useMemo)(() => {
    return getWholeDocumentFeaturesForChildField(outerConfig.documentFeatures, props.schema.options);
  }, [props.schema, outerConfig.documentFeatures]);
  if (state.value !== props.value) {
    setState({
      key: newKey$1(),
      value: props.value
    });
  }
  return (0, import_jsx_runtime76.jsx)(ResetEntryLayoutContext, {
    children: (0, import_jsx_runtime76.jsx)(Field, {
      label: props.schema.options.label,
      children: (inputProps) => (0, import_react73.createElement)(DocumentEditor, {
        ...inputProps,
        key: state.key,
        componentBlocks: props.schema.options.componentBlocks === "inherit" ? outerConfig.componentBlocks : emptyObj,
        documentFeatures,
        onChange: (val) => {
          setState((state2) => ({
            key: state2.key,
            value: val
          }));
          props.onChange(val);
        },
        value: state.value
      })
    })
  });
}
function ChildFieldInput(props) {
  const data = getChildFieldData(props);
  if (props.schema.options.kind === "block" && (props.schema.options.editIn === "both" || props.schema.options.editIn === "modal") && data.value) {
    return (0, import_jsx_runtime76.jsx)(InnerChildFieldInput, {
      schema: props.schema,
      ...data
    });
  }
  return null;
}
function getInputComponent(schema) {
  if (schema.kind === "object") {
    var _schema$Input;
    return (_schema$Input = schema.Input) !== null && _schema$Input !== void 0 ? _schema$Input : ObjectFieldInput;
  }
  if (schema.kind === "conditional") {
    var _schema$Input2;
    return (_schema$Input2 = schema.Input) !== null && _schema$Input2 !== void 0 ? _schema$Input2 : ConditionalFieldInput;
  }
  if (schema.kind === "array") {
    var _schema$Input3;
    return (_schema$Input3 = schema.Input) !== null && _schema$Input3 !== void 0 ? _schema$Input3 : ArrayFieldInput;
  }
  if (schema.kind === "child") {
    return ChildFieldInput;
  }
  return schema.Input;
}
var InnerFormValueContentFromPreviewProps = (0, import_react73.memo)(function InnerFormValueContentFromPreview(props) {
  let Input = getInputComponent(props.schema);
  return (0, import_jsx_runtime76.jsx)(Input, {
    ...props,
    autoFocus: !!props.autoFocus,
    forceValidation: !!props.forceValidation
  });
});
var emptyArray$1 = [];
var FormValueContentFromPreviewProps = (0, import_react73.memo)(function FormValueContentFromPreview({
  slugField,
  ...props
}) {
  let Input = getInputComponent(props.schema);
  return (0, import_jsx_runtime76.jsx)(PathContextProvider, {
    value: emptyArray$1,
    children: (0, import_jsx_runtime76.jsx)(SlugFieldProvider, {
      value: slugField,
      children: (0, import_jsx_runtime76.jsx)(Input, {
        ...props,
        autoFocus: !!props.autoFocus,
        forceValidation: !!props.forceValidation
      })
    })
  });
});
var emptyArray = [];
var RESPONSIVE_PADDING = {
  mobile: "medium",
  tablet: "xlarge",
  desktop: "xxlarge"
};
function containerWidthForEntryLayout(config2) {
  return config2.entryLayout === "content" ? "none" : "medium";
}
var EntryLayoutSplitPaneContext = (0, import_react73.createContext)(null);
function useEntryLayoutSplitPaneContext() {
  return (0, import_react73.useContext)(EntryLayoutSplitPaneContext);
}
function ResetEntryLayoutContext(props) {
  return (0, import_jsx_runtime76.jsx)(EntryLayoutSplitPaneContext.Provider, {
    value: null,
    children: props.children
  });
}
function FormForEntry({
  formatInfo,
  forceValidation,
  slugField,
  entryLayout,
  previewProps: props
}) {
  const isAboveMobile = useContentPanelQuery({
    above: "mobile"
  });
  if (entryLayout === "content" && formatInfo.contentField && isAboveMobile) {
    const {
      contentField
    } = formatInfo;
    return (0, import_jsx_runtime76.jsx)(PathContextProvider, {
      value: emptyArray,
      children: (0, import_jsx_runtime76.jsx)(SlugFieldProvider, {
        value: slugField,
        children: (0, import_jsx_runtime76.jsxs)(SplitView, {
          autoSaveId: "keystatic-content-split-view",
          defaultSize: 320,
          minSize: 240,
          maxSize: 480,
          flex: true,
          children: [(0, import_jsx_runtime76.jsx)(SplitPaneSecondary, {
            children: (0, import_jsx_runtime76.jsx)(EntryLayoutSplitPaneContext.Provider, {
              value: "main",
              children: (0, import_jsx_runtime76.jsx)(ScrollView, {
                children: (0, import_jsx_runtime76.jsx)(AddToPathProvider, {
                  part: contentField.key,
                  children: (0, import_jsx_runtime76.jsx)(InnerFormValueContentFromPreviewProps, {
                    forceValidation,
                    ...props.fields[contentField.key]
                  })
                })
              })
            })
          }), (0, import_jsx_runtime76.jsx)(SplitPanePrimary, {
            children: (0, import_jsx_runtime76.jsx)(EntryLayoutSplitPaneContext.Provider, {
              value: "side",
              children: (0, import_jsx_runtime76.jsx)(ScrollView, {
                children: (0, import_jsx_runtime76.jsx)(Grid, {
                  gap: "xlarge",
                  padding: RESPONSIVE_PADDING,
                  children: Object.entries(props.fields).map(([key, propVal]) => key === contentField.key ? null : (0, import_jsx_runtime76.jsx)(AddToPathProvider, {
                    part: key,
                    children: (0, import_jsx_runtime76.jsx)(InnerFormValueContentFromPreviewProps, {
                      forceValidation,
                      ...propVal
                    })
                  }, key))
                })
              })
            })
          })]
        })
      })
    });
  }
  return (0, import_jsx_runtime76.jsx)(ScrollView, {
    children: (0, import_jsx_runtime76.jsx)(PageContainer, {
      paddingY: RESPONSIVE_PADDING,
      children: (0, import_jsx_runtime76.jsx)(
        FormValueContentFromPreviewProps,
        {
          forceValidation,
          slugField,
          ...props
        }
      )
    })
  });
}
var i5 = 0;
function newKey() {
  return i5++;
}
function DocumentFieldInput(props) {
  let entryLayoutPane = useEntryLayoutSplitPaneContext();
  const [state, setState] = (0, import_react73.useState)(() => ({
    key: newKey(),
    value: props.value
  }));
  if (state.value !== props.value) {
    setState({
      key: newKey(),
      value: props.value
    });
  }
  let fieldProps = {
    label: props.label,
    description: props.description
  };
  if (entryLayoutPane === "main") {
    fieldProps = {
      "aria-label": props.label
    };
  }
  return (0, import_jsx_runtime76.jsx)(Field, {
    height: entryLayoutPane === "main" ? "100%" : void 0,
    ...fieldProps,
    children: (inputProps) => (0, import_react73.createElement)(DocumentEditor, {
      ...inputProps,
      key: state.key,
      componentBlocks: props.componentBlocks,
      documentFeatures: props.documentFeatures,
      onChange: (val) => {
        setState((state2) => ({
          key: state2.key,
          value: val
        }));
        props.onChange(val);
      },
      value: state.value
    })
  });
}
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var defaultAltField = text2({
  label: "Alt text",
  description: "This text will be used by screen readers and search engines."
});
var emptyTitleField = basicFormFieldWithSimpleReaderParse({
  Input() {
    return null;
  },
  defaultValue() {
    return "";
  },
  parse(value2) {
    if (value2 === void 0)
      return "";
    if (typeof value2 !== "string") {
      throw new FieldDataError("Must be string");
    }
    return value2;
  },
  validate(value2) {
    return value2;
  },
  serialize(value2) {
    return {
      value: value2
    };
  }
});
function normaliseDocumentFeatures(config2) {
  var _config$formatting, _formatting$alignment, _formatting$alignment2, _formatting$blockType, _formatting$inlineMar, _formatting$inlineMar2, _formatting$inlineMar3, _formatting$inlineMar4, _formatting$inlineMar5, _formatting$inlineMar6, _formatting$inlineMar7, _formatting$inlineMar8, _formatting$listTypes, _formatting$listTypes2, _imagesConfig$schema$, _imagesConfig$schema, _imagesConfig$schema$2, _imagesConfig$schema2;
  const formatting = config2.formatting === true ? {
    // alignment: true, // not supported natively in markdown
    blockTypes: true,
    headingLevels: true,
    inlineMarks: true,
    listTypes: true,
    softBreaks: true
  } : (_config$formatting = config2.formatting) !== null && _config$formatting !== void 0 ? _config$formatting : {};
  const imagesConfig = config2.images === true ? {} : config2.images;
  return {
    formatting: {
      alignment: formatting.alignment === true ? {
        center: true,
        end: true
      } : {
        center: !!((_formatting$alignment = formatting.alignment) !== null && _formatting$alignment !== void 0 && _formatting$alignment.center),
        end: !!((_formatting$alignment2 = formatting.alignment) !== null && _formatting$alignment2 !== void 0 && _formatting$alignment2.end)
      },
      blockTypes: (formatting === null || formatting === void 0 ? void 0 : formatting.blockTypes) === true ? {
        blockquote: true,
        code: {
          schema: object({})
        }
      } : {
        blockquote: !!((_formatting$blockType = formatting.blockTypes) !== null && _formatting$blockType !== void 0 && _formatting$blockType.blockquote),
        code: ((_formatting$blockType2) => {
          if (((_formatting$blockType2 = formatting.blockTypes) === null || _formatting$blockType2 === void 0 ? void 0 : _formatting$blockType2.code) === void 0) {
            return false;
          }
          if (formatting.blockTypes.code === true || !formatting.blockTypes.code.schema) {
            return {
              schema: object({})
            };
          }
          for (const key of ["type", "children", "language"]) {
            if (key in formatting.blockTypes.code.schema) {
              throw new Error(`"${key}" cannot be a key in the schema for code blocks`);
            }
          }
          return {
            schema: object(formatting.blockTypes.code.schema)
          };
        })()
      },
      headings: ((_obj$schema) => {
        const opt = formatting === null || formatting === void 0 ? void 0 : formatting.headingLevels;
        const obj = typeof opt === "object" && "levels" in opt ? opt : {
          levels: opt,
          schema: void 0
        };
        if (obj.schema) {
          for (const key of ["type", "children", "level", "textAlign"]) {
            if (key in obj.schema) {
              throw new Error(`"${key}" cannot be a key in the schema for headings`);
            }
          }
        }
        return {
          levels: [...new Set(obj.levels === true ? [1, 2, 3, 4, 5, 6] : obj.levels)],
          schema: object((_obj$schema = obj.schema) !== null && _obj$schema !== void 0 ? _obj$schema : {})
        };
      })(),
      inlineMarks: formatting.inlineMarks === true ? {
        bold: true,
        code: true,
        italic: true,
        keyboard: false,
        // not supported natively in markdown
        strikethrough: true,
        subscript: false,
        // not supported natively in markdown
        superscript: false,
        // not supported natively in markdown
        underline: false
        // not supported natively in markdown
      } : {
        bold: !!((_formatting$inlineMar = formatting.inlineMarks) !== null && _formatting$inlineMar !== void 0 && _formatting$inlineMar.bold),
        code: !!((_formatting$inlineMar2 = formatting.inlineMarks) !== null && _formatting$inlineMar2 !== void 0 && _formatting$inlineMar2.code),
        italic: !!((_formatting$inlineMar3 = formatting.inlineMarks) !== null && _formatting$inlineMar3 !== void 0 && _formatting$inlineMar3.italic),
        strikethrough: !!((_formatting$inlineMar4 = formatting.inlineMarks) !== null && _formatting$inlineMar4 !== void 0 && _formatting$inlineMar4.strikethrough),
        underline: !!((_formatting$inlineMar5 = formatting.inlineMarks) !== null && _formatting$inlineMar5 !== void 0 && _formatting$inlineMar5.underline),
        keyboard: !!((_formatting$inlineMar6 = formatting.inlineMarks) !== null && _formatting$inlineMar6 !== void 0 && _formatting$inlineMar6.keyboard),
        subscript: !!((_formatting$inlineMar7 = formatting.inlineMarks) !== null && _formatting$inlineMar7 !== void 0 && _formatting$inlineMar7.subscript),
        superscript: !!((_formatting$inlineMar8 = formatting.inlineMarks) !== null && _formatting$inlineMar8 !== void 0 && _formatting$inlineMar8.superscript)
      },
      listTypes: formatting.listTypes === true ? {
        ordered: true,
        unordered: true
      } : {
        ordered: !!((_formatting$listTypes = formatting.listTypes) !== null && _formatting$listTypes !== void 0 && _formatting$listTypes.ordered),
        unordered: !!((_formatting$listTypes2 = formatting.listTypes) !== null && _formatting$listTypes2 !== void 0 && _formatting$listTypes2.unordered)
      },
      softBreaks: !!formatting.softBreaks
    },
    links: !!config2.links,
    layouts: [...new Set((config2.layouts || []).map((x3) => JSON.stringify(x3)))].map((x3) => JSON.parse(x3)),
    dividers: !!config2.dividers,
    images: imagesConfig === void 0 ? false : {
      ...imagesConfig,
      schema: {
        alt: (_imagesConfig$schema$ = (_imagesConfig$schema = imagesConfig.schema) === null || _imagesConfig$schema === void 0 ? void 0 : _imagesConfig$schema.alt) !== null && _imagesConfig$schema$ !== void 0 ? _imagesConfig$schema$ : defaultAltField,
        title: (_imagesConfig$schema$2 = (_imagesConfig$schema2 = imagesConfig.schema) === null || _imagesConfig$schema2 === void 0 ? void 0 : _imagesConfig$schema2.title) !== null && _imagesConfig$schema$2 !== void 0 ? _imagesConfig$schema$2 : emptyTitleField
      }
    },
    tables: !!config2.tables
  };
}
function document$1({
  label,
  componentBlocks = {},
  description,
  ...documentFeaturesConfig
}) {
  const documentFeatures = normaliseDocumentFeatures(documentFeaturesConfig);
  const parse7 = (mode) => (_value, data) => {
    const markdoc = textDecoder.decode(data.content);
    const document3 = fromMarkdoc(Markdoc.parse(markdoc), componentBlocks);
    const editor = createDocumentEditorForNormalization(documentFeatures, componentBlocks);
    editor.children = document3;
    Editor.normalize(editor, {
      force: true
    });
    return deserializeFiles(editor.children, componentBlocks, data.other, data.external || /* @__PURE__ */ new Map(), mode, documentFeatures, data.slug);
  };
  return {
    kind: "form",
    formKind: "content",
    defaultValue() {
      return [{
        type: "paragraph",
        children: [{
          text: ""
        }]
      }];
    },
    Input(props) {
      return (0, import_jsx_runtime76.jsx)(DocumentFieldInput, {
        componentBlocks,
        description,
        label,
        documentFeatures,
        ...props
      });
    },
    parse: parse7("edit"),
    contentExtension: ".mdoc",
    validate(value2) {
      return value2;
    },
    directories: [...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(componentBlocks).map(([name2, block5]) => [name2, object(block5.schema)])))), ...typeof documentFeatures.images === "object" && typeof documentFeatures.images.directory === "string" ? [fixPath(documentFeatures.images.directory)] : []],
    serialize(value2, opts) {
      const {
        extraFiles,
        node: node3
      } = toMarkdocDocument(value2, {
        componentBlocks,
        documentFeatures,
        slug: opts.slug
      });
      const other = /* @__PURE__ */ new Map();
      const external = /* @__PURE__ */ new Map();
      for (const file of extraFiles) {
        if (file.parent === void 0) {
          other.set(file.path, file.contents);
          continue;
        }
        if (!external.has(file.parent)) {
          external.set(file.parent, /* @__PURE__ */ new Map());
        }
        external.get(file.parent).set(file.path, file.contents);
      }
      return {
        content: textEncoder.encode(Markdoc.format(Markdoc.parse(Markdoc.format(node3)))),
        other,
        external,
        value: void 0
      };
    },
    reader: {
      parse: parse7("read")
    }
  };
}
function parseImageData(data) {
  try {
    const parsed = JSON.parse(data);
    if (typeof parsed === "object" && parsed !== null && "src" in parsed && typeof parsed.src === "string") {
      return {
        src: parsed.src,
        alt: "alt" in parsed && typeof parsed.alt === "string" ? parsed.alt : "",
        height: "height" in parsed && typeof parsed.height === "number" && Number.isInteger(parsed.height) ? parsed.height : void 0,
        width: "width" in parsed && typeof parsed.width === "number" && Number.isInteger(parsed.width) ? parsed.width : void 0
      };
    }
  } catch (err) {
  }
  const pattern = /^\s*!\[(.*)\]\(([a-z0-9_\-/:.]+)\)\s*$/;
  const match3 = data.match(pattern);
  if (match3) {
    return {
      src: match3[2],
      alt: match3[1]
    };
  }
  return {
    src: data,
    alt: ""
  };
}
function useImageDimensions(src) {
  const [dimensions, setDimensions] = (0, import_react73.useState)({});
  (0, import_react73.useEffect)(() => {
    if (!src || !isValidURL2(src)) {
      setDimensions({});
      return;
    }
    let shouldSet = true;
    loadImageDimensions(src).then((dimensions2) => {
      if (shouldSet)
        setDimensions(dimensions2);
    });
    return () => {
      shouldSet = false;
    };
  }, [src]);
  return dimensions;
}
function loadImageDimensions(url) {
  return new Promise((resolve3, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve3({
        width: img.width,
        height: img.height
      });
    };
    img.onerror = () => {
      reject();
    };
    img.src = url;
  });
}
var imageDataSchema = z.object({
  src: z.string(),
  alt: z.string(),
  width: z.number(),
  height: z.number()
});
async function loadImageData(url, config2) {
  const auth = getCloudAuth(config2);
  if (auth) {
    const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/v1/image?${new URLSearchParams({
      url
    })}`, {
      headers: {
        Authorization: `Bearer ${auth.accessToken}`,
        ...KEYSTATIC_CLOUD_HEADERS
      }
    });
    if (res.ok) {
      const data = await res.json();
      const parsed = imageDataSchema.safeParse(data);
      if (parsed.success) {
        return parsed.data;
      }
    }
  }
  return loadImageDimensions(url).then((dimensions) => ({
    src: url,
    alt: "",
    ...dimensions
  }));
}
function ImageDimensionsInput(props) {
  const dimensions = useImageDimensions(props.src);
  const [constrainProportions, setConstrainProportions] = (0, import_react73.useState)(true);
  const revertLabel = `Revert to original (${dimensions.width} × ${dimensions.height})`;
  const dimensionsMatchOriginal = dimensions.width === props.image.width && dimensions.height === props.image.height;
  return (0, import_jsx_runtime76.jsxs)(HStack, {
    gap: "regular",
    alignItems: "end",
    children: [(0, import_jsx_runtime76.jsx)(NumberField, {
      label: "Width",
      width: "scale.1600",
      formatOptions: {
        maximumFractionDigits: 0
      },
      value: props.image.width,
      onChange: (width) => {
        if (constrainProportions) {
          props.onChange({
            width,
            height: Math.round(width / getAspectRatio(props.image))
          });
        } else {
          props.onChange({
            width
          });
        }
      }
    }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime76.jsx)(ToggleButton, {
        isSelected: constrainProportions,
        "aria-label": "Constrain proportions",
        prominence: "low",
        onPress: () => {
          setConstrainProportions((state) => !state);
        },
        children: (0, import_jsx_runtime76.jsx)(Icon, {
          src: constrainProportions ? link2Icon : link2OffIcon
        })
      }), (0, import_jsx_runtime76.jsx)(Tooltip, {
        children: "Constrain proportions"
      })]
    }), (0, import_jsx_runtime76.jsx)(NumberField, {
      label: "Height",
      width: "scale.1600",
      formatOptions: {
        maximumFractionDigits: 0
      },
      value: props.image.height,
      onChange: (height) => {
        if (constrainProportions) {
          props.onChange({
            height,
            width: Math.round(height * getAspectRatio(props.image))
          });
        } else {
          props.onChange({
            height
          });
        }
      }
    }), (0, import_jsx_runtime76.jsxs)(_TooltipTrigger, {
      children: [(0, import_jsx_runtime76.jsx)(ActionButton, {
        "aria-label": revertLabel,
        isDisabled: dimensionsMatchOriginal || !dimensions.width || !dimensions.height,
        onPress: () => {
          props.onChange({
            height: dimensions.height,
            width: dimensions.width
          });
        },
        children: (0, import_jsx_runtime76.jsx)(Icon, {
          src: undo2Icon
        })
      }), (0, import_jsx_runtime76.jsx)(Tooltip, {
        maxWidth: "100%",
        children: revertLabel
      })]
    })]
  });
}
var emptyImageData = {
  src: "",
  alt: ""
};
function isValidURL2(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}
function useImageLibraryURL() {
  const config2 = useConfig();
  const split2 = getSplitCloudProject(config2);
  if (!split2)
    return "https://keystatic.cloud/";
  return `https://keystatic.cloud/teams/${split2.team}/project/${split2.project}/images`;
}
function getAspectRatio(state) {
  if (!state.width || !state.height)
    return 1;
  return state.width / state.height;
}

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/useSlugsInCollection-705e51c4.esm.js
var import_react74 = __toESM(require_react());
function useSlugsInCollection(collection2) {
  const config2 = useConfig();
  const tree2 = useTree().current;
  return (0, import_react74.useMemo)(() => {
    const loadedTree = tree2.kind === "loaded" ? tree2.data.tree : /* @__PURE__ */ new Map();
    return getEntriesInCollectionWithTreeKey(config2, collection2, loadedTree).map((x3) => x3.slug);
  }, [config2, tree2, collection2]);
}

export {
  $458b0a5536c1a7cf$export$40bfa8c7b0832715,
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c,
  $1dbecbe27a04f9af$export$14d238f342723f25,
  $bdb11010cef70236$export$f680877a34711e37,
  $bdb11010cef70236$export$b4cc09c592e8fdb8,
  $ff5963eb1fccf552$export$e08e3b67e392101e,
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f,
  $7215afc6de606d6b$export$de79e2c695e052f3,
  $c87311424ea30a05$export$a11b0059900ceec8,
  $ea8dcbcb9ea1b556$export$51437d503373d223,
  $df56164dff5785e2$export$4338b53315abf666,
  $4f58c5f72bcf79f7$export$496315a1608d9602,
  $9daab02d461809db$export$683480f191c0e3ea,
  $ef06256079686ba0$export$f8aeda7b10753fa1,
  $99facab73266f662$export$5add1d006293d136,
  $18f2051aff69b9bf$export$43bb16f9c6d9e3f7,
  $fca6afa0e843324b$export$f12b703ca79dfbb1,
  $325a3faab7a68acd$export$a16aca283550c30d,
  $f6c31cce2adf654f$export$45712eceda6fad21,
  $507fabe10e71c6fb$export$630ff653c5ada6a9,
  $9ab94262bd0047c7$export$420e68273165f4ec,
  $6179b936705e76d3$export$ae780daf29e6d456,
  $9bf71ea28793e738$export$20e40289641fbbb6,
  $9bf71ea28793e738$export$2d6ec8fc375ceafa,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  $e6afbd83fe6ebbd2$export$4c014de7c8940b4c,
  $5c3e21d68f1c4674$export$439d29a4e110a164,
  injectGlobal,
  keyframes,
  css,
  assert,
  warning,
  isNumber,
  tokenSchema,
  transition,
  resetClassName,
  classNames,
  ClassList,
  breakpointQueries$1,
  containerQueries,
  toDataAttributes,
  FocusRing,
  useIsMobileDevice,
  useMediaQuery,
  useStyleProps,
  useProviderProps,
  KeystarProvider,
  ClientSideOnlyDocumentElement,
  SlotProvider,
  Content,
  Footer,
  $298d61e98472621b$export$dcf14c9974fe2767,
  useHasChild,
  isReactText,
  Heading,
  Text,
  Icon,
  ButtonGroup,
  Button,
  ActionButton,
  ClearButton,
  Box,
  Divider,
  minmax,
  Flex,
  Grid,
  VStack,
  require_lib,
  TextLink3 as TextLink,
  $2baaea4c71418dea$export$294aa081a6c6f55d,
  ProgressCircle,
  $e93e671b31057976$export$b8473d3665f3a75a,
  $e5be200c675c3b3a$export$fc1a364ae1f3ff10,
  $2d73ec29415bd339$export$712718f7aec83d5,
  alertTriangleIcon,
  FieldLabel,
  FieldMessage,
  FieldPrimitive,
  validateFieldProps,
  TextFieldPrimitive,
  TextField,
  TextArea,
  StatusLight,
  $c1d7fb2ec91bae71$export$6d08773d2e66f8f2,
  $9fc4852771d079eb$export$6e2c8f0811a474ce,
  $7613b1592d41b092$export$6cd28814d92fa9c9,
  $c5a24bc478652b5f$export$1005530eda016c13,
  $c5a24bc478652b5f$export$fbdeaa6a76694f71,
  $c5a24bc478652b5f$export$5f3398f8733f90e2,
  $c5a24bc478652b5f$export$7475b2c64539e4cf,
  $7af3f5b51489e0b5$export$253fe78d46329472,
  $d496c0a20b6e58ec$export$6c8a5aaad13c9852,
  $fc0b13b484ac1194$export$1505db82fe357e65,
  $319e236875307eab$export$a9b970dcc4ae71a9,
  $d1c300d9c497e402$export$de9feff04fda126e,
  $83c6e2eafa584c67$export$f6b86a04e5d66d90,
  $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf,
  $4159a7a9cbb0cc18$export$96357d5a73f686fa,
  $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c,
  $7cb39d07f245a780$export$70e2eed1a92976ad,
  $ce415dc67314b753$export$ed5fd5ffe5ab0ac,
  $44a6ee657928b002$export$5665e3d6be6adea,
  $ccf8a0a04e4175ae$export$6796df8ba7398521,
  $ccf8a0a04e4175ae$export$1481e64fbe01b8b3,
  $6d0a5c394373ae64$export$dd6d526d88b5a137,
  $a152112e902709bf$export$62444c3c724b1b20,
  Checkbox,
  Tooltip,
  _TooltipTrigger,
  require_dist,
  localizedMessages2 as localizedMessages,
  isValidURL,
  SplitView,
  SplitPanePrimary,
  SplitPaneSecondary,
  Dialog,
  AlertDialog,
  DialogContainer,
  useDialogContainer,
  _DialogTrigger,
  trash2Icon,
  chevronLeftIcon,
  chevronRightIcon,
  externalLinkIcon,
  _Menu,
  MenuTrigger,
  _ActionMenu,
  _ActionGroup,
  plusIcon,
  _Picker,
  comboboxClassList,
  _Combobox,
  imageIcon,
  NumberField,
  filter,
  lib_default2 as lib_default,
  e2 as e,
  valueFromASTUntyped2 as valueFromASTUntyped,
  filter2,
  map,
  mergeMap,
  merge3 as merge,
  onStart,
  share,
  take,
  takeUntil,
  r4 as r,
  makeSubject,
  empty,
  fromPromise,
  toPromise,
  stringifyVariables,
  stringifyDocument,
  createRequest,
  makeErrorResult,
  formatDocument,
  makeOperation,
  fetchExchange,
  j2 as j,
  f4 as f,
  useClient,
  useMutation,
  lru_cache_default,
  require_slugify,
  require_mdast_util_from_markdown,
  require_from_markdown,
  require_micromark_extension_gfm_autolink_literal,
  require_from_markdown2,
  require_micromark_extension_gfm_strikethrough,
  fromUint8Array,
  Badge,
  RouterProvider,
  useRouter,
  fixPath,
  getCollectionPath,
  getCollectionFormat,
  getSingletonFormat,
  getCollectionItemPath,
  getEntryDataFilepath,
  getSlugGlobForCollection,
  getSingletonPath,
  getDataFileExtension,
  getPathPrefix,
  blobSha,
  getTreeNodeAtPath,
  treeSha,
  updateTreeWithChanges,
  LOADING,
  useData,
  getDirectoriesForTreeKey,
  getTreeKey,
  object,
  pluralize,
  getBranchPrefix,
  isGitHubConfig,
  isLocalConfig,
  isCloudConfig,
  getRepoUrl,
  getSlugFromState,
  getEntriesInCollectionWithTreeKey,
  KEYSTATIC_CLOUD_API_URL,
  KEYSTATIC_CLOUD_HEADERS,
  redirectToCloudAuth,
  getSyncAuth,
  getAuth,
  useViewer,
  parseRepoConfig,
  serializeRepoConfig,
  assertValidRepoConfig,
  scopeEntriesWithPathPrefix,
  useSetTreeSha,
  LocalAppShellProvider,
  useCloudInfo,
  useRawCloudInfo,
  CloudInfoProvider,
  GitHubAppShellDataContext,
  GitHubAppShellDataProvider,
  GitHubAppShellProvider,
  AppShellErrorContext,
  useTree,
  useCurrentUnscopedTree,
  useBaseCommit,
  useIsRepoPrivate,
  useRepositoryId,
  Ref_base,
  CloudAppShellQuery,
  GitHubAppShellQuery,
  hydrateTreeCacheWithEntries,
  fetchGitHubTreeData,
  RepoWithWriteAccessContext,
  BranchInfoContext,
  useBranchInfo,
  config,
  collection,
  singleton,
  ConfigContext,
  useConfig,
  AppStateContext,
  useAppState,
  ContentPanelProvider,
  useContentPanelState,
  useNavItems,
  useBrand,
  useSidebar,
  SidebarProvider,
  SidebarPanel,
  SidebarDialog,
  PageRoot,
  PageHeader,
  PageBody,
  FieldDataError,
  assertRequired,
  basicFormFieldWithSimpleReaderParse,
  getInitialPropsValue,
  getSrcPrefix,
  serializeProps,
  validateText,
  SlugFieldContext,
  PathContext,
  text2 as text,
  createGetPreviewProps,
  previewPropsToValue,
  valueToUpdater,
  setValueToPreviewProps,
  parseProps,
  toFormattedFormDataError,
  clientSideValidateProp,
  useEventCallback,
  ArrayFieldValidationMessages,
  ArrayFieldListView,
  BlockWrapper,
  NotEditable,
  ToolbarSeparator,
  getUploadedFile,
  useObjectURL,
  ImageFieldInput,
  useIsInDocumentEditor,
  FormValueContentFromPreviewProps,
  containerWidthForEntryLayout,
  FormForEntry,
  document$1,
  parseImageData,
  loadImageData,
  ImageDimensionsInput,
  emptyImageData,
  useImageLibraryURL,
  useSlugsInCollection
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@keystatic/core/dist/languages-97fa34d5.esm.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=chunk-6IM3O46K.js.map
