import {
  $18f2051aff69b9bf$export$43bb16f9c6d9e3f7,
  $1dbecbe27a04f9af$export$14d238f342723f25,
  $298d61e98472621b$export$dcf14c9974fe2767,
  $2baaea4c71418dea$export$294aa081a6c6f55d,
  $2d73ec29415bd339$export$712718f7aec83d5,
  $319e236875307eab$export$a9b970dcc4ae71a9,
  $325a3faab7a68acd$export$a16aca283550c30d,
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $4159a7a9cbb0cc18$export$96357d5a73f686fa,
  $44a6ee657928b002$export$5665e3d6be6adea,
  $458b0a5536c1a7cf$export$40bfa8c7b0832715,
  $4f58c5f72bcf79f7$export$496315a1608d9602,
  $507fabe10e71c6fb$export$630ff653c5ada6a9,
  $5c3e21d68f1c4674$export$439d29a4e110a164,
  $6179b936705e76d3$export$ae780daf29e6d456,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f,
  $6d0a5c394373ae64$export$dd6d526d88b5a137,
  $7215afc6de606d6b$export$de79e2c695e052f3,
  $7613b1592d41b092$export$6cd28814d92fa9c9,
  $7af3f5b51489e0b5$export$253fe78d46329472,
  $7cb39d07f245a780$export$70e2eed1a92976ad,
  $83c6e2eafa584c67$export$f6b86a04e5d66d90,
  $99facab73266f662$export$5add1d006293d136,
  $9ab94262bd0047c7$export$420e68273165f4ec,
  $9bf71ea28793e738$export$20e40289641fbbb6,
  $9bf71ea28793e738$export$2d6ec8fc375ceafa,
  $9daab02d461809db$export$683480f191c0e3ea,
  $9fc4852771d079eb$export$6e2c8f0811a474ce,
  $a152112e902709bf$export$62444c3c724b1b20,
  $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c,
  $bdb11010cef70236$export$b4cc09c592e8fdb8,
  $bdb11010cef70236$export$f680877a34711e37,
  $c1d7fb2ec91bae71$export$6d08773d2e66f8f2,
  $c5a24bc478652b5f$export$1005530eda016c13,
  $c5a24bc478652b5f$export$5f3398f8733f90e2,
  $c5a24bc478652b5f$export$7475b2c64539e4cf,
  $c5a24bc478652b5f$export$fbdeaa6a76694f71,
  $c87311424ea30a05$export$a11b0059900ceec8,
  $ccf8a0a04e4175ae$export$1481e64fbe01b8b3,
  $ccf8a0a04e4175ae$export$6796df8ba7398521,
  $ce415dc67314b753$export$ed5fd5ffe5ab0ac,
  $d1c300d9c497e402$export$de9feff04fda126e,
  $d496c0a20b6e58ec$export$6c8a5aaad13c9852,
  $df56164dff5785e2$export$4338b53315abf666,
  $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf,
  $e5be200c675c3b3a$export$fc1a364ae1f3ff10,
  $e6afbd83fe6ebbd2$export$4c014de7c8940b4c,
  $e93e671b31057976$export$b8473d3665f3a75a,
  $ea8dcbcb9ea1b556$export$51437d503373d223,
  $ef06256079686ba0$export$f8aeda7b10753fa1,
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c,
  $f6c31cce2adf654f$export$45712eceda6fad21,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  $fc0b13b484ac1194$export$1505db82fe357e65,
  $fca6afa0e843324b$export$f12b703ca79dfbb1,
  $ff5963eb1fccf552$export$e08e3b67e392101e,
  ActionButton,
  AlertDialog,
  AppShellErrorContext,
  AppStateContext,
  Badge,
  Box,
  BranchInfoContext,
  Button,
  ButtonGroup,
  Checkbox,
  ClassList,
  ClearButton,
  ClientSideOnlyDocumentElement,
  CloudAppShellQuery,
  CloudInfoProvider,
  ConfigContext,
  Content,
  ContentPanelProvider,
  Dialog,
  DialogContainer,
  Divider,
  FieldPrimitive,
  Flex,
  FocusRing,
  Footer,
  FormForEntry,
  GitHubAppShellDataContext,
  GitHubAppShellDataProvider,
  GitHubAppShellProvider,
  GitHubAppShellQuery,
  Grid,
  Heading,
  Icon,
  KEYSTATIC_CLOUD_API_URL,
  KEYSTATIC_CLOUD_HEADERS,
  KeystarProvider,
  LOADING,
  LocalAppShellProvider,
  MenuTrigger,
  PageBody,
  PageHeader,
  PageRoot,
  ProgressCircle,
  Ref_base,
  RepoWithWriteAccessContext,
  RouterProvider,
  SidebarDialog,
  SidebarPanel,
  SidebarProvider,
  SlotProvider,
  SplitPanePrimary,
  SplitPaneSecondary,
  SplitView,
  StatusLight,
  Text,
  TextField,
  TextFieldPrimitive,
  TextLink,
  Tooltip,
  VStack,
  _ActionGroup,
  _ActionMenu,
  _Combobox,
  _DialogTrigger,
  _Menu,
  _TooltipTrigger,
  alertTriangleIcon,
  assert,
  assertValidRepoConfig,
  blobSha,
  breakpointQueries$1,
  chevronLeftIcon,
  chevronRightIcon,
  classNames,
  clientSideValidateProp,
  comboboxClassList,
  containerQueries,
  containerWidthForEntryLayout,
  createGetPreviewProps,
  createRequest,
  css,
  e,
  empty,
  externalLinkIcon,
  f,
  fetchExchange,
  fetchGitHubTreeData,
  filter2 as filter,
  formatDocument,
  fromPromise,
  fromUint8Array,
  getAuth,
  getBranchPrefix,
  getCollectionFormat,
  getCollectionItemPath,
  getCollectionPath,
  getDataFileExtension,
  getDirectoriesForTreeKey,
  getEntriesInCollectionWithTreeKey,
  getEntryDataFilepath,
  getInitialPropsValue,
  getPathPrefix,
  getRepoUrl,
  getSingletonFormat,
  getSingletonPath,
  getSlugFromState,
  getSlugGlobForCollection,
  getSyncAuth,
  getTreeKey,
  getTreeNodeAtPath,
  hydrateTreeCacheWithEntries,
  imageIcon,
  injectGlobal,
  isCloudConfig,
  isGitHubConfig,
  isLocalConfig,
  isNumber,
  isReactText,
  j,
  keyframes,
  lib_default,
  localizedMessages,
  lru_cache_default,
  makeErrorResult,
  makeOperation,
  makeSubject,
  map,
  merge,
  mergeMap,
  minmax,
  object,
  onStart,
  parseProps,
  parseRepoConfig,
  pluralize,
  plusIcon,
  r,
  redirectToCloudAuth,
  require_dist,
  require_from_markdown,
  require_from_markdown2,
  require_lib,
  require_mdast_util_from_markdown,
  require_micromark_extension_gfm_autolink_literal,
  require_micromark_extension_gfm_strikethrough,
  require_slugify,
  resetClassName,
  scopeEntriesWithPathPrefix,
  serializeProps,
  serializeRepoConfig,
  share,
  stringifyDocument,
  stringifyVariables,
  take,
  takeUntil,
  toDataAttributes,
  toFormattedFormDataError,
  toPromise,
  tokenSchema,
  transition,
  trash2Icon,
  treeSha,
  updateTreeWithChanges,
  useAppState,
  useBaseCommit,
  useBranchInfo,
  useBrand,
  useClient,
  useCloudInfo,
  useConfig,
  useContentPanelState,
  useCurrentUnscopedTree,
  useData,
  useEventCallback,
  useHasChild,
  useImageLibraryURL,
  useIsMobileDevice,
  useIsRepoPrivate,
  useMediaQuery,
  useMutation,
  useNavItems,
  useProviderProps,
  useRawCloudInfo,
  useRepositoryId,
  useRouter,
  useSetTreeSha,
  useSidebar,
  useSlugsInCollection,
  useStyleProps,
  useTree,
  useViewer,
  validateFieldProps,
  valueFromASTUntyped,
  warning
} from "./chunk-6IM3O46K.js";
import {
  require_jsx_runtime
} from "./chunk-6EJBKNQI.js";
import {
  require_react_dom
} from "./chunk-LMF45TQU.js";
import {
  require_react
} from "./chunk-YOU5AYP3.js";
import {
  require_cookie,
  z
} from "./chunk-7KTIU2EK.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __require,
  __toESM
} from "./chunk-KGMB3LMK.js";

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React3 = require_react();
        var ReactSharedInternals = React3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x2, y) {
          return x2 === y && (x2 !== 0 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState3 = React3.useState, useEffect3 = React3.useEffect, useLayoutEffect = React3.useLayoutEffect, useDebugValue = React3.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe2, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React3.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState3({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe2, value, getSnapshot]);
          useEffect3(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe2(handleStoreChange);
          }, [subscribe2]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React3.useSyncExternalStore !== void 0 ? React3.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b2) {
      if (a === b2)
        return true;
      if (a && b2 && typeof a == "object" && typeof b2 == "object") {
        if (a.constructor !== b2.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b2.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b2[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b2.source && a.flags === b2.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b2.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b2.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b2).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b2[key]))
            return false;
        }
        return true;
      }
      return a !== a && b2 !== b2;
    };
  }
});

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/ui/dist/keystatic-core-ui.esm.js
var import_react15 = __toESM(require_react());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/fileX2Icon/dist/keystar-ui-icon-icons-fileX2Icon.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var fileX2Icon = (0, import_jsx_runtime.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime.jsx)("path", {
    d: "M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"
  }), (0, import_jsx_runtime.jsx)("path", {
    d: "M14 2v6h6M3 12.5l5 5M8 12.5l-5 5"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/githubIcon/dist/keystar-ui-icon-icons-githubIcon.esm.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var githubIcon = (0, import_jsx_runtime2.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime2.jsx)("path", {
    d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"
  }), (0, import_jsx_runtime2.jsx)("path", {
    d: "M9 18c-4.51 2-5-2-7-2"
  })]
});

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/ui/dist/keystatic-core-ui.esm.js
var import_is_hotkey = __toESM(require_lib());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/alertCircleIcon/dist/keystar-ui-icon-icons-alertCircleIcon.esm.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var alertCircleIcon = (0, import_jsx_runtime3.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime3.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 10
  }), (0, import_jsx_runtime3.jsx)("path", {
    d: "M12 8v4M12 16h.01"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/listXIcon/dist/keystar-ui-icon-icons-listXIcon.esm.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var listXIcon = (0, import_jsx_runtime4.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime4.jsx)("path", {
    d: "M11 12H3M16 6H3M16 18H3M19 10l-4 4M15 10l4 4"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/searchIcon/dist/keystar-ui-icon-icons-searchIcon.esm.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var searchIcon = (0, import_jsx_runtime5.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime5.jsx)("circle", {
    cx: 11,
    cy: 11,
    r: 8
  }), (0, import_jsx_runtime5.jsx)("path", {
    d: "m21 21-4.3-4.3"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/searchXIcon/dist/keystar-ui-icon-icons-searchXIcon.esm.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var searchXIcon = (0, import_jsx_runtime6.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime6.jsx)("path", {
    d: "m13.5 8.5-5 5M8.5 8.5l5 5"
  }), (0, import_jsx_runtime6.jsx)("circle", {
    cx: 11,
    cy: 11,
    r: 8
  }), (0, import_jsx_runtime6.jsx)("path", {
    d: "m21 21-4.3-4.3"
  })]
});

// node_modules/.pnpm/@react-aria+searchfield@3.6.0_react@18.2.0/node_modules/@react-aria/searchfield/dist/import.mjs
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $8112f8b883c0272d$exports = {};
var $03c9a1a10de12f06$exports = {};
$03c9a1a10de12f06$exports = {
  "Clear search": `مسح البحث`
};
var $4da0c2ffa4ba4159$exports = {};
$4da0c2ffa4ba4159$exports = {
  "Clear search": `Изчистване на търсене`
};
var $8c59fd0c2c96821b$exports = {};
$8c59fd0c2c96821b$exports = {
  "Clear search": `Vymazat hledání`
};
var $0a371f9c1df8120f$exports = {};
$0a371f9c1df8120f$exports = {
  "Clear search": `Ryd søgning`
};
var $67f4d0b0de9f8a52$exports = {};
$67f4d0b0de9f8a52$exports = {
  "Clear search": `Suche zurücksetzen`
};
var $72a312d948f0214b$exports = {};
$72a312d948f0214b$exports = {
  "Clear search": `Απαλοιφή αναζήτησης`
};
var $5012d21d933388c1$exports = {};
$5012d21d933388c1$exports = {
  "Clear search": `Clear search`
};
var $0159854399308e2e$exports = {};
$0159854399308e2e$exports = {
  "Clear search": `Borrar búsqueda`
};
var $390613981d970276$exports = {};
$390613981d970276$exports = {
  "Clear search": `Tühjenda otsing`
};
var $961ae0833f811705$exports = {};
$961ae0833f811705$exports = {
  "Clear search": `Tyhjennä haku`
};
var $26d76742decfd829$exports = {};
$26d76742decfd829$exports = {
  "Clear search": `Effacer la recherche`
};
var $92ef254c82a5c769$exports = {};
$92ef254c82a5c769$exports = {
  "Clear search": `נקה חיפוש`
};
var $e0321b43bdefb8b3$exports = {};
$e0321b43bdefb8b3$exports = {
  "Clear search": `Obriši pretragu`
};
var $0c1ee0b8d50940d9$exports = {};
$0c1ee0b8d50940d9$exports = {
  "Clear search": `Keresés törlése`
};
var $b09198915a38946f$exports = {};
$b09198915a38946f$exports = {
  "Clear search": `Cancella ricerca`
};
var $3a9a3d180c3145c0$exports = {};
$3a9a3d180c3145c0$exports = {
  "Clear search": `検索をクリア`
};
var $b7a611726449f4a3$exports = {};
$b7a611726449f4a3$exports = {
  "Clear search": `검색 지우기`
};
var $d9a3d49db610dd5c$exports = {};
$d9a3d49db610dd5c$exports = {
  "Clear search": `Išvalyti iešką`
};
var $3ab64b73ea27c23a$exports = {};
$3ab64b73ea27c23a$exports = {
  "Clear search": `Notīrīt meklēšanu`
};
var $bf5cce1b47d23baf$exports = {};
$bf5cce1b47d23baf$exports = {
  "Clear search": `Tøm søk`
};
var $4e0c9a9a010e4598$exports = {};
$4e0c9a9a010e4598$exports = {
  "Clear search": `Zoekactie wissen`
};
var $63cf4a75ec270508$exports = {};
$63cf4a75ec270508$exports = {
  "Clear search": `Wyczyść zawartość wyszukiwania`
};
var $083b0cad27fdbd06$exports = {};
$083b0cad27fdbd06$exports = {
  "Clear search": `Limpar pesquisa`
};
var $1b7f0864d830ba6d$exports = {};
$1b7f0864d830ba6d$exports = {
  "Clear search": `Limpar pesquisa`
};
var $d6d2588377fc9718$exports = {};
$d6d2588377fc9718$exports = {
  "Clear search": `Ştergeţi căutarea`
};
var $701c918a4653e946$exports = {};
$701c918a4653e946$exports = {
  "Clear search": `Очистить поиск`
};
var $7cacc29a1e5f4fbe$exports = {};
$7cacc29a1e5f4fbe$exports = {
  "Clear search": `Vymazať vyhľadávanie`
};
var $c63231bcc300d0df$exports = {};
$c63231bcc300d0df$exports = {
  "Clear search": `Počisti iskanje`
};
var $b61510478bc0e6f6$exports = {};
$b61510478bc0e6f6$exports = {
  "Clear search": `Obriši pretragu`
};
var $ce325e6dd3f9c37a$exports = {};
$ce325e6dd3f9c37a$exports = {
  "Clear search": `Rensa sökning`
};
var $1f7e1cf2285af2b2$exports = {};
$1f7e1cf2285af2b2$exports = {
  "Clear search": `Aramayı temizle`
};
var $2d999353ca652e34$exports = {};
$2d999353ca652e34$exports = {
  "Clear search": `Очистити пошук`
};
var $117b536bfb1ae554$exports = {};
$117b536bfb1ae554$exports = {
  "Clear search": `清除搜索`
};
var $525f6fa4ac26e278$exports = {};
$525f6fa4ac26e278$exports = {
  "Clear search": `清除搜尋條件`
};
$8112f8b883c0272d$exports = {
  "ar-AE": $03c9a1a10de12f06$exports,
  "bg-BG": $4da0c2ffa4ba4159$exports,
  "cs-CZ": $8c59fd0c2c96821b$exports,
  "da-DK": $0a371f9c1df8120f$exports,
  "de-DE": $67f4d0b0de9f8a52$exports,
  "el-GR": $72a312d948f0214b$exports,
  "en-US": $5012d21d933388c1$exports,
  "es-ES": $0159854399308e2e$exports,
  "et-EE": $390613981d970276$exports,
  "fi-FI": $961ae0833f811705$exports,
  "fr-FR": $26d76742decfd829$exports,
  "he-IL": $92ef254c82a5c769$exports,
  "hr-HR": $e0321b43bdefb8b3$exports,
  "hu-HU": $0c1ee0b8d50940d9$exports,
  "it-IT": $b09198915a38946f$exports,
  "ja-JP": $3a9a3d180c3145c0$exports,
  "ko-KR": $b7a611726449f4a3$exports,
  "lt-LT": $d9a3d49db610dd5c$exports,
  "lv-LV": $3ab64b73ea27c23a$exports,
  "nb-NO": $bf5cce1b47d23baf$exports,
  "nl-NL": $4e0c9a9a010e4598$exports,
  "pl-PL": $63cf4a75ec270508$exports,
  "pt-BR": $083b0cad27fdbd06$exports,
  "pt-PT": $1b7f0864d830ba6d$exports,
  "ro-RO": $d6d2588377fc9718$exports,
  "ru-RU": $701c918a4653e946$exports,
  "sk-SK": $7cacc29a1e5f4fbe$exports,
  "sl-SI": $c63231bcc300d0df$exports,
  "sr-SP": $b61510478bc0e6f6$exports,
  "sv-SE": $ce325e6dd3f9c37a$exports,
  "tr-TR": $1f7e1cf2285af2b2$exports,
  "uk-UA": $2d999353ca652e34$exports,
  "zh-CN": $117b536bfb1ae554$exports,
  "zh-TW": $525f6fa4ac26e278$exports
};
function $4d52238874b24f86$export$9bb30bbe003b82e0(props, state, inputRef) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault($8112f8b883c0272d$exports)));
  let { isDisabled, isReadOnly, onSubmit = () => {
  }, onClear, type: type2 = "search" } = props;
  let onKeyDown = (e2) => {
    const key = e2.key;
    if (key === "Enter" || key === "Escape")
      e2.preventDefault();
    if (isDisabled || isReadOnly)
      return;
    if (key === "Enter")
      onSubmit(state.value);
    if (key === "Escape") {
      state.setValue("");
      if (onClear)
        onClear();
    }
  };
  let onClearButtonClick = () => {
    state.setValue("");
    if (onClear)
      onClear();
  };
  let onPressStart = () => {
    var _inputRef_current;
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
  };
  let { labelProps, inputProps, descriptionProps, errorMessageProps, ...validation } = (0, $2d73ec29415bd339$export$712718f7aec83d5)({
    ...props,
    value: state.value,
    onChange: state.setValue,
    onKeyDown: (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(onKeyDown, props.onKeyDown),
    type: type2
  }, inputRef);
  return {
    labelProps,
    inputProps: {
      ...inputProps,
      // already handled by useSearchFieldState
      defaultValue: void 0
    },
    clearButtonProps: {
      "aria-label": stringFormatter.format("Clear search"),
      excludeFromTabOrder: true,
      // @ts-ignore
      preventFocusOnPress: true,
      isDisabled: isDisabled || isReadOnly,
      onPress: onClearButtonClick,
      onPressStart
    },
    descriptionProps,
    errorMessageProps,
    ...validation
  };
}

// node_modules/.pnpm/@react-stately+searchfield@3.5.0_react@18.2.0/node_modules/@react-stately/searchfield/dist/import.mjs
function $0b2218c4e3fe7d7e$export$3f8be18b0f41eaf2(props) {
  let [value, setValue] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)($0b2218c4e3fe7d7e$var$toString(props.value), $0b2218c4e3fe7d7e$var$toString(props.defaultValue) || "", props.onChange);
  return {
    value,
    setValue
  };
}
function $0b2218c4e3fe7d7e$var$toString(val) {
  if (val == null)
    return;
  return val.toString();
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/search-field/dist/keystar-ui-search-field.esm.js
var import_react = __toESM(require_react());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var SearchField = (0, import_react.forwardRef)(function SearchField2(props, forwardedRef) {
  const {
    autoFocus,
    description,
    errorMessage,
    id,
    isDisabled,
    isReadOnly,
    isRequired,
    label,
    showIcon = true,
    ...styleProps
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(forwardedRef);
  let state = $0b2218c4e3fe7d7e$export$3f8be18b0f41eaf2(props);
  let {
    labelProps,
    inputProps,
    clearButtonProps,
    descriptionProps,
    errorMessageProps
  } = $4d52238874b24f86$export$9bb30bbe003b82e0(props, state, domRef);
  let clearButtonVisible = state.value !== "" && !props.isReadOnly;
  let clearButton = (0, import_jsx_runtime7.jsx)(ClearButton, {
    ...clearButtonProps,
    preventFocus: true,
    isDisabled
  });
  let startElement = (0, import_jsx_runtime7.jsx)(Flex, {
    alignItems: "center",
    flexShrink: 0,
    justifyContent: "center",
    pointerEvents: "none",
    width: "element.regular",
    children: (0, import_jsx_runtime7.jsx)(Icon, {
      src: searchIcon,
      color: props.isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary"
    })
  });
  return (0, import_jsx_runtime7.jsx)(TextFieldPrimitive, {
    ref: domRef,
    ...styleProps,
    isDisabled,
    isReadOnly,
    isRequired,
    label,
    labelProps,
    inputProps,
    inputWrapperProps: {
      className: css({
        input: {
          '&[data-adornment="start"]': {
            paddingInlineStart: 0
          },
          '&[data-adornment="end"]': {
            paddingInlineEnd: 0
          },
          '&[data-adornment="both"]': {
            paddingInline: 0
          }
        }
      })
    },
    description,
    descriptionProps,
    errorMessage,
    errorMessageProps,
    startElement: showIcon && startElement,
    endElement: clearButtonVisible && clearButton
  });
});

// node_modules/.pnpm/@react-stately+table@3.11.3_react@18.2.0/node_modules/@react-stately/table/dist/import.mjs
var import_react3 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-stately+grid@3.8.3_react@18.2.0/node_modules/@react-stately/grid/dist/import.mjs
var import_react2 = __toESM(require_react(), 1);
function $62967d126f3aa823$export$4007ac09ff9c68ed(props) {
  let { collection, focusMode } = props;
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react2.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let setFocusedKey = selectionState.setFocusedKey;
  selectionState.setFocusedKey = (key, child) => {
    if (focusMode === "cell" && key != null) {
      let item = collection.getItem(key);
      if ((item === null || item === void 0 ? void 0 : item.type) === "item") {
        var _getLastItem, _getFirstItem;
        let children = (0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection);
        if (child === "last")
          key = (_getLastItem = (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;
        else
          key = (_getFirstItem = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;
      }
    }
    setFocusedKey(key, child);
  };
  let selectionManager = (0, import_react2.useMemo)(() => new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(collection, selectionState), [
    collection,
    selectionState
  ]);
  const cachedCollection = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {
      const node = cachedCollection.current.getItem(selectionState.focusedKey);
      const parentNode = node.parentKey != null && (node.type === "cell" || node.type === "rowheader" || node.type === "column") ? cachedCollection.current.getItem(node.parentKey) : node;
      const cachedRows = cachedCollection.current.rows;
      const rows = collection.rows;
      const diff = cachedRows.length - rows.length;
      let index = Math.min(diff > 1 ? Math.max(parentNode.index - diff + 1, 0) : parentNode.index, rows.length - 1);
      let newRow;
      while (index >= 0) {
        if (!selectionManager.isDisabled(rows[index].key) && rows[index].type !== "headerrow") {
          newRow = rows[index];
          break;
        }
        if (index < rows.length - 1)
          index++;
        else {
          if (index > parentNode.index)
            index = parentNode.index;
          index--;
        }
      }
      if (newRow) {
        const childNodes = newRow.hasChildNodes ? [
          ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(newRow, collection)
        ] : [];
        const keyToFocus = newRow.hasChildNodes && parentNode !== node && node.index < childNodes.length ? childNodes[node.index].key : newRow.key;
        selectionState.setFocusedKey(keyToFocus);
      } else
        selectionState.setFocusedKey(null);
    }
    cachedCollection.current = collection;
  }, [
    collection,
    selectionManager,
    selectionState,
    selectionState.focusedKey
  ]);
  return {
    collection,
    disabledKeys,
    isKeyboardNavigationDisabled: false,
    selectionManager
  };
}
var $16805b1b18093c5f$export$de3fdf6493c353d = class {
  *[Symbol.iterator]() {
    yield* [
      ...this.rows
    ];
  }
  get size() {
    return [
      ...this.rows
    ].length;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }
  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }
  getFirstKey() {
    var _2;
    return (_2 = [
      ...this.rows
    ][0]) === null || _2 === void 0 ? void 0 : _2.key;
  }
  getLastKey() {
    var _rows_;
    let rows = [
      ...this.rows
    ];
    return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  getChildren(key) {
    let node = this.keyMap.get(key);
    return (node === null || node === void 0 ? void 0 : node.childNodes) || [];
  }
  constructor(opts) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyMap = /* @__PURE__ */ new Map();
    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;
    this.rows = [];
    let visit = (node) => {
      let prevNode = this.keyMap.get(node.key);
      if (opts.visitNode)
        node = opts.visitNode(node);
      this.keyMap.set(node.key, node);
      let childKeys = /* @__PURE__ */ new Set();
      let last2;
      for (let child of node.childNodes) {
        if (child.type === "cell" && child.parentKey == null)
          child.parentKey = node.key;
        childKeys.add(child.key);
        if (last2) {
          last2.nextKey = child.key;
          child.prevKey = last2.key;
        } else
          child.prevKey = null;
        visit(child);
        last2 = child;
      }
      if (last2)
        last2.nextKey = null;
      if (prevNode) {
        for (let child of prevNode.childNodes)
          if (!childKeys.has(child.key))
            remove(child);
      }
    };
    let remove = (node) => {
      this.keyMap.delete(node.key);
      for (let child of node.childNodes)
        if (this.keyMap.get(child.key) === child)
          remove(child);
    };
    let last;
    opts.items.forEach((node, i) => {
      let rowNode = {
        level: 0,
        key: "row-" + i,
        type: "row",
        value: void 0,
        hasChildNodes: true,
        childNodes: [
          ...node.childNodes
        ],
        rendered: void 0,
        textValue: void 0,
        ...node
      };
      if (last) {
        last.nextKey = rowNode.key;
        rowNode.prevKey = last.key;
      } else
        rowNode.prevKey = null;
      this.rows.push(rowNode);
      visit(rowNode);
      last = rowNode;
    });
    if (last)
      last.nextKey = null;
  }
};

// node_modules/.pnpm/@react-stately+flags@3.0.0/node_modules/@react-stately/flags/dist/import.mjs
var $f4e2df6bd15f8569$var$_tableNestedRows = false;
function $f4e2df6bd15f8569$export$1b00cb14a96194e6() {
  return $f4e2df6bd15f8569$var$_tableNestedRows;
}

// node_modules/.pnpm/@react-stately+table@3.11.3_react@18.2.0/node_modules/@react-stately/table/dist/import.mjs
function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {
  return width != null && (!isNaN(width) || String(width).match(/^(\d+)(?=%$)/) !== null);
}
function $6818b1c4fc67028d$export$9078bad4c3934604(width) {
  if (!width)
    return 1;
  let match = width.match(/^(.+)(?=fr$)/);
  if (!match) {
    console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, "defaulting to '1fr'");
    return 1;
  }
  return parseFloat(match[0]);
}
function $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {
  if (typeof width === "string") {
    let match = width.match(/^(\d+)(?=%$)/);
    if (!match)
      throw new Error("Only percentages or numbers are supported for static column widths");
    return tableWidth * (parseFloat(match[0]) / 100);
  }
  return width;
}
function $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {
  return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;
}
function $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {
  return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;
}
function $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {
  let hasNonFrozenItems = false;
  let flexItems = columns.map((column, index) => {
    var _column_width, _ref, _ref1;
    let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : "1fr";
    let frozen = false;
    let baseSize = 0;
    let flex = 0;
    let targetMainSize = null;
    if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {
      baseSize = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);
      frozen = true;
    } else {
      flex = $6818b1c4fc67028d$export$9078bad4c3934604(width);
      if (flex <= 0)
        frozen = true;
    }
    var _column_minWidth, _ref2;
    let min = $6818b1c4fc67028d$export$f556054ce4358701((_ref2 = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index)) !== null && _ref2 !== void 0 ? _ref2 : 0, availableWidth);
    let max = $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth);
    let hypotheticalMainSize = Math.max(min, Math.min(baseSize, max));
    if (frozen)
      targetMainSize = hypotheticalMainSize;
    else if (baseSize > hypotheticalMainSize) {
      frozen = true;
      targetMainSize = hypotheticalMainSize;
    }
    if (!frozen)
      hasNonFrozenItems = true;
    return {
      frozen,
      baseSize,
      hypotheticalMainSize,
      min,
      max,
      flex,
      targetMainSize,
      violation: 0
    };
  });
  while (hasNonFrozenItems) {
    let usedWidth = 0;
    let flexFactors = 0;
    flexItems.forEach((item) => {
      if (item.frozen)
        usedWidth += item.targetMainSize;
      else {
        usedWidth += item.baseSize;
        flexFactors += item.flex;
      }
    });
    let remainingFreeSpace = availableWidth - usedWidth;
    if (remainingFreeSpace > 0)
      flexItems.forEach((item) => {
        if (!item.frozen) {
          let ratio = item.flex / flexFactors;
          item.targetMainSize = item.baseSize + ratio * remainingFreeSpace;
        }
      });
    let totalViolation = 0;
    flexItems.forEach((item) => {
      item.violation = 0;
      if (!item.frozen) {
        let { min, max, targetMainSize } = item;
        item.targetMainSize = Math.max(min, Math.min(targetMainSize, max));
        item.violation = item.targetMainSize - targetMainSize;
        totalViolation += item.violation;
      }
    });
    hasNonFrozenItems = false;
    flexItems.forEach((item) => {
      if (totalViolation === 0 || Math.sign(totalViolation) === Math.sign(item.violation))
        item.frozen = true;
      else if (!item.frozen)
        hasNonFrozenItems = true;
    });
  }
  return $6818b1c4fc67028d$var$cascadeRounding(flexItems);
}
function $6818b1c4fc67028d$var$cascadeRounding(flexItems) {
  let fpTotal = 0;
  let intTotal = 0;
  let roundedArray = [];
  flexItems.forEach(function(item) {
    let float2 = item.targetMainSize;
    let integer = Math.round(float2 + fpTotal) - intTotal;
    fpTotal += float2;
    intTotal += integer;
    roundedArray.push(integer);
  });
  return roundedArray;
}
var $a9e7ae544a4e41dd$export$7ff77a162970b30e = class {
  /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */
  splitColumnsIntoControlledAndUncontrolled(columns) {
    return columns.reduce((acc, col) => {
      if (col.props.width != null)
        acc[0].set(col.key, col);
      else
        acc[1].set(col.key, col);
      return acc;
    }, [
      /* @__PURE__ */ new Map(),
      /* @__PURE__ */ new Map()
    ]);
  }
  /** Takes uncontrolled and controlled widths and joins them into a single Map. */
  recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {
    return new Map(columns.map((col) => {
      if (uncontrolledColumns.has(col.key))
        return [
          col.key,
          uncontrolledWidths.get(col.key)
        ];
      else
        return [
          col.key,
          controlledColumns.get(col.key).props.width
        ];
    }));
  }
  /** Used to make an initial Map of the uncontrolled widths based on default widths. */
  getInitialUncontrolledWidths(uncontrolledColumns) {
    return new Map(Array.from(uncontrolledColumns).map(([key, col]) => {
      var _this_getDefaultWidth, _this;
      var _col_props_defaultWidth, _ref;
      return [
        key,
        (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : "1fr"
      ];
    }));
  }
  getColumnWidth(key) {
    var _this_columnWidths_get;
    return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;
  }
  getColumnMinWidth(key) {
    return this.columnMinWidths.get(key);
  }
  getColumnMaxWidth(key) {
    return this.columnMaxWidths.get(key);
  }
  resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {
    let prevColumnWidths = this.columnWidths;
    let resizeIndex = Infinity;
    let resizingChanged = new Map([
      ...controlledWidths,
      ...uncontrolledWidths
    ]);
    let percentKeys = /* @__PURE__ */ new Map();
    let frKeysToTheRight = /* @__PURE__ */ new Map();
    let minWidths = /* @__PURE__ */ new Map();
    collection.columns.forEach((column, i) => {
      var _column_props_width_endsWith, _column_props_width;
      let frKey;
      let frValue;
      minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));
      if (col !== column.key && !column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {
        frKey = column.key;
        frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key));
      } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.props.width) && !uncontrolledWidths.get(column.key)) {
        frKey = column.key;
        frValue = (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.props.width);
      } else if (col !== column.key && ((_column_props_width = column.props.width) === null || _column_props_width === void 0 ? void 0 : (_column_props_width_endsWith = _column_props_width.endsWith) === null || _column_props_width_endsWith === void 0 ? void 0 : _column_props_width_endsWith.call(_column_props_width, "%")))
        percentKeys.set(column.key, column.props.width);
      if (resizeIndex < i) {
        if (frKey)
          frKeysToTheRight.set(frKey, frValue);
        return;
      }
      if (column.key === col) {
        resizeIndex = i;
        resizingChanged.set(column.key, Math.floor(width));
        return;
      }
      resizingChanged.set(column.key, prevColumnWidths.get(column.key));
    });
    let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col2) => ({
      ...col2.props,
      key: col2.key
    })), resizingChanged, (i) => this.getDefaultWidth(collection.columns[i]), (i) => this.getDefaultMinWidth(collection.columns[i]));
    let newWidths = /* @__PURE__ */ new Map();
    columnWidths.forEach((width2, index) => {
      let key = collection.columns[index].key;
      newWidths.set(key, width2);
    });
    Array.from(frKeysToTheRight).forEach(([key]) => {
      newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);
    });
    Array.from(percentKeys).forEach(([key, width2]) => {
      if (key === col)
        return;
      newWidths.set(key, width2);
    });
    return newWidths;
  }
  buildColumnWidths(tableWidth, collection, widths) {
    this.columnWidths = /* @__PURE__ */ new Map();
    this.columnMinWidths = /* @__PURE__ */ new Map();
    this.columnMaxWidths = /* @__PURE__ */ new Map();
    let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col) => ({
      ...col.props,
      key: col.key
    })), widths, (i) => this.getDefaultWidth(collection.columns[i]), (i) => this.getDefaultMinWidth(collection.columns[i]));
    columnWidths.forEach((width, index) => {
      let key = collection.columns[index].key;
      let column = collection.columns[index];
      this.columnWidths.set(key, width);
      var _column_props_minWidth;
      this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_props_minWidth = column.props.minWidth) !== null && _column_props_minWidth !== void 0 ? _column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));
      this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.props.maxWidth, tableWidth));
    });
    return this.columnWidths;
  }
  constructor(options) {
    this.columnWidths = /* @__PURE__ */ new Map();
    this.columnMinWidths = /* @__PURE__ */ new Map();
    this.columnMaxWidths = /* @__PURE__ */ new Map();
    var _options_getDefaultWidth;
    this.getDefaultWidth = (_options_getDefaultWidth = options === null || options === void 0 ? void 0 : options.getDefaultWidth) !== null && _options_getDefaultWidth !== void 0 ? _options_getDefaultWidth : () => "1fr";
    var _options_getDefaultMinWidth;
    this.getDefaultMinWidth = (_options_getDefaultMinWidth = options === null || options === void 0 ? void 0 : options.getDefaultMinWidth) !== null && _options_getDefaultMinWidth !== void 0 ? _options_getDefaultMinWidth : () => 75;
  }
};
var $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = "row-header-column-" + Math.random().toString(36).slice(2);
var $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = "row-header-column-" + Math.random().toString(36).slice(2);
while ($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG)
  $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = "row-header-column-" + Math.random().toString(36).slice(2);
function $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {
  if (columnNodes.length === 0)
    return [];
  let columns = [];
  let seen = /* @__PURE__ */ new Map();
  for (let column of columnNodes) {
    let parentKey = column.parentKey;
    let col = [
      column
    ];
    while (parentKey) {
      let parent = keyMap.get(parentKey);
      if (!parent)
        break;
      if (seen.has(parent)) {
        parent.colspan++;
        let { column: column2, index } = seen.get(parent);
        if (index > col.length)
          break;
        for (let i2 = index; i2 < col.length; i2++)
          column2.splice(i2, 0, null);
        for (let i2 = col.length; i2 < column2.length; i2++)
          if (column2[i2] && seen.has(column2[i2]))
            seen.get(column2[i2]).index = i2;
      } else {
        parent.colspan = 1;
        col.push(parent);
        seen.set(parent, {
          column: col,
          index: col.length - 1
        });
      }
      parentKey = parent.parentKey;
    }
    columns.push(col);
    column.index = columns.length - 1;
  }
  let maxLength = Math.max(...columns.map((c) => c.length));
  let headerRows = Array(maxLength).fill(0).map(() => []);
  let colIndex = 0;
  for (let column of columns) {
    let i2 = maxLength - 1;
    for (let item of column) {
      if (item) {
        let row = headerRows[i2];
        let rowLength = row.reduce((p2, c) => p2 + c.colspan, 0);
        if (rowLength < colIndex) {
          let placeholder = {
            type: "placeholder",
            key: "placeholder-" + item.key,
            colspan: colIndex - rowLength,
            index: rowLength,
            value: null,
            rendered: null,
            level: i2,
            hasChildNodes: false,
            childNodes: [],
            textValue: null
          };
          if (row.length > 0) {
            row[row.length - 1].nextKey = placeholder.key;
            placeholder.prevKey = row[row.length - 1].key;
          }
          row.push(placeholder);
        }
        if (row.length > 0) {
          row[row.length - 1].nextKey = item.key;
          item.prevKey = row[row.length - 1].key;
        }
        item.level = i2;
        item.colIndex = colIndex;
        row.push(item);
      }
      i2--;
    }
    colIndex++;
  }
  let i = 0;
  for (let row of headerRows) {
    let rowLength = row.reduce((p2, c) => p2 + c.colspan, 0);
    if (rowLength < columnNodes.length) {
      let placeholder = {
        type: "placeholder",
        key: "placeholder-" + row[row.length - 1].key,
        colspan: columnNodes.length - rowLength,
        index: rowLength,
        value: null,
        rendered: null,
        level: i,
        hasChildNodes: false,
        childNodes: [],
        textValue: null,
        prevKey: row[row.length - 1].key
      };
      row.push(placeholder);
    }
    i++;
  }
  return headerRows.map((childNodes, index) => {
    let row = {
      type: "headerrow",
      key: "headerrow-" + index,
      index,
      value: null,
      rendered: null,
      level: 0,
      hasChildNodes: true,
      childNodes,
      textValue: null
    };
    return row;
  });
}
var $788781baa30117fa$export$596e1b2e2cf93690 = class extends (0, $16805b1b18093c5f$export$de3fdf6493c353d) {
  *[Symbol.iterator]() {
    yield* this.body.childNodes;
  }
  get size() {
    return this._size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }
  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }
  getFirstKey() {
    var _getFirstItem;
    return (_getFirstItem = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key;
  }
  getLastKey() {
    var _getLastItem;
    return (_getLastItem = (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  getTextValue(key) {
    let row = this.getItem(key);
    if (!row)
      return "";
    if (row.textValue)
      return row.textValue;
    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;
    if (rowHeaderColumnKeys) {
      let text = [];
      for (let cell of row.childNodes) {
        let column = this.columns[cell.index];
        if (rowHeaderColumnKeys.has(column.key) && cell.textValue)
          text.push(cell.textValue);
        if (text.length === rowHeaderColumnKeys.size)
          break;
      }
      return text.join(" ");
    }
    return "";
  }
  constructor(nodes, prev, opts) {
    let rowHeaderColumnKeys = /* @__PURE__ */ new Set();
    let body;
    let columns = [];
    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {
      let rowHeaderColumn = {
        type: "column",
        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,
        value: null,
        textValue: "",
        level: 0,
        index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,
        hasChildNodes: false,
        rendered: null,
        childNodes: [],
        props: {
          isSelectionCell: true
        }
      };
      columns.unshift(rowHeaderColumn);
    }
    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {
      let rowHeaderColumn = {
        type: "column",
        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,
        value: null,
        textValue: "",
        level: 0,
        index: 0,
        hasChildNodes: false,
        rendered: null,
        childNodes: [],
        props: {
          isDragButtonCell: true
        }
      };
      columns.unshift(rowHeaderColumn);
    }
    let rows = [];
    let columnKeyMap = /* @__PURE__ */ new Map();
    let visit = (node) => {
      switch (node.type) {
        case "body":
          body = node;
          break;
        case "column":
          columnKeyMap.set(node.key, node);
          if (!node.hasChildNodes) {
            columns.push(node);
            if (node.props.isRowHeader)
              rowHeaderColumnKeys.add(node.key);
          }
          break;
        case "item":
          rows.push(node);
          return;
      }
      for (let child of node.childNodes)
        visit(child);
    };
    for (let node of nodes)
      visit(node);
    let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);
    headerRows.forEach((row, i) => rows.splice(i, 0, row));
    super({
      columnCount: columns.length,
      items: rows,
      visitNode: (node) => {
        node.column = columns[node.index];
        return node;
      }
    });
    this._size = 0;
    this.columns = columns;
    this.rowHeaderColumnKeys = rowHeaderColumnKeys;
    this.body = body;
    this.headerRows = headerRows;
    this._size = [
      ...body.childNodes
    ].length;
    if (this.rowHeaderColumnKeys.size === 0) {
      if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {
        if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons)
          this.rowHeaderColumnKeys.add(this.columns[2].key);
        else
          this.rowHeaderColumnKeys.add(this.columns[1].key);
      } else
        this.rowHeaderColumnKeys.add(this.columns[0].key);
    }
  }
};
var $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {
  ascending: "descending",
  descending: "ascending"
};
function $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {
  let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, import_react3.useState)(false);
  let { selectionMode = "none", showSelectionCheckboxes, showDragButtons } = props;
  let context = (0, import_react3.useMemo)(() => ({
    showSelectionCheckboxes: showSelectionCheckboxes && selectionMode !== "none",
    showDragButtons,
    selectionMode,
    columns: []
  }), [
    props.children,
    showSelectionCheckboxes,
    selectionMode,
    showDragButtons
  ]);
  let collection = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, (0, import_react3.useCallback)((nodes) => new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, null, context), [
    context
  ]), context);
  let { disabledKeys, selectionManager } = (0, $62967d126f3aa823$export$4007ac09ff9c68ed)({
    ...props,
    collection,
    disabledBehavior: props.disabledBehavior || "selection"
  });
  return {
    collection,
    disabledKeys,
    selectionManager,
    showSelectionCheckboxes: props.showSelectionCheckboxes || false,
    sortDescriptor: props.sortDescriptor,
    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,
    setKeyboardNavigationDisabled,
    sort(columnKey, direction) {
      var _props_sortDescriptor;
      props.onSortChange({
        column: columnKey,
        direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : "ascending"
      });
    }
  };
}
function $312ae3b56a94a86e$var$TableHeader(props) {
  return null;
}
$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props, context) {
  let { children, columns } = props;
  context.columns = [];
  if (typeof children === "function") {
    if (!columns)
      throw new Error("props.children was a function but props.columns is missing");
    for (let column of columns)
      yield {
        type: "column",
        value: column,
        renderer: children
      };
  } else {
    let columns2 = [];
    (0, import_react3.default).Children.forEach(children, (column) => {
      columns2.push({
        type: "column",
        element: column
      });
    });
    yield* columns2;
  }
};
var $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;
function $4ae5314bf50db1a3$var$TableBody(props) {
  return null;
}
$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode2(props) {
  let { children, items } = props;
  yield {
    type: "body",
    hasChildNodes: true,
    props,
    *childNodes() {
      if (typeof children === "function") {
        if (!items)
          throw new Error("props.children was a function but props.items is missing");
        for (let item of items)
          yield {
            type: "item",
            value: item,
            renderer: children
          };
      } else {
        let items2 = [];
        (0, import_react3.default).Children.forEach(children, (item) => {
          items2.push({
            type: "item",
            element: item
          });
        });
        yield* items2;
      }
    }
  };
};
var $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;
function $1cd244557c2f97d5$var$Column(props) {
  return null;
}
$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode3(props, context) {
  let { title, children, childColumns } = props;
  let rendered = title || children;
  let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"];
  let fullNodes = yield {
    type: "column",
    hasChildNodes: !!childColumns || title && (0, import_react3.default).Children.count(children) > 0,
    rendered,
    textValue,
    props,
    *childNodes() {
      if (childColumns)
        for (let child of childColumns)
          yield {
            type: "column",
            value: child
          };
      else if (title) {
        let childColumns2 = [];
        (0, import_react3.default).Children.forEach(children, (child) => {
          childColumns2.push({
            type: "column",
            element: child
          });
        });
        yield* childColumns2;
      }
    },
    shouldInvalidate(newContext) {
      updateContext2(newContext);
      return false;
    }
  };
  let updateContext2 = (context2) => {
    for (let node of fullNodes)
      if (!node.hasChildNodes)
        context2.columns.push(node);
  };
  updateContext2(context);
};
var $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;
function $70d70eb16ea48428$var$Row(props) {
  return null;
}
$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode4(props, context) {
  let { children, textValue, UNSTABLE_childItems } = props;
  yield {
    type: "item",
    props,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: true,
    *childNodes() {
      if (context.showDragButtons)
        yield {
          type: "cell",
          key: "header-drag",
          props: {
            isDragButtonCell: true
          }
        };
      if (context.showSelectionCheckboxes && context.selectionMode !== "none")
        yield {
          type: "cell",
          key: "header",
          props: {
            isSelectionCell: true
          }
        };
      if (typeof children === "function") {
        for (let column of context.columns)
          yield {
            type: "cell",
            element: children(column.key),
            key: column.key
            // this is combined with the row key by CollectionBuilder
          };
        if (UNSTABLE_childItems)
          for (let child of UNSTABLE_childItems)
            yield {
              type: "item",
              value: child
            };
      } else {
        let cells = [];
        let childRows = [];
        (0, import_react3.default).Children.forEach(children, (node) => {
          if (node.type === $70d70eb16ea48428$var$Row) {
            if (cells.length < context.columns.length)
              throw new Error("All of a Row's child Cells must be positioned before any child Rows.");
            childRows.push({
              type: "item",
              element: node
            });
          } else
            cells.push({
              type: "cell",
              element: node
            });
        });
        if (cells.length !== context.columns.length)
          throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);
        yield* cells;
        yield* childRows;
      }
    },
    shouldInvalidate(newContext) {
      return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i) => c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.showDragButtons !== context.showDragButtons || newContext.selectionMode !== context.selectionMode;
    }
  };
};
var $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;
function $941d1d9a6a28982a$var$Cell(props) {
  return null;
}
$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode5(props) {
  let { children } = props;
  let textValue = props.textValue || (typeof children === "string" ? children : "") || props["aria-label"] || "";
  yield {
    type: "cell",
    props,
    rendered: children,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: false
  };
};
var $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/table/dist/keystar-ui-table.esm.js
var import_react5 = __toESM(require_react());

// node_modules/.pnpm/@react-aria+table@3.13.2_react-dom@18.2.0_react@18.2.0/node_modules/@react-aria/table/dist/import.mjs
var import_react4 = __toESM(require_react(), 1);
function $parcel$interopDefault2(a) {
  return a && a.__esModule ? a.default : a;
}
var $2140fb2337097f2d$export$552312adfd451dab = /* @__PURE__ */ new WeakMap();
function $2140fb2337097f2d$var$normalizeKey(key) {
  if (typeof key === "string")
    return key.replace(/\s*/g, "");
  return "" + key;
}
function $2140fb2337097f2d$export$37cd4213f2ad742e(state, columnKey) {
  let gridId = $2140fb2337097f2d$export$552312adfd451dab.get(state);
  if (!gridId)
    throw new Error("Unknown grid");
  return `${gridId}-${$2140fb2337097f2d$var$normalizeKey(columnKey)}`;
}
function $2140fb2337097f2d$export$19baff3266315d44(state, rowKey, columnKey) {
  let gridId = $2140fb2337097f2d$export$552312adfd451dab.get(state);
  if (!gridId)
    throw new Error("Unknown grid");
  return `${gridId}-${$2140fb2337097f2d$var$normalizeKey(rowKey)}-${$2140fb2337097f2d$var$normalizeKey(columnKey)}`;
}
function $2140fb2337097f2d$export$85069b70317f543(state, rowKey) {
  return [
    ...state.collection.rowHeaderColumnKeys
  ].map((columnKey) => $2140fb2337097f2d$export$19baff3266315d44(state, rowKey, columnKey)).join(" ");
}
var $7476b46781682bf5$exports = {};
var $ce3de3ff2fd66848$exports = {};
$ce3de3ff2fd66848$exports = {
  "ascending": `تصاعدي`,
  "ascendingSort": (args) => `ترتيب حسب العمود ${args.columnName} بترتيب تصاعدي`,
  "columnSize": (args) => `${args.value} بالبكسل`,
  "descending": `تنازلي`,
  "descendingSort": (args) => `ترتيب حسب العمود ${args.columnName} بترتيب تنازلي`,
  "resizerDescription": `اضغط على مفتاح Enter لبدء تغيير الحجم`,
  "select": `تحديد`,
  "selectAll": `تحديد الكل`,
  "sortable": `عمود قابل للترتيب`
};
var $cb80dcce530985b9$exports = {};
$cb80dcce530985b9$exports = {
  "ascending": `възходящ`,
  "ascendingSort": (args) => `сортирано по колона ${args.columnName} във възходящ ред`,
  "columnSize": (args) => `${args.value} пиксела`,
  "descending": `низходящ`,
  "descendingSort": (args) => `сортирано по колона ${args.columnName} в низходящ ред`,
  "resizerDescription": `Натиснете „Enter“, за да започнете да преоразмерявате`,
  "select": `Изберете`,
  "selectAll": `Изберете всичко`,
  "sortable": `сортираща колона`
};
var $68ac86749db4c0fb$exports = {};
$68ac86749db4c0fb$exports = {
  "ascending": `vzestupně`,
  "ascendingSort": (args) => `řazeno vzestupně podle sloupce ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixelů`,
  "descending": `sestupně`,
  "descendingSort": (args) => `řazeno sestupně podle sloupce ${args.columnName}`,
  "resizerDescription": `Stisknutím klávesy Enter začnete měnit velikost`,
  "select": `Vybrat`,
  "selectAll": `Vybrat vše`,
  "sortable": `sloupec s možností řazení`
};
var $9a6cbac08487e661$exports = {};
$9a6cbac08487e661$exports = {
  "ascending": `stigende`,
  "ascendingSort": (args) => `sorteret efter kolonne ${args.columnName} i stigende rækkefølge`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `faldende`,
  "descendingSort": (args) => `sorteret efter kolonne ${args.columnName} i faldende rækkefølge`,
  "resizerDescription": `Tryk på Enter for at ændre størrelse`,
  "select": `Vælg`,
  "selectAll": `Vælg alle`,
  "sortable": `sorterbar kolonne`
};
var $c963661d89486e72$exports = {};
$c963661d89486e72$exports = {
  "ascending": `aufsteigend`,
  "ascendingSort": (args) => `sortiert nach Spalte ${args.columnName} in aufsteigender Reihenfolge`,
  "columnSize": (args) => `${args.value} Pixel`,
  "descending": `absteigend`,
  "descendingSort": (args) => `sortiert nach Spalte ${args.columnName} in absteigender Reihenfolge`,
  "resizerDescription": `Eingabetaste zum Starten der Größenänderung drücken`,
  "select": `Auswählen`,
  "selectAll": `Alles auswählen`,
  "sortable": `sortierbare Spalte`
};
var $ac03861c6e8605f4$exports = {};
$ac03861c6e8605f4$exports = {
  "ascending": `αύξουσα`,
  "ascendingSort": (args) => `διαλογή ανά στήλη ${args.columnName} σε αύξουσα σειρά`,
  "columnSize": (args) => `${args.value} pixel`,
  "descending": `φθίνουσα`,
  "descendingSort": (args) => `διαλογή ανά στήλη ${args.columnName} σε φθίνουσα σειρά`,
  "resizerDescription": `Πατήστε Enter για έναρξη της αλλαγής μεγέθους`,
  "select": `Επιλογή`,
  "selectAll": `Επιλογή όλων`,
  "sortable": `Στήλη διαλογής`
};
var $09e6b82e0d6e466a$exports = {};
$09e6b82e0d6e466a$exports = {
  "select": `Select`,
  "selectAll": `Select All`,
  "sortable": `sortable column`,
  "ascending": `ascending`,
  "descending": `descending`,
  "ascendingSort": (args) => `sorted by column ${args.columnName} in ascending order`,
  "descendingSort": (args) => `sorted by column ${args.columnName} in descending order`,
  "columnSize": (args) => `${args.value} pixels`,
  "resizerDescription": `Press Enter to start resizing`
};
var $8cc39eb66c2bf220$exports = {};
$8cc39eb66c2bf220$exports = {
  "ascending": `de subida`,
  "ascendingSort": (args) => `ordenado por columna ${args.columnName} en orden de subida`,
  "columnSize": (args) => `${args.value} píxeles`,
  "descending": `de bajada`,
  "descendingSort": (args) => `ordenado por columna ${args.columnName} en orden de bajada`,
  "resizerDescription": `Pulse Intro para empezar a redimensionar`,
  "select": `Seleccionar`,
  "selectAll": `Seleccionar todos`,
  "sortable": `columna ordenable`
};
var $4e11db3c25a38112$exports = {};
$4e11db3c25a38112$exports = {
  "ascending": `tõusev järjestus`,
  "ascendingSort": (args) => `sorditud veeru järgi ${args.columnName} tõusvas järjestuses`,
  "columnSize": (args) => `${args.value} pikslit`,
  "descending": `laskuv järjestus`,
  "descendingSort": (args) => `sorditud veeru järgi ${args.columnName} laskuvas järjestuses`,
  "resizerDescription": `Suuruse muutmise alustamiseks vajutage klahvi Enter`,
  "select": `Vali`,
  "selectAll": `Vali kõik`,
  "sortable": `sorditav veerg`
};
var $da1e751a92575e02$exports = {};
$da1e751a92575e02$exports = {
  "ascending": `nouseva`,
  "ascendingSort": (args) => `lajiteltu sarakkeen ${args.columnName} mukaan nousevassa järjestyksessä`,
  "columnSize": (args) => `${args.value} pikseliä`,
  "descending": `laskeva`,
  "descendingSort": (args) => `lajiteltu sarakkeen ${args.columnName} mukaan laskevassa järjestyksessä`,
  "resizerDescription": `Aloita koon muutos painamalla Enter-näppäintä`,
  "select": `Valitse`,
  "selectAll": `Valitse kaikki`,
  "sortable": `lajiteltava sarake`
};
var $1b5d6c6c47d55106$exports = {};
$1b5d6c6c47d55106$exports = {
  "ascending": `croissant`,
  "ascendingSort": (args) => `trié en fonction de la colonne ${args.columnName} par ordre croissant`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `décroissant`,
  "descendingSort": (args) => `trié en fonction de la colonne ${args.columnName} par ordre décroissant`,
  "resizerDescription": `Appuyez sur Entrée pour commencer le redimensionnement.`,
  "select": `Sélectionner`,
  "selectAll": `Sélectionner tout`,
  "sortable": `colonne triable`
};
var $7c18ba27b86d3308$exports = {};
$7c18ba27b86d3308$exports = {
  "ascending": `עולה`,
  "ascendingSort": (args) => `מוין לפי עמודה ${args.columnName} בסדר עולה`,
  "columnSize": (args) => `${args.value} פיקסלים`,
  "descending": `יורד`,
  "descendingSort": (args) => `מוין לפי עמודה ${args.columnName} בסדר יורד`,
  "resizerDescription": `הקש Enter כדי לשנות את הגודל`,
  "select": `בחר`,
  "selectAll": `בחר הכול`,
  "sortable": `עמודה שניתן למיין`
};
var $2cb40998e20e8a46$exports = {};
$2cb40998e20e8a46$exports = {
  "ascending": `rastući`,
  "ascendingSort": (args) => `razvrstano po stupcima ${args.columnName} rastućem redoslijedom`,
  "columnSize": (args) => `${args.value} piksela`,
  "descending": `padajući`,
  "descendingSort": (args) => `razvrstano po stupcima ${args.columnName} padajućim redoslijedom`,
  "resizerDescription": `Pritisnite Enter da biste započeli promenu veličine`,
  "select": `Odaberite`,
  "selectAll": `Odaberite sve`,
  "sortable": `stupac koji se može razvrstati`
};
var $189e23eec1d6aa3a$exports = {};
$189e23eec1d6aa3a$exports = {
  "ascending": `növekvő`,
  "ascendingSort": (args) => `rendezve a(z) ${args.columnName} oszlop szerint, növekvő sorrendben`,
  "columnSize": (args) => `${args.value} képpont`,
  "descending": `csökkenő`,
  "descendingSort": (args) => `rendezve a(z) ${args.columnName} oszlop szerint, csökkenő sorrendben`,
  "resizerDescription": `Nyomja le az Enter billentyűt az átméretezés megkezdéséhez`,
  "select": `Kijelölés`,
  "selectAll": `Összes kijelölése`,
  "sortable": `rendezendő oszlop`
};
var $3c5ec8e4f015dfd0$exports = {};
$3c5ec8e4f015dfd0$exports = {
  "ascending": `crescente`,
  "ascendingSort": (args) => `in ordine crescente in base alla colonna ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixel`,
  "descending": `decrescente`,
  "descendingSort": (args) => `in ordine decrescente in base alla colonna ${args.columnName}`,
  "resizerDescription": `Premi Invio per iniziare a ridimensionare`,
  "select": `Seleziona`,
  "selectAll": `Seleziona tutto`,
  "sortable": `colonna ordinabile`
};
var $d021d50e6b315ebb$exports = {};
$d021d50e6b315ebb$exports = {
  "ascending": `昇順`,
  "ascendingSort": (args) => `列 ${args.columnName} を昇順で並べ替え`,
  "columnSize": (args) => `${args.value} ピクセル`,
  "descending": `降順`,
  "descendingSort": (args) => `列 ${args.columnName} を降順で並べ替え`,
  "resizerDescription": `Enter キーを押してサイズ変更を開始`,
  "select": `選択`,
  "selectAll": `すべて選択`,
  "sortable": `並べ替え可能な列`
};
var $52535c35c24ec937$exports = {};
$52535c35c24ec937$exports = {
  "ascending": `오름차순`,
  "ascendingSort": (args) => `${args.columnName} 열을 기준으로 오름차순으로 정렬됨`,
  "columnSize": (args) => `${args.value} 픽셀`,
  "descending": `내림차순`,
  "descendingSort": (args) => `${args.columnName} 열을 기준으로 내림차순으로 정렬됨`,
  "resizerDescription": `크기 조정을 시작하려면 Enter를 누르세요.`,
  "select": `선택`,
  "selectAll": `모두 선택`,
  "sortable": `정렬 가능한 열`
};
var $b37ee03672edfd1d$exports = {};
$b37ee03672edfd1d$exports = {
  "ascending": `didėjančia tvarka`,
  "ascendingSort": (args) => `surikiuota pagal stulpelį ${args.columnName} didėjančia tvarka`,
  "columnSize": (args) => `${args.value} piks.`,
  "descending": `mažėjančia tvarka`,
  "descendingSort": (args) => `surikiuota pagal stulpelį ${args.columnName} mažėjančia tvarka`,
  "resizerDescription": `Paspauskite „Enter“, kad pradėtumėte keisti dydį`,
  "select": `Pasirinkti`,
  "selectAll": `Pasirinkti viską`,
  "sortable": `rikiuojamas stulpelis`
};
var $c7df6686b4189d56$exports = {};
$c7df6686b4189d56$exports = {
  "ascending": `augošā secībā`,
  "ascendingSort": (args) => `kārtots pēc kolonnas ${args.columnName} augošā secībā`,
  "columnSize": (args) => `${args.value} pikseļi`,
  "descending": `dilstošā secībā`,
  "descendingSort": (args) => `kārtots pēc kolonnas ${args.columnName} dilstošā secībā`,
  "resizerDescription": `Nospiediet Enter, lai sāktu izmēru mainīšanu`,
  "select": `Atlasīt`,
  "selectAll": `Atlasīt visu`,
  "sortable": `kārtojamā kolonna`
};
var $da07fe8ec87e6b68$exports = {};
$da07fe8ec87e6b68$exports = {
  "ascending": `stigende`,
  "ascendingSort": (args) => `sortert etter kolonne ${args.columnName} i stigende rekkefølge`,
  "columnSize": (args) => `${args.value} piksler`,
  "descending": `synkende`,
  "descendingSort": (args) => `sortert etter kolonne ${args.columnName} i synkende rekkefølge`,
  "resizerDescription": `Trykk på Enter for å starte størrelsesendring`,
  "select": `Velg`,
  "selectAll": `Velg alle`,
  "sortable": `kolonne som kan sorteres`
};
var $64b7e390f5791490$exports = {};
$64b7e390f5791490$exports = {
  "ascending": `oplopend`,
  "ascendingSort": (args) => `gesorteerd in oplopende volgorde in kolom ${args.columnName}`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `aflopend`,
  "descendingSort": (args) => `gesorteerd in aflopende volgorde in kolom ${args.columnName}`,
  "resizerDescription": `Druk op Enter om het formaat te wijzigen`,
  "select": `Selecteren`,
  "selectAll": `Alles selecteren`,
  "sortable": `sorteerbare kolom`
};
var $2a03621e773f1678$exports = {};
$2a03621e773f1678$exports = {
  "ascending": `rosnąco`,
  "ascendingSort": (args) => `posortowano według kolumny ${args.columnName} w porządku rosnącym`,
  "columnSize": (args) => `Liczba pikseli: ${args.value}`,
  "descending": `malejąco`,
  "descendingSort": (args) => `posortowano według kolumny ${args.columnName} w porządku malejącym`,
  "resizerDescription": `Naciśnij Enter, aby rozpocząć zmienianie rozmiaru`,
  "select": `Zaznacz`,
  "selectAll": `Zaznacz wszystko`,
  "sortable": `kolumna z możliwością sortowania`
};
var $0a79c0aba9e5ecc6$exports = {};
$0a79c0aba9e5ecc6$exports = {
  "ascending": `crescente`,
  "ascendingSort": (args) => `classificado pela coluna ${args.columnName} em ordem crescente`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `decrescente`,
  "descendingSort": (args) => `classificado pela coluna ${args.columnName} em ordem decrescente`,
  "resizerDescription": `Pressione Enter para começar a redimensionar`,
  "select": `Selecionar`,
  "selectAll": `Selecionar tudo`,
  "sortable": `coluna classificável`
};
var $de7b4d0f7dc86fc8$exports = {};
$de7b4d0f7dc86fc8$exports = {
  "ascending": `ascendente`,
  "ascendingSort": (args) => `Ordenar por coluna ${args.columnName} em ordem ascendente`,
  "columnSize": (args) => `${args.value} pixels`,
  "descending": `descendente`,
  "descendingSort": (args) => `Ordenar por coluna ${args.columnName} em ordem descendente`,
  "resizerDescription": `Prima Enter para iniciar o redimensionamento`,
  "select": `Selecionar`,
  "selectAll": `Selecionar tudo`,
  "sortable": `Coluna ordenável`
};
var $28ea7e849d77bd1c$exports = {};
$28ea7e849d77bd1c$exports = {
  "ascending": `crescătoare`,
  "ascendingSort": (args) => `sortate după coloana ${args.columnName} în ordine crescătoare`,
  "columnSize": (args) => `${args.value} pixeli`,
  "descending": `descrescătoare`,
  "descendingSort": (args) => `sortate după coloana ${args.columnName} în ordine descrescătoare`,
  "resizerDescription": `Apăsați pe Enter pentru a începe redimensionarea`,
  "select": `Selectare`,
  "selectAll": `Selectare totală`,
  "sortable": `coloană sortabilă`
};
var $9a09321cf046b187$exports = {};
$9a09321cf046b187$exports = {
  "ascending": `возрастание`,
  "ascendingSort": (args) => `сортировать столбец ${args.columnName} в порядке возрастания`,
  "columnSize": (args) => `${args.value} пикс.`,
  "descending": `убывание`,
  "descendingSort": (args) => `сортировать столбец ${args.columnName} в порядке убывания`,
  "resizerDescription": `Нажмите клавишу Enter для начала изменения размеров`,
  "select": `Выбрать`,
  "selectAll": `Выбрать все`,
  "sortable": `сортируемый столбец`
};
var $5afe469a63fcac7b$exports = {};
$5afe469a63fcac7b$exports = {
  "ascending": `vzostupne`,
  "ascendingSort": (args) => `zoradené zostupne podľa stĺpca ${args.columnName}`,
  "columnSize": (args) => `Počet pixelov: ${args.value}`,
  "descending": `zostupne`,
  "descendingSort": (args) => `zoradené zostupne podľa stĺpca ${args.columnName}`,
  "resizerDescription": `Stlačením klávesu Enter začnete zmenu veľkosti`,
  "select": `Vybrať`,
  "selectAll": `Vybrať všetko`,
  "sortable": `zoraditeľný stĺpec`
};
var $2956757ac31a7ce2$exports = {};
$2956757ac31a7ce2$exports = {
  "ascending": `naraščajoče`,
  "ascendingSort": (args) => `razvrščeno po stolpcu ${args.columnName} v naraščajočem vrstnem redu`,
  "columnSize": (args) => `${args.value} slikovnih pik`,
  "descending": `padajoče`,
  "descendingSort": (args) => `razvrščeno po stolpcu ${args.columnName} v padajočem vrstnem redu`,
  "resizerDescription": `Pritisnite tipko Enter da začnete spreminjati velikost`,
  "select": `Izberite`,
  "selectAll": `Izberite vse`,
  "sortable": `razvrstljivi stolpec`
};
var $cedee0e66b175529$exports = {};
$cedee0e66b175529$exports = {
  "ascending": `rastući`,
  "ascendingSort": (args) => `sortirano po kolonama ${args.columnName} rastućim redosledom`,
  "columnSize": (args) => `${args.value} piksela`,
  "descending": `padajući`,
  "descendingSort": (args) => `sortirano po kolonama ${args.columnName} padajućim redosledom`,
  "resizerDescription": `Pritisnite Enter da biste započeli promenu veličine`,
  "select": `Izaberite`,
  "selectAll": `Izaberite sve`,
  "sortable": `kolona koja se može sortirati`
};
var $6db19998ba4427da$exports = {};
$6db19998ba4427da$exports = {
  "ascending": `stigande`,
  "ascendingSort": (args) => `sorterat på kolumn ${args.columnName} i stigande ordning`,
  "columnSize": (args) => `${args.value} pixlar`,
  "descending": `fallande`,
  "descendingSort": (args) => `sorterat på kolumn ${args.columnName} i fallande ordning`,
  "resizerDescription": `Tryck på Retur för att börja ändra storlek`,
  "select": `Markera`,
  "selectAll": `Markera allt`,
  "sortable": `sorterbar kolumn`
};
var $166b7c9cc1adb1a1$exports = {};
$166b7c9cc1adb1a1$exports = {
  "ascending": `artan sırada`,
  "ascendingSort": (args) => `${args.columnName} sütuna göre artan düzende sırala`,
  "columnSize": (args) => `${args.value} piksel`,
  "descending": `azalan sırada`,
  "descendingSort": (args) => `${args.columnName} sütuna göre azalan düzende sırala`,
  "resizerDescription": `Yeniden boyutlandırmak için Enter'a basın`,
  "select": `Seç`,
  "selectAll": `Tümünü Seç`,
  "sortable": `Sıralanabilir sütun`
};
var $c7ab180b401e49ff$exports = {};
$c7ab180b401e49ff$exports = {
  "ascending": `висхідний`,
  "ascendingSort": (args) => `відсортовано за стовпцем ${args.columnName} у висхідному порядку`,
  "columnSize": (args) => `${args.value} пікс.`,
  "descending": `низхідний`,
  "descendingSort": (args) => `відсортовано за стовпцем ${args.columnName} у низхідному порядку`,
  "resizerDescription": `Натисніть Enter, щоб почати зміну розміру`,
  "select": `Вибрати`,
  "selectAll": `Вибрати все`,
  "sortable": `сортувальний стовпець`
};
var $1648ec00941567f3$exports = {};
$1648ec00941567f3$exports = {
  "ascending": `升序`,
  "ascendingSort": (args) => `按列 ${args.columnName} 升序排序`,
  "columnSize": (args) => `${args.value} 像素`,
  "descending": `降序`,
  "descendingSort": (args) => `按列 ${args.columnName} 降序排序`,
  "resizerDescription": `按“输入”键开始调整大小。`,
  "select": `选择`,
  "selectAll": `全选`,
  "sortable": `可排序的列`
};
var $b26f22384b3c1526$exports = {};
$b26f22384b3c1526$exports = {
  "ascending": `遞增`,
  "ascendingSort": (args) => `已依據「${args.columnName}」欄遞增排序`,
  "columnSize": (args) => `${args.value} 像素`,
  "descending": `遞減`,
  "descendingSort": (args) => `已依據「${args.columnName}」欄遞減排序`,
  "resizerDescription": `按 Enter 鍵以開始調整大小`,
  "select": `選取`,
  "selectAll": `全選`,
  "sortable": `可排序的欄`
};
$7476b46781682bf5$exports = {
  "ar-AE": $ce3de3ff2fd66848$exports,
  "bg-BG": $cb80dcce530985b9$exports,
  "cs-CZ": $68ac86749db4c0fb$exports,
  "da-DK": $9a6cbac08487e661$exports,
  "de-DE": $c963661d89486e72$exports,
  "el-GR": $ac03861c6e8605f4$exports,
  "en-US": $09e6b82e0d6e466a$exports,
  "es-ES": $8cc39eb66c2bf220$exports,
  "et-EE": $4e11db3c25a38112$exports,
  "fi-FI": $da1e751a92575e02$exports,
  "fr-FR": $1b5d6c6c47d55106$exports,
  "he-IL": $7c18ba27b86d3308$exports,
  "hr-HR": $2cb40998e20e8a46$exports,
  "hu-HU": $189e23eec1d6aa3a$exports,
  "it-IT": $3c5ec8e4f015dfd0$exports,
  "ja-JP": $d021d50e6b315ebb$exports,
  "ko-KR": $52535c35c24ec937$exports,
  "lt-LT": $b37ee03672edfd1d$exports,
  "lv-LV": $c7df6686b4189d56$exports,
  "nb-NO": $da07fe8ec87e6b68$exports,
  "nl-NL": $64b7e390f5791490$exports,
  "pl-PL": $2a03621e773f1678$exports,
  "pt-BR": $0a79c0aba9e5ecc6$exports,
  "pt-PT": $de7b4d0f7dc86fc8$exports,
  "ro-RO": $28ea7e849d77bd1c$exports,
  "ru-RU": $9a09321cf046b187$exports,
  "sk-SK": $5afe469a63fcac7b$exports,
  "sl-SI": $2956757ac31a7ce2$exports,
  "sr-SP": $cedee0e66b175529$exports,
  "sv-SE": $6db19998ba4427da$exports,
  "tr-TR": $166b7c9cc1adb1a1$exports,
  "uk-UA": $c7ab180b401e49ff$exports,
  "zh-CN": $1648ec00941567f3$exports,
  "zh-TW": $b26f22384b3c1526$exports
};
var $0ba3c81c7f1caedd$export$da43f8f5cb04028d = class extends (0, $d1c300d9c497e402$export$de9feff04fda126e) {
  isCell(node) {
    return node.type === "cell" || node.type === "rowheader" || node.type === "column";
  }
  getKeyBelow(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem)
      return;
    if (startItem.type === "column") {
      let child = (0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(startItem, this.collection));
      if (child)
        return child.key;
      let firstKey = this.getFirstKey();
      if (firstKey == null)
        return;
      let firstItem = this.collection.getItem(firstKey);
      return (0, $c5a24bc478652b5f$export$5f3398f8733f90e2)((0, $c5a24bc478652b5f$export$1005530eda016c13)(firstItem, this.collection), startItem.index).key;
    }
    return super.getKeyBelow(key);
  }
  getKeyAbove(key) {
    let startItem = this.collection.getItem(key);
    if (!startItem)
      return;
    if (startItem.type === "column") {
      let parent = this.collection.getItem(startItem.parentKey);
      if (parent && parent.type === "column")
        return parent.key;
      return;
    }
    let superKey = super.getKeyAbove(key);
    if (superKey != null && this.collection.getItem(superKey).type !== "headerrow")
      return superKey;
    if (this.isCell(startItem))
      return this.collection.columns[startItem.index].key;
    return this.collection.columns[0].key;
  }
  findNextColumnKey(column) {
    let key = this.findNextKey(column.key, (item) => item.type === "column");
    if (key != null)
      return key;
    let row = this.collection.headerRows[column.level];
    for (let item of (0, $c5a24bc478652b5f$export$1005530eda016c13)(row, this.collection)) {
      if (item.type === "column")
        return item.key;
    }
  }
  findPreviousColumnKey(column) {
    let key = this.findPreviousKey(column.key, (item) => item.type === "column");
    if (key != null)
      return key;
    let row = this.collection.headerRows[column.level];
    let childNodes = [
      ...(0, $c5a24bc478652b5f$export$1005530eda016c13)(row, this.collection)
    ];
    for (let i = childNodes.length - 1; i >= 0; i--) {
      let item = childNodes[i];
      if (item.type === "column")
        return item.key;
    }
  }
  getKeyRightOf(key) {
    let item = this.collection.getItem(key);
    if (!item)
      return;
    if (item.type === "column")
      return this.direction === "rtl" ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);
    return super.getKeyRightOf(key);
  }
  getKeyLeftOf(key) {
    let item = this.collection.getItem(key);
    if (!item)
      return;
    if (item.type === "column")
      return this.direction === "rtl" ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);
    return super.getKeyLeftOf(key);
  }
  getKeyForSearch(search, fromKey) {
    if (!this.collator)
      return null;
    let collection = this.collection;
    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();
    if (key == null)
      return null;
    let startItem = collection.getItem(key);
    if (startItem.type === "cell")
      key = startItem.parentKey;
    let hasWrapped = false;
    while (key != null) {
      let item = collection.getItem(key);
      for (let cell of (0, $c5a24bc478652b5f$export$1005530eda016c13)(item, this.collection)) {
        let column = collection.columns[cell.index];
        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {
          let substring = cell.textValue.slice(0, search.length);
          if (this.collator.compare(substring, search) === 0) {
            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;
            return fromItem.type === "cell" ? cell.key : item.key;
          }
        }
      }
      key = this.getKeyBelow(key);
      if (key == null && !hasWrapped) {
        key = this.getFirstKey();
        hasWrapped = true;
      }
    }
    return null;
  }
};
function $6e31608fbba75bab$export$25bceaac3c7e4dc7(props, state, ref) {
  let { keyboardDelegate, isVirtualized, layout } = props;
  let collator2 = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let disabledBehavior = state.selectionManager.disabledBehavior;
  let delegate = (0, import_react4.useMemo)(() => keyboardDelegate || new (0, $0ba3c81c7f1caedd$export$da43f8f5cb04028d)({
    collection: state.collection,
    disabledKeys: disabledBehavior === "selection" ? /* @__PURE__ */ new Set() : state.disabledKeys,
    ref,
    direction,
    collator: collator2,
    layout
  }), [
    keyboardDelegate,
    state.collection,
    state.disabledKeys,
    disabledBehavior,
    ref,
    direction,
    collator2,
    layout
  ]);
  let id = (0, $bdb11010cef70236$export$f680877a34711e37)(props.id);
  (0, $2140fb2337097f2d$export$552312adfd451dab).set(state, id);
  let { gridProps } = (0, $83c6e2eafa584c67$export$f6b86a04e5d66d90)({
    ...props,
    id,
    keyboardDelegate: delegate
  }, state, ref);
  if (isVirtualized)
    gridProps["aria-rowcount"] = state.collection.size + state.collection.headerRows.length;
  if ((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state)
    gridProps.role = "treegrid";
  let { column, direction: sortDirection } = state.sortDescriptor || {};
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($7476b46781682bf5$exports)));
  let sortDescription = (0, import_react4.useMemo)(() => {
    var _state_collection_columns_find;
    let columnName = (_state_collection_columns_find = state.collection.columns.find((c) => c.key === column)) === null || _state_collection_columns_find === void 0 ? void 0 : _state_collection_columns_find.textValue;
    return sortDirection && column ? stringFormatter.format(`${sortDirection}Sort`, {
      columnName
    }) : void 0;
  }, [
    sortDirection,
    column,
    state.collection.columns
  ]);
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(sortDescription);
  (0, $4f58c5f72bcf79f7$export$496315a1608d9602)(() => {
    (0, $319e236875307eab$export$a9b970dcc4ae71a9)(sortDescription, "assertive", 500);
  }, [
    sortDescription
  ]);
  return {
    gridProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(gridProps, descriptionProps, {
      // merge sort description with long press information
      "aria-describedby": [
        descriptionProps["aria-describedby"],
        gridProps["aria-describedby"]
      ].filter(Boolean).join(" ")
    })
  };
}
function $f329116d8ad0aba0$export$9514819a8c81e960(props, state, ref) {
  var _state_sortDescriptor, _state_sortDescriptor1;
  let { node } = props;
  let allowsSorting = node.props.allowsSorting;
  let { gridCellProps } = (0, $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c)({
    ...props,
    focusMode: "child"
  }, state, ref);
  let isSelectionCellDisabled = node.props.isSelectionCell && state.selectionManager.selectionMode === "single";
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled: !allowsSorting || isSelectionCellDisabled,
    onPress() {
      state.sort(node.key);
    },
    ref
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)({}, ref);
  let ariaSort = null;
  let isSortedColumn = ((_state_sortDescriptor = state.sortDescriptor) === null || _state_sortDescriptor === void 0 ? void 0 : _state_sortDescriptor.column) === node.key;
  let sortDirection = (_state_sortDescriptor1 = state.sortDescriptor) === null || _state_sortDescriptor1 === void 0 ? void 0 : _state_sortDescriptor1.direction;
  if (node.props.allowsSorting && !(0, $c87311424ea30a05$export$a11b0059900ceec8)())
    ariaSort = isSortedColumn ? sortDirection : "none";
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($7476b46781682bf5$exports)));
  let sortDescription;
  if (allowsSorting) {
    sortDescription = `${stringFormatter.format("sortable")}`;
    if (isSortedColumn && sortDirection && (0, $c87311424ea30a05$export$a11b0059900ceec8)())
      sortDescription = `${sortDescription}, ${stringFormatter.format(sortDirection)}`;
  }
  let descriptionProps = (0, $ef06256079686ba0$export$f8aeda7b10753fa1)(sortDescription);
  let shouldDisableFocus = state.collection.size === 0;
  (0, import_react4.useEffect)(() => {
    if (shouldDisableFocus && state.selectionManager.focusedKey === node.key)
      state.selectionManager.setFocusedKey(null);
  }, [
    shouldDisableFocus,
    state.selectionManager,
    node.key
  ]);
  return {
    columnHeaderProps: {
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(
        gridCellProps,
        pressProps,
        focusableProps,
        descriptionProps,
        // If the table is empty, make all column headers untabbable
        shouldDisableFocus && {
          tabIndex: -1
        }
      ),
      role: "columnheader",
      id: (0, $2140fb2337097f2d$export$37cd4213f2ad742e)(state, node.key),
      "aria-colspan": node.colspan && node.colspan > 1 ? node.colspan : null,
      "aria-sort": ariaSort
    }
  };
}
var $b2db214c022798eb$var$EXPANSION_KEYS = {
  expand: {
    ltr: "ArrowRight",
    rtl: "ArrowLeft"
  },
  "collapse": {
    ltr: "ArrowLeft",
    rtl: "ArrowRight"
  }
};
function $b2db214c022798eb$export$7f2f6ae19e707aa5(props, state, ref) {
  let { node, isVirtualized } = props;
  let { rowProps, ...states } = (0, $4159a7a9cbb0cc18$export$96357d5a73f686fa)(props, state, ref);
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  if (isVirtualized && !((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state))
    rowProps["aria-rowindex"] = node.index + 1 + state.collection.headerRows.length;
  else
    delete rowProps["aria-rowindex"];
  let treeGridRowProps = {};
  if ((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state) {
    let treeNode = state.keyMap.get(node.key);
    if (treeNode != null) {
      var _treeNode_props, _treeNode_props_children, _treeNode_props1;
      let hasChildRows = ((_treeNode_props = treeNode.props) === null || _treeNode_props === void 0 ? void 0 : _treeNode_props.UNSTABLE_childItems) || ((_treeNode_props1 = treeNode.props) === null || _treeNode_props1 === void 0 ? void 0 : (_treeNode_props_children = _treeNode_props1.children) === null || _treeNode_props_children === void 0 ? void 0 : _treeNode_props_children.length) > state.userColumnCount;
      treeGridRowProps = {
        onKeyDown: (e2) => {
          if (e2.key === $b2db214c022798eb$var$EXPANSION_KEYS["expand"][direction] && state.selectionManager.focusedKey === treeNode.key && hasChildRows && state.expandedKeys !== "all" && !state.expandedKeys.has(treeNode.key)) {
            state.toggleKey(treeNode.key);
            e2.stopPropagation();
          } else if (e2.key === $b2db214c022798eb$var$EXPANSION_KEYS["collapse"][direction] && state.selectionManager.focusedKey === treeNode.key && hasChildRows && (state.expandedKeys === "all" || state.expandedKeys.has(treeNode.key))) {
            state.toggleKey(treeNode.key);
            e2.stopPropagation();
          }
        },
        "aria-expanded": hasChildRows ? state.expandedKeys === "all" || state.expandedKeys.has(node.key) : void 0,
        "aria-level": treeNode.level,
        "aria-posinset": treeNode.indexOfType + 1,
        "aria-setsize": treeNode.level > 1 ? (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(state.keyMap.get(treeNode === null || treeNode === void 0 ? void 0 : treeNode.parentKey).childNodes).indexOfType + 1 : (0, $c5a24bc478652b5f$export$7475b2c64539e4cf)(state.keyMap.get(state.collection.body.key).childNodes).indexOfType + 1
      };
    }
  }
  let linkProps = states.hasAction ? (0, $ea8dcbcb9ea1b556$export$51437d503373d223)(node.props) : {};
  return {
    rowProps: {
      ...(0, $3ef42575df84b30b$export$9d1611c77c2fe928)(rowProps, treeGridRowProps, linkProps),
      "aria-labelledby": (0, $2140fb2337097f2d$export$85069b70317f543)(state, node.key)
    },
    ...states
  };
}
function $f917ee10f4c32dab$export$1b95a7d2d517b841(props, state, ref) {
  let { node, isVirtualized } = props;
  let rowProps = {
    role: "row"
  };
  if (isVirtualized && !((0, $f4e2df6bd15f8569$export$1b00cb14a96194e6)() && "expandedKeys" in state))
    rowProps["aria-rowindex"] = node.index + 1;
  return {
    rowProps
  };
}
function $7713593715703b24$export$49571c903d73624c(props, state, ref) {
  let { gridCellProps, isPressed } = (0, $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c)(props, state, ref);
  let columnKey = props.node.column.key;
  if (state.collection.rowHeaderColumnKeys.has(columnKey)) {
    gridCellProps.role = "rowheader";
    gridCellProps.id = (0, $2140fb2337097f2d$export$19baff3266315d44)(state, props.node.parentKey, columnKey);
  }
  return {
    gridCellProps,
    isPressed
  };
}
function $2a795c53a101c542$export$16ea7f650bd7c1bb(props, state) {
  let { key } = props;
  const { checkboxProps } = (0, $7cb39d07f245a780$export$70e2eed1a92976ad)(props, state);
  return {
    checkboxProps: {
      ...checkboxProps,
      "aria-labelledby": `${checkboxProps.id} ${(0, $2140fb2337097f2d$export$85069b70317f543)(state, key)}`
    }
  };
}
function $2a795c53a101c542$export$1003db6a7e384b99(state) {
  let { isEmpty, isSelectAll, selectionMode } = state.selectionManager;
  const stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault2($7476b46781682bf5$exports)));
  return {
    checkboxProps: {
      "aria-label": stringFormatter.format(selectionMode === "single" ? "select" : "selectAll"),
      isSelected: isSelectAll,
      isDisabled: selectionMode !== "multiple" || state.collection.size === 0,
      isIndeterminate: !isEmpty && !isSelectAll,
      onChange: () => state.selectionManager.toggleSelectAll()
    }
  };
}
function $0047e6c294ea075f$export$6fb1613bd7b28198() {
  return (0, $e45487f8ba1cbdbf$export$d3037f5d3f3e51bf)();
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/arrowUpIcon/dist/keystar-ui-icon-icons-arrowUpIcon.esm.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var arrowUpIcon = (0, import_jsx_runtime8.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime8.jsx)("path", {
    d: "m5 12 7-7 7 7M12 19V5"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/table/dist/keystar-ui-table.esm.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var localizedMessages2 = {
  "ar-AE": {
    loading: "جارٍ التحميل...",
    loadingMore: "جارٍ تحميل المزيد..."
  },
  "bg-BG": {
    loading: "Зареждане...",
    loadingMore: "Зареждане на още..."
  },
  "cs-CZ": {
    loading: "Načítání...",
    loadingMore: "Načítání dalších..."
  },
  "da-DK": {
    loading: "Indlæser...",
    loadingMore: "Indlæser flere..."
  },
  "de-DE": {
    loading: "Laden...",
    loadingMore: "Mehr laden ..."
  },
  "el-GR": {
    loading: "Φόρτωση...",
    loadingMore: "Φόρτωση περισσότερων..."
  },
  "en-US": {
    loading: "Loading…",
    loadingMore: "Loading more…"
  },
  "es-ES": {
    loading: "Cargando…",
    loadingMore: "Cargando más…"
  },
  "et-EE": {
    loading: "Laadimine...",
    loadingMore: "Laadi rohkem..."
  },
  "fi-FI": {
    loading: "Ladataan…",
    loadingMore: "Ladataan lisää…"
  },
  "fr-FR": {
    loading: "Chargement...",
    loadingMore: "Chargement supplémentaire..."
  },
  "he-IL": {
    loading: "טוען...",
    loadingMore: "טוען עוד..."
  },
  "hr-HR": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "hu-HU": {
    loading: "Betöltés folyamatban…",
    loadingMore: "Továbbiak betöltése folyamatban…"
  },
  "it-IT": {
    loading: "Caricamento...",
    loadingMore: "Caricamento altri..."
  },
  "ja-JP": {
    loading: "読み込み中...",
    loadingMore: "さらに読み込み中..."
  },
  "ko-KR": {
    loading: "로드 중…",
    loadingMore: "추가 로드 중…"
  },
  "lt-LT": {
    loading: "Įkeliama...",
    loadingMore: "Įkeliama daugiau..."
  },
  "lv-LV": {
    loading: "Notiek ielāde...",
    loadingMore: "Tiek ielādēts vēl..."
  },
  "nb-NO": {
    loading: "Laster inn ...",
    loadingMore: "Laster inn flere ..."
  },
  "nl-NL": {
    loading: "Laden...",
    loadingMore: "Meer laden..."
  },
  "pl-PL": {
    loading: "Ładowanie...",
    loadingMore: "Wczytywanie większej liczby..."
  },
  "pt-BR": {
    loading: "Carregando...",
    loadingMore: "Carregando mais..."
  },
  "pt-PT": {
    loading: "A carregar...",
    loadingMore: "A carregar mais..."
  },
  "ro-RO": {
    loading: "Se încarcă...",
    loadingMore: "Se încarcă mai multe..."
  },
  "ru-RU": {
    loading: "Загрузка...",
    loadingMore: "Дополнительная загрузка..."
  },
  "sk-SK": {
    loading: "Načítava sa...",
    loadingMore: "Načítava sa viac..."
  },
  "sl-SI": {
    loading: "Nalaganje ...",
    loadingMore: "Nalaganje več vsebine ..."
  },
  "sr-SP": {
    loading: "Učitavam...",
    loadingMore: "Učitavam još..."
  },
  "sv-SE": {
    loading: "Läser in...",
    loadingMore: "Läser in mer..."
  },
  "tr-TR": {
    loading: "Yükleniyor...",
    loadingMore: "Daha fazla yükleniyor..."
  },
  "uk-UA": {
    loading: "Завантаження…",
    loadingMore: "Завантаження інших об’єктів..."
  },
  "zh-CN": {
    loading: "正在加载...",
    loadingMore: "正在加载更多..."
  },
  "zh-T": {
    loading: "載入中…",
    loadingMore: "正在載入更多…"
  }
};
var tableViewClassList = new ClassList("TableView", ["cell", "cell-wrapper", "row"]);
var SortIndicator = () => {
  let labelHeight = tokenSchema.typography.text.regular.capheight;
  return (0, import_jsx_runtime9.jsx)("span", {
    "aria-hidden": "true",
    className: css({
      alignItems: "center",
      display: "flex",
      flexShrink: 0,
      height: labelHeight,
      justifyContent: "center",
      marginInline: tokenSchema.size.space.small,
      opacity: 0,
      position: "relative",
      transition: transition(["opacity", "transform"], {
        easing: "easeOut"
      }),
      width: labelHeight,
      svg: {
        position: "absolute"
      },
      ['[aria-sort="ascending"] &, [aria-sort="descending"] &']: {
        opacity: 1
      },
      ['[aria-sort="descending"] &']: {
        transform: "rotate(180deg)"
      }
    }),
    children: (0, import_jsx_runtime9.jsx)(Icon, {
      src: arrowUpIcon
    })
  });
};
function useTableStyleProps(props) {
  let {
    density,
    overflowMode,
    prominence
  } = props;
  let styleProps = useStyleProps(props);
  return {
    ...toDataAttributes({
      density,
      overflowMode,
      prominence
    }),
    className: classNames(tableViewClassList.element("root"), styleProps.className, css({
      display: "flex",
      flexDirection: "column",
      isolation: "isolate",
      minHeight: 0,
      minWidth: 0,
      outline: "none",
      position: "relative",
      userSelect: "none"
    })),
    style: styleProps.style
  };
}
function useHeaderWrapperStyleProps({
  style
} = {}) {
  return {
    className: css({
      overflow: "hidden",
      position: "relative",
      boxSizing: "content-box",
      flex: "none",
      // keep aligned with the border of the body
      [`${tableViewClassList.selector("root")}:not([data-prominence="low"]) &`]: {
        borderLeft: `${tokenSchema.size.border.regular} solid transparent`,
        borderRight: `${tokenSchema.size.border.regular} solid transparent`
      }
    }),
    style
  };
}
function useHeadStyleProps({
  style
} = {}) {
  return {
    className: css({
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column"
    }),
    style
  };
}
function useBodyStyleProps({
  style
} = {}) {
  return {
    className: css({
      [`${tableViewClassList.selector("root")}[data-prominence="low"] &`]: {
        borderBlock: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`
      },
      [`${tableViewClassList.selector("root")}:not([data-prominence="low"]) &`]: {
        backgroundColor: tokenSchema.color.background.canvas,
        border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`,
        borderRadius: tokenSchema.size.radius.medium,
        /* Fix scrollbars on iOS with sticky row headers */
        transform: "translate3d(0, 0, 0)"
      }
    }),
    style
  };
}
var commonCellStyles = {
  // borderBottom: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.neutral}`,
  boxSizing: "border-box",
  cursor: "default",
  display: "flex",
  height: "100%",
  justifyContent: "flex-start",
  minWidth: 0,
  outline: 0,
  paddingInline: tokenSchema.size.space.medium,
  position: "relative",
  // Density
  paddingBlock: tokenSchema.size.space.medium,
  [`${tableViewClassList.selector("root")}[data-density="compact"] &:not([role="columnheader"])`]: {
    paddingBlock: tokenSchema.size.space.regular
  },
  [`${tableViewClassList.selector("root")}[data-density="spacious"] &:not([role="columnheader"])`]: {
    paddingBlock: tokenSchema.size.space.large
  },
  // wrapping text shouldn't be centered
  alignItems: "center",
  [`${tableViewClassList.selector("root")}[data-overflow-mode="wrap"] &:not([role="columnheader"])`]: {
    alignItems: "start"
  }
};
function useCellStyleProps(props, state) {
  const className = classNames(tableViewClassList.element("cell"), css([commonCellStyles, {
    // Alignment
    '&[data-align="end"]': {
      justifyContent: "flex-end",
      textAlign: "end"
    },
    '&[data-align="center"]': {
      justifyContent: "center",
      textAlign: "center"
    },
    // focus ring
    '&[data-focus="visible"]::after': {
      borderRadius: tokenSchema.size.radius.small,
      boxShadow: `inset 0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
      content: '""',
      inset: 0,
      position: "absolute",
      transition: transition(["box-shadow", "margin"], {
        easing: "easeOut"
      })
    },
    // HEADERS
    '&[role="columnheader"]': {
      color: tokenSchema.color.foreground.neutralSecondary,
      ["&[aria-sort]"]: {
        cursor: "default",
        '&:hover, &[data-focus="visible"]': {
          color: tokenSchema.color.foreground.neutralEmphasis
        }
      }
    }
  }]));
  return {
    ...toDataAttributes({
      focus: state !== null && state !== void 0 && state.isFocusVisible ? "visible" : void 0,
      align: props === null || props === void 0 ? void 0 : props.align
    }),
    className
    // style: getStyleFromColumn(props),
  };
}
function useSelectionCellStyleProps() {
  return {
    className: classNames(tableViewClassList.element("cell"), css(commonCellStyles, {
      alignItems: "center",
      flex: "0 0 auto",
      paddingInlineStart: tokenSchema.size.space.medium,
      width: "auto"
    }))
  };
}
function useRowStyleProps(props, state) {
  let {
    style
  } = props;
  let calculatedRadius = `calc(${tokenSchema.size.radius.medium} - ${tokenSchema.size.border.regular})`;
  const className = css({
    boxSizing: "border-box",
    display: "flex",
    position: "relative",
    outline: 0,
    // separators
    "&:not(:last-child)": {
      backgroundColor: tokenSchema.color.border.muted,
      paddingBottom: 1
    },
    // prominence
    [`${tableViewClassList.selector("root")}:not([data-prominence="low"]) &`]: {
      "&:first-child": {
        borderStartStartRadius: calculatedRadius,
        borderStartEndRadius: calculatedRadius
      },
      "&:last-child": {
        borderEndStartRadius: calculatedRadius,
        borderEndEndRadius: calculatedRadius
      }
    },
    // focus indicator
    '&[data-focus="visible"]': {
      "&::before": {
        backgroundColor: tokenSchema.color.background.accentEmphasis,
        borderRadius: tokenSchema.size.space.small,
        content: '""',
        insetInlineStart: tokenSchema.size.space.xsmall,
        marginBlock: tokenSchema.size.space.xsmall,
        marginInlineEnd: `calc(${tokenSchema.size.space.small} * -1)`,
        position: "sticky",
        width: tokenSchema.size.space.small,
        zIndex: 4
      }
    },
    // interactions
    [`&[data-interaction="hover"] ${tableViewClassList.selector("cell")}`]: {
      backgroundColor: tokenSchema.color.scale.slate2
    },
    [`&[data-interaction="press"] ${tableViewClassList.selector("cell")}`]: {
      backgroundColor: tokenSchema.color.scale.slate3
      // backgroundColor: tokenSchema.color.alias.backgroundPressed,
    },
    // selected
    [`&[aria-selected="true"] ${tableViewClassList.selector("cell")}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundSelected
    },
    [`&[aria-selected="true"][data-interaction="hover"] ${tableViewClassList.selector("cell")}`]: {
      backgroundColor: tokenSchema.color.alias.backgroundSelectedHovered
    }
  });
  return {
    ...toDataAttributes({
      focus: state.isFocusVisible ? "visible" : state.isFocusWithin ? "within" : void 0,
      interaction: state.isPressed ? "press" : state.isHovered ? "hover" : void 0
    }),
    className: classNames(tableViewClassList.element("row"), className),
    style
  };
}
function useRowHeaderStyleProps({
  style
}) {
  const className = css({
    display: "flex"
  });
  return {
    className,
    style
  };
}
var DEFAULT_HEADER_HEIGHT = 34;
var DEFAULT_HIDE_HEADER_CELL_WIDTH = 34;
var SELECTION_CELL_DEFAULT_WIDTH = 34;
var ROW_HEIGHTS = {
  compact: 26,
  regular: 34,
  spacious: 42
};
var TableContext = (0, import_react5.createContext)(null);
function useTableContext() {
  return (0, import_react5.useContext)(TableContext);
}
function TableView(props) {
  let domRef = (0, import_react5.useRef)(null);
  let headerRef = (0, import_react5.useRef)(null);
  let bodyRef = (0, import_react5.useRef)(null);
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages2);
  let {
    density = "regular",
    overflowMode
  } = props;
  let renderWrapper = (parent, reusableView, children, renderChildren) => {
    let style = $ccf8a0a04e4175ae$export$1481e64fbe01b8b3(reusableView.layoutInfo, direction, parent && parent.layoutInfo);
    if (style.overflow === "hidden") {
      style.overflow = "visible";
    }
    if (reusableView.viewType === "rowgroup") {
      return (0, import_jsx_runtime9.jsx)(TableBody, {
        style,
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "header") {
      return (0, import_jsx_runtime9.jsx)(TableHead, {
        style,
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "row") {
      return (0, import_jsx_runtime9.jsx)(TableRow, {
        item: reusableView.content,
        style,
        hasAction: !!props.onRowAction,
        children: renderChildren(children)
      }, reusableView.key);
    }
    if (reusableView.viewType === "headerrow") {
      return (0, import_jsx_runtime9.jsx)(TableHeaderRow, {
        style,
        item: reusableView.content,
        children: renderChildren(children)
      }, reusableView.key);
    }
    return (0, import_jsx_runtime9.jsx)($ccf8a0a04e4175ae$export$6796df8ba7398521, {
      layoutInfo: reusableView.layoutInfo,
      virtualizer: reusableView.virtualizer,
      parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo,
      className: classNames(tableViewClassList.element("cell-wrapper"), css({
        backgroundColor: tokenSchema.color.background.canvas
      })),
      children: reusableView.rendered
    }, reusableView.key);
  };
  let renderView = (type2, item) => {
    var _item$index, _item$colspan;
    switch (type2) {
      case "header":
      case "rowgroup":
      case "section":
      case "row":
      case "headerrow":
        return null;
      case "cell": {
        if (item.props.isSelectionCell) {
          return (0, import_jsx_runtime9.jsx)(TableCheckboxCell, {
            cell: item
          });
        }
        return (0, import_jsx_runtime9.jsx)(TableCell, {
          cell: item,
          overflowMode
        });
      }
      case "placeholder":
        return (0, import_jsx_runtime9.jsx)("div", {
          role: "gridcell",
          "aria-colindex": ((_item$index = item.index) !== null && _item$index !== void 0 ? _item$index : 0) + 1,
          "aria-colspan": ((_item$colspan = item.colspan) !== null && _item$colspan !== void 0 ? _item$colspan : 0) > 1 ? item.colspan : void 0
        });
      case "column":
        if (item.props.isSelectionCell) {
          return (0, import_jsx_runtime9.jsx)(TableSelectAllCell, {
            column: item
          });
        }
        if (item.props.hideHeader) {
          return (0, import_jsx_runtime9.jsxs)(_TooltipTrigger, {
            placement: "top",
            trigger: "focus",
            children: [(0, import_jsx_runtime9.jsx)(TableColumnHeader, {
              column: item
            }), (0, import_jsx_runtime9.jsx)(Tooltip, {
              children: item.rendered
            })]
          });
        }
        return (0, import_jsx_runtime9.jsx)(TableColumnHeader, {
          column: item
        });
      case "loader":
        return (0, import_jsx_runtime9.jsx)(CenteredWrapper, {
          children: (0, import_jsx_runtime9.jsx)(ProgressCircle, {
            isIndeterminate: true,
            "aria-label": state.collection.size > 0 ? stringFormatter.format("loadingMore") : stringFormatter.format("loading")
          })
        });
      case "empty": {
        let emptyState = props.renderEmptyState ? props.renderEmptyState() : null;
        if (emptyState == null) {
          return null;
        }
        return (0, import_jsx_runtime9.jsx)(CenteredWrapper, {
          children: emptyState
        });
      }
    }
  };
  let state = $4a0dd036d492cee4$export$907bcc6c48325fd6({
    ...props,
    showSelectionCheckboxes: props.selectionMode === "multiple"
  });
  const getDefaultWidth = (0, import_react5.useCallback)(({
    props: {
      hideHeader,
      isSelectionCell
    }
  }) => {
    if (hideHeader) {
      return DEFAULT_HIDE_HEADER_CELL_WIDTH;
    } else if (isSelectionCell) {
      return SELECTION_CELL_DEFAULT_WIDTH;
    }
  }, []);
  const getDefaultMinWidth = (0, import_react5.useCallback)(({
    props: {
      hideHeader,
      isSelectionCell
    }
  }) => {
    if (hideHeader) {
      return DEFAULT_HIDE_HEADER_CELL_WIDTH;
    } else if (isSelectionCell) {
      return SELECTION_CELL_DEFAULT_WIDTH;
    }
    return 75;
  }, []);
  let columnLayout = (0, import_react5.useMemo)(() => new $a9e7ae544a4e41dd$export$7ff77a162970b30e({
    getDefaultWidth,
    getDefaultMinWidth
  }), [getDefaultWidth, getDefaultMinWidth]);
  let tableLayout = (0, import_react5.useMemo)(
    () => new $a152112e902709bf$export$62444c3c724b1b20({
      // If props.rowHeight is auto, then use estimated heights, otherwise use fixed heights.
      rowHeight: overflowMode === "wrap" ? void 0 : ROW_HEIGHTS[density],
      estimatedRowHeight: overflowMode === "wrap" ? ROW_HEIGHTS[density] : void 0,
      headingHeight: overflowMode === "wrap" ? void 0 : DEFAULT_HEADER_HEIGHT,
      estimatedHeadingHeight: overflowMode === "wrap" ? DEFAULT_HEADER_HEIGHT : void 0,
      columnLayout,
      initialCollection: state.collection
    }),
    // don't recompute when state.collection changes, only used for initial value
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [overflowMode, density, columnLayout]
  );
  let layout = (0, import_react5.useMemo)(() => {
    let proxy = new Proxy(tableLayout, {
      get(target, prop, receiver) {
        return prop === "tableState" ? state : Reflect.get(target, prop, receiver);
      }
    });
    return proxy;
  }, [state, tableLayout]);
  let {
    gridProps
  } = $6e31608fbba75bab$export$25bceaac3c7e4dc7({
    ...props,
    isVirtualized: true,
    layout
  }, state, domRef);
  const isEmpty = state.collection.size === 0;
  return (0, import_jsx_runtime9.jsx)(TableContext.Provider, {
    value: {
      isEmpty,
      layout,
      state
    },
    children: (0, import_jsx_runtime9.jsx)(TableVirtualizer, {
      layout,
      collection: state.collection,
      renderView,
      renderWrapper,
      bodyRef,
      domRef,
      headerRef,
      ...gridProps,
      ...props
    })
  });
}
function TableVirtualizer(props) {
  var _layout$getLayoutInfo;
  let {
    layout,
    collection,
    // focusedKey,
    renderView,
    renderWrapper,
    domRef,
    bodyRef,
    headerRef,
    disallowEmptySelection: UNUSED_disallowEmptySelection,
    onRowAction: UNUSED_onRowAction,
    onSelectionChange: UNUSED_onSelectionChange,
    onSortChange: UNUSED_onSortChange,
    overflowMode: UNUSED_overflowMode,
    renderEmptyState: UNUSED_renderEmptyState,
    selectedKeys: UNUSED_selectedKeys,
    sortDescriptor: UNUSED_sortDescriptor,
    selectionMode,
    ...otherProps
  } = props;
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let loadingState = collection.body.props.loadingState;
  let isLoading = loadingState === "loading" || loadingState === "loadingMore";
  let onLoadMore = collection.body.props.onLoadMore;
  let virtualizerState = $fc0b13b484ac1194$export$1505db82fe357e65({
    layout,
    collection,
    renderView,
    renderWrapper,
    onVisibleRectChange(rect) {
      let bodyEl = bodyRef.current;
      if (bodyEl) {
        bodyEl.scrollTop = rect.y;
        $ce415dc67314b753$export$ed5fd5ffe5ab0ac(bodyEl, direction, rect.x);
      }
    }
  });
  let styleProps = useTableStyleProps(props);
  let syncScroll = (0, import_react5.useCallback)(() => {
    let bodyEl = bodyRef.current;
    let headerEl = headerRef.current;
    if (bodyEl && headerEl) {
      headerEl.scrollLeft = bodyEl.scrollLeft;
    }
  }, [bodyRef, headerRef]);
  let scrollToItem = (0, import_react5.useCallback)((key) => {
    let item = collection.getItem(key);
    let column = collection.columns[0];
    let virtualizer = virtualizerState.virtualizer;
    virtualizer.scrollToItem(key, {
      duration: 0,
      // Prevent scrolling to the top when clicking on column headers.
      shouldScrollY: (item === null || item === void 0 ? void 0 : item.type) !== "column",
      // Offset scroll position by width of selection cell
      // (which is sticky and will overlap the cell we're scrolling to).
      offsetX: column.props.isSelectionCell || column.props.isDragButtonCell ? layout.getColumnWidth(column.key) : 0
    });
    syncScroll();
  }, [collection, layout, syncScroll, virtualizerState.virtualizer]);
  let memoedVirtualizerProps = (0, import_react5.useMemo)(() => ({
    scrollToItem,
    isLoading,
    onLoadMore
  }), [scrollToItem, isLoading, onLoadMore]);
  let {
    virtualizerProps,
    scrollViewProps
  } = $6d0a5c394373ae64$export$dd6d526d88b5a137(memoedVirtualizerProps, virtualizerState, domRef);
  let mergedProps = $3ef42575df84b30b$export$9d1611c77c2fe928(otherProps, virtualizerProps);
  const [headerView, bodyView] = virtualizerState.visibleViews;
  let headerHeight = ((_layout$getLayoutInfo = layout.getLayoutInfo("header")) === null || _layout$getLayoutInfo === void 0 ? void 0 : _layout$getLayoutInfo.rect.height) || 0;
  let bodyStyleProps = useBodyStyleProps({
    style: {
      flex: 1
    }
  });
  return (0, import_jsx_runtime9.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, {
    children: (0, import_jsx_runtime9.jsxs)("div", {
      ...mergedProps,
      ...styleProps,
      ref: domRef,
      children: [(0, import_jsx_runtime9.jsx)(TableHeaderWrapper, {
        ref: headerRef,
        style: {
          height: headerHeight,
          willChange: virtualizerState.isScrolling ? "scroll-position" : void 0
        },
        children: headerView
      }), (0, import_jsx_runtime9.jsx)($44a6ee657928b002$export$5665e3d6be6adea, {
        ...scrollViewProps,
        ...bodyStyleProps,
        role: "presentation",
        innerStyle: {
          overflow: "visible"
        },
        ref: bodyRef,
        contentSize: virtualizerState.contentSize,
        onScrollStart: virtualizerState.startScrolling,
        onScrollEnd: virtualizerState.endScrolling,
        onScroll: syncScroll,
        children: bodyView
      })]
    })
  });
}
function TableHead({
  children,
  style
}) {
  let {
    rowGroupProps
  } = $0047e6c294ea075f$export$6fb1613bd7b28198();
  let styleProps = useHeadStyleProps({
    style
  });
  return (0, import_jsx_runtime9.jsx)("div", {
    ...rowGroupProps,
    ...styleProps,
    children
  });
}
function TableBody(props) {
  let {
    rowGroupProps
  } = $0047e6c294ea075f$export$6fb1613bd7b28198();
  return (0, import_jsx_runtime9.jsx)("div", {
    ...rowGroupProps,
    ...props
  });
}
var TableHeaderWrapper = (0, import_react5.forwardRef)(function TableHeaderWrapper2(props, ref) {
  let styleProps = useHeaderWrapperStyleProps(props);
  return (0, import_jsx_runtime9.jsx)("div", {
    ref,
    role: "presentation",
    ...styleProps,
    children: props.children
  });
});
function TableHeaderRow(props) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    rowProps
  } = $f917ee10f4c32dab$export$1b95a7d2d517b841({
    node: props.item,
    isVirtualized: true
  }, state, ref);
  let styleProps = useRowHeaderStyleProps(props);
  return (0, import_jsx_runtime9.jsx)("div", {
    ...rowProps,
    ...styleProps,
    ref,
    children: props.children
  });
}
function TableColumnHeader({
  column
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = $f329116d8ad0aba0$export$9514819a8c81e960({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let columnProps = column.props;
  let cellStyleProps = useCellStyleProps(columnProps, {
    isFocusVisible
  });
  return (0, import_jsx_runtime9.jsxs)("div", {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(columnHeaderProps, focusProps),
    ...cellStyleProps,
    ref,
    children: [columnProps.allowsSorting && columnProps.align === "end" && (0, import_jsx_runtime9.jsx)(SortIndicator, {}), columnProps.hideHeader ? (0, import_jsx_runtime9.jsx)($5c3e21d68f1c4674$export$439d29a4e110a164, {
      children: column.rendered
    }) : isReactText(column.rendered) ? (0, import_jsx_runtime9.jsx)(Text, {
      color: "inherit",
      weight: "semibold",
      truncate: true,
      children: column.rendered
    }) : column.rendered, columnProps.allowsSorting && columnProps.align !== "end" && (0, import_jsx_runtime9.jsx)(SortIndicator, {})]
  });
}
function TableRow({
  children,
  hasAction,
  item,
  style
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let allowsInteraction = state.selectionManager.selectionMode !== "none" || hasAction;
  let isDisabled = !allowsInteraction || state.disabledKeys.has(item.key);
  let {
    rowProps
  } = $b2db214c022798eb$export$7f2f6ae19e707aa5({
    node: item,
    isVirtualized: true
  }, state, ref);
  let {
    isFocusVisible: isFocusWithin,
    focusProps: focusWithinProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    within: true
  });
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled
  });
  let {
    pressProps,
    isPressed
  } = $f6c31cce2adf654f$export$45712eceda6fad21({
    isDisabled
  });
  let styleProps = useRowStyleProps({
    style
  }, {
    isFocusVisible,
    isFocusWithin,
    isHovered,
    isPressed
  });
  return (0, import_jsx_runtime9.jsx)("div", {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(rowProps, focusWithinProps, focusProps, hoverProps, pressProps),
    ...styleProps,
    ref,
    children
  });
}
function TableCell({
  cell,
  overflowMode
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    gridCellProps
  } = $7713593715703b24$export$49571c903d73624c({
    node: cell,
    isVirtualized: true
  }, state, ref);
  let {
    isFocusVisible,
    focusProps
  } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  let styleProps = useCellStyleProps(cell.column.props, {
    isFocusVisible
  });
  return (0, import_jsx_runtime9.jsx)("div", {
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(gridCellProps, focusProps),
    ...styleProps,
    ref,
    children: (0, import_jsx_runtime9.jsx)(SlotProvider, {
      slots: {
        text: {
          truncate: overflowMode === "truncate"
        }
      },
      children: isReactText(cell.rendered) ? (0, import_jsx_runtime9.jsx)(Text, {
        children: cell.rendered
      }) : cell.rendered
    })
  });
}
function TableCheckboxCell({
  cell
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    gridCellProps
  } = $7713593715703b24$export$49571c903d73624c({
    node: cell,
    isVirtualized: true
  }, state, ref);
  let {
    checkboxProps
  } = $2a795c53a101c542$export$16ea7f650bd7c1bb({
    key: cell.parentKey
  }, state);
  let styleProps = useSelectionCellStyleProps();
  return (0, import_jsx_runtime9.jsx)("div", {
    ...styleProps,
    ...gridCellProps,
    ref,
    children: (0, import_jsx_runtime9.jsx)(Checkbox, {
      ...checkboxProps
    })
  });
}
function TableSelectAllCell({
  column
}) {
  let ref = (0, import_react5.useRef)(null);
  let {
    state
  } = useTableContext();
  let {
    columnHeaderProps
  } = $f329116d8ad0aba0$export$9514819a8c81e960({
    node: column,
    isVirtualized: true
  }, state, ref);
  let {
    checkboxProps
  } = $2a795c53a101c542$export$1003db6a7e384b99(state);
  let styleProps = useSelectionCellStyleProps();
  return (0, import_jsx_runtime9.jsx)("div", {
    ...styleProps,
    ...columnHeaderProps,
    ref,
    children: state.selectionManager.selectionMode === "single" ? (0, import_jsx_runtime9.jsx)(Text, {
      visuallyHidden: true,
      children: checkboxProps["aria-label"]
    }) : (0, import_jsx_runtime9.jsx)(Checkbox, {
      ...checkboxProps
    })
  });
}
function CenteredWrapper({
  children
}) {
  let {
    state
  } = useTableContext();
  return (0, import_jsx_runtime9.jsx)("div", {
    role: "row",
    "aria-rowindex": state.collection.headerRows.length + state.collection.size + 1,
    style: {
      alignItems: "center",
      display: "flex",
      height: "100%",
      justifyContent: "center",
      width: "100%"
    },
    children: (0, import_jsx_runtime9.jsx)("div", {
      role: "rowheader",
      "aria-colspan": state.collection.columns.length,
      children
    })
  });
}
var VoussoirColumn = $1cd244557c2f97d5$export$816b5d811295e6bc;

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/ui/dist/keystatic-core-ui.esm.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-aria+breadcrumbs@3.5.8_react@18.2.0/node_modules/@react-aria/breadcrumbs/dist/import.mjs
function $parcel$interopDefault3(a) {
  return a && a.__esModule ? a.default : a;
}
function $dafd15390222438a$export$452b38fce62c9384(props, ref) {
  let { isCurrent, isDisabled, "aria-current": ariaCurrent, elementType = "a", ...otherProps } = props;
  let { linkProps } = (0, $298d61e98472621b$export$dcf14c9974fe2767)({
    isDisabled: isDisabled || isCurrent,
    elementType,
    ...otherProps
  }, ref);
  let isHeading = /^h[1-6]$/.test(elementType);
  let itemProps = {};
  if (!isHeading)
    itemProps = linkProps;
  if (isCurrent) {
    itemProps["aria-current"] = ariaCurrent || "page";
    itemProps.tabIndex = props.autoFocus ? -1 : void 0;
  }
  return {
    itemProps: {
      "aria-disabled": isDisabled,
      ...itemProps
    }
  };
}
var $8229b34715874f89$exports = {};
var $b91590b2dc47de39$exports = {};
$b91590b2dc47de39$exports = {
  "breadcrumbs": `عناصر الواجهة`
};
var $55b0693b2cf3fe91$exports = {};
$55b0693b2cf3fe91$exports = {
  "breadcrumbs": `Трохи хляб`
};
var $6ec1ed7729e948cc$exports = {};
$6ec1ed7729e948cc$exports = {
  "breadcrumbs": `Popis cesty`
};
var $5a41bb2baa6861e4$exports = {};
$5a41bb2baa6861e4$exports = {
  "breadcrumbs": `Brødkrummer`
};
var $f28bbea439e87eca$exports = {};
$f28bbea439e87eca$exports = {
  "breadcrumbs": `Breadcrumbs`
};
var $b3eca51cb720961a$exports = {};
$b3eca51cb720961a$exports = {
  "breadcrumbs": `Πλοηγήσεις breadcrumb`
};
var $0b39b205118db415$exports = {};
$0b39b205118db415$exports = {
  "breadcrumbs": `Breadcrumbs`
};
var $f467c0ee7bfb0950$exports = {};
$f467c0ee7bfb0950$exports = {
  "breadcrumbs": `Migas de pan`
};
var $ab711d2ffb4cdf3d$exports = {};
$ab711d2ffb4cdf3d$exports = {
  "breadcrumbs": `Lingiread`
};
var $b63105d663e6f9d5$exports = {};
$b63105d663e6f9d5$exports = {
  "breadcrumbs": `Navigointilinkit`
};
var $9d2ed7be7fcdc2a1$exports = {};
$9d2ed7be7fcdc2a1$exports = {
  "breadcrumbs": `Chemin de navigation`
};
var $c5704294d85c7b5d$exports = {};
$c5704294d85c7b5d$exports = {
  "breadcrumbs": `שבילי ניווט`
};
var $20c975671d6bbc63$exports = {};
$20c975671d6bbc63$exports = {
  "breadcrumbs": `Navigacijski putovi`
};
var $2569ca3917233115$exports = {};
$2569ca3917233115$exports = {
  "breadcrumbs": `Morzsamenü`
};
var $caa152f7f8e96c85$exports = {};
$caa152f7f8e96c85$exports = {
  "breadcrumbs": `Breadcrumb`
};
var $cbc6af0cc98fad10$exports = {};
$cbc6af0cc98fad10$exports = {
  "breadcrumbs": `パンくずリスト`
};
var $ad9be5d332b4d607$exports = {};
$ad9be5d332b4d607$exports = {
  "breadcrumbs": `탐색 표시`
};
var $659de19a00ff9617$exports = {};
$659de19a00ff9617$exports = {
  "breadcrumbs": `Naršymo kelias`
};
var $173e9fb4d14fe309$exports = {};
$173e9fb4d14fe309$exports = {
  "breadcrumbs": `Atpakaļceļi`
};
var $d8e2640a066567a9$exports = {};
$d8e2640a066567a9$exports = {
  "breadcrumbs": `Navigasjonsstier`
};
var $d71fd764236c0d12$exports = {};
$d71fd764236c0d12$exports = {
  "breadcrumbs": `Broodkruimels`
};
var $f4ad3faf9f4aaec6$exports = {};
$f4ad3faf9f4aaec6$exports = {
  "breadcrumbs": `Struktura nawigacyjna`
};
var $9703be9d55d8e9c2$exports = {};
$9703be9d55d8e9c2$exports = {
  "breadcrumbs": `Caminho detalhado`
};
var $7e23baec8a14f309$exports = {};
$7e23baec8a14f309$exports = {
  "breadcrumbs": `Categorias`
};
var $568f95594049d56e$exports = {};
$568f95594049d56e$exports = {
  "breadcrumbs": `Miez de pâine`
};
var $625df06cecc70764$exports = {};
$625df06cecc70764$exports = {
  "breadcrumbs": `Навигация`
};
var $b5a67525f3a2f594$exports = {};
$b5a67525f3a2f594$exports = {
  "breadcrumbs": `Navigačné prvky Breadcrumbs`
};
var $16125922964febca$exports = {};
$16125922964febca$exports = {
  "breadcrumbs": `Drobtine`
};
var $de104bf355206bcf$exports = {};
$de104bf355206bcf$exports = {
  "breadcrumbs": `Putanje navigacije`
};
var $d5ab76bcbadc9c07$exports = {};
$d5ab76bcbadc9c07$exports = {
  "breadcrumbs": `Sökvägar`
};
var $a6a1af5968159b55$exports = {};
$a6a1af5968159b55$exports = {
  "breadcrumbs": `İçerik haritaları`
};
var $5204a30f0d17ffec$exports = {};
$5204a30f0d17ffec$exports = {
  "breadcrumbs": `Навігаційна стежка`
};
var $8d15e736e12d3dfd$exports = {};
$8d15e736e12d3dfd$exports = {
  "breadcrumbs": `导航栏`
};
var $f8c49dd804b75140$exports = {};
$f8c49dd804b75140$exports = {
  "breadcrumbs": `導覽列`
};
$8229b34715874f89$exports = {
  "ar-AE": $b91590b2dc47de39$exports,
  "bg-BG": $55b0693b2cf3fe91$exports,
  "cs-CZ": $6ec1ed7729e948cc$exports,
  "da-DK": $5a41bb2baa6861e4$exports,
  "de-DE": $f28bbea439e87eca$exports,
  "el-GR": $b3eca51cb720961a$exports,
  "en-US": $0b39b205118db415$exports,
  "es-ES": $f467c0ee7bfb0950$exports,
  "et-EE": $ab711d2ffb4cdf3d$exports,
  "fi-FI": $b63105d663e6f9d5$exports,
  "fr-FR": $9d2ed7be7fcdc2a1$exports,
  "he-IL": $c5704294d85c7b5d$exports,
  "hr-HR": $20c975671d6bbc63$exports,
  "hu-HU": $2569ca3917233115$exports,
  "it-IT": $caa152f7f8e96c85$exports,
  "ja-JP": $cbc6af0cc98fad10$exports,
  "ko-KR": $ad9be5d332b4d607$exports,
  "lt-LT": $659de19a00ff9617$exports,
  "lv-LV": $173e9fb4d14fe309$exports,
  "nb-NO": $d8e2640a066567a9$exports,
  "nl-NL": $d71fd764236c0d12$exports,
  "pl-PL": $f4ad3faf9f4aaec6$exports,
  "pt-BR": $9703be9d55d8e9c2$exports,
  "pt-PT": $7e23baec8a14f309$exports,
  "ro-RO": $568f95594049d56e$exports,
  "ru-RU": $625df06cecc70764$exports,
  "sk-SK": $b5a67525f3a2f594$exports,
  "sl-SI": $16125922964febca$exports,
  "sr-SP": $de104bf355206bcf$exports,
  "sv-SE": $d5ab76bcbadc9c07$exports,
  "tr-TR": $a6a1af5968159b55$exports,
  "uk-UA": $5204a30f0d17ffec$exports,
  "zh-CN": $8d15e736e12d3dfd$exports,
  "zh-TW": $f8c49dd804b75140$exports
};
function $848231d7a2b3998e$export$8cefe241bd876ca0(props) {
  let { "aria-label": ariaLabel, ...otherProps } = props;
  let strings = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault3($8229b34715874f89$exports)));
  return {
    navProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(otherProps, {
        labelable: true
      }),
      "aria-label": ariaLabel || strings.format("breadcrumbs")
    }
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/breadcrumbs/dist/keystar-ui-breadcrumbs.esm.js
var import_react6 = __toESM(require_react());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/folderClosedIcon/dist/keystar-ui-icon-icons-folderClosedIcon.esm.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var folderClosedIcon = (0, import_jsx_runtime10.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime10.jsx)("path", {
    d: "M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2ZM2 10h20"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/folderOpenIcon/dist/keystar-ui-icon-icons-folderOpenIcon.esm.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var folderOpenIcon = (0, import_jsx_runtime11.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime11.jsx)("path", {
    d: "m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/breadcrumbs/dist/keystar-ui-breadcrumbs.esm.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var breadcrumbsClassList = new ClassList("Breadcrumbs", ["item", "link", "list", "separator"]);
function BreadcrumbItem(props) {
  let {
    children,
    isCurrent,
    isDisabled,
    size = "regular"
  } = props;
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let ref = (0, import_react6.useRef)(null);
  let {
    itemProps
  } = $dafd15390222438a$export$452b38fce62c9384({
    ...props,
    elementType: "span"
  }, ref);
  let {
    hoverProps,
    isHovered
  } = $6179b936705e76d3$export$ae780daf29e6d456(props);
  let icon = (0, import_react6.useMemo)(() => {
    return direction === "rtl" ? chevronLeftIcon : chevronRightIcon;
  }, [direction]);
  return (0, import_jsx_runtime12.jsxs)(import_react6.Fragment, {
    children: [(0, import_jsx_runtime12.jsx)(FocusRing, {
      children: (0, import_jsx_runtime12.jsx)("span", {
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(itemProps, hoverProps),
        ...toDataAttributes({
          size: size !== "regular" ? size : void 0,
          interaction: isHovered ? "hover" : void 0
        }),
        ref,
        className: classNames(breadcrumbsClassList.element("link"), css({
          color: tokenSchema.color.foreground.neutral,
          cursor: "default",
          fontSize: tokenSchema.typography.text.regular.size,
          fontFamily: tokenSchema.typography.fontFamily.base,
          fontWeight: tokenSchema.typography.fontWeight.medium,
          MozOsxFontSmoothing: "auto",
          WebkitFontSmoothing: "auto",
          "&[data-size=small]": {
            fontSize: tokenSchema.typography.text.small.size
          },
          "&[data-size=medium]": {
            fontSize: tokenSchema.typography.text.medium.size
          },
          "&[data-size=large]": {
            fontSize: tokenSchema.typography.text.large.size
          },
          "&:not([aria-current=page])": {
            "&:not([aria-disabled=true])": {
              cursor: "pointer"
            },
            "&[data-interaction=hover]": {
              color: tokenSchema.color.foreground.neutralEmphasis,
              textDecoration: "underline"
            },
            "&[aria-disabled=true]": {
              color: tokenSchema.color.alias.foregroundDisabled
            }
          },
          "&[aria-current=page]": {
            color: tokenSchema.color.foreground.neutralEmphasis,
            fontWeight: tokenSchema.typography.fontWeight.semibold,
            overflow: "hidden",
            textOverflow: "ellipsis"
          }
        }), {
          "is-hovered": isHovered
        }),
        children
      })
    }), !isCurrent && (0, import_jsx_runtime12.jsx)(Icon, {
      src: icon,
      color: isDisabled ? "color.alias.foregroundDisabled" : "neutralSecondary",
      marginX: "small",
      UNSAFE_className: breadcrumbsClassList.element("separator")
    })]
  });
}
var MIN_VISIBLE_ITEMS = 1;
var MAX_VISIBLE_ITEMS = 4;
function Breadcrumbs(props, ref) {
  props = useProviderProps(props);
  let {
    children,
    showRoot,
    size = "regular",
    isDisabled,
    onAction,
    ...otherProps
  } = props;
  let childArray = [];
  import_react6.Children.forEach(children, (child) => {
    if ((0, import_react6.isValidElement)(child)) {
      childArray.push(child);
    }
  });
  let domRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let listRef = (0, import_react6.useRef)(null);
  let [menuIsOpen, setMenuOpen] = (0, import_react6.useState)(false);
  let [visibleItems, setVisibleItems] = $1dbecbe27a04f9af$export$14d238f342723f25(childArray.length);
  let {
    navProps
  } = $848231d7a2b3998e$export$8cefe241bd876ca0(props);
  let styleProps = useStyleProps(otherProps);
  let updateOverflow = (0, import_react6.useCallback)(() => {
    let computeVisibleItems = (visibleItems2) => {
      let currListRef = listRef.current;
      if (!currListRef) {
        return;
      }
      let listItems = Array.from(currListRef.children);
      let containerWidth = currListRef.offsetWidth;
      let isShowingMenu = childArray.length > visibleItems2;
      let calculatedWidth = 0;
      let newVisibleItems = 0;
      let maxVisibleItems = MAX_VISIBLE_ITEMS;
      if (showRoot) {
        let el = listItems.shift();
        if (el) {
          calculatedWidth += el.offsetWidth;
          newVisibleItems++;
        }
      }
      if (isShowingMenu) {
        let el = listItems.shift();
        if (el) {
          calculatedWidth += el.offsetWidth;
          maxVisibleItems--;
        }
      }
      if (showRoot && calculatedWidth >= containerWidth) {
        newVisibleItems--;
      }
      if (listItems.length > 0) {
        let last = listItems.pop();
        if (last) {
          last.style.overflow = "visible";
          calculatedWidth += last.offsetWidth;
          if (calculatedWidth < containerWidth) {
            newVisibleItems++;
          }
          last.style.overflow = "";
        }
      }
      for (let breadcrumb of listItems.reverse()) {
        calculatedWidth += breadcrumb.offsetWidth;
        if (calculatedWidth < containerWidth) {
          newVisibleItems++;
        }
      }
      return Math.max(MIN_VISIBLE_ITEMS, Math.min(maxVisibleItems, newVisibleItems));
    };
    setVisibleItems(function* () {
      yield childArray.length;
      let newVisibleItems = computeVisibleItems(childArray.length);
      yield newVisibleItems;
      if (isNumber(newVisibleItems) && newVisibleItems < childArray.length && newVisibleItems > 1) {
        yield computeVisibleItems(newVisibleItems);
      }
    });
  }, [childArray.length, setVisibleItems, showRoot]);
  $9daab02d461809db$export$683480f191c0e3ea({
    ref: domRef,
    onResize: updateOverflow
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(updateOverflow, [children]);
  let contents = childArray;
  if (childArray.length > visibleItems) {
    var _selectedItem$key;
    let selectedItem = childArray[childArray.length - 1];
    let selectedKey = (_selectedItem$key = selectedItem.key) !== null && _selectedItem$key !== void 0 ? _selectedItem$key : childArray.length - 1;
    let onMenuAction = (key) => {
      if (key !== selectedKey && onAction) {
        onAction(key);
      }
    };
    let menuItem = (0, import_jsx_runtime12.jsx)(BreadcrumbItem, {
      children: (0, import_jsx_runtime12.jsxs)(MenuTrigger, {
        onOpenChange: setMenuOpen,
        children: [(0, import_jsx_runtime12.jsx)(ActionButton, {
          "aria-label": "…",
          prominence: "low",
          isDisabled,
          children: (0, import_jsx_runtime12.jsx)(Icon, {
            src: menuIsOpen ? folderOpenIcon : folderClosedIcon
          })
        }), (0, import_jsx_runtime12.jsx)(_Menu, {
          selectionMode: "single",
          selectedKeys: [selectedKey],
          onAction: onMenuAction,
          children: childArray
        })]
      })
    }, "menu");
    contents = [menuItem];
    let breadcrumbs = [...childArray];
    let endItems = visibleItems;
    if (showRoot && visibleItems > 1) {
      let el = breadcrumbs.shift();
      if (el) {
        contents.unshift(el);
        endItems--;
      }
    }
    contents.push(...breadcrumbs.slice(-endItems));
  }
  let lastIndex = contents.length - 1;
  let breadcrumbItems = contents.map((child, index) => {
    var _child$key;
    let isCurrent = index === lastIndex;
    let key = (_child$key = child.key) !== null && _child$key !== void 0 ? _child$key : index;
    let onPress = () => {
      if (onAction) {
        onAction(key);
      }
    };
    return (0, import_jsx_runtime12.jsx)("li", {
      className: classNames(breadcrumbsClassList.element("item"), css({
        alignItems: "center",
        display: "inline-flex",
        whiteSpace: "nowrap",
        "&:last-child": {
          overflow: "hidden"
        }
      })),
      children: (0, import_jsx_runtime12.jsx)(BreadcrumbItem, {
        isCurrent,
        isDisabled,
        onPress,
        size,
        children: child.props.children
      }, key)
    }, index);
  });
  return (0, import_jsx_runtime12.jsx)("nav", {
    ...navProps,
    ...styleProps,
    ref: domRef,
    className: classNames(breadcrumbsClassList.element("root"), styleProps.className),
    children: (0, import_jsx_runtime12.jsx)("ul", {
      ref: listRef,
      className: classNames(breadcrumbsClassList.element("list"), css({
        display: "flex",
        height: tokenSchema.size.element.regular,
        justifyContent: "flex-start"
      })),
      children: breadcrumbItems
    })
  });
}
var _Breadcrumbs = (0, import_react6.forwardRef)(Breadcrumbs);

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/notice/dist/keystar-ui-notice.esm.js
var import_react7 = __toESM(require_react());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/checkCircle2Icon/dist/keystar-ui-icon-icons-checkCircle2Icon.esm.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var checkCircle2Icon = (0, import_jsx_runtime13.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime13.jsx)("path", {
    d: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"
  }), (0, import_jsx_runtime13.jsx)("path", {
    d: "m9 12 2 2 4-4"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/infoIcon/dist/keystar-ui-icon-icons-infoIcon.esm.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var infoIcon = (0, import_jsx_runtime14.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime14.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 10
  }), (0, import_jsx_runtime14.jsx)("path", {
    d: "M12 16v-4M12 8h.01"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/notice/dist/keystar-ui-notice.esm.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var noticeClassList = new ClassList("Notice", ["heading"]);
var toneToIcon = {
  caution: alertTriangleIcon,
  critical: alertTriangleIcon,
  neutral: infoIcon,
  positive: checkCircle2Icon
};
var toneToRole = {
  caution: "alert",
  critical: "alert",
  neutral: "status",
  positive: "status"
};
function Notice(props) {
  const {
    children,
    tone = "neutral",
    ...otherProps
  } = props;
  const ref = (0, import_react7.useRef)(null);
  const styleProps = useStyleProps(otherProps);
  const headingClassName = noticeClassList.element("heading");
  const headingId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  const contentId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  const hasHeading = useHasChild(noticeClassList.selector("heading"), ref);
  const coercedTone = tone === "neutral" ? "accent" : tone;
  const icon = toneToIcon[tone];
  const contentStyles = css({
    display: "grid",
    gap: tokenSchema.size.space.large
  });
  const slots = (0, import_react7.useMemo)(() => ({
    content: {
      elementType: "div",
      gridArea: hasHeading ? "content" : "heading-start / heading-start / content-end / content-end",
      id: contentId,
      paddingY: hasHeading ? "regular" : void 0,
      UNSAFE_className: contentStyles
    },
    heading: {
      elementType: "div",
      gridArea: "heading",
      id: headingId,
      UNSAFE_className: headingClassName,
      size: "small"
    },
    text: {
      color: coercedTone,
      weight: "medium"
    }
  }), [coercedTone, contentId, contentStyles, hasHeading, headingClassName, headingId]);
  return (0, import_jsx_runtime15.jsxs)(Grid, {
    "aria-live": "polite",
    "aria-labelledby": headingId,
    "aria-describedby": contentId,
    role: toneToRole[tone],
    ref,
    tabIndex: 0,
    UNSAFE_className: styleProps.className,
    UNSAFE_style: styleProps.style,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    // appearance
    backgroundColor: coercedTone,
    border: coercedTone,
    borderRadius: "medium",
    minWidth: 0,
    padding: "medium",
    width: "100%",
    alignItems: "center",
    areas: ["icon heading", "icon content"],
    columnGap: "medium",
    columns: ["icon.medium", "auto"],
    rows: `${minmax("icon.medium", "auto")} auto`,
    children: [(0, import_jsx_runtime15.jsx)(Icon, {
      src: icon,
      size: "medium",
      color: coercedTone,
      gridArea: "icon",
      alignSelf: "start"
    }), (0, import_jsx_runtime15.jsx)(SlotProvider, {
      slots,
      children: isReactText(children) ? (0, import_jsx_runtime15.jsx)(Content, {
        children: (0, import_jsx_runtime15.jsx)(Text, {
          children
        })
      }) : children
    })]
  });
}

// node_modules/.pnpm/@react-stately+toast@3.0.0-beta.1_react@18.2.0/node_modules/@react-stately/toast/dist/import.mjs
var import_react8 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
function $77b352cf12efcf73$export$84726ef35ca2129a(queue) {
  let subscribe2 = (0, import_react8.useCallback)((fn) => queue.subscribe(fn), [
    queue
  ]);
  let getSnapshot = (0, import_react8.useCallback)(() => queue.visibleToasts, [
    queue
  ]);
  let visibleToasts = (0, import_shim.useSyncExternalStore)(subscribe2, getSnapshot, getSnapshot);
  return {
    visibleToasts,
    add: (content, options) => queue.add(content, options),
    close: (key) => queue.close(key),
    remove: (key) => queue.remove(key),
    pauseAll: () => queue.pauseAll(),
    resumeAll: () => queue.resumeAll()
  };
}
var $77b352cf12efcf73$export$f1f8569633bbbec4 = class {
  /** Subscribes to updates to the visible toasts. */
  subscribe(fn) {
    this.subscriptions.add(fn);
    return () => this.subscriptions.delete(fn);
  }
  /** Adds a new toast to the queue. */
  add(content, options = {}) {
    let toastKey = Math.random().toString(36);
    let toast = {
      ...options,
      content,
      key: toastKey,
      timer: options.timeout ? new $77b352cf12efcf73$var$Timer(() => this.close(toastKey), options.timeout) : null
    };
    let low = 0;
    let high = this.queue.length;
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if ((toast.priority || 0) > (this.queue[mid].priority || 0))
        high = mid;
      else
        low = mid + 1;
    }
    this.queue.splice(low, 0, toast);
    toast.animation = low < this.maxVisibleToasts ? "entering" : "queued";
    let i = this.maxVisibleToasts;
    while (i < this.queue.length)
      this.queue[i++].animation = "queued";
    this.updateVisibleToasts();
    return toastKey;
  }
  /**
  * Closes a toast. If `hasExitAnimation` is true, the toast
  * transitions to an "exiting" state instead of being removed immediately.
  */
  close(key) {
    let index = this.queue.findIndex((t) => t.key === key);
    if (index >= 0) {
      var _this_queue_index, _this_queue_index_onClose;
      (_this_queue_index_onClose = (_this_queue_index = this.queue[index]).onClose) === null || _this_queue_index_onClose === void 0 ? void 0 : _this_queue_index_onClose.call(_this_queue_index);
      this.queue.splice(index, 1);
    }
    this.updateVisibleToasts();
  }
  /** Removes a toast from the visible toasts after an exiting animation. */
  remove(key) {
    this.visibleToasts = this.visibleToasts.filter((t) => t.key !== key);
    this.updateVisibleToasts();
  }
  updateVisibleToasts() {
    let toasts = this.queue.slice(0, this.maxVisibleToasts);
    if (this.hasExitAnimation) {
      let prevToasts = this.visibleToasts.filter((t) => !toasts.some((t2) => t.key === t2.key)).map((t) => ({
        ...t,
        animation: "exiting"
      }));
      this.visibleToasts = prevToasts.concat(toasts).sort((a, b2) => b2.priority - a.priority);
    } else
      this.visibleToasts = toasts;
    for (let fn of this.subscriptions)
      fn();
  }
  /** Pauses the timers for all visible toasts. */
  pauseAll() {
    for (let toast of this.visibleToasts)
      if (toast.timer)
        toast.timer.pause();
  }
  /** Resumes the timers for all visible toasts. */
  resumeAll() {
    for (let toast of this.visibleToasts)
      if (toast.timer)
        toast.timer.resume();
  }
  constructor(options) {
    this.queue = [];
    this.subscriptions = /* @__PURE__ */ new Set();
    this.visibleToasts = [];
    var _options_maxVisibleToasts;
    this.maxVisibleToasts = (_options_maxVisibleToasts = options === null || options === void 0 ? void 0 : options.maxVisibleToasts) !== null && _options_maxVisibleToasts !== void 0 ? _options_maxVisibleToasts : 1;
    var _options_hasExitAnimation;
    this.hasExitAnimation = (_options_hasExitAnimation = options === null || options === void 0 ? void 0 : options.hasExitAnimation) !== null && _options_hasExitAnimation !== void 0 ? _options_hasExitAnimation : false;
  }
};
var $77b352cf12efcf73$var$Timer = class {
  reset(delay) {
    this.remaining = delay;
    this.resume();
  }
  pause() {
    if (this.timerId == null)
      return;
    clearTimeout(this.timerId);
    this.timerId = null;
    this.remaining -= Date.now() - this.startTime;
  }
  resume() {
    if (this.remaining <= 0)
      return;
    this.startTime = Date.now();
    this.timerId = setTimeout(() => {
      this.timerId = null;
      this.remaining = 0;
      this.callback();
    }, this.remaining);
  }
  constructor(callback, delay) {
    this.remaining = delay;
    this.callback = callback;
  }
};

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/toast/dist/keystar-ui-toast.esm.js
var import_react11 = __toESM(require_react());

// node_modules/.pnpm/@react-aria+toast@3.0.0-beta.2_react@18.2.0/node_modules/@react-aria/toast/dist/import.mjs
var import_react10 = __toESM(require_react(), 1);

// node_modules/.pnpm/@react-aria+landmark@3.0.0-beta.2_react@18.2.0/node_modules/@react-aria/landmark/dist/import.mjs
var import_react9 = __toESM(require_react(), 1);
var import_shim2 = __toESM(require_shim(), 1);
var $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION = 1;
var $a86207c5d7f7e1fb$var$landmarkSymbol = Symbol.for("react-aria-landmark-manager");
function $a86207c5d7f7e1fb$var$subscribe(fn) {
  document.addEventListener("react-aria-landmark-manager-change", fn);
  return () => document.removeEventListener("react-aria-landmark-manager-change", fn);
}
function $a86207c5d7f7e1fb$var$getLandmarkManager() {
  if (typeof document === "undefined")
    return null;
  let instance = document[$a86207c5d7f7e1fb$var$landmarkSymbol];
  if (instance && instance.version >= $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION)
    return instance;
  document[$a86207c5d7f7e1fb$var$landmarkSymbol] = new $a86207c5d7f7e1fb$var$LandmarkManager();
  document.dispatchEvent(new CustomEvent("react-aria-landmark-manager-change"));
  return document[$a86207c5d7f7e1fb$var$landmarkSymbol];
}
function $a86207c5d7f7e1fb$var$useLandmarkManager() {
  return (0, import_shim2.useSyncExternalStore)($a86207c5d7f7e1fb$var$subscribe, $a86207c5d7f7e1fb$var$getLandmarkManager, $a86207c5d7f7e1fb$var$getLandmarkManager);
}
var $a86207c5d7f7e1fb$var$LandmarkManager = class {
  setupIfNeeded() {
    if (this.isListening)
      return;
    document.addEventListener("keydown", this.f6Handler, {
      capture: true
    });
    document.addEventListener("focusin", this.focusinHandler, {
      capture: true
    });
    document.addEventListener("focusout", this.focusoutHandler, {
      capture: true
    });
    this.isListening = true;
  }
  teardownIfNeeded() {
    if (!this.isListening || this.landmarks.length > 0 || this.refCount > 0)
      return;
    document.removeEventListener("keydown", this.f6Handler, {
      capture: true
    });
    document.removeEventListener("focusin", this.focusinHandler, {
      capture: true
    });
    document.removeEventListener("focusout", this.focusoutHandler, {
      capture: true
    });
    this.isListening = false;
  }
  focusLandmark(landmark, direction) {
    var _this_landmarks_find, _this_landmarks_find_focus;
    (_this_landmarks_find = this.landmarks.find((l) => l.ref.current === landmark)) === null || _this_landmarks_find === void 0 ? void 0 : (_this_landmarks_find_focus = _this_landmarks_find.focus) === null || _this_landmarks_find_focus === void 0 ? void 0 : _this_landmarks_find_focus.call(_this_landmarks_find, direction);
  }
  /**
  * Return set of landmarks with a specific role.
  */
  getLandmarksByRole(role) {
    return new Set(this.landmarks.filter((l) => l.role === role));
  }
  /**
  * Return first landmark with a specific role.
  */
  getLandmarkByRole(role) {
    return this.landmarks.find((l) => l.role === role);
  }
  addLandmark(newLandmark) {
    this.setupIfNeeded();
    if (this.landmarks.find((landmark) => landmark.ref === newLandmark.ref) || !newLandmark.ref.current)
      return;
    if (this.landmarks.filter((landmark) => landmark.role === "main").length > 1)
      console.error('Page can contain no more than one landmark with the role "main".');
    if (this.landmarks.length === 0) {
      this.landmarks = [
        newLandmark
      ];
      this.checkLabels(newLandmark.role);
      return;
    }
    let start = 0;
    let end = this.landmarks.length - 1;
    while (start <= end) {
      let mid = Math.floor((start + end) / 2);
      let comparedPosition = newLandmark.ref.current.compareDocumentPosition(this.landmarks[mid].ref.current);
      let isNewAfterExisting = Boolean(comparedPosition & Node.DOCUMENT_POSITION_PRECEDING || comparedPosition & Node.DOCUMENT_POSITION_CONTAINS);
      if (isNewAfterExisting)
        start = mid + 1;
      else
        end = mid - 1;
    }
    this.landmarks.splice(start, 0, newLandmark);
    this.checkLabels(newLandmark.role);
  }
  updateLandmark(landmark) {
    let index = this.landmarks.findIndex((l) => l.ref === landmark.ref);
    if (index >= 0) {
      this.landmarks[index] = {
        ...this.landmarks[index],
        ...landmark
      };
      this.checkLabels(this.landmarks[index].role);
    }
  }
  removeLandmark(ref) {
    this.landmarks = this.landmarks.filter((landmark) => landmark.ref !== ref);
    this.teardownIfNeeded();
  }
  /**
  * Warn if there are 2+ landmarks with the same role but no label.
  * Labels for landmarks with the same role must also be unique.
  *
  * See https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/.
  */
  checkLabels(role) {
    let landmarksWithRole = this.getLandmarksByRole(role);
    if (landmarksWithRole.size > 1) {
      let duplicatesWithoutLabel = [
        ...landmarksWithRole
      ].filter((landmark) => !landmark.label);
      if (duplicatesWithoutLabel.length > 0)
        console.warn(`Page contains more than one landmark with the '${role}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `, duplicatesWithoutLabel.map((landmark) => landmark.ref.current));
      else {
        let labels = [
          ...landmarksWithRole
        ].map((landmark) => landmark.label);
        let duplicateLabels = labels.filter((item, index) => labels.indexOf(item) !== index);
        duplicateLabels.forEach((label) => {
          console.warn(`Page contains more than one landmark with the '${role}' role and '${label}' label. If two or more landmarks on a page share the same role, they must have unique labels: `, [
            ...landmarksWithRole
          ].filter((landmark) => landmark.label === label).map((landmark) => landmark.ref.current));
        });
      }
    }
  }
  /**
  * Get the landmark that is the closest parent in the DOM.
  * Returns undefined if no parent is a landmark.
  */
  closestLandmark(element) {
    let landmarkMap = new Map(this.landmarks.map((l) => [
      l.ref.current,
      l
    ]));
    let currentElement = element;
    while (currentElement && !landmarkMap.has(currentElement) && currentElement !== document.body && currentElement.parentElement)
      currentElement = currentElement.parentElement;
    return landmarkMap.get(currentElement);
  }
  /**
  * Gets the next landmark, in DOM focus order, or previous if backwards is specified.
  * If last landmark, next should be the first landmark.
  * If not inside a landmark, will return first landmark.
  * Returns undefined if there are no landmarks.
  */
  getNextLandmark(element, { backward }) {
    var _this_landmarks_nextLandmarkIndex_ref_current;
    let currentLandmark = this.closestLandmark(element);
    let nextLandmarkIndex = backward ? this.landmarks.length - 1 : 0;
    if (currentLandmark)
      nextLandmarkIndex = this.landmarks.indexOf(currentLandmark) + (backward ? -1 : 1);
    let wrapIfNeeded = () => {
      if (nextLandmarkIndex < 0) {
        if (!element.dispatchEvent(new CustomEvent("react-aria-landmark-navigation", {
          detail: {
            direction: "backward"
          },
          bubbles: true,
          cancelable: true
        })))
          return true;
        nextLandmarkIndex = this.landmarks.length - 1;
      } else if (nextLandmarkIndex >= this.landmarks.length) {
        if (!element.dispatchEvent(new CustomEvent("react-aria-landmark-navigation", {
          detail: {
            direction: "forward"
          },
          bubbles: true,
          cancelable: true
        })))
          return true;
        nextLandmarkIndex = 0;
      }
      if (nextLandmarkIndex < 0 || nextLandmarkIndex >= this.landmarks.length)
        return true;
      return false;
    };
    if (wrapIfNeeded())
      return void 0;
    let i = nextLandmarkIndex;
    while ((_this_landmarks_nextLandmarkIndex_ref_current = this.landmarks[nextLandmarkIndex].ref.current) === null || _this_landmarks_nextLandmarkIndex_ref_current === void 0 ? void 0 : _this_landmarks_nextLandmarkIndex_ref_current.closest("[aria-hidden=true]")) {
      nextLandmarkIndex += backward ? -1 : 1;
      if (wrapIfNeeded())
        return void 0;
      if (nextLandmarkIndex === i)
        break;
    }
    return this.landmarks[nextLandmarkIndex];
  }
  /**
  * Look at next landmark. If an element was previously focused inside, restore focus there.
  * If not, focus the landmark itself.
  * If no landmarks at all, or none with focusable elements, don't move focus.
  */
  f6Handler(e2) {
    if (e2.key === "F6") {
      let handled = e2.altKey ? this.focusMain() : this.navigate(e2.target, e2.shiftKey);
      if (handled) {
        e2.preventDefault();
        e2.stopPropagation();
      }
    }
  }
  focusMain() {
    let main = this.getLandmarkByRole("main");
    if (main && main.ref.current && document.contains(main.ref.current)) {
      this.focusLandmark(main.ref.current, "forward");
      return true;
    }
    return false;
  }
  navigate(from, backward) {
    let nextLandmark = this.getNextLandmark(from, {
      backward
    });
    if (!nextLandmark)
      return false;
    if (nextLandmark.lastFocused) {
      let lastFocused = nextLandmark.lastFocused;
      if (document.body.contains(lastFocused)) {
        lastFocused.focus();
        return true;
      }
    }
    if (nextLandmark.ref.current && document.contains(nextLandmark.ref.current)) {
      this.focusLandmark(nextLandmark.ref.current, backward ? "backward" : "forward");
      return true;
    }
    return false;
  }
  /**
  * Sets lastFocused for a landmark, if focus is moved within that landmark.
  * Lets the last focused landmark know it was blurred if something else is focused.
  */
  focusinHandler(e2) {
    let currentLandmark = this.closestLandmark(e2.target);
    if (currentLandmark && currentLandmark.ref.current !== e2.target)
      this.updateLandmark({
        ref: currentLandmark.ref,
        lastFocused: e2.target
      });
    let previousFocusedElement = e2.relatedTarget;
    if (previousFocusedElement) {
      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);
      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement)
        closestPreviousLandmark.blur();
    }
  }
  /**
  * Track if the focus is lost to the body. If it is, do cleanup on the landmark that last had focus.
  */
  focusoutHandler(e2) {
    let previousFocusedElement = e2.target;
    let nextFocusedElement = e2.relatedTarget;
    if (!nextFocusedElement || nextFocusedElement === document) {
      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);
      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement)
        closestPreviousLandmark.blur();
    }
  }
  createLandmarkController() {
    let instance = this;
    instance.refCount++;
    instance.setupIfNeeded();
    return {
      navigate(direction, opts) {
        let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element, direction === "backward");
      },
      focusNext(opts) {
        let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element, false);
      },
      focusPrevious(opts) {
        let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;
        return instance.navigate(element, true);
      },
      focusMain() {
        return instance.focusMain();
      },
      dispose() {
        if (instance) {
          instance.refCount--;
          instance.teardownIfNeeded();
          instance = null;
        }
      }
    };
  }
  registerLandmark(landmark) {
    if (this.landmarks.find((l) => l.ref === landmark.ref))
      this.updateLandmark(landmark);
    else
      this.addLandmark(landmark);
    return () => this.removeLandmark(landmark.ref);
  }
  constructor() {
    this.landmarks = [];
    this.isListening = false;
    this.refCount = 0;
    this.version = $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION;
    this.f6Handler = this.f6Handler.bind(this);
    this.focusinHandler = this.focusinHandler.bind(this);
    this.focusoutHandler = this.focusoutHandler.bind(this);
  }
};
function $a86207c5d7f7e1fb$export$4cc632584fd87fae(props, ref) {
  const { role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, focus } = props;
  let manager = $a86207c5d7f7e1fb$var$useLandmarkManager();
  let label = ariaLabel || ariaLabelledby;
  let [isLandmarkFocused, setIsLandmarkFocused] = (0, import_react9.useState)(false);
  let defaultFocus = (0, import_react9.useCallback)(() => {
    setIsLandmarkFocused(true);
  }, [
    setIsLandmarkFocused
  ]);
  let blur = (0, import_react9.useCallback)(() => {
    setIsLandmarkFocused(false);
  }, [
    setIsLandmarkFocused
  ]);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    if (manager)
      return manager.registerLandmark({
        ref,
        label,
        role,
        focus: focus || defaultFocus,
        blur
      });
  }, [
    manager,
    label,
    ref,
    role,
    focus,
    defaultFocus,
    blur
  ]);
  (0, import_react9.useEffect)(() => {
    var _ref_current;
    if (isLandmarkFocused)
      (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
  }, [
    isLandmarkFocused,
    ref
  ]);
  return {
    landmarkProps: {
      role,
      tabIndex: isLandmarkFocused ? -1 : void 0,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby
    }
  };
}

// node_modules/.pnpm/@react-aria+toast@3.0.0-beta.2_react@18.2.0/node_modules/@react-aria/toast/dist/import.mjs
function $parcel$interopDefault4(a) {
  return a && a.__esModule ? a.default : a;
}
var $7853651519a70071$exports = {};
var $ff9177efc58547ad$exports = {};
$ff9177efc58547ad$exports = {
  "close": `إغلاق`,
  "notifications": `إشعارات`
};
var $25eb7c0c0c45e544$exports = {};
$25eb7c0c0c45e544$exports = {
  "close": `Затвори`,
  "notifications": `Известия`
};
var $28feffc3d61a8691$exports = {};
$28feffc3d61a8691$exports = {
  "close": `Zavřít`,
  "notifications": `Upozornění`
};
var $390d441203d25ff4$exports = {};
$390d441203d25ff4$exports = {
  "close": `Luk`,
  "notifications": `Påmindelser`
};
var $7063c2d0f14f979a$exports = {};
$7063c2d0f14f979a$exports = {
  "close": `Schließen`,
  "notifications": `Benachrichtigungen`
};
var $2dfc1dbb6590af88$exports = {};
$2dfc1dbb6590af88$exports = {
  "close": `Κλείσιμο`,
  "notifications": `Ειδοποιήσεις`
};
var $9a12ff1caae5a7a5$exports = {};
$9a12ff1caae5a7a5$exports = {
  "close": `Close`,
  "notifications": `Notifications`
};
var $f4095fb5a72adbe6$exports = {};
$f4095fb5a72adbe6$exports = {
  "close": `Cerrar`,
  "notifications": `Notificaciones`
};
var $75bc5191b9d7826a$exports = {};
$75bc5191b9d7826a$exports = {
  "close": `Sule`,
  "notifications": `Teated`
};
var $e4b9aef18b0db8dc$exports = {};
$e4b9aef18b0db8dc$exports = {
  "close": `Sulje`,
  "notifications": `Ilmoitukset`
};
var $888756784d832bd7$exports = {};
$888756784d832bd7$exports = {
  "close": `Fermer`,
  "notifications": `Notifications`
};
var $6835949b68a1fabf$exports = {};
$6835949b68a1fabf$exports = {
  "close": `סגור`,
  "notifications": `התראות`
};
var $87ffcbc0b651e40b$exports = {};
$87ffcbc0b651e40b$exports = {
  "close": `Zatvori`,
  "notifications": `Obavijesti`
};
var $dc6e3b2813600d69$exports = {};
$dc6e3b2813600d69$exports = {
  "close": `Bezárás`,
  "notifications": `Értesítések`
};
var $fe136bcbacfcfa14$exports = {};
$fe136bcbacfcfa14$exports = {
  "close": `Chiudi`,
  "notifications": `Notifiche`
};
var $8fb53a929b46df83$exports = {};
$8fb53a929b46df83$exports = {
  "close": `閉じる`,
  "notifications": `通知`
};
var $2c38dbfaf041a865$exports = {};
$2c38dbfaf041a865$exports = {
  "close": `닫기`,
  "notifications": `알림`
};
var $48f3f33a29908d4c$exports = {};
$48f3f33a29908d4c$exports = {
  "close": `Uždaryti`,
  "notifications": `Pranešimai`
};
var $9867160d996455a0$exports = {};
$9867160d996455a0$exports = {
  "close": `Aizvērt`,
  "notifications": `Paziņojumi`
};
var $196258ea25c96487$exports = {};
$196258ea25c96487$exports = {
  "close": `Lukk`,
  "notifications": `Varsler`
};
var $949061cb954e8000$exports = {};
$949061cb954e8000$exports = {
  "close": `Sluiten`,
  "notifications": `Meldingen`
};
var $8189bed27add1ad3$exports = {};
$8189bed27add1ad3$exports = {
  "close": `Zamknij`,
  "notifications": `Powiadomienia`
};
var $a361756a93b6e28c$exports = {};
$a361756a93b6e28c$exports = {
  "close": `Fechar`,
  "notifications": `Notificações`
};
var $034c7393857c8db0$exports = {};
$034c7393857c8db0$exports = {
  "close": `Fechar`,
  "notifications": `Notificações`
};
var $e33d3b3868478b04$exports = {};
$e33d3b3868478b04$exports = {
  "close": `Închideţi`,
  "notifications": `Notificări`
};
var $9a7dcb914b29cd9f$exports = {};
$9a7dcb914b29cd9f$exports = {
  "close": `Закрыть`,
  "notifications": `Уведомления`
};
var $e43d964a0c7f1266$exports = {};
$e43d964a0c7f1266$exports = {
  "close": `Zatvoriť`,
  "notifications": `Oznámenia`
};
var $0bc56cee3275bcaa$exports = {};
$0bc56cee3275bcaa$exports = {
  "close": `Zapri`,
  "notifications": `Obvestila`
};
var $7dbdd7289c10d2ba$exports = {};
$7dbdd7289c10d2ba$exports = {
  "close": `Zatvori`,
  "notifications": `Obaveštenja`
};
var $ccbe6066c10b1e53$exports = {};
$ccbe6066c10b1e53$exports = {
  "close": `Stäng`,
  "notifications": `Aviseringar`
};
var $9d503476b9d858b7$exports = {};
$9d503476b9d858b7$exports = {
  "close": `Kapat`,
  "notifications": `Bildirimler`
};
var $32ee419c7b9b7a83$exports = {};
$32ee419c7b9b7a83$exports = {
  "close": `Закрити`,
  "notifications": `Сповіщення`
};
var $122525af1cb737c7$exports = {};
$122525af1cb737c7$exports = {
  "close": `关闭`,
  "notifications": `通知`
};
var $52e8b1b00094e5a3$exports = {};
$52e8b1b00094e5a3$exports = {
  "close": `關閉`,
  "notifications": `通知`
};
$7853651519a70071$exports = {
  "ar-AE": $ff9177efc58547ad$exports,
  "bg-BG": $25eb7c0c0c45e544$exports,
  "cs-CZ": $28feffc3d61a8691$exports,
  "da-DK": $390d441203d25ff4$exports,
  "de-DE": $7063c2d0f14f979a$exports,
  "el-GR": $2dfc1dbb6590af88$exports,
  "en-US": $9a12ff1caae5a7a5$exports,
  "es-ES": $f4095fb5a72adbe6$exports,
  "et-EE": $75bc5191b9d7826a$exports,
  "fi-FI": $e4b9aef18b0db8dc$exports,
  "fr-FR": $888756784d832bd7$exports,
  "he-IL": $6835949b68a1fabf$exports,
  "hr-HR": $87ffcbc0b651e40b$exports,
  "hu-HU": $dc6e3b2813600d69$exports,
  "it-IT": $fe136bcbacfcfa14$exports,
  "ja-JP": $8fb53a929b46df83$exports,
  "ko-KR": $2c38dbfaf041a865$exports,
  "lt-LT": $48f3f33a29908d4c$exports,
  "lv-LV": $9867160d996455a0$exports,
  "nb-NO": $196258ea25c96487$exports,
  "nl-NL": $949061cb954e8000$exports,
  "pl-PL": $8189bed27add1ad3$exports,
  "pt-BR": $a361756a93b6e28c$exports,
  "pt-PT": $034c7393857c8db0$exports,
  "ro-RO": $e33d3b3868478b04$exports,
  "ru-RU": $9a7dcb914b29cd9f$exports,
  "sk-SK": $e43d964a0c7f1266$exports,
  "sl-SI": $0bc56cee3275bcaa$exports,
  "sr-SP": $7dbdd7289c10d2ba$exports,
  "sv-SE": $ccbe6066c10b1e53$exports,
  "tr-TR": $9d503476b9d858b7$exports,
  "uk-UA": $32ee419c7b9b7a83$exports,
  "zh-CN": $122525af1cb737c7$exports,
  "zh-TW": $52e8b1b00094e5a3$exports
};
function $d6542812f0669241$export$a407b657d3044108(props, state, ref) {
  let { key, timer, timeout, animation } = props.toast;
  (0, import_react10.useEffect)(() => {
    if (!timer)
      return;
    timer.reset(timeout);
    return () => {
      timer.pause();
    };
  }, [
    timer,
    timeout
  ]);
  let focusOnUnmount = (0, import_react10.useRef)(null);
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {
    let container = ref.current.closest("[role=region]");
    return () => {
      if (container && container.contains(document.activeElement))
        focusOnUnmount.current = container;
    };
  }, [
    ref
  ]);
  (0, import_react10.useEffect)(() => {
    return () => {
      if (focusOnUnmount.current)
        focusOnUnmount.current.focus();
    };
  }, [
    ref
  ]);
  let titleId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let descriptionId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault4($7853651519a70071$exports)));
  return {
    toastProps: {
      role: "alert",
      "aria-label": props["aria-label"],
      "aria-labelledby": props["aria-labelledby"] || titleId,
      "aria-describedby": props["aria-describedby"] || descriptionId,
      "aria-details": props["aria-details"],
      // Hide toasts that are animating out so VoiceOver doesn't announce them.
      "aria-hidden": animation === "exiting" ? "true" : void 0
    },
    titleProps: {
      id: titleId
    },
    descriptionProps: {
      id: descriptionId
    },
    closeButtonProps: {
      "aria-label": stringFormatter.format("close"),
      onPress: () => state.close(key)
    }
  };
}
function $6cc546b19ee7130a$export$b8cbbb20a51697de(props, state, ref) {
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault4($7853651519a70071$exports)));
  let { landmarkProps } = (0, $a86207c5d7f7e1fb$export$4cc632584fd87fae)({
    role: "region",
    "aria-label": props["aria-label"] || stringFormatter.format("notifications")
  }, ref);
  let { hoverProps } = (0, $6179b936705e76d3$export$ae780daf29e6d456)({
    onHoverStart: state.pauseAll,
    onHoverEnd: state.resumeAll
  });
  let lastFocused = (0, import_react10.useRef)(null);
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onFocusWithin: (e2) => {
      state.pauseAll();
      lastFocused.current = e2.relatedTarget;
    },
    onBlurWithin: () => {
      state.resumeAll();
      lastFocused.current = null;
    }
  });
  (0, import_react10.useEffect)(() => {
    return () => {
      if (lastFocused.current && document.body.contains(lastFocused.current)) {
        if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "pointer")
          (0, $7215afc6de606d6b$export$de79e2c695e052f3)(lastFocused.current);
        else
          lastFocused.current.focus();
      }
    };
  }, [
    ref
  ]);
  return {
    regionProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(landmarkProps, hoverProps, focusWithinProps, {
      tabIndex: -1,
      // Mark the toast region as a "top layer", so that it:
      //   - is not aria-hidden when opening an overlay
      //   - allows focus even outside a containing focus scope
      //   - doesn’t dismiss overlays when clicking on it, even though it is outside
      // @ts-ignore
      "data-react-aria-top-layer": true
    })
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/toast/dist/keystar-ui-toast.esm.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var import_react_dom = __toESM(require_react_dom());
var intlMessages = {
  "ar-AE": {
    info: "معلومات",
    critical: "خطأ",
    positive: "تم بنجاح"
  },
  "bg-BG": {
    info: "Инфо",
    critical: "Грешка",
    positive: "Успех"
  },
  "cs-CZ": {
    info: "Informace",
    critical: "Chyba",
    positive: "Úspěch"
  },
  "da-DK": {
    info: "Info",
    critical: "Fejl",
    positive: "Fuldført"
  },
  "de-DE": {
    info: "Informationen",
    critical: "Fehler",
    positive: "Erfolg"
  },
  "el-GR": {
    info: "Πληροφορίες",
    critical: "Σφάλμα",
    positive: "Επιτυχία"
  },
  "en-US": {
    info: "Info",
    critical: "Error",
    positive: "Success"
  },
  "es-ES": {
    info: "Información",
    critical: "Error",
    positive: "Éxito"
  },
  "et-EE": {
    info: "Teave",
    critical: "Viga",
    positive: "Valmis"
  },
  "fi-FI": {
    info: "Tiedot",
    critical: "Virhe",
    positive: "Onnistui"
  },
  "fr-FR": {
    info: "Infos",
    critical: "Erreur",
    positive: "Succès"
  },
  "he-IL": {
    info: "מידע",
    critical: "שגיאה",
    positive: "הצלחה"
  },
  "hr-HR": {
    info: "Informacije",
    critical: "Pogreška",
    positive: "Uspješno"
  },
  "hu-HU": {
    info: "Információ",
    critical: "Hiba",
    positive: "Siker"
  },
  "it-IT": {
    info: "Informazioni",
    critical: "Errore",
    positive: "Operazione riuscita"
  },
  "ja-JP": {
    info: "情報",
    critical: "エラー",
    positive: "成功"
  },
  "ko-KR": {
    info: "정보",
    critical: "오류",
    positive: "성공"
  },
  "lt-LT": {
    info: "Informacija",
    critical: "Klaida",
    positive: "Sėkmingai"
  },
  "lv-LV": {
    info: "Informācija",
    critical: "Kļūda",
    positive: "Izdevās"
  },
  "nb-NO": {
    info: "Info",
    critical: "Feil",
    positive: "Vellykket"
  },
  "nl-NL": {
    info: "Info",
    critical: "Fout",
    positive: "Geslaagd"
  },
  "pl-PL": {
    info: "Informacje",
    critical: "Błąd",
    positive: "Powodzenie"
  },
  "pt-BR": {
    info: "Informações",
    critical: "Erro",
    positive: "Sucesso"
  },
  "pt-PT": {
    info: "Informação",
    critical: "Erro",
    positive: "Sucesso"
  },
  "ro-RO": {
    info: "Informaţii",
    critical: "Eroare",
    positive: "Succes"
  },
  "ru-RU": {
    info: "Информация",
    critical: "Ошибка",
    positive: "Успешно"
  },
  "sk-SK": {
    info: "Informácie",
    critical: "Chyba",
    positive: "Úspech"
  },
  "sl-SI": {
    info: "Informacije",
    critical: "Napaka",
    positive: "Uspešno"
  },
  "sr-SP": {
    info: "Informacije",
    critical: "Greška",
    positive: "Uspešno"
  },
  "sv-SE": {
    info: "Info",
    critical: "Fel",
    positive: "Lyckades"
  },
  "tr-TR": {
    info: "Bilgiler",
    critical: "Hata",
    positive: "Başarılı"
  },
  "uk-UA": {
    info: "Інформація",
    critical: "Помилка",
    positive: "Успішно"
  },
  "zh-CN": {
    info: "信息",
    critical: "错误",
    positive: "成功"
  },
  "zh-TW": {
    info: "資訊",
    critical: "錯誤",
    positive: "成功"
  }
};
var ICONS = {
  info: infoIcon,
  critical: alertTriangleIcon,
  // neutral: infoIcon,
  positive: checkCircle2Icon
};
function Toast(props, ref) {
  let {
    toast: {
      key,
      animation,
      content: {
        children,
        tone,
        actionLabel,
        onAction,
        shouldCloseOnAction
      }
    },
    state,
    ...otherProps
  } = props;
  let domRef = $df56164dff5785e2$export$4338b53315abf666(ref);
  let {
    closeButtonProps,
    titleProps,
    toastProps
  } = $d6542812f0669241$export$a407b657d3044108(props, state, domRef);
  let styleProps = useStyleProps(otherProps);
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(intlMessages);
  let iconLabel = tone && tone !== "neutral" ? stringFormatter.format(tone) : null;
  let icon = tone && tone !== "neutral" ? ICONS[tone] : null;
  const handleAction = () => {
    if (onAction) {
      onAction();
    }
    if (shouldCloseOnAction) {
      state.close(key);
    }
  };
  let slots = (0, import_react11.useMemo)(() => ({
    text: {
      color: "inherit"
    }
  }), []);
  return (0, import_jsx_runtime16.jsx)("div", {
    ...styleProps,
    ...toastProps,
    ref: domRef,
    "data-tone": tone,
    className: classNames(css({
      borderRadius: tokenSchema.size.radius.regular,
      display: "flex",
      margin: tokenSchema.size.space.large,
      maxWidth: tokenSchema.size.container.xsmall,
      minHeight: tokenSchema.size.element.large,
      padding: tokenSchema.size.space.regular,
      paddingInlineStart: tokenSchema.size.space.large,
      pointerEvents: "auto",
      position: "absolute",
      // tones
      color: tokenSchema.color.foreground.onEmphasis,
      "&[data-tone=neutral]": {
        background: tokenSchema.color.scale["slate9"]
      },
      "&[data-tone=info]": {
        background: tokenSchema.color.background.accentEmphasis
      },
      "&[data-tone=positive]": {
        background: tokenSchema.color.background.positiveEmphasis
      },
      "&[data-tone=critical]": {
        background: tokenSchema.color.background.criticalEmphasis
      },
      // animations
      "&[data-animation=entering]": {
        animation: `${slideInAnim} 300ms`
      },
      "&[data-animation=exiting]": {
        animation: `${fadeOutAnim} 300ms forwards`
      }
    }), styleProps.className),
    style: {
      ...styleProps.style,
      zIndex: props.toast.priority
    },
    "data-animation": animation,
    onAnimationEnd: () => {
      if (animation === "exiting") {
        state.remove(key);
      }
    },
    children: (0, import_jsx_runtime16.jsxs)(SlotProvider, {
      slots,
      children: [icon && (0, import_jsx_runtime16.jsx)(Icon, {
        "aria-label": iconLabel,
        src: icon,
        size: "medium",
        marginTop: "small",
        marginEnd: "regular"
      }), (0, import_jsx_runtime16.jsxs)("div", {
        className: classNames(css({
          alignItems: "center",
          display: "flex",
          columnGap: tokenSchema.size.space.large,
          flex: 1,
          flexWrap: "wrap",
          justifyContent: "flex-end",
          paddingInlineEnd: tokenSchema.size.space.large
        })),
        children: [(0, import_jsx_runtime16.jsx)("div", {
          className: classNames(css({
            flexGrow: 1,
            paddingBlock: tokenSchema.size.space.regular
          })),
          ...titleProps,
          children: isReactText(children) ? (0, import_jsx_runtime16.jsx)(Text, {
            children
          }) : children
        }), actionLabel && (0, import_jsx_runtime16.jsx)(Button, {
          onPress: handleAction,
          static: "light",
          children: actionLabel
        })]
      }), (0, import_jsx_runtime16.jsx)("div", {
        className: css({
          borderInlineStart: `${tokenSchema.size.border.regular} solid #fff3`,
          paddingInlineStart: tokenSchema.size.space.regular
        }),
        children: (0, import_jsx_runtime16.jsx)(ClearButton, {
          static: "light",
          ...closeButtonProps
        })
      })]
    })
  });
}
var slideInAnim = keyframes({
  from: {
    transform: `var(--slide-from)`
  },
  to: {
    transform: `var(--slide-to)`
  }
});
var fadeOutAnim = keyframes({
  from: {
    opacity: 1
  },
  to: {
    opacity: 0
  }
});
var _Toast = (0, import_react11.forwardRef)(Toast);
function ToastContainer(props) {
  let {
    children,
    state
  } = props;
  let {
    direction
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  let isMobileDevice = useIsMobileDevice();
  let placement = isMobileDevice ? "center" : props.placement || "end";
  let position = isMobileDevice ? "bottom" : props.position || "bottom";
  let ref = (0, import_react11.useRef)(null);
  let {
    regionProps
  } = $6cc546b19ee7130a$export$b8cbbb20a51697de(props, state, ref);
  let contents = (0, import_jsx_runtime16.jsx)(KeystarProvider, {
    UNSAFE_style: {
      background: "transparent"
    },
    children: (0, import_jsx_runtime16.jsx)(FocusRing, {
      children: (0, import_jsx_runtime16.jsx)("div", {
        ...regionProps,
        ref,
        "data-direction": direction,
        "data-position": position,
        "data-placement": placement,
        className: css({
          display: "flex",
          insetInline: 0,
          outline: "none",
          pointerEvents: "none",
          position: "fixed",
          zIndex: 100,
          "&[data-focus=visible] > :first-child:after": {
            borderRadius: `calc(${tokenSchema.size.radius.regular} + ${tokenSchema.size.alias.focusRingGap})`,
            boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
            content: '""',
            inset: 0,
            margin: `calc(-1 * ${tokenSchema.size.alias.focusRingGap})`,
            pointerEvents: "none",
            position: "absolute"
          },
          "&[data-position=top]": {
            top: 0,
            flexDirection: "column",
            "--slide-from": "translateY(-100%)",
            "--slide-to": "translateY(0)"
          },
          "&[data-position=bottom]": {
            bottom: 0,
            flexDirection: "column-reverse",
            "--slide-from": "translateY(100%)",
            "--slide-to": "translateY(0)"
          },
          "&[data-placement=start]": {
            alignItems: "flex-start",
            "--slide-from": "translateX(-100%)",
            "--slide-to": "translateX(0)",
            "&[data-direction=rtl]": {
              "--slide-from": "translateX(100%)"
            }
          },
          "&[data-placement=center]": {
            alignItems: "center"
          },
          "&[data-placement=end]": {
            alignItems: "flex-end",
            "--slide-from": "translateX(100%)",
            "--slide-to": "translateX(0)",
            "&[data-direction=rtl]": {
              "--slide-from": "translateX(-100%)"
            }
          }
        }),
        children
      })
    })
  });
  return import_react_dom.default.createPortal(contents, document.body);
}
var globalToastQueue = null;
function getGlobalToastQueue() {
  if (!globalToastQueue) {
    globalToastQueue = new $77b352cf12efcf73$export$f1f8569633bbbec4({
      maxVisibleToasts: 1,
      hasExitAnimation: true
    });
  }
  return globalToastQueue;
}
var toastProviders = /* @__PURE__ */ new Set();
var subscriptions = /* @__PURE__ */ new Set();
function subscribe(fn) {
  subscriptions.add(fn);
  return () => subscriptions.delete(fn);
}
function getActiveToaster() {
  return toastProviders.values().next().value;
}
function useActiveToaster() {
  return (0, import_react11.useSyncExternalStore)(subscribe, getActiveToaster, getActiveToaster);
}
function Toaster(props) {
  let ref = (0, import_react11.useRef)();
  toastProviders.add(ref);
  (0, import_react11.useEffect)(() => {
    return () => {
      for (let toast of getGlobalToastQueue().visibleToasts) {
        toast.animation = void 0;
      }
      toastProviders.delete(ref);
      for (let fn of subscriptions) {
        fn();
      }
    };
  }, []);
  let activeToaster = useActiveToaster();
  let state = $77b352cf12efcf73$export$84726ef35ca2129a(getGlobalToastQueue());
  if (ref === activeToaster && state.visibleToasts.length > 0) {
    return (0, import_jsx_runtime16.jsx)(ToastContainer, {
      state,
      ...props,
      children: state.visibleToasts.map((toast) => (0, import_jsx_runtime16.jsx)(_Toast, {
        toast,
        state
      }, toast.key))
    });
  }
  return null;
}
function addToast(children, tone, options = {}) {
  if (typeof CustomEvent !== "undefined" && typeof window !== "undefined") {
    let event = new CustomEvent("keystar-ui-toast", {
      cancelable: true,
      bubbles: true,
      detail: {
        children,
        tone,
        options
      }
    });
    let shouldContinue = window.dispatchEvent(event);
    if (!shouldContinue) {
      return () => {
      };
    }
  }
  let value = {
    children,
    tone,
    actionLabel: options.actionLabel,
    onAction: options.onAction,
    shouldCloseOnAction: options.shouldCloseOnAction
  };
  warning(!(options.timeout && options.onAction), "Timeouts are not supported on actionable toasts.");
  warning(!!(options.timeout && options.timeout >= 5e3), "Timeouts must be at least 5000ms, for accessibility.");
  let timeout = options.timeout && !options.onAction ? Math.max(options.timeout, 5e3) : void 0;
  let queue = getGlobalToastQueue();
  let key = queue.add(value, {
    priority: getPriority(tone, options),
    timeout,
    onClose: options.onClose
  });
  return () => queue.close(key);
}
var toastQueue = {
  /** Queues a neutral toast. */
  neutral(children, options = {}) {
    return addToast(children, "neutral", options);
  },
  /** Queues a positive toast. */
  positive(children, options = {}) {
    return addToast(children, "positive", options);
  },
  /** Queues a critical toast. */
  critical(children, options = {}) {
    return addToast(children, "critical", options);
  },
  /** Queues an informational toast. */
  info(children, options = {}) {
    return addToast(children, "info", options);
  }
};
var PRIORITY = {
  // actionable toasts gain 4 priority points. make sure critical toasts are
  // always at the top.
  critical: 10,
  positive: 3,
  info: 2,
  neutral: 1
};
function getPriority(tone, options) {
  let priority = PRIORITY[tone] || 1;
  if (options.onAction) {
    priority += 4;
  }
  return priority;
}

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/ui/dist/keystatic-core-ui.esm.js
var import_slugify = __toESM(require_slugify());
var import_sanitize_url = __toESM(require_dist());

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/copyPlusIcon/dist/keystar-ui-icon-icons-copyPlusIcon.esm.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var copyPlusIcon = (0, import_jsx_runtime17.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime17.jsx)("path", {
    d: "M15 12v6M12 15h6"
  }), (0, import_jsx_runtime17.jsx)("rect", {
    width: 14,
    height: 14,
    x: 8,
    y: 8,
    rx: 2,
    ry: 2
  }), (0, import_jsx_runtime17.jsx)("path", {
    d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/historyIcon/dist/keystar-ui-icon-icons-historyIcon.esm.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var historyIcon = (0, import_jsx_runtime18.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime18.jsx)("path", {
    d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
  }), (0, import_jsx_runtime18.jsx)("path", {
    d: "M3 3v5h5M12 7v5l4 2"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/gitBranchIcon/dist/keystar-ui-icon-icons-gitBranchIcon.esm.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var gitBranchIcon = (0, import_jsx_runtime19.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime19.jsx)("path", {
    d: "M6 3v12"
  }), (0, import_jsx_runtime19.jsx)("circle", {
    cx: 18,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime19.jsx)("circle", {
    cx: 6,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime19.jsx)("path", {
    d: "M18 9a9 9 0 0 1-9 9"
  })]
});

// node_modules/.pnpm/@react-aria+radio@3.9.0_react@18.2.0/node_modules/@react-aria/radio/dist/import.mjs
var $884aeceb3d67f00f$export$37b65e5b5444d35c = /* @__PURE__ */ new WeakMap();
function $0d5c49892c1215da$export$37b0961d2f4751e2(props, state, ref) {
  let { value, children, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby } = props;
  const isDisabled = props.isDisabled || state.isDisabled;
  let hasChildren = children != null;
  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;
  if (!hasChildren && !hasAriaLabel)
    console.warn("If you do not provide children, you must specify an aria-label for accessibility");
  let checked = state.selectedValue === value;
  let onChange = (e2) => {
    e2.stopPropagation();
    state.setSelectedValue(value);
  };
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    isDisabled
  });
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)((0, $3ef42575df84b30b$export$9d1611c77c2fe928)(props, {
    onFocus: () => state.setLastFocusedValue(value)
  }), ref);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(pressProps, focusableProps);
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let tabIndex = -1;
  if (state.selectedValue != null) {
    if (state.selectedValue === value)
      tabIndex = 0;
  } else if (state.lastFocusedValue === value || state.lastFocusedValue == null)
    tabIndex = 0;
  if (isDisabled)
    tabIndex = void 0;
  let { name, descriptionId, errorMessageId, validationBehavior } = (0, $884aeceb3d67f00f$export$37b65e5b5444d35c).get(state);
  (0, $99facab73266f662$export$5add1d006293d136)(ref, state.selectedValue, state.setSelectedValue);
  (0, $e93e671b31057976$export$b8473d3665f3a75a)({
    validationBehavior
  }, state, ref);
  return {
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      ...interactions,
      type: "radio",
      name,
      tabIndex,
      disabled: isDisabled,
      required: state.isRequired && validationBehavior === "native",
      checked,
      value,
      onChange,
      "aria-describedby": [
        props["aria-describedby"],
        state.isInvalid ? errorMessageId : null,
        descriptionId
      ].filter(Boolean).join(" ") || void 0
    }),
    isDisabled,
    isSelected: checked,
    isPressed
  };
}
function $430f30ed08ec25fa$export$62b9571f283ff5c2(props, state) {
  let { name, isReadOnly, isRequired, isDisabled, orientation = "vertical", validationBehavior = "aria" } = props;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let { isInvalid, validationErrors, validationDetails } = state.displayValidation;
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)({
    ...props,
    // Radio group is not an HTML input element so it
    // shouldn't be labeled by a <label> element.
    labelElementType: "span",
    isInvalid: state.isInvalid,
    errorMessage: props.errorMessage || validationErrors
  });
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    onBlurWithin() {
      if (!state.selectedValue)
        state.setLastFocusedValue(null);
    }
  });
  let onKeyDown = (e2) => {
    let nextDir;
    switch (e2.key) {
      case "ArrowRight":
        if (direction === "rtl" && orientation !== "vertical")
          nextDir = "prev";
        else
          nextDir = "next";
        break;
      case "ArrowLeft":
        if (direction === "rtl" && orientation !== "vertical")
          nextDir = "next";
        else
          nextDir = "prev";
        break;
      case "ArrowDown":
        nextDir = "next";
        break;
      case "ArrowUp":
        nextDir = "prev";
        break;
      default:
        return;
    }
    e2.preventDefault();
    let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(e2.currentTarget, {
      from: e2.target
    });
    let nextElem;
    if (nextDir === "next") {
      nextElem = walker.nextNode();
      if (!nextElem) {
        walker.currentNode = e2.currentTarget;
        nextElem = walker.firstChild();
      }
    } else {
      nextElem = walker.previousNode();
      if (!nextElem) {
        walker.currentNode = e2.currentTarget;
        nextElem = walker.lastChild();
      }
    }
    if (nextElem) {
      nextElem.focus();
      state.setSelectedValue(nextElem.value);
    }
  };
  let groupName = (0, $bdb11010cef70236$export$f680877a34711e37)(name);
  (0, $884aeceb3d67f00f$export$37b65e5b5444d35c).set(state, {
    name: groupName,
    descriptionId: descriptionProps.id,
    errorMessageId: errorMessageProps.id,
    validationBehavior
  });
  return {
    radioGroupProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, {
      // https://www.w3.org/TR/wai-aria-1.2/#radiogroup
      role: "radiogroup",
      onKeyDown,
      "aria-invalid": state.isInvalid || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-readonly": isReadOnly || void 0,
      "aria-required": isRequired || void 0,
      "aria-disabled": isDisabled || void 0,
      "aria-orientation": orientation,
      ...fieldProps,
      ...focusWithinProps
    }),
    labelProps,
    descriptionProps,
    errorMessageProps,
    isInvalid,
    validationErrors,
    validationDetails
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/radio/dist/keystar-ui-radio.esm.js
var import_react13 = __toESM(require_react());
var import_jsx_runtime20 = __toESM(require_jsx_runtime());

// node_modules/.pnpm/@react-stately+radio@3.10.0_react@18.2.0/node_modules/@react-stately/radio/dist/import.mjs
var import_react12 = __toESM(require_react(), 1);
var $a54cdc5c1942b639$var$instance = Math.round(Math.random() * 1e10);
var $a54cdc5c1942b639$var$i = 0;
function $a54cdc5c1942b639$export$bca9d026f8e704eb(props) {
  let name = (0, import_react12.useMemo)(() => props.name || `radio-group-${$a54cdc5c1942b639$var$instance}-${++$a54cdc5c1942b639$var$i}`, [
    props.name
  ]);
  var _props_defaultValue;
  let [selectedValue, setSelected] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);
  let [lastFocusedValue, setLastFocusedValue] = (0, import_react12.useState)(null);
  let validation = (0, $e5be200c675c3b3a$export$fc1a364ae1f3ff10)({
    ...props,
    value: selectedValue
  });
  let setSelectedValue = (value) => {
    if (!props.isReadOnly && !props.isDisabled) {
      setSelected(value);
      validation.commitValidation();
    }
  };
  let isInvalid = validation.displayValidation.isInvalid;
  return {
    ...validation,
    name,
    selectedValue,
    setSelectedValue,
    lastFocusedValue,
    setLastFocusedValue,
    isDisabled: props.isDisabled || false,
    isReadOnly: props.isReadOnly || false,
    isRequired: props.isRequired || false,
    validationState: props.validationState || (isInvalid ? "invalid" : null),
    isInvalid
  };
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/radio/dist/keystar-ui-radio.esm.js
var RadioContext = import_react13.default.createContext(null);
function useRadioProvider() {
  const context = import_react13.default.useContext(RadioContext);
  if (!context) {
    throw new Error("useRadioProvider must be used within a RadioGroupProvider");
  }
  return context;
}
var radioClassList = new ClassList("Radio", ["indicator"]);
function Radio(props) {
  let {
    children,
    autoFocus,
    ...otherProps
  } = props;
  let styleProps = useStyleProps(otherProps);
  let inputRef = (0, import_react13.useRef)(null);
  let radioGroupProps = useRadioProvider();
  let {
    state
  } = radioGroupProps;
  let {
    inputProps
  } = $0d5c49892c1215da$export$37b0961d2f4751e2({
    ...props,
    ...radioGroupProps
  }, state, inputRef);
  const inputClassName = css({
    position: "absolute",
    zIndex: 1,
    inset: 0,
    opacity: 1e-4
  });
  const labelClassName = css({
    alignItems: "flex-start",
    display: "inline-flex",
    gap: tokenSchema.size.space.regular,
    position: "relative",
    userSelect: "none"
  });
  const slots = (0, import_react13.useMemo)(() => ({
    text: {
      color: "inherit"
    },
    description: {
      color: "neutralTertiary"
    }
  }), []);
  return (0, import_jsx_runtime20.jsxs)("label", {
    className: classNames(styleProps.className, labelClassName),
    style: styleProps.style,
    children: [(0, import_jsx_runtime20.jsx)(FocusRing, {
      autoFocus,
      children: (0, import_jsx_runtime20.jsx)("input", {
        ...inputProps,
        ref: inputRef,
        className: classNames(inputClassName)
      })
    }), (0, import_jsx_runtime20.jsx)(Indicator, {
      inputClassName
    }), (0, import_jsx_runtime20.jsx)(SlotProvider, {
      slots,
      children: children && (0, import_jsx_runtime20.jsx)(Content2, {
        children: isReactText(children) ? (0, import_jsx_runtime20.jsx)(Text, {
          children
        }) : children
      })
    })]
  });
}
var sizeToken = tokenSchema.size.element.xsmall;
var Indicator = (props) => {
  let {
    inputClassName
  } = props;
  return (0, import_jsx_runtime20.jsx)("span", {
    className: classNames(css({
      backgroundColor: tokenSchema.color.background.canvas,
      borderRadius: tokenSchema.size.radius.full,
      color: tokenSchema.color.foreground.onEmphasis,
      display: "flex",
      flexShrink: 0,
      justifyContent: "center",
      alignItems: "center",
      position: "relative",
      height: sizeToken,
      width: sizeToken,
      // indicator icons
      [radioClassList.selector("indicator")]: {
        opacity: 0,
        transform: `scale(0) translate3d(0, 0, 0)`,
        transition: transition(["opacity", "transform"]),
        willChange: "opacity, transform"
      },
      // focus ring
      "::after": {
        borderRadius: tokenSchema.size.radius.full,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["box-shadow", "margin"], {
          easing: "easeOut"
        })
      },
      [`.${inputClassName}[data-focus=visible] + &::after`]: {
        boxShadow: `0 0 0 ${tokenSchema.size.alias.focusRing} ${tokenSchema.color.alias.focusRing}`,
        margin: `calc(${tokenSchema.size.alias.focusRingGap} * -1)`
      },
      // border / background
      "&::before": {
        border: `${tokenSchema.size.border.medium} solid ${tokenSchema.color.alias.borderIdle}`,
        borderRadius: `inherit`,
        content: '""',
        inset: 0,
        margin: 0,
        position: "absolute",
        transition: transition(["border-color", "border-width"], {
          duration: "regular"
        })
      },
      [`.${inputClassName}:disabled + &`]: {
        color: tokenSchema.color.alias.foregroundDisabled,
        "&::before": {
          borderColor: tokenSchema.color.alias.borderDisabled
        }
      },
      [`.${inputClassName}:enabled:hover + &::before`]: {
        borderColor: tokenSchema.color.alias.borderHovered
      },
      [`.${inputClassName}:enabled:active + &::before`]: {
        borderColor: tokenSchema.color.alias.borderPressed
      },
      // checked states
      [`.${inputClassName}:checked + &`]: {
        "&::before": {
          borderWidth: `calc(${sizeToken} / 2)`
        },
        [radioClassList.selector("indicator")]: {
          opacity: 1,
          transform: `scale(1)`
        }
      },
      [`.${inputClassName}:enabled:checked + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo9
      },
      [`.${inputClassName}:enabled:checked:hover + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo10
      },
      [`.${inputClassName}:enabled:checked:active + &::before`]: {
        borderColor: tokenSchema.color.scale.indigo11
      }
    })),
    children: (0, import_jsx_runtime20.jsx)("span", {
      className: radioClassList.element("indicator"),
      children: (0, import_jsx_runtime20.jsx)("svg", {
        className: resetClassName,
        fill: "currentColor",
        height: 12,
        viewBox: "0 0 24 24",
        width: 12,
        children: (0, import_jsx_runtime20.jsx)("circle", {
          cx: "12",
          cy: "12",
          r: "6"
        })
      })
    })
  });
};
var Content2 = (props) => {
  return (0, import_jsx_runtime20.jsx)("div", {
    className: classNames(css({
      color: tokenSchema.color.alias.foregroundIdle,
      display: "grid",
      paddingTop: `calc((${sizeToken} - ${tokenSchema.typography.text.regular.capheight}) / 2)`,
      gap: tokenSchema.size.space.large,
      'input[type="radio"]:hover ~ &': {
        color: tokenSchema.color.alias.foregroundHovered
      },
      'input[type="radio"]:disabled ~ &': {
        color: tokenSchema.color.alias.foregroundDisabled
      }
    })),
    ...props
  });
};
var RadioGroup = (0, import_react13.forwardRef)(function RadioGroup2(props, forwardedRef) {
  props = useProviderProps(props);
  props = validateFieldProps(props);
  let {
    validationState,
    children,
    orientation = "vertical"
  } = props;
  let state = $a54cdc5c1942b639$export$bca9d026f8e704eb(props);
  let {
    radioGroupProps,
    labelProps,
    descriptionProps,
    errorMessageProps
  } = $430f30ed08ec25fa$export$62b9571f283ff5c2(props, state);
  return (0, import_jsx_runtime20.jsx)(FieldPrimitive, {
    ...props,
    ref: forwardedRef,
    labelProps,
    descriptionProps,
    errorMessageProps,
    children: (0, import_jsx_runtime20.jsx)("div", {
      ...radioGroupProps,
      ...toDataAttributes({
        orientation
      }),
      className: classNames(css({
        display: "flex",
        gap: tokenSchema.size.space.large,
        '&[data-orientation="vertical"]': {
          flexDirection: "column"
        }
      })),
      children: (0, import_jsx_runtime20.jsx)(RadioContext.Provider, {
        value: {
          validationState,
          state
        },
        children
      })
    })
  });
});

// node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map3) {
  var result = {};
  if (map3 !== null) {
    Object.keys(map3).forEach(function(style) {
      map3[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map2 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map2
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object2) {
  return object2 === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object2) {
  return Object.prototype.toString.call(object2) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object2) {
      return object2 ? "true" : "false";
    },
    uppercase: function(object2) {
      return object2 ? "TRUE" : "FALSE";
    },
    camelcase: function(object2) {
      return object2 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common.isNegativeZero(object2));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object2, style) {
  var res;
  if (isNaN(object2)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object2)) {
    return "-0.0";
  }
  res = object2.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common.isNegativeZero(object2));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object2) {
  return object2.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge2 = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map3.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map3 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map3.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object2) {
  var result = "", bits = 0, idx, tail, max = object2.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map3[bits >> 18 & 63];
      result += map3[bits >> 12 & 63];
      result += map3[bits >> 6 & 63];
      result += map3[bits & 63];
    }
    bits = (bits << 8) + object2[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map3[bits >> 18 & 63];
    result += map3[bits >> 12 & 63];
    result += map3[bits >> 6 & 63];
    result += map3[bits & 63];
  } else if (tail === 2) {
    result += map3[bits >> 10 & 63];
    result += map3[bits >> 4 & 63];
    result += map3[bits << 2 & 63];
    result += map3[64];
  } else if (tail === 1) {
    result += map3[bits >> 2 & 63];
    result += map3[bits << 4 & 63];
    result += map3[64];
    result += map3[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object2 = data;
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length = object2.length; index < length; index += 1) {
    pair = object2[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object2 = data;
  for (key in object2) {
    if (_hasOwnProperty$2.call(object2, key)) {
      if (object2[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge2
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? " " : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map3) {
  var result, keys, index, length, tag, style, type2;
  if (map3 === null)
    return {};
  result = {};
  keys = Object.keys(map3);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map3[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object2) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object2.length; index < length; index += 1) {
    value = object2[index];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object2, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object2.length; index < length; index += 1) {
    value = object2[index];
    if (state.replacer) {
      value = state.replacer.call(object2, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object2) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object2, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object2), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object2, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object2 === "object" && object2 instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object2))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object2);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object2, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object2, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object2, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object2;
  if (!detectType(state, object2, false)) {
    detectType(state, object2, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object2);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object2, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object2, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object2, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object2 !== null && typeof object2 === "object") {
    index = objects.indexOf(object2);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object2);
      if (Array.isArray(object2)) {
        for (index = 0, length = object2.length; index < length; index += 1) {
          inspectNode(object2[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object2);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object2[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/required-files-77a6642f.esm.js
var textDecoder = new TextDecoder();
var textEncoder = new TextEncoder();
function splitFrontmatter(data) {
  const str2 = textDecoder.decode(data);
  const match = str2.match(/^---(?:\r?\n([^]*?))?\r?\n---\r?\n?/);
  if (match) {
    var _match$;
    const encoded = textEncoder.encode(match[0]);
    return {
      frontmatter: (_match$ = match[1]) !== null && _match$ !== void 0 ? _match$ : "",
      content: data.slice(encoded.byteLength)
    };
  }
  return null;
}
function loadDataFile(data, formatInfo) {
  const parse = formatInfo.data === "json" ? JSON.parse : load;
  if (!formatInfo.contentField) {
    const dataFile = textDecoder.decode(data);
    return {
      loaded: parse(dataFile)
    };
  }
  const res = splitFrontmatter(data);
  assert(res !== null, "frontmatter not found");
  return {
    loaded: parse(res.frontmatter),
    extraFakeFile: {
      path: `${formatInfo.contentField.key}${formatInfo.contentField.config.contentExtension}`,
      contents: res.content
    }
  };
}

// node_modules/.pnpm/@urql+exchange-graphcache@6.4.0_graphql@16.8.1/node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs
var h = "\nhttps://bit.ly/2XbVrpR#";
var m = /* @__PURE__ */ new Set();
var g = [];
var popDebugNode = () => g.pop();
var pushDebugNode = (e2, r2) => {
  var t = "";
  if (r2.kind === e.INLINE_FRAGMENT) {
    t = e2 ? `Inline Fragment on "${e2}"` : "Inline Fragment";
  } else if (r2.kind === e.OPERATION_DEFINITION) {
    t = `${r2.name ? `"${r2.name.value}"` : "Unnamed"} ${r2.operation}`;
  } else if (r2.kind === e.FRAGMENT_DEFINITION) {
    t = `"${r2.name.value}" Fragment`;
  }
  if (t) {
    g.push(t);
  }
};
var getDebugOutput = () => g.length ? "\n(Caused At: " + g.join(", ") + ")" : "";
function invariant(e2, r2, t) {
  if (!e2) {
    var i = r2 || "Minfied Error #" + t + "\n";
    if (true) {
      i += getDebugOutput();
    }
    var a = new Error(i + h + t);
    a.name = "Graphcache Error";
    throw a;
  }
}
function warn(e2, r2, t) {
  if (!m.has(e2)) {
    if (t) {
      t("warn", e2 + getDebugOutput() + h + r2);
    } else {
      console.warn(e2 + getDebugOutput() + h + r2);
    }
    m.add(e2);
  }
}
var N = {};
var getDirectives = (e2) => e2._directives || N;
var getName = (e2) => e2.name.value;
var getFragmentTypeName = (e2) => e2.typeCondition.name.value;
var getFieldAlias = (e2) => e2.alias ? e2.alias.value : e2.name.value;
var _ = [];
var getSelectionSet = (e2) => e2.selectionSet ? e2.selectionSet.selections : _;
var getTypeCondition = (e2) => e2.typeCondition ? e2.typeCondition.name.value : null;
var getFieldArguments = (e2, r2) => {
  var t = null;
  if (e2.arguments) {
    for (var i = 0, a = e2.arguments.length; i < a; i++) {
      var n = e2.arguments[i];
      var s = valueFromASTUntyped(n.value, r2);
      if (null != s) {
        if (!t) {
          t = {};
        }
        t[getName(n)] = s;
      }
    }
  }
  return t;
};
var filterVariables = (e2, r2) => {
  if (!r2 || !e2.variableDefinitions) {
    return;
  }
  var t = {};
  for (var i = 0, a = e2.variableDefinitions.length; i < a; i++) {
    var n = getName(e2.variableDefinitions[i].variable);
    t[n] = r2[n];
  }
  return t;
};
var normalizeVariables = (e2, r2) => {
  var t = {};
  if (!r2) {
    return t;
  }
  if (e2.variableDefinitions) {
    for (var i = 0, a = e2.variableDefinitions.length; i < a; i++) {
      var n = e2.variableDefinitions[i];
      var s = getName(n.variable);
      t[s] = void 0 === r2[s] && n.defaultValue ? valueFromASTUntyped(n.defaultValue, r2) : r2[s];
    }
  }
  for (var l in r2) {
    if (!(l in t)) {
      t[l] = r2[l];
    }
  }
  return t;
};
function getMainOperation(e2) {
  for (var r2 = 0; r2 < e2.definitions.length; r2++) {
    if (e2.definitions[r2].kind === e.OPERATION_DEFINITION) {
      return e2.definitions[r2];
    }
  }
  invariant(false, true ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
}
var getFragments = (e2) => {
  var r2 = {};
  for (var t = 0; t < e2.definitions.length; t++) {
    var i = e2.definitions[t];
    if (i.kind === e.FRAGMENT_DEFINITION) {
      r2[getName(i)] = i;
    }
  }
  return r2;
};
var shouldInclude = (e2, r2) => {
  var t = getDirectives(e2);
  if (t.include || t.skip) {
    for (var i in t) {
      var a = t[i];
      if (a && ("include" === i || "skip" === i) && a.arguments && a.arguments[0] && "if" === getName(a.arguments[0])) {
        var n = valueFromASTUntyped(a.arguments[0].value, r2);
        return "include" === i ? !!n : !n;
      }
    }
  }
  return true;
};
var isDeferred = (e2, r2) => {
  var { defer: t } = getDirectives(e2);
  if (t) {
    for (var i of t.arguments || []) {
      if ("if" === getName(i)) {
        return !!valueFromASTUntyped(i.value, r2);
      }
    }
    return true;
  }
  return false;
};
var k = "__";
var isFieldNullable = (e2, r2, t, i) => {
  var a = getField(e2, r2, t, i);
  return !!a && "NON_NULL" !== a.type.kind;
};
var isListNullable = (e2, r2, t, i) => {
  var a = getField(e2, r2, t, i);
  if (!a) {
    return false;
  }
  var n = "NON_NULL" === a.type.kind ? a.type.ofType : a.type;
  return "LIST" === n.kind && "NON_NULL" !== n.ofType.kind;
};
var isFieldAvailableOnType = (e2, r2, t, i) => 0 === t.indexOf(k) || 0 === r2.indexOf(k) || !!getField(e2, r2, t, i);
var isInterfaceOfType = (e2, r2, t) => {
  if (!t) {
    return false;
  }
  var i = getTypeCondition(r2);
  if (!i || t === i) {
    return true;
  } else if (e2.types.has(i) && "OBJECT" === e2.types.get(i).kind) {
    return i === t;
  }
  !function expectAbstractType(e3, r3) {
    invariant(e3.types.has(r3) && ("INTERFACE" === e3.types.get(r3).kind || "UNION" === e3.types.get(r3).kind), true ? "Invalid Abstract type: The type `" + r3 + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5);
  }(e2, i);
  expectObjectType(e2, t);
  return e2.isSubType(i, t);
};
var getField = (e2, r2, t, i) => {
  if (0 === t.indexOf(k) || 0 === r2.indexOf(k)) {
    return;
  }
  expectObjectType(e2, r2);
  var a = e2.types.get(r2).fields()[t];
  if (true) {
    if (!a) {
      warn("Invalid field: The field `" + t + "` does not exist on `" + r2 + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4, i);
    }
  }
  return a;
};
function expectObjectType(e2, r2) {
  invariant(e2.types.has(r2) && "OBJECT" === e2.types.get(r2).kind, true ? "Invalid Object type: The type `" + r2 + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}
function warnAboutResolver(e2, r2) {
  warn(`Invalid resolver: \`${e2}\` is not in the defined schema, but the \`resolvers\` option is referencing it.`, 23, r2);
}
function warnAboutAbstractResolver(e2, r2, t) {
  warn(`Invalid resolver: \`${e2}\` does not match to a concrete type in the schema, but the \`resolvers\` option is referencing it. Implement the resolver for the types that ${"UNION" === r2 ? "make up the union" : "implement the interface"} instead.`, 26, t);
}
var keyOfField = (r2, t) => t ? `${r2}(${stringifyVariables(t)})` : r2;
var joinKeys = (e2, r2) => `${e2}.${r2}`;
var fieldInfoOfKey = (e2) => {
  var r2 = e2.indexOf("(");
  if (r2 > -1) {
    return {
      fieldKey: e2,
      fieldName: e2.slice(0, r2),
      arguments: JSON.parse(e2.slice(r2 + 1, -1))
    };
  } else {
    return {
      fieldKey: e2,
      fieldName: e2,
      arguments: null
    };
  }
};
var deserializeKeyInfo = (e2) => {
  var r2 = e2.indexOf(".");
  return {
    entityKey: e2.slice(0, r2).replace(/%2e/g, "."),
    fieldKey: e2.slice(r2 + 1)
  };
};
var E = null;
var O = null;
var w = null;
var b = null;
var D = null;
var x = null;
var V = false;
var I = false;
function makeData(e2, r2) {
  var t;
  if (e2) {
    if (E.has(e2)) {
      return e2;
    }
    t = O.get(e2);
  }
  if (null == t) {
    t = r2 ? [] : {};
  }
  if (e2) {
    O.set(e2, t);
  }
  E.add(t);
  return t;
}
var ownsData = (e2) => !!e2 && E.has(e2);
var initDataState = (e2, r2, t, i, a) => {
  E = /* @__PURE__ */ new WeakSet();
  O = /* @__PURE__ */ new WeakMap();
  D = e2;
  w = r2;
  x = /* @__PURE__ */ new Set();
  I = !!i;
  V = !!a;
  if (true) {
    g.length = 0;
  }
  if (!t) {
    b = null;
  } else if ("read" === D) {
    b = t;
  } else if (i || r2.hydrating || r2.optimisticOrder.length > 1) {
    if (!i && !r2.commutativeKeys.has(t)) {
      reserveLayer(r2, t);
    } else if (i) {
      if (-1 !== r2.optimisticOrder.indexOf(t) && !r2.commutativeKeys.has(t)) {
        r2.optimisticOrder.splice(r2.optimisticOrder.indexOf(t), 1);
      }
      r2.commutativeKeys.delete(t);
    }
    b = t;
    createLayer(r2, t);
  } else {
    b = null;
    deleteLayer(r2, t);
  }
};
var clearDataState = () => {
  if (true) {
    getCurrentDependencies();
  }
  var e2 = w;
  var r2 = b;
  I = false;
  b = null;
  if (!e2.hydrating && r2 && e2.optimisticOrder.indexOf(r2) > -1) {
    var t = e2.optimisticOrder.length;
    while (--t >= 0 && e2.dirtyKeys.has(e2.optimisticOrder[t]) && e2.commutativeKeys.has(e2.optimisticOrder[t])) {
      squashLayer(e2.optimisticOrder[t]);
    }
  }
  E = null;
  O = null;
  D = null;
  w = null;
  x = null;
  if (true) {
    g.length = 0;
  }
  if (true) {
    if (!e2.defer && (e2.storage || !e2.optimisticOrder.length)) {
      e2.defer = true;
      setTimeout(() => {
        initDataState("read", e2, null);
        gc();
        persistData();
        clearDataState();
        e2.defer = false;
      });
    }
  }
};
var noopDataState = (e2, r2, t) => {
  if (r2 && !t) {
    e2.deferredKeys.delete(r2);
  }
  initDataState("write", e2, r2, t);
  clearDataState();
};
var getCurrentDependencies = () => {
  invariant(null !== x, true ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return x;
};
var setNode = (e2, r2, t, i) => {
  if (true) {
    invariant("read" !== D, true ? "Invalid Cache write: You may not write to the cache during cache reads.  Accesses to `cache.writeFragment`, `cache.updateQuery`, and `cache.link` may  not be made inside `resolvers` for instance." : "", 27);
  }
  var a = b ? e2.optimistic.get(b) : e2.base;
  var n = a.get(r2);
  if (void 0 === n) {
    a.set(r2, n = /* @__PURE__ */ Object.create(null));
  }
  if (void 0 === i && !b) {
    delete n[t];
  } else {
    n[t] = i;
  }
};
var getNode = (e2, r2, t) => {
  var i;
  var a = !I && "read" === D && b && w.commutativeKeys.has(b);
  for (var n = 0, o = w.optimisticOrder.length; n < o; n++) {
    var s = w.optimisticOrder[n];
    var l = e2.optimistic.get(s);
    a = a && s !== b;
    if (l && (!a || !w.commutativeKeys.has(s)) && (!I || "write" === D || w.commutativeKeys.has(s)) && void 0 !== (i = l.get(r2)) && t in i) {
      return i[t];
    }
  }
  return void 0 !== (i = e2.base.get(r2)) ? i[t] : void 0;
};
var updateRCForLink = (e2, r2) => {
  if (Array.isArray(e2)) {
    for (var t = 0, i = e2.length; t < i; t++) {
      updateRCForLink(e2[t], r2);
    }
  } else if ("string" == typeof e2) {
    ((e3, r3) => {
      var t2 = w.refCount.get(e3) || 0;
      var i2 = t2 + r3 > 0 ? t2 + r3 : 0;
      w.refCount.set(e3, i2);
      if (!i2) {
        w.gc.add(e3);
      } else if (!t2 && i2) {
        w.gc.delete(e3);
      }
    })(e2, r2);
  }
};
var extractNodeFields = (e2, r2, t) => {
  if (void 0 !== t) {
    for (var i in t) {
      if (!r2.has(i)) {
        e2.push(fieldInfoOfKey(i));
        r2.add(i);
      }
    }
  }
};
var extractNodeMapFields = (e2, r2, t, i) => {
  extractNodeFields(e2, r2, i.base.get(t));
  for (var a = 0, n = w.optimisticOrder.length; a < n; a++) {
    var o = i.optimistic.get(w.optimisticOrder[a]);
    if (void 0 !== o) {
      extractNodeFields(e2, r2, o.get(t));
    }
  }
};
var gc = () => {
  if (w.optimisticOrder.length) {
    return;
  }
  for (var e2 of w.gc.keys()) {
    w.gc.delete(e2);
    if ((w.refCount.get(e2) || 0) > 0) {
      continue;
    }
    w.refCount.delete(e2);
    w.records.base.delete(e2);
    var r2 = w.links.base.get(e2);
    if (r2) {
      w.links.base.delete(e2);
      for (var t in r2) {
        updateRCForLink(r2[t], -1);
      }
    }
  }
};
var updateDependencies = (e2, r2) => {
  if (e2 !== w.queryRootKey) {
    x.add(e2);
  } else if (void 0 !== r2 && "__typename" !== r2) {
    x.add(joinKeys(e2, r2));
  }
};
var updatePersist = (e2, r2) => {
  if (!I && w.storage) {
    w.persist.add(((e3, r3) => `${e3.replace(/\./g, "%2e")}.${r3}`)(e2, r2));
  }
};
var readRecord = (e2, r2) => {
  updateDependencies(e2, r2);
  return getNode(w.records, e2, r2);
};
var readLink = (e2, r2) => {
  updateDependencies(e2, r2);
  return getNode(w.links, e2, r2);
};
var writeRecord = (e2, r2, t) => {
  updateDependencies(e2, r2);
  updatePersist(e2, r2);
  setNode(w.records, e2, r2, t);
};
var hasField = (e2, r2) => void 0 !== readRecord(e2, r2) || void 0 !== readLink(e2, r2);
var writeLink = (e2, r2, t) => {
  var i = b ? w.links.optimistic.get(b) : w.links.base;
  if (!b) {
    var a = i && i.get(e2);
    updateRCForLink(a && a[r2], -1);
    updateRCForLink(t, 1);
  }
  updateDependencies(e2, r2);
  updatePersist(e2, r2);
  setNode(w.links, e2, r2, t);
};
var reserveLayer = (e2, r2, t) => {
  var i = e2.optimisticOrder.indexOf(r2);
  if (i > -1) {
    e2.optimisticOrder.splice(i, 1);
  }
  if (t) {
    e2.deferredKeys.add(r2);
    for (i = i > -1 ? i : 0; i < e2.optimisticOrder.length && !e2.deferredKeys.has(e2.optimisticOrder[i]) && (!e2.dirtyKeys.has(e2.optimisticOrder[i]) || !e2.commutativeKeys.has(e2.optimisticOrder[i])); i++) {
    }
  } else {
    e2.deferredKeys.delete(r2);
    if (i > -1 && !e2.commutativeKeys.has(r2)) {
      clearLayer(e2, r2);
    }
    i = 0;
  }
  e2.optimisticOrder.splice(i, 0, r2);
  e2.commutativeKeys.add(r2);
};
var createLayer = (e2, r2) => {
  if (-1 === e2.optimisticOrder.indexOf(r2)) {
    e2.optimisticOrder.unshift(r2);
  }
  if (!e2.dirtyKeys.has(r2)) {
    e2.dirtyKeys.add(r2);
    e2.links.optimistic.set(r2, /* @__PURE__ */ new Map());
    e2.records.optimistic.set(r2, /* @__PURE__ */ new Map());
  }
};
var clearLayer = (e2, r2) => {
  if (e2.dirtyKeys.has(r2)) {
    e2.dirtyKeys.delete(r2);
    e2.records.optimistic.delete(r2);
    e2.links.optimistic.delete(r2);
    e2.deferredKeys.delete(r2);
  }
};
var deleteLayer = (e2, r2) => {
  var t = e2.optimisticOrder.indexOf(r2);
  if (t > -1) {
    e2.optimisticOrder.splice(t, 1);
    e2.commutativeKeys.delete(r2);
  }
  clearLayer(e2, r2);
};
var squashLayer = (e2) => {
  var r2 = x;
  x = /* @__PURE__ */ new Set();
  D = "write";
  var t = w.links.optimistic.get(e2);
  if (t) {
    for (var i of t.entries()) {
      var a = i[0];
      var n = i[1];
      for (var o in n) {
        writeLink(a, o, n[o]);
      }
    }
  }
  var s = w.records.optimistic.get(e2);
  if (s) {
    for (var l of s.entries()) {
      var v = l[0];
      var d2 = l[1];
      for (var u in d2) {
        writeRecord(v, u, d2[u]);
      }
    }
  }
  x = r2;
  deleteLayer(w, e2);
};
var inspectFields = (e2) => {
  var { links: r2, records: t } = w;
  var i = [];
  var a = /* @__PURE__ */ new Set();
  updateDependencies(e2);
  extractNodeMapFields(i, a, e2, r2);
  extractNodeMapFields(i, a, e2, t);
  return i;
};
var persistData = () => {
  if (w.storage) {
    I = true;
    D = "read";
    var r2 = {};
    for (var t of w.persist.keys()) {
      var { entityKey: i, fieldKey: a } = deserializeKeyInfo(t);
      var n = void 0;
      if (void 0 !== (n = readLink(i, a))) {
        r2[t] = `:${stringifyVariables(n)}`;
      } else if (void 0 !== (n = readRecord(i, a))) {
        r2[t] = stringifyVariables(n);
      } else {
        r2[t] = void 0;
      }
    }
    I = false;
    w.storage.writeData(r2);
    w.persist.clear();
  }
};
var q = null;
var T = false;
var getFieldError = (e2) => e2.__internal.path.length > 0 && e2.__internal.errorMap ? e2.__internal.errorMap[e2.__internal.path.join(".")] : void 0;
var makeContext = (e2, r2, t, i, a, n) => {
  var o = {
    store: e2,
    variables: r2,
    fragments: t,
    parent: {
      __typename: i
    },
    parentTypeName: i,
    parentKey: a,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: false,
    hasNext: false,
    optimistic: I,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (n && n.graphQLErrors) {
    for (var s = 0; s < n.graphQLErrors.length; s++) {
      var l = n.graphQLErrors[s];
      if (l.path && l.path.length) {
        if (!o.__internal.errorMap) {
          o.__internal.errorMap = /* @__PURE__ */ Object.create(null);
        }
        o.__internal.errorMap[l.path.join(".")] = l;
      }
    }
  }
  return o;
};
var updateContext = (e2, r2, t, i, a, n) => {
  q = e2;
  e2.parent = r2;
  e2.parentTypeName = t;
  e2.parentKey = i;
  e2.parentFieldKey = a;
  e2.fieldName = n;
  e2.error = getFieldError(e2);
};
var isFragmentHeuristicallyMatching = (e2, r2, t, i, a) => {
  if (!r2) {
    return false;
  }
  var o = getTypeCondition(e2);
  if (!o || r2 === o) {
    return true;
  }
  warn("Heuristic Fragment Matching: A fragment is trying to match against the `" + r2 + "` type, but the type condition is `" + o + "`. Since GraphQL allows for interfaces `" + o + "` may be an interface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16, a);
  return "write" === D || !getSelectionSet(e2).some((e3) => {
    if (e3.kind !== e.FIELD) {
      return false;
    }
    var r3 = keyOfField(getName(e3), getFieldArguments(e3, i));
    return !hasField(t, r3);
  });
};
var makeSelectionIterator = (e2, r2, t, i, a) => {
  var o;
  var s = 0;
  return function next() {
    var l;
    while (o || s < i.length) {
      l = void 0;
      T = t;
      if (o) {
        if (l = o()) {
          return l;
        } else {
          o = void 0;
          if (true) {
            popDebugNode();
          }
        }
      } else {
        var v = i[s++];
        if (!shouldInclude(v, a.variables)) {
        } else if (v.kind !== e.FIELD) {
          var d2 = v.kind !== e.INLINE_FRAGMENT ? a.fragments[getName(v)] : v;
          if (d2) {
            if (!d2.typeCondition || (a.store.schema ? isInterfaceOfType(a.store.schema, d2, e2) : isFragmentHeuristicallyMatching(d2, e2, r2, a.variables, a.store.logger))) {
              if (true) {
                pushDebugNode(e2, d2);
              }
              o = makeSelectionIterator(e2, r2, t || isDeferred(v, a.variables), getSelectionSet(d2), a);
            }
          }
        } else if ("write" === D || !v._generated) {
          return v;
        }
      }
    }
  };
};
var ensureData = (e2) => null == e2 ? null : e2;
var ensureLink = (e2, r2) => {
  if (!r2) {
    return r2 || null;
  } else if (Array.isArray(r2)) {
    var t = new Array(r2.length);
    for (var i = 0, a = t.length; i < a; i++) {
      t[i] = ensureLink(e2, r2[i]);
    }
    return t;
  }
  var n = e2.keyOfEntity(r2);
  if (true) {
    if (!n && r2 && "object" == typeof r2) {
      warn("Can't generate a key for link(...) item.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + r2.__typename + "`.", 12, e2.logger);
    }
  }
  return n;
};
var _query = (e2, t, i, a) => {
  var n = formatDocument(t.query);
  var o = getMainOperation(n);
  var s = e2.rootFields[o.operation];
  var l = getSelectionSet(o);
  var v = makeContext(e2, normalizeVariables(o, t.variables), getFragments(n), s, s, a);
  if (true) {
    pushDebugNode(s, o);
  }
  var d2 = s !== v.store.rootFields.query ? readRoot(v, s, l, i || makeData()) : readSelection(v, s, l, i || makeData());
  if (true) {
    popDebugNode();
    getCurrentDependencies();
  }
  return {
    dependencies: x,
    partial: v.partial || !d2,
    hasNext: v.hasNext,
    data: d2 || null
  };
};
var readRoot = (e2, r2, t, i) => {
  if ("string" != typeof (e2.store.rootNames[r2] ? r2 : i.__typename)) {
    return i;
  }
  var a = makeSelectionIterator(r2, r2, T, t, e2);
  var n;
  var o = V;
  var s = makeData(i);
  while (n = a()) {
    var l = getFieldAlias(n);
    var v = i[l];
    e2.__internal.path.push(l);
    var d2 = void 0;
    if (n.selectionSet && null !== v) {
      d2 = readRootField(e2, getSelectionSet(n), ensureData(v));
    } else {
      d2 = v;
    }
    o = o || d2 !== v;
    if (void 0 !== d2) {
      s[l] = d2;
    }
    e2.__internal.path.pop();
  }
  return o ? s : i;
};
var readRootField = (e2, r2, t) => {
  if (Array.isArray(t)) {
    var i = new Array(t.length);
    var a = V;
    for (var n = 0, o = t.length; n < o; n++) {
      e2.__internal.path.push(n);
      i[n] = readRootField(e2, r2, t[n]);
      a = a || i[n] !== t[n];
      e2.__internal.path.pop();
    }
    return a ? i : t;
  } else if (null === t) {
    return null;
  }
  var s = e2.store.keyOfEntity(t);
  if (null !== s) {
    return readSelection(e2, s, r2, t) || null;
  } else {
    return readRoot(e2, t.__typename, r2, t);
  }
};
function getFieldResolver(e2, r2, t, i) {
  var a = i.store.resolvers[r2];
  var n = a && a[t];
  var o;
  for (var s in e2) {
    var l = e2[s];
    if (l && "include" !== s && "skip" !== s && i.store.directives[s]) {
      o = i.store.directives[s](getFieldArguments(l, i.variables));
      if (false) {
        return o;
      }
      break;
    }
  }
  if (true) {
    if (n && o) {
      warn(`A resolver and directive is being used at "${r2}.${t}" simultaneously. Only the directive will apply.`, 28, i.store.logger);
    }
  }
  return o || n;
}
var readSelection = (e2, r2, t, i, a) => {
  var { store: n } = e2;
  var o = r2 === n.rootFields.query;
  var s = a && n.keyOfEntity(a) || r2;
  if (true) {
    if (!o && e2.store.rootNames[s]) {
      warn("Invalid root traversal: A selection was being read on `" + s + "` which is an uncached root type.\nThe `" + e2.store.rootFields.mutation + "` and `" + e2.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25, n.logger);
    }
  }
  var l = !o ? readRecord(s, "__typename") || a && a.__typename : r2;
  if ("string" != typeof l) {
    return;
  } else if (a && l !== a.__typename) {
    warn("Invalid resolver data: The resolver at `" + s + "` returned an invalid typename that could not be reconciled with the cache.", 8, n.logger);
    return;
  }
  var v = makeSelectionIterator(l, s, T, t, e2);
  var d2 = false;
  var u = false;
  var c = V;
  var p2;
  var f2 = e2.partial;
  var y = makeData(i);
  while (void 0 !== (p2 = v())) {
    var h2 = getName(p2);
    var m2 = getFieldArguments(p2, e2.variables);
    var g2 = getFieldAlias(p2);
    var N2 = getDirectives(p2);
    var _2 = getFieldResolver(N2, l, h2, e2);
    var k2 = keyOfField(h2, m2);
    var E2 = joinKeys(s, k2);
    var O2 = readRecord(s, k2);
    var w2 = a ? a[h2] : void 0;
    if (n.schema && l) {
      isFieldAvailableOnType(n.schema, l, h2, e2.store.logger);
    }
    e2.__internal.path.push(g2);
    var b2 = void 0;
    if ("__typename" === h2) {
      b2 = l;
    } else if (void 0 !== w2 && void 0 === p2.selectionSet) {
      b2 = w2;
    } else if ("read" === D && _2) {
      var x2 = y;
      if (void 0 === p2.selectionSet && void 0 !== O2) {
        x2 = {
          ...y,
          [g2]: O2,
          [h2]: O2
        };
      }
      updateContext(e2, x2, l, s, k2, h2);
      b2 = _2(x2, m2 || {}, n, e2);
      if (p2.selectionSet) {
        b2 = resolveResolverResult(e2, l, h2, E2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : i[g2], b2, ownsData(i));
      }
      if (n.schema && null === b2 && !isFieldNullable(n.schema, l, h2, e2.store.logger)) {
        return;
      }
    } else if (!p2.selectionSet) {
      b2 = O2;
    } else if (void 0 !== w2) {
      b2 = resolveResolverResult(e2, l, h2, E2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : i[g2], w2, ownsData(i));
    } else {
      var I2 = readLink(s, k2);
      if (void 0 !== I2) {
        b2 = resolveLink(e2, I2, l, h2, getSelectionSet(p2), void 0 !== y[g2] ? y[g2] : i[g2], ownsData(i));
      } else if ("object" == typeof O2 && null !== O2) {
        b2 = O2;
      }
    }
    if (!T && void 0 === b2 && (N2.optional || getFieldError(e2) || n.schema && isFieldNullable(n.schema, l, h2, e2.store.logger))) {
      e2.partial = true;
      b2 = null;
    } else if (null === b2 && N2.required) {
      if (e2.store.logger && true && "read" === D) {
        e2.store.logger("debug", `Got value "null" for required field "${h2}"${m2 ? ` with args ${JSON.stringify(m2)}` : ""} on entity "${s}"`);
      }
      b2 = void 0;
    } else {
      d2 = d2 || "__typename" !== h2;
    }
    e2.__internal.path.pop();
    c = c || b2 !== i[g2];
    if (void 0 !== b2) {
      y[g2] = b2;
    } else if (T) {
      u = true;
    } else {
      if (e2.store.logger && true && "read" === D) {
        e2.store.logger("debug", `No value for field "${h2}"${m2 ? ` with args ${JSON.stringify(m2)}` : ""} on entity "${s}"`);
      }
      e2.partial = f2;
      return;
    }
  }
  e2.partial = e2.partial || f2;
  e2.hasNext = e2.hasNext || u;
  return o && e2.partial && !d2 ? void 0 : c ? y : i;
};
var resolveResolverResult = (e2, r2, t, i, a, n, o, s) => {
  if (Array.isArray(o)) {
    var { store: l } = e2;
    var v = l.schema ? isListNullable(l.schema, r2, t, e2.store.logger) : false;
    var d2 = e2.partial;
    var u = makeData(n, true);
    var c = V || !Array.isArray(n) || o.length !== n.length;
    for (var p2 = 0, f2 = o.length; p2 < f2; p2++) {
      e2.__internal.path.push(p2);
      var y = resolveResolverResult(e2, r2, t, joinKeys(i, `${p2}`), a, null != n ? n[p2] : void 0, o[p2], s);
      e2.__internal.path.pop();
      if (void 0 === y && !v) {
        e2.partial = d2;
        return;
      } else {
        e2.partial = e2.partial || void 0 === y && v;
        u[p2] = null != y ? y : null;
        c = c || u[p2] !== n[p2];
      }
    }
    return c ? u : n;
  } else if (null == o) {
    return o;
  } else if (s && null === n) {
    return null;
  } else if (isDataOrKey(o)) {
    var h2 = n || makeData(n);
    return "string" == typeof o ? readSelection(e2, o, a, h2) : readSelection(e2, i, a, h2, o);
  } else {
    warn("Invalid resolver value: The field at `" + i + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9, e2.store.logger);
    return;
  }
};
var resolveLink = (e2, r2, t, i, a, n, o) => {
  if (Array.isArray(r2)) {
    var { store: s } = e2;
    var l = s.schema ? isListNullable(s.schema, t, i, e2.store.logger) : false;
    var v = makeData(n, true);
    var d2 = e2.partial;
    var u = V || !Array.isArray(n) || r2.length !== n.length;
    for (var c = 0, p2 = r2.length; c < p2; c++) {
      e2.__internal.path.push(c);
      var f2 = resolveLink(e2, r2[c], t, i, a, null != n ? n[c] : void 0, o);
      e2.__internal.path.pop();
      if (void 0 === f2 && !l) {
        e2.partial = d2;
        return;
      } else {
        e2.partial = e2.partial || void 0 === f2 && l;
        v[c] = f2 || null;
        u = u || v[c] !== n[c];
      }
    }
    return u ? v : n;
  } else if (null === r2 || null === n && o) {
    return null;
  }
  return readSelection(e2, r2, a, n || makeData(n));
};
var isDataOrKey = (e2) => "string" == typeof e2 || "object" == typeof e2 && "string" == typeof e2.__typename;
var _write = (e2, t, i, a) => {
  if (true) {
    getCurrentDependencies();
  }
  var n = formatDocument(t.query);
  var o = getMainOperation(n);
  var s = {
    data: i || makeData(),
    dependencies: x
  };
  var l = e2.rootFields[o.operation];
  var v = makeContext(e2, normalizeVariables(o, t.variables), getFragments(n), l, l, a);
  if (true) {
    pushDebugNode(l, o);
  }
  writeSelection(v, l, getSelectionSet(o), s.data);
  if (true) {
    popDebugNode();
  }
  return s;
};
var writeSelection = (e2, r2, t, i) => {
  var a = e2.store.rootNames[r2] || "query";
  var n = !!e2.store.rootNames[r2];
  var o = n ? r2 : i.__typename;
  if (!o && r2 && e2.optimistic) {
    o = readRecord(r2, "__typename");
  }
  if (!o) {
    warn("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14, e2.store.logger);
    return;
  } else if (!n && r2) {
    writeRecord(r2, "__typename", o);
  }
  var s = e2.store.updates[o];
  var l = makeSelectionIterator(o, r2 || o, T, t, e2);
  var v;
  while (v = l()) {
    var d2 = getName(v);
    var u = getFieldArguments(v, e2.variables);
    var c = keyOfField(d2, u);
    var p2 = getFieldAlias(v);
    var f2 = i[e2.optimistic ? d2 : p2];
    if ("__typename" === d2 || void 0 === f2 && (T || e2.optimistic && "query" === a)) {
      continue;
    }
    if (true) {
      if (e2.store.schema && o && "__typename" !== d2) {
        isFieldAvailableOnType(e2.store.schema, o, d2, e2.store.logger);
      }
    }
    e2.__internal.path.push(p2);
    var y = void 0;
    if (e2.optimistic && "mutation" === a) {
      if (!(y = e2.store.optimisticMutations[d2])) {
        continue;
      }
    } else if (e2.optimistic && "function" == typeof f2) {
      y = f2;
    }
    if (y) {
      updateContext(e2, i, o, r2 || o, c, d2);
      f2 = ensureData(y(u || {}, e2.store, e2));
    }
    if (void 0 === f2) {
      if (true) {
        if (!r2 || !hasField(r2, c) || e2.optimistic && !readRecord(r2, "__typename")) {
          warn("Invalid undefined: The field at `" + c + "` is `undefined`, but the GraphQL query expects a " + (void 0 === v.selectionSet ? "scalar (number, boolean, etc)" : "selection set") + " for this field.", 13, e2.store.logger);
        }
      }
      continue;
    }
    if (v.selectionSet) {
      if (r2 && "query" === a) {
        var h2 = joinKeys(r2, c);
        var m2 = writeField(e2, getSelectionSet(v), ensureData(f2), h2, e2.optimistic ? readLink(r2 || o, c) : void 0);
        writeLink(r2 || o, c, m2);
      } else {
        writeField(e2, getSelectionSet(v), ensureData(f2));
      }
    } else if (r2 && "query" === a) {
      writeRecord(r2 || o, c, null !== f2 || !getFieldError(e2) ? f2 : void 0);
    }
    var g2 = s && s[d2];
    if (g2) {
      updateContext(e2, i, o, r2 || o, c, d2);
      i[d2] = f2;
      g2(i, u || {}, e2.store, e2);
    }
    e2.__internal.path.pop();
  }
};
var A = /^__|PageInfo|(Connection|Edge)$/;
var writeField = (e2, r2, t, i, a) => {
  if (Array.isArray(t)) {
    var n = new Array(t.length);
    for (var o = 0, s = t.length; o < s; o++) {
      e2.__internal.path.push(o);
      var l = i ? joinKeys(i, `${o}`) : void 0;
      var v = writeField(e2, r2, t[o], l, null != a ? a[o] : void 0);
      n[o] = v;
      e2.__internal.path.pop();
    }
    return n;
  } else if (null === t) {
    return getFieldError(e2) ? void 0 : null;
  }
  var d2 = e2.store.keyOfEntity(t) || ("string" == typeof a ? a : null);
  var u = t.__typename;
  if (true) {
    if (i && !e2.store.keys[t.__typename] && null === d2 && "string" == typeof u && !A.test(u)) {
      warn("Invalid key: The GraphQL query at the field at `" + i + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + u + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + u + "` that always returns null.", 15, e2.store.logger);
    }
  }
  var c = d2 || i;
  writeSelection(e2, c, r2, t);
  return c || null;
};
var Store = class {
  constructor(e2) {
    if (!e2) {
      e2 = {};
    }
    this.logger = e2.logger;
    this.resolvers = e2.resolvers || {};
    this.directives = e2.directives || {};
    this.optimisticMutations = e2.optimistic || {};
    this.keys = e2.keys || {};
    this.globalIDs = Array.isArray(e2.globalIDs) ? new Set(e2.globalIDs) : !!e2.globalIDs;
    var r2 = "Query";
    var t = "Mutation";
    var i = "Subscription";
    if (e2.schema) {
      var a = (({ __schema: e3 }) => {
        var r3 = /* @__PURE__ */ new Map();
        var buildNameMap = (e4) => {
          var r4;
          return () => {
            if (!r4) {
              r4 = {};
              for (var t3 = 0; t3 < e4.length; t3++) {
                r4[e4[t3].name] = e4[t3];
              }
            }
            return r4;
          };
        };
        var buildType = (e4) => {
          switch (e4.kind) {
            case "OBJECT":
            case "INTERFACE":
              return {
                name: e4.name,
                kind: e4.kind,
                interfaces: buildNameMap(e4.interfaces || []),
                fields: buildNameMap(e4.fields.map((e5) => ({
                  name: e5.name,
                  type: e5.type,
                  args: buildNameMap(e5.args)
                })))
              };
            case "UNION":
              return {
                name: e4.name,
                kind: e4.kind,
                types: buildNameMap(e4.possibleTypes || [])
              };
          }
        };
        var t2 = {
          query: e3.queryType ? e3.queryType.name : null,
          mutation: e3.mutationType ? e3.mutationType.name : null,
          subscription: e3.subscriptionType ? e3.subscriptionType.name : null,
          types: void 0,
          isSubType(e4, t3) {
            var i3 = r3.get(e4);
            var a3 = r3.get(t3);
            if (!i3 || !a3) {
              return false;
            } else if ("UNION" === i3.kind) {
              return !!i3.types()[t3];
            } else if ("OBJECT" !== i3.kind && "OBJECT" === a3.kind) {
              return !!a3.interfaces()[e4];
            } else {
              return e4 === t3;
            }
          }
        };
        if (e3.types) {
          t2.types = r3;
          for (var i2 = 0; i2 < e3.types.length; i2++) {
            var a2 = e3.types[i2];
            if (a2 && a2.name) {
              var n2 = buildType(a2);
              if (n2) {
                r3.set(a2.name, n2);
              }
            }
          }
        }
        return t2;
      })(e2.schema);
      r2 = a.query || r2;
      t = a.mutation || t;
      i = a.subscription || i;
      if (a.types) {
        this.schema = a;
      }
    }
    this.updates = e2.updates || {};
    this.rootFields = {
      query: r2,
      mutation: t,
      subscription: i
    };
    this.rootNames = {
      [r2]: "query",
      [t]: "mutation",
      [i]: "subscription"
    };
    this.data = (n = r2, {
      hydrating: false,
      defer: false,
      gc: /* @__PURE__ */ new Set(),
      persist: /* @__PURE__ */ new Set(),
      queryRootKey: n,
      refCount: /* @__PURE__ */ new Map(),
      links: {
        optimistic: /* @__PURE__ */ new Map(),
        base: /* @__PURE__ */ new Map()
      },
      records: {
        optimistic: /* @__PURE__ */ new Map(),
        base: /* @__PURE__ */ new Map()
      },
      deferredKeys: /* @__PURE__ */ new Set(),
      commutativeKeys: /* @__PURE__ */ new Set(),
      dirtyKeys: /* @__PURE__ */ new Set(),
      optimisticOrder: [],
      storage: null
    });
    var n;
    if (this.schema && true) {
      !function expectValidKeyingConfig(e3, r3, t2) {
        if (true) {
          for (var i2 in r3) {
            if (true) {
              if (!e3.types.has(i2)) {
                warn("Invalid Object type: The type `" + i2 + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20, t2);
              }
            }
          }
        }
      }(this.schema, this.keys, this.logger);
      !function expectValidUpdatesConfig(e3, r3, t2) {
        if (false) {
          return;
        }
        for (var i2 in r3) {
          if (!r3[i2]) {
            continue;
          } else if (!e3.types.has(i2)) {
            var a2 = "";
            if ("Mutation" === i2 && e3.mutation && "Mutation" !== e3.mutation) {
              a2 += "\nMaybe your config should reference `" + e3.mutation + "`?";
            } else if ("Subscription" === i2 && e3.subscription && "Subscription" !== e3.subscription) {
              a2 += "\nMaybe your config should reference `" + e3.subscription + "`?";
            }
            return true ? warn("Invalid updates type: The type `" + i2 + "` is not an object in the defined schema, but the `updates` config is referencing it." + a2, 21, t2) : void 0;
          }
          var n2 = e3.types.get(i2).fields();
          for (var o in r3[i2]) {
            if (true) {
              if (!n2[o]) {
                warn("Invalid updates field: `" + o + "` on `" + i2 + "` is not in the defined schema, but the `updates` config is referencing it.", 22, t2);
              }
            }
          }
        }
      }(this.schema, this.updates, this.logger);
      !function expectValidResolversConfig(e3, r3, t2) {
        if (false) {
          return;
        }
        for (var i2 in r3) {
          if ("Query" === i2) {
            if (e3.query) {
              var a2 = e3.types.get(e3.query).fields();
              for (var n2 in r3.Query || {}) {
                if (!a2[n2]) {
                  warnAboutResolver("Query." + n2, t2);
                }
              }
            } else {
              warnAboutResolver("Query", t2);
            }
          } else if (!e3.types.has(i2)) {
            warnAboutResolver(i2, t2);
          } else if ("INTERFACE" === e3.types.get(i2).kind || "UNION" === e3.types.get(i2).kind) {
            warnAboutAbstractResolver(i2, e3.types.get(i2).kind, t2);
          } else {
            var o = e3.types.get(i2).fields();
            for (var s in r3[i2] || {}) {
              if (!o[s]) {
                warnAboutResolver(i2 + "." + s, t2);
              }
            }
          }
        }
      }(this.schema, this.resolvers, this.logger);
      !function expectValidOptimisticMutationsConfig(e3, r3, t2) {
        if (false) {
          return;
        }
        if (e3.mutation) {
          var i2 = e3.types.get(e3.mutation).fields();
          for (var a2 in r3) {
            if (true) {
              if (!i2[a2]) {
                warn(`Invalid optimistic mutation field: \`${a2}\` is not a mutation field in the defined schema, but the \`optimistic\` option is referencing it.`, 24, t2);
              }
            }
          }
        }
      }(this.schema, this.optimisticMutations, this.logger);
    }
  }
  keyOfField(e2, r2) {
    return keyOfField(e2, r2);
  }
  keyOfEntity(e2) {
    if (q && e2 === q.parent) {
      return q.parentKey;
    } else if (null == e2 || "string" == typeof e2) {
      return e2 || null;
    } else if (!e2.__typename) {
      return null;
    } else if (this.rootNames[e2.__typename]) {
      return e2.__typename;
    }
    var r2 = null;
    if (this.keys[e2.__typename]) {
      r2 = this.keys[e2.__typename](e2) || null;
    } else if (null != e2.id) {
      r2 = `${e2.id}`;
    } else if (null != e2._id) {
      r2 = `${e2._id}`;
    }
    var t = e2.__typename;
    return true === this.globalIDs || this.globalIDs && this.globalIDs.has(t) || !r2 ? r2 : `${t}:${r2}`;
  }
  resolve(e2, r2, t) {
    var i = null;
    var a = this.keyOfEntity(e2);
    if (a) {
      var n = keyOfField(r2, t);
      if (void 0 === (i = readRecord(a, n))) {
        i = readLink(a, n);
      }
    }
    return i;
  }
  resolveFieldByKey(e2, r2, t) {
    return this.resolve(e2, r2, t);
  }
  invalidate(e2, r2, t) {
    var i = this.keyOfEntity(e2);
    invariant(i, true ? "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + ("object" == typeof e2 ? e2.__typename : e2 + "`.") : "", 19);
    ((e3, r3, t2) => {
      var i2 = r3 ? [{
        fieldKey: keyOfField(r3, t2)
      }] : inspectFields(e3);
      for (var a = 0, n = i2.length; a < n; a++) {
        var { fieldKey: o } = i2[a];
        if (void 0 !== readLink(e3, o)) {
          writeLink(e3, o, void 0);
        } else {
          writeRecord(e3, o, void 0);
        }
      }
    })(i, r2, t);
  }
  inspectFields(e2) {
    var r2 = this.keyOfEntity(e2);
    return r2 ? inspectFields(r2) : [];
  }
  updateQuery(e2, r2) {
    var i = createRequest(e2.query, e2.variables);
    var a = r2(this.readQuery(i));
    if (null !== a) {
      _write(this, i, a, void 0);
    }
  }
  readQuery(e2) {
    var r2 = createRequest(e2.query, e2.variables);
    return _query(this, r2, void 0, void 0).data;
  }
  readFragment(e2, t, i, a) {
    return ((e3, r2, t2, i2, a2) => {
      var n = getFragments(r2);
      var o;
      if (a2) {
        if (!(o = n[a2])) {
          warn("readFragment(...) was called with a fragment name that does not exist.\nYou provided " + a2 + " but could only find " + Object.keys(n).join(", ") + ".", 6, e3.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        warn("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6, e3.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      if ("string" != typeof t2 && !t2.__typename) {
        t2.__typename = s;
      }
      var l = e3.keyOfEntity(t2);
      if (!l) {
        warn("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 7, e3.logger);
        return null;
      }
      if (true) {
        pushDebugNode(s, o);
      }
      var v = makeContext(e3, i2 || {}, n, s, l, void 0);
      var d2 = readSelection(v, l, getSelectionSet(o), makeData()) || null;
      if (true) {
        popDebugNode();
      }
      return d2;
    })(this, formatDocument(e2), t, i, a);
  }
  writeFragment(e2, t, i, a) {
    ((e3, r2, t2, i2, a2) => {
      var n = getFragments(r2);
      var o;
      if (a2) {
        if (!(o = n[a2])) {
          warn("writeFragment(...) was called with a fragment name that does not exist.\nYou provided " + a2 + " but could only find " + Object.keys(n).join(", ") + ".", 11, e3.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        warn("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11, e3.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      var l = {
        __typename: s,
        ...t2
      };
      var v = e3.keyOfEntity(l);
      if (!v) {
        return true ? warn("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 12, e3.logger) : void 0;
      }
      if (true) {
        pushDebugNode(s, o);
      }
      var d2 = makeContext(e3, i2 || {}, n, s, v, void 0);
      writeSelection(d2, v, getSelectionSet(o), l);
      if (true) {
        popDebugNode();
      }
    })(this, formatDocument(e2), t, i, a);
  }
  link(e2, r2, ...t) {
    var i = 2 === t.length ? t[0] : null;
    var a = 2 === t.length ? t[1] : t[0];
    var n = this.keyOfEntity(e2);
    if (n) {
      writeLink(n, keyOfField(r2, i), ensureLink(this, a));
    }
  }
};
var addMetadata = (e2, r2) => makeOperation(e2.kind, e2, {
  ...e2.context,
  meta: {
    ...e2.context.meta,
    ...r2
  }
});
var toRequestPolicy = (e2, r2) => makeOperation(e2.kind, e2, {
  ...e2.context,
  requestPolicy: r2
});
var cacheExchange = (e2) => ({ forward: t, client: a, dispatchDebug: n }) => {
  var o = new Store(e2);
  if (e2 && e2.storage) {
    o.data.hydrating = true;
    e2.storage.readData().then((r2) => {
      ((e3, r3, t2) => {
        initDataState("write", e3, null);
        for (var i in t2) {
          var a2 = t2[i];
          if (void 0 !== a2) {
            var { entityKey: n2, fieldKey: o2 } = deserializeKeyInfo(i);
            if (":" === a2[0]) {
              if (void 0 === readLink(n2, o2)) {
                writeLink(n2, o2, JSON.parse(a2.slice(1)));
              }
            } else if (void 0 === readRecord(n2, o2)) {
              writeRecord(n2, o2, JSON.parse(a2));
            }
          }
        }
        e3.storage = r3;
        e3.hydrating = false;
        clearDataState();
      })(o.data, e2.storage, r2);
      if (e2.storage.onCacheHydrated) {
        e2.storage.onCacheHydrated();
      }
    });
  }
  var f2 = /* @__PURE__ */ new Map();
  var y = [];
  var h2 = /* @__PURE__ */ new Map();
  var m2 = /* @__PURE__ */ new Map();
  var g2 = /* @__PURE__ */ new Set();
  var N2 = /* @__PURE__ */ new Set();
  var _2 = /* @__PURE__ */ new Map();
  var k2 = /* @__PURE__ */ new Set();
  var E2 = /* @__PURE__ */ new Set();
  var isBlockedByOptimisticUpdate = (e3) => {
    for (var r2 of e3.values()) {
      if (g2.has(r2)) {
        return true;
      }
    }
    return false;
  };
  var collectPendingOperations = (e3, r2) => {
    if (r2) {
      for (var t2 of r2.values()) {
        var i = _2.get(t2);
        if (i) {
          for (var a2 of i.values()) {
            e3.add(a2);
          }
        }
      }
    }
  };
  var executePendingOperations = (e3, r2, t2) => {
    for (var i of r2.values()) {
      if (i !== e3.key) {
        var n2 = h2.get(i);
        if (n2) {
          if ("query" === e3.kind) {
            E2.add(i);
          }
          var o2 = "cache-first";
          if (N2.has(i)) {
            N2.delete(i);
            o2 = "cache-and-network";
          }
          a.reexecuteOperation(toRequestPolicy(n2, o2));
        }
      }
    }
    if (!t2) {
      var s = k2;
      if ("query" === e3.kind) {
        (k2 = E2).add(e3.key);
      }
      (E2 = s).clear();
    }
  };
  var prepareForwardedOperation = (e3) => {
    var t2 = false;
    if ("query" === e3.kind) {
      reserveLayer(o.data, e3.key);
      h2.set(e3.key, e3);
    } else if ("teardown" === e3.kind) {
      h2.delete(e3.key);
      m2.delete(e3.key);
      k2.delete(e3.key);
      noopDataState(o.data, e3.key);
      return e3;
    } else if ("mutation" === e3.kind && "network-only" !== e3.context.requestPolicy) {
      h2.set(e3.key, e3);
      initDataState("write", o.data, e3.key, true, false);
      var { dependencies: a2 } = _write(o, e3, void 0, void 0);
      clearDataState();
      if (a2.size) {
        for (var n2 of a2.values()) {
          g2.add(n2);
        }
        f2.set(e3.key, a2);
        var s = /* @__PURE__ */ new Set();
        collectPendingOperations(s, a2);
        executePendingOperations(e3, s, true);
        t2 = true;
      }
    }
    return makeOperation(e3.kind, {
      key: e3.key,
      query: formatDocument(e3.query),
      variables: e3.variables ? filterVariables(getMainOperation(e3.query), e3.variables) : e3.variables
    }, {
      ...e3.context,
      optimistic: t2
    });
  };
  var updateDependencies2 = (e3, r2) => {
    for (var t2 of r2.values()) {
      var i = _2.get(t2);
      if (!i) {
        _2.set(t2, i = /* @__PURE__ */ new Set());
      }
      i.add(e3.key);
    }
  };
  var operationResultFromCache = (e3) => {
    initDataState("read", o.data, void 0, false, false);
    var r2 = _query(o, e3, m2.get(e3.key), void 0);
    clearDataState();
    var t2 = r2.data ? !r2.partial && !r2.hasNext ? "hit" : "partial" : "miss";
    m2.set(e3.key, r2.data);
    h2.set(e3.key, e3);
    updateDependencies2(e3, r2.dependencies);
    return {
      outcome: t2,
      operation: e3,
      data: r2.data,
      dependencies: r2.dependencies,
      hasNext: r2.hasNext
    };
  };
  var updateCacheWithResult = (e3, r2) => {
    var t2 = h2.get(e3.operation.key) || e3.operation;
    if ("mutation" === t2.kind) {
      var i = f2.get(t2.key);
      collectPendingOperations(r2, i);
      f2.delete(t2.key);
    }
    if ("subscription" === t2.kind || e3.hasNext) {
      reserveLayer(o.data, t2.key, true);
    }
    var a2;
    var n2 = e3.data;
    if (n2) {
      initDataState("write", o.data, t2.key, false, false);
      var s = _write(o, t2, n2, e3.error).dependencies;
      clearDataState();
      collectPendingOperations(r2, s);
      var l = "query" === t2.kind ? m2.get(t2.key) : null;
      initDataState("read", o.data, t2.key, false, l !== n2);
      var v = _query(o, t2, l || n2, e3.error);
      clearDataState();
      n2 = v.data;
      if ("query" === t2.kind) {
        collectPendingOperations(r2, a2 = v.dependencies);
        m2.set(t2.key, n2);
      }
    } else {
      noopDataState(o.data, t2.key);
    }
    if (a2) {
      updateDependencies2(e3.operation, a2);
    }
    return {
      operation: t2,
      data: n2,
      error: e3.error,
      extensions: e3.extensions,
      hasNext: e3.hasNext,
      stale: e3.stale
    };
  };
  return (e3) => {
    var r2 = share(map(operationResultFromCache)(filter((e4) => "query" === e4.kind && "network-only" !== e4.context.requestPolicy)(e3)));
    var i = filter((e4) => "query" !== e4.kind || "network-only" === e4.context.requestPolicy)(e3);
    var m3 = map((e4) => {
      n({
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache",
        operation: e4.operation,
        source: "cacheExchange"
      });
      return true ? addMetadata(e4.operation, {
        cacheOutcome: "miss"
      }) : e4.operation;
    })(filter((e4) => "miss" === e4.outcome && "cache-only" !== e4.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e4.dependencies) && !k2.has(e4.operation.key))(r2));
    var _3 = map((e4) => {
      var { requestPolicy: r3 } = e4.operation.context;
      var t2 = "cache-only" !== r3 && (e4.hasNext || "cache-and-network" === r3 || "cache-first" === r3 && "partial" === e4.outcome && !k2.has(e4.operation.key));
      var i2 = {
        operation: true ? addMetadata(e4.operation, {
          cacheOutcome: e4.outcome
        }) : e4.operation,
        data: e4.data,
        error: e4.error,
        extensions: e4.extensions,
        stale: t2 && !e4.hasNext,
        hasNext: t2 && e4.hasNext
      };
      if (!t2) {
      } else if (!isBlockedByOptimisticUpdate(e4.dependencies)) {
        a.reexecuteOperation(toRequestPolicy(h2.get(e4.operation.key) || e4.operation, "network-only"));
      } else if ("cache-and-network" === r3) {
        N2.add(e4.operation.key);
      }
      n({
        type: "cacheHit",
        message: "A requested operation was found and returned from the cache.",
        operation: e4.operation,
        data: {
          value: i2
        },
        source: "cacheExchange"
      });
      return i2;
    })(filter((e4) => "miss" !== e4.outcome || "cache-only" === e4.operation.context.requestPolicy)(r2));
    var E3 = t(map(prepareForwardedOperation)(merge([i, m3])));
    var O2 = map((e4) => {
      var r3 = /* @__PURE__ */ new Set();
      var t2 = updateCacheWithResult(e4, r3);
      executePendingOperations(e4.operation, r3, false);
      return t2;
    })(filter((e4) => !f2.has(e4.operation.key))(E3));
    var w2 = mergeMap((e4) => {
      if (y.push(e4) < f2.size) {
        return empty;
      }
      for (var r3 = 0; r3 < y.length; r3++) {
        reserveLayer(o.data, y[r3].operation.key);
      }
      g2.clear();
      var t2 = [];
      var i2 = /* @__PURE__ */ new Set();
      var a2;
      while (a2 = y.shift()) {
        t2.push(updateCacheWithResult(a2, i2));
      }
      executePendingOperations(e4.operation, i2, false);
      return r(t2);
    })(filter((e4) => f2.has(e4.operation.key))(E3));
    return merge([O2, w2, _3]);
  };
};

// node_modules/.pnpm/@urql+exchange-auth@2.1.6_graphql@16.8.1/node_modules/@urql/exchange-auth/dist/urql-exchange-auth.mjs
var addAuthAttemptToOperation = (t, e2) => makeOperation(t.kind, t, {
  ...t.context,
  authAttempt: e2
});
function authExchange(s) {
  return ({ client: f2, forward: d2 }) => {
    var l = /* @__PURE__ */ new Set();
    var p2 = makeSubject();
    var x2 = makeSubject();
    var A2 = /* @__PURE__ */ new Map();
    function flushQueue() {
      v = void 0;
      var t = A2;
      A2 = /* @__PURE__ */ new Map();
      t.forEach(p2.next);
    }
    function errorQueue(t) {
      v = void 0;
      var e2 = A2;
      A2 = /* @__PURE__ */ new Map();
      e2.forEach((e3) => {
        x2.next(makeErrorResult(e3, t));
      });
    }
    var v;
    var w2 = null;
    return (t) => {
      function initAuth() {
        v = Promise.resolve().then(() => s({
          mutate(t2, n, r2) {
            var u = f2.createRequestOperation("mutation", createRequest(t2, n), r2);
            return toPromise(take(1)(filter((t3) => t3.operation.key === u.key && u.context._instance === t3.operation.context._instance)(onStart(() => {
              var t3 = addAuthToOperation(u);
              l.add(t3.context._instance);
              p2.next(t3);
            })(E2))));
          },
          appendHeaders(t2, e2) {
            var n = "function" == typeof t2.context.fetchOptions ? t2.context.fetchOptions() : t2.context.fetchOptions || {};
            return makeOperation(t2.kind, t2, {
              ...t2.context,
              fetchOptions: {
                ...n,
                headers: {
                  ...n.headers,
                  ...e2
                }
              }
            });
          }
        })).then((t2) => {
          if (t2) {
            w2 = t2;
          }
          flushQueue();
        }).catch((t2) => {
          if (true) {
            console.warn("authExchange()’s initialization function has failed, which is unexpected.\nIf your initialization function is expected to throw/reject, catch this error and handle it explicitly.\nUnless this error is handled it’ll be passed onto any `OperationResult` instantly and authExchange() will block further operations and retry.", t2);
          }
          errorQueue(t2);
        });
      }
      initAuth();
      function refreshAuth(t2) {
        A2.set(t2.key, addAuthAttemptToOperation(t2, true));
        if (w2 && !v) {
          v = w2.refreshAuth().then(flushQueue).catch(errorQueue);
        }
      }
      function addAuthToOperation(t2) {
        return w2 ? w2.addAuthToOperation(t2) : t2;
      }
      var h2 = filter(Boolean)(map((t2) => {
        if ("teardown" === t2.kind) {
          A2.delete(t2.key);
          return t2;
        } else if (t2.context._instance && l.has(t2.context._instance)) {
          return t2;
        } else if (t2.context.authAttempt) {
          return addAuthToOperation(t2);
        } else if (v || !w2) {
          if (!v) {
            initAuth();
          }
          if (!A2.has(t2.key)) {
            A2.set(t2.key, addAuthAttemptToOperation(t2, false));
          }
          return null;
        } else if (function willAuthError(t3) {
          return !t3.context.authAttempt && w2 && w2.willAuthError && w2.willAuthError(t3);
        }(t2)) {
          refreshAuth(t2);
          return null;
        }
        return addAuthToOperation(addAuthAttemptToOperation(t2, false));
      })(merge([p2.source, t])));
      var E2 = d2(h2);
      return merge([x2.source, filter((t2) => {
        if (!l.has(t2.operation.context._instance) && t2.error && function didAuthError(t3) {
          return w2 && w2.didAuthError && w2.didAuthError(t3.error, t3.operation);
        }(t2) && !t2.operation.context.authAttempt) {
          refreshAuth(t2.operation);
          return false;
        }
        if (l.has(t2.operation.context._instance)) {
          l.delete(t2.operation.context._instance);
        }
        return true;
      })(E2)]);
    };
  };
}

// node_modules/.pnpm/@urql+exchange-persisted@4.1.1_graphql@16.8.1/node_modules/@urql/exchange-persisted/dist/urql-exchange-persisted.mjs
var d = "undefined" != typeof window ? window.crypto : "undefined" != typeof self ? self.crypto : null;
var p;
var hash = async (e2) => {
  if (d && d.subtle) {
    var r2 = await d.subtle.digest({
      name: "SHA-256"
    }, new TextEncoder().encode(e2));
    return new Uint8Array(r2).reduce((e3, r3) => e3 + r3.toString(16).padStart(2, "0"), "");
  } else if (await (async () => {
    if (!p) {
      try {
        p = new Function("require", 'return require("crypto")')(__require);
      } catch (e3) {
        try {
          p = new Function('return import("crypto")')();
        } catch (e4) {
        }
      }
    }
    return p;
  })()) {
    return (await p).createHash("sha256").update(e2).digest("hex");
  }
  if (true) {
    console.warn("[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\nThis is an unexpected error. Please report it by filing a GitHub Issue.");
  }
  return "";
};
var persistedExchange = (d2) => ({ forward: p2 }) => {
  if (!d2) {
    d2 = {};
  }
  var c = d2.preferGetForPersistedQueries;
  var y = !!d2.enforcePersistedQueries;
  var f2 = d2.generateHash || hash;
  var h2 = !!d2.enableForMutation;
  var l = true;
  var operationFilter = (e2) => l && !e2.context.persistAttempt && (h2 && "mutation" === e2.kind || "query" === e2.kind);
  return (d3) => {
    var h3 = makeSubject();
    var x2 = filter((e2) => !operationFilter(e2))(d3);
    var v = mergeMap((e2) => {
      var t = (async (e3) => {
        var r2 = makeOperation(e3.kind, e3, {
          ...e3.context,
          persistAttempt: true
        });
        var t2 = await f2(stringifyDocument(e3.query), e3.query);
        if (t2) {
          r2.extensions = {
            ...r2.extensions,
            persistedQuery: {
              version: 1,
              sha256Hash: t2
            }
          };
          if ("query" === r2.kind && c) {
            r2.context.preferGetMethod = c;
          }
        }
        return r2;
      })(e2);
      return takeUntil(filter((r2) => "teardown" === r2.kind && r2.key === e2.key)(d3))(fromPromise(t));
    })(filter(operationFilter)(d3));
    return filter((e2) => !!e2)(map((e2) => {
      if (!y && e2.operation.extensions && e2.operation.extensions.persistedQuery) {
        if (e2.error && e2.error.graphQLErrors.some((e3) => "PersistedQueryNotSupported" === e3.message)) {
          l = false;
          var r2 = makeOperation(e2.operation.kind, e2.operation);
          if (r2.extensions) {
            delete r2.extensions.persistedQuery;
          }
          h3.next(r2);
          return null;
        } else if (e2.error && ((e3) => e3.graphQLErrors.some((e4) => "PersistedQueryNotFound" === e4.message))(e2.error)) {
          if (e2.operation.extensions.persistedQuery.miss) {
            if (true) {
              console.warn("persistedExchange()’s results include two misses for the same operation.\nThis is not expected as it means a persisted error has been delivered for a non-persisted query!\nAnother exchange with a cache may be delivering an outdated result. For example, a server-side ssrExchange() may be caching an errored result.\nTry moving the persistedExchange() in past these exchanges, for example in front of your fetchExchange.");
            }
            return e2;
          }
          var t = makeOperation(e2.operation.kind, e2.operation);
          t.extensions = {
            ...t.extensions,
            persistedQuery: {
              ...(t.extensions || {}).persistedQuery,
              miss: true
            }
          };
          h3.next(t);
          return null;
        }
      }
      return e2;
    })(p2(merge([v, x2, h3.source]))));
  };
};

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/ui/dist/keystatic-core-ui.esm.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());

// node_modules/.pnpm/idb-keyval@6.2.1/node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store2) => promisifyRequest(store2.get(key)));
}
function set2(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    store2.put(value, key);
    return promisifyRequest(store2.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store2) => {
    store2.delete(key);
    return promisifyRequest(store2.transaction);
  });
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/avatar/dist/keystar-ui-avatar.esm.js
var import_react14 = __toESM(require_react());
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var Avatar = (0, import_react14.forwardRef)(function Avatar2(props, forwardedRef) {
  const {
    alt,
    size = "regular",
    ...otherProps
  } = props;
  const styleProps = useStyleProps(otherProps);
  return (0, import_jsx_runtime21.jsx)("div", {
    ref: forwardedRef,
    role: "img",
    "aria-label": alt,
    "data-size": size === "regular" ? void 0 : size,
    ...styleProps,
    ...$65484d02dcb7eb3e$export$457c3d6518dd4c6f(otherProps),
    className: classNames(styleProps.className, css({
      alignItems: "center",
      backgroundColor: tokenSchema.color.background.surfaceTertiary,
      borderRadius: "50%",
      display: "inline-flex",
      flexShrink: 0,
      fontSize: "var(--avatar-text-size)",
      height: "var(--avatar-size)",
      justifyContent: "center",
      overflow: "hidden",
      width: "var(--avatar-size)",
      userSelect: "none",
      // sizes
      "--avatar-size": tokenSchema.size.element.regular,
      "--avatar-text-size": tokenSchema.typography.text.regular.size,
      "&[data-size=xsmall]": {
        "--avatar-size": tokenSchema.size.element.xsmall,
        "--avatar-text-size": tokenSchema.typography.text.small.size
      },
      "&[data-size=small]": {
        "--avatar-size": tokenSchema.size.element.small,
        "--avatar-text-size": tokenSchema.typography.text.small.size
      },
      "&[data-size=medium]": {
        "--avatar-size": tokenSchema.size.element.medium,
        "--avatar-text-size": tokenSchema.typography.text.medium.size
      },
      "&[data-size=large]": {
        "--avatar-size": tokenSchema.size.element.large,
        "--avatar-text-size": tokenSchema.typography.text.large.size
      },
      "&[data-size=xlarge]": {
        "--avatar-size": tokenSchema.size.element.xlarge,
        "--avatar-text-size": tokenSchema.typography.text.large.size
      }
    })),
    children: "src" in props ? (0, import_jsx_runtime21.jsx)("div", {
      className: css({
        height: "100%",
        width: "100%"
      }),
      style: {
        backgroundImage: `url(${props.src})`,
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
        backgroundSize: "cover"
      }
    }) : (0, import_jsx_runtime21.jsx)(Text, {
      "aria-hidden": true,
      color: "neutralSecondary",
      weight: "medium",
      UNSAFE_className: css({
        fontSize: "inherit"
      }),
      children: getInitials(props.name, size)
    })
  });
});
function getInitials(name, size) {
  const words = name.split(" ");
  const first = words[0].charAt(0);
  const last = words[words.length - 1].charAt(0);
  if (size === "xsmall") {
    return `${first}`.toUpperCase();
  }
  return `${first}${last}`.toUpperCase();
}

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/gitBranchPlusIcon/dist/keystar-ui-icon-icons-gitBranchPlusIcon.esm.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var gitBranchPlusIcon = (0, import_jsx_runtime22.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime22.jsx)("path", {
    d: "M6 3v12M18 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM6 21a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"
  }), (0, import_jsx_runtime22.jsx)("path", {
    d: "M15 6a9 9 0 0 0-9 9M18 15v6M21 18h-6"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/gitPullRequestIcon/dist/keystar-ui-icon-icons-gitPullRequestIcon.esm.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var gitPullRequestIcon = (0, import_jsx_runtime23.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime23.jsx)("circle", {
    cx: 18,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime23.jsx)("circle", {
    cx: 6,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime23.jsx)("path", {
    d: "M13 6h3a2 2 0 0 1 2 2v7M6 9v12"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/logOutIcon/dist/keystar-ui-icon-icons-logOutIcon.esm.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var logOutIcon = (0, import_jsx_runtime24.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime24.jsx)("path", {
    d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/gitForkIcon/dist/keystar-ui-icon-icons-gitForkIcon.esm.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var gitForkIcon = (0, import_jsx_runtime25.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime25.jsx)("circle", {
    cx: 12,
    cy: 18,
    r: 3
  }), (0, import_jsx_runtime25.jsx)("circle", {
    cx: 6,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime25.jsx)("circle", {
    cx: 18,
    cy: 6,
    r: 3
  }), (0, import_jsx_runtime25.jsx)("path", {
    d: "M18 9v1a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V9M12 12v3"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/monitorIcon/dist/keystar-ui-icon-icons-monitorIcon.esm.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var monitorIcon = (0, import_jsx_runtime26.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime26.jsx)("rect", {
    width: 20,
    height: 14,
    x: 2,
    y: 3,
    rx: 2
  }), (0, import_jsx_runtime26.jsx)("path", {
    d: "M8 21h8M12 17v4"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/moonIcon/dist/keystar-ui-icon-icons-moonIcon.esm.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var moonIcon = (0, import_jsx_runtime27.jsx)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: (0, import_jsx_runtime27.jsx)("path", {
    d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"
  })
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/sunIcon/dist/keystar-ui-icon-icons-sunIcon.esm.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var sunIcon = (0, import_jsx_runtime28.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime28.jsx)("circle", {
    cx: 12,
    cy: 12,
    r: 4
  }), (0, import_jsx_runtime28.jsx)("path", {
    d: "M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"
  })]
});

// node_modules/.pnpm/@keystar+ui@0.4.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystar/ui/icon/icons/userIcon/dist/keystar-ui-icon-icons-userIcon.esm.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var userIcon = (0, import_jsx_runtime29.jsxs)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  width: "1em",
  height: "1em",
  children: [(0, import_jsx_runtime29.jsx)("path", {
    d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"
  }), (0, import_jsx_runtime29.jsx)("circle", {
    cx: 12,
    cy: 7,
    r: 4
  })]
});

// node_modules/.pnpm/@keystatic+core@0.2.4_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/ui/dist/keystatic-core-ui.esm.js
var import_mdast_util_from_markdown = __toESM(require_mdast_util_from_markdown());
var import_from_markdown = __toESM(require_from_markdown());
var import_micromark_extension_gfm_autolink_literal = __toESM(require_micromark_extension_gfm_autolink_literal());
var import_from_markdown2 = __toESM(require_from_markdown2());
var import_micromark_extension_gfm_strikethrough = __toESM(require_micromark_extension_gfm_strikethrough());
var import_cookie = __toESM(require_cookie());
var collator = new Intl.Collator(void 0, {
  sensitivity: "base"
});
function sortByDescriptor(sortDescriptor) {
  const key = sortDescriptor.column;
  assert(key != null, "`sortDescriptor.column` is required");
  return (a, b2) => {
    const valueA = a[key];
    const valueB = b2[key];
    const modifier = sortDescriptor.direction === "ascending" ? 1 : -1;
    if (valueA == null)
      return 1;
    if (valueB == null)
      return -1;
    if (typeof valueA === "string" && typeof valueB === "string") {
      return collator.compare(valueA, valueB) * modifier;
    }
    return compare(valueA, valueB) * modifier;
  };
}
function compare(a, b2) {
  if (a < b2)
    return -1;
  if (a > b2)
    return 1;
  return 0;
}
function EmptyState(props) {
  return (0, import_jsx_runtime30.jsx)(Flex, {
    alignItems: "center",
    direction: "column",
    gap: "large",
    justifyContent: "center",
    minHeight: "scale.3000",
    paddingX: {
      mobile: "medium",
      tablet: "xlarge",
      desktop: "xxlarge"
    },
    children: "children" in props ? props.children : (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
      children: [props.icon && (0, import_jsx_runtime30.jsx)(Icon, {
        src: props.icon,
        size: "large",
        color: "neutralEmphasis"
      }), props.title && (0, import_jsx_runtime30.jsx)(Heading, {
        align: "center",
        size: "medium",
        children: props.title
      }), props.message && (0, import_jsx_runtime30.jsx)(Text, {
        align: "center",
        children: props.message
      }), props.actions]
    })
  });
}
var NotFoundError = class extends Error {
  constructor() {
    super("Not found");
    this.name = "NotFoundError";
  }
};
function isNotFoundError(err) {
  return typeof err === "object" && err !== null && err instanceof NotFoundError;
}
function notFound() {
  throw new NotFoundError();
}
var NotFoundErrorBoundaryInner = class extends import_react15.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      notFound: false,
      lastHref: props.href
    };
  }
  static getDerivedStateFromError(err) {
    if (isNotFoundError(err)) {
      return {
        notFound: true
      };
    }
    throw err;
  }
  static getDerivedStateFromProps(props, state) {
    if (props.href !== state.lastHref && state.notFound) {
      return {
        notFound: false,
        lastHref: props.href
      };
    }
    return {
      notFound: state.notFound,
      lastHref: props.href
    };
  }
  render() {
    if (this.state.notFound)
      return this.props.fallback;
    return this.props.children;
  }
};
function NotFoundBoundary(props) {
  const router = useRouter();
  return (0, import_jsx_runtime30.jsx)(NotFoundErrorBoundaryInner, {
    ...props,
    href: router.href
  });
}
function CollectionPage(props) {
  var _config$collections;
  const {
    collection,
    config
  } = props;
  const containerWidth = "none";
  const collectionConfig = (_config$collections = config.collections) === null || _config$collections === void 0 ? void 0 : _config$collections[collection];
  if (!collectionConfig)
    notFound();
  const [searchTerm, setSearchTerm] = (0, import_react15.useState)("");
  let debouncedSearchTerm = useDebouncedValue(searchTerm, 300);
  return (0, import_jsx_runtime30.jsxs)(PageRoot, {
    containerWidth,
    children: [(0, import_jsx_runtime30.jsx)(CollectionPageHeader, {
      collectionLabel: collectionConfig.label,
      createHref: `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`,
      searchTerm,
      onSearchTermChange: setSearchTerm
    }), (0, import_jsx_runtime30.jsx)(CollectionPageContent, {
      searchTerm: debouncedSearchTerm,
      ...props
    })]
  });
}
function CollectionPageHeader(props) {
  const {
    collectionLabel,
    createHref
  } = props;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const isAboveMobile = useMediaQuery(breakpointQueries$1.above.mobile);
  const [searchVisible, setSearchVisible] = (0, import_react15.useState)(isAboveMobile);
  const searchRef = (0, import_react15.useRef)(null);
  (0, import_react15.useEffect)(() => {
    setSearchVisible(isAboveMobile);
  }, [isAboveMobile]);
  (0, import_react15.useEffect)(() => {
    const listener = (event) => {
      if (document.activeElement === searchRef.current) {
        return;
      }
      if ((0, import_is_hotkey.default)("mod+f", event)) {
        var _searchRef$current;
        event.preventDefault();
        (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 || _searchRef$current.select();
      }
    };
    document.addEventListener("keydown", listener);
    return () => document.removeEventListener("keydown", listener);
  }, []);
  return (0, import_jsx_runtime30.jsxs)(PageHeader, {
    children: [(0, import_jsx_runtime30.jsx)(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      flex: true,
      minWidth: 0,
      children: collectionLabel
    }), (0, import_jsx_runtime30.jsx)("div", {
      role: "search",
      style: {
        display: searchVisible ? "block" : "none"
      },
      children: (0, import_jsx_runtime30.jsx)(SearchField, {
        ref: searchRef,
        "aria-label": stringFormatter.format("search"),
        onChange: props.onSearchTermChange,
        onClear: () => {
          props.onSearchTermChange("");
          if (!isAboveMobile) {
            setTimeout(() => {
              setSearchVisible(false);
            }, 250);
          }
        },
        onBlur: () => {
          if (!isAboveMobile && props.searchTerm === "") {
            setSearchVisible(false);
          }
        },
        placeholder: stringFormatter.format("search"),
        value: props.searchTerm,
        width: "scale.2400"
      })
    }), (0, import_jsx_runtime30.jsx)(ActionButton, {
      "aria-label": "show search",
      isHidden: searchVisible || {
        above: "mobile"
      },
      onPress: () => {
        setSearchVisible(true);
        let tempInput = document.createElement("input");
        tempInput.style.position = "absolute";
        tempInput.style.opacity = "0";
        document.body.appendChild(tempInput);
        tempInput.focus();
        setTimeout(() => {
          var _searchRef$current2;
          (_searchRef$current2 = searchRef.current) === null || _searchRef$current2 === void 0 || _searchRef$current2.focus();
          tempInput.remove();
        }, 0);
      },
      children: (0, import_jsx_runtime30.jsx)(Icon, {
        src: searchIcon
      })
    }), (0, import_jsx_runtime30.jsx)(Button, {
      marginStart: "auto",
      prominence: "high",
      href: createHref,
      isHidden: searchVisible ? {
        below: "tablet"
      } : void 0,
      children: stringFormatter.format("add")
    })]
  });
}
function CollectionPageContent(props) {
  const trees = useTree();
  const tree = trees.merged.kind === "loaded" ? trees.merged.data.current.entries.get(getCollectionPath(props.config, props.collection)) : null;
  if (trees.merged.kind === "error") {
    return (0, import_jsx_runtime30.jsx)(EmptyState, {
      icon: alertCircleIcon,
      title: "Unable to load collection",
      message: trees.merged.error.message,
      actions: (0, import_jsx_runtime30.jsx)(Button, {
        tone: "accent",
        href: props.basePath,
        children: "Dashboard"
      })
    });
  }
  if (trees.merged.kind === "loading") {
    return (0, import_jsx_runtime30.jsx)(EmptyState, {
      children: (0, import_jsx_runtime30.jsx)(ProgressCircle, {
        "aria-label": "Loading Entries",
        isIndeterminate: true,
        size: "large"
      })
    });
  }
  if (!tree) {
    return (0, import_jsx_runtime30.jsx)(EmptyState, {
      icon: listXIcon,
      title: "Empty collection",
      message: (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
        children: ["There aren't any entries yet.", " ", (0, import_jsx_runtime30.jsx)(TextLink, {
          href: `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`,
          children: "Create the first entry"
        }), " ", "to see it here."]
      })
    });
  }
  return (0, import_jsx_runtime30.jsx)(CollectionTable, {
    ...props,
    trees: trees.merged.data
  });
}
function CollectionTable(props) {
  let {
    searchTerm
  } = props;
  let isLocalMode = isLocalConfig(props.config);
  let router = useRouter();
  let [sortDescriptor, setSortDescriptor] = (0, import_react15.useState)({
    column: "name",
    direction: "ascending"
  });
  const entriesWithStatus = (0, import_react15.useMemo)(() => {
    const defaultEntries = new Map(getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.default.tree).map((x2) => [x2.slug, x2.key]));
    return getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.current.tree).map((entry) => {
      return {
        name: entry.slug,
        status: defaultEntries.has(entry.slug) ? defaultEntries.get(entry.slug) === entry.key ? "Unchanged" : "Changed" : "Added"
      };
    });
  }, [props.collection, props.config, props.trees]);
  const filteredItems = (0, import_react15.useMemo)(() => {
    return entriesWithStatus.filter((item) => item.name.toLowerCase().includes(searchTerm.toLowerCase()));
  }, [entriesWithStatus, searchTerm]);
  const sortedItems = (0, import_react15.useMemo)(() => {
    return [...filteredItems].sort(sortByDescriptor(sortDescriptor));
  }, [filteredItems, sortDescriptor]);
  const columns = (0, import_react15.useMemo)(() => {
    return isLocalMode ? [{
      name: "Name",
      key: "name"
    }] : [{
      name: "Name",
      key: "name"
    }, {
      name: "Status",
      key: "status",
      minWidth: 140,
      width: "20%"
    }];
  }, [isLocalMode]);
  return (0, import_jsx_runtime30.jsxs)(TableView, {
    "aria-labelledby": "page-title",
    selectionMode: "none",
    onSortChange: setSortDescriptor,
    sortDescriptor,
    density: "spacious",
    overflowMode: "truncate",
    prominence: "low",
    onRowAction: (key) => {
      router.push(getItemPath(props.basePath, props.collection, key));
    },
    renderEmptyState: () => (0, import_jsx_runtime30.jsx)(EmptyState, {
      icon: searchXIcon,
      title: "No results",
      message: `No items matching "${searchTerm}" were found.`
    }),
    flex: true,
    marginTop: {
      tablet: "large"
    },
    marginBottom: {
      mobile: "regular",
      tablet: "xlarge"
    },
    UNSAFE_className: css({
      marginInline: tokenSchema.size.space.regular,
      [breakpointQueries$1.above.mobile]: {
        marginInline: `calc(${tokenSchema.size.space.xlarge} - ${tokenSchema.size.space.medium})`
      },
      [breakpointQueries$1.above.tablet]: {
        marginInline: `calc(${tokenSchema.size.space.xxlarge} - ${tokenSchema.size.space.medium})`
      },
      "[role=rowheader]": {
        cursor: "pointer"
      }
    }),
    children: [(0, import_jsx_runtime30.jsx)($312ae3b56a94a86e$export$f850895b287ef28e, {
      columns,
      children: ({
        name,
        key,
        ...options
      }) => (0, import_jsx_runtime30.jsx)(VoussoirColumn, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: name
      }, key)
    }), (0, import_jsx_runtime30.jsx)($4ae5314bf50db1a3$export$76ccd210b9029917, {
      items: sortedItems,
      children: (item) => isLocalMode ? (0, import_jsx_runtime30.jsx)($70d70eb16ea48428$export$b59bdbef9ce70de2, {
        children: (0, import_jsx_runtime30.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
          textValue: item.name,
          children: (0, import_jsx_runtime30.jsx)(Text, {
            weight: "medium",
            children: item.name
          })
        })
      }, item.name) : (0, import_jsx_runtime30.jsxs)($70d70eb16ea48428$export$b59bdbef9ce70de2, {
        children: [(0, import_jsx_runtime30.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
          textValue: item.name,
          children: (0, import_jsx_runtime30.jsx)(Text, {
            weight: "medium",
            children: item.name
          })
        }), (0, import_jsx_runtime30.jsx)($941d1d9a6a28982a$export$f6f0c3fe4ec306ea, {
          textValue: item.status,
          children: (0, import_jsx_runtime30.jsx)(StatusLight, {
            tone: statusTones[item.status],
            children: item.status
          })
        })]
      }, item.name)
    })]
  });
}
function getItemPath(basePath, collection, key) {
  return `${basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(key)}`;
}
function useDebouncedValue(value, delay = 300) {
  const [debouncedValue, setDebouncedValue] = (0, import_react15.useState)(value);
  (0, import_react15.useEffect)(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  return debouncedValue;
}
var statusTones = {
  Added: "positive",
  Changed: "accent",
  Unchanged: "neutral"
};
function BranchPicker() {
  const {
    allBranches,
    currentBranch,
    defaultBranch
  } = (0, import_react15.useContext)(BranchInfoContext);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const isMobile = useIsMobileDevice();
  const router = useRouter();
  const config = useConfig();
  const branchPrefix = getBranchPrefix(config);
  const items = (0, import_react15.useMemo)(() => {
    let defaultItems = allBranches.map((name) => ({
      id: name,
      name
    }));
    if (defaultBranch) {
      return [{
        id: defaultBranch,
        name: defaultBranch,
        description: stringFormatter.format("defaultBranch")
      }, ...defaultItems.filter((i) => i.name !== defaultBranch)];
    }
    return defaultItems;
  }, [allBranches, defaultBranch, stringFormatter]);
  const filteredBranches = (0, import_react15.useMemo)(() => items.filter((item) => item.name === defaultBranch || !branchPrefix || item.name.startsWith(branchPrefix) || item.name === currentBranch), [branchPrefix, currentBranch, defaultBranch, items]);
  return (0, import_jsx_runtime30.jsx)(_Combobox, {
    "aria-label": stringFormatter.format("currentBranch"),
    defaultItems: filteredBranches,
    loadingState: filteredBranches.length === 0 ? "loading" : void 0,
    selectedKey: currentBranch,
    onSelectionChange: (key) => {
      if (typeof key === "string") {
        router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(key)));
      }
    },
    menuTrigger: "focus",
    menuWidth: 232,
    UNSAFE_className: css({
      [comboboxClassList.selector("mobile-trigger")]: {
        minWidth: 100,
        width: "auto"
      }
    }),
    UNSAFE_style: isMobile ? void 0 : {
      width: currentBranch.length * 7 + 64
    },
    children: (item) => (0, import_jsx_runtime30.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
      textValue: item.name,
      children: [(0, import_jsx_runtime30.jsx)(Icon, {
        src: gitBranchIcon
      }), (0, import_jsx_runtime30.jsx)(Text, {
        truncate: true,
        children: item.name
      }), "description" in item && (0, import_jsx_runtime30.jsx)(Text, {
        slot: "description",
        children: item.description
      })]
    }, item.id)
  });
}
function CreateBranchDialog(props) {
  const config = useConfig();
  const branchInfo = (0, import_react15.useContext)(BranchInfoContext);
  const isDefaultBranch = branchInfo.defaultBranch === branchInfo.currentBranch;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const [{
    error,
    fetching
  }, createBranch] = useCreateBranchMutation();
  const repositoryId = useRepositoryId();
  const createBranchSubmitButtonId = "create-branch-submit-button";
  const [branchName, setBranchName] = (0, import_react15.useState)("");
  const [baseBranch, setBaseBranch] = (0, import_react15.useState)(branchInfo.defaultBranch);
  const branchPrefix = getBranchPrefix(config);
  const propsForBranchPrefix = branchPrefix ? {
    UNSAFE_className: css({
      "& input": {
        paddingInlineStart: tokenSchema.size.space.xsmall
      }
    }),
    startElement: (0, import_jsx_runtime30.jsx)(Flex, {
      alignItems: "center",
      paddingStart: "regular",
      justifyContent: "center",
      pointerEvents: "none",
      children: (0, import_jsx_runtime30.jsx)(Text, {
        color: "neutralSecondary",
        children: branchPrefix
      })
    })
  } : {};
  return (0, import_jsx_runtime30.jsx)(Dialog, {
    size: "small",
    children: (0, import_jsx_runtime30.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: async (event) => {
        var _result$data;
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        const fullBranchName = (branchPrefix !== null && branchPrefix !== void 0 ? branchPrefix : "") + branchName;
        const name = `refs/heads/${fullBranchName}`;
        const result = await createBranch({
          input: {
            name,
            oid: branchInfo.branchNameToBaseCommit.get(baseBranch),
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(fullBranchName);
        }
      },
      children: [(0, import_jsx_runtime30.jsx)(Heading, {
        children: stringFormatter.format("newBranch")
      }), (0, import_jsx_runtime30.jsx)(Content, {
        children: isDefaultBranch ? (0, import_jsx_runtime30.jsx)(TextField, {
          value: branchName,
          onChange: setBranchName,
          label: stringFormatter.format("branchName"),
          autoFocus: true,
          errorMessage: error === null || error === void 0 ? void 0 : error.message,
          ...propsForBranchPrefix
        }) : (0, import_jsx_runtime30.jsxs)(Grid, {
          gap: "xlarge",
          children: [(0, import_jsx_runtime30.jsx)(TextField, {
            label: stringFormatter.format("branchName"),
            value: branchName,
            onChange: setBranchName,
            autoFocus: true,
            errorMessage: error === null || error === void 0 ? void 0 : error.message,
            ...propsForBranchPrefix
          }), (0, import_jsx_runtime30.jsxs)(RadioGroup, {
            label: stringFormatter.format("basedOn"),
            value: baseBranch,
            onChange: setBaseBranch,
            children: [(0, import_jsx_runtime30.jsxs)(Radio, {
              value: branchInfo.defaultBranch,
              children: [(0, import_jsx_runtime30.jsxs)(Text, {
                children: [branchInfo.defaultBranch, (0, import_jsx_runtime30.jsx)(Text, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), (0, import_jsx_runtime30.jsx)(Text, {
                slot: "description",
                children: stringFormatter.format("theDefaultBranchInYourRepository")
              })]
            }), (0, import_jsx_runtime30.jsxs)(Radio, {
              value: branchInfo.currentBranch,
              children: [(0, import_jsx_runtime30.jsxs)(Text, {
                children: [branchInfo.currentBranch, (0, import_jsx_runtime30.jsx)(Text, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), (0, import_jsx_runtime30.jsx)(Text, {
                slot: "description",
                children: stringFormatter.format("theCurrentlyCheckedOutBranch")
              })]
            })]
          })]
        })
      }), (0, import_jsx_runtime30.jsx)(Footer, {
        UNSAFE_style: {
          justifyContent: "flex-end"
        },
        children: fetching && (0, import_jsx_runtime30.jsx)(ProgressCircle, {
          "aria-labelledby": createBranchSubmitButtonId,
          isIndeterminate: true,
          size: "small"
        })
      }), (0, import_jsx_runtime30.jsxs)(ButtonGroup, {
        children: [(0, import_jsx_runtime30.jsx)(Button, {
          onPress: props.onDismiss,
          isDisabled: fetching,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime30.jsx)(Button, {
          isDisabled: fetching,
          prominence: "high",
          type: "submit",
          id: createBranchSubmitButtonId,
          children: stringFormatter.format("create")
        })]
      })]
    })
  });
}
function useCreateBranchMutation() {
  return useMutation(lib_default`
      mutation CreateBranch($input: CreateRefInput!) {
        createRef(input: $input) {
          __typename
          ref {
            ...Ref_base
          }
        }
      }
      ${Ref_base}
    `);
}
var AppSlugContext = (0, import_react15.createContext)(void 0);
var AppSlugProvider = AppSlugContext.Provider;
function InstallGitHubApp(props) {
  var _URL$searchParams$get;
  const router = useRouter();
  const appSlugFromContext = (0, import_react15.useContext)(AppSlugContext);
  const appSlug = (_URL$searchParams$get = new URL(router.href, "https://example.com").searchParams.get("slug")) !== null && _URL$searchParams$get !== void 0 ? _URL$searchParams$get : appSlugFromContext === null || appSlugFromContext === void 0 ? void 0 : appSlugFromContext.value;
  const parsedRepo = parseRepoConfig(props.config.storage.repo);
  return (0, import_jsx_runtime30.jsxs)(Flex, {
    direction: "column",
    gap: "regular",
    children: [(0, import_jsx_runtime30.jsxs)(Flex, {
      alignItems: "end",
      gap: "regular",
      children: [(0, import_jsx_runtime30.jsx)(TextField, {
        label: "Repo Name",
        width: "100%",
        isReadOnly: true,
        value: parsedRepo.name
      }), (0, import_jsx_runtime30.jsx)(ActionButton, {
        onPress: () => {
          navigator.clipboard.writeText(parsedRepo.name);
        },
        children: "Copy Repo Name"
      })]
    }), appSlug ? (0, import_jsx_runtime30.jsx)(Button, {
      prominence: "high",
      href: `https://github.com/apps/${appSlug}/installations/new`,
      children: "Install GitHub App"
    }) : (0, import_jsx_runtime30.jsx)(Notice, {
      tone: "caution",
      children: appSlugFromContext ? (0, import_jsx_runtime30.jsxs)(Text, {
        children: ["The ", (0, import_jsx_runtime30.jsx)("code", {
          children: appSlugFromContext.envName
        }), " environment variable wasn't provided so we can't link to the GitHub app installation page. You should find the App on GitHub and add the repo yourself."]
      }) : (0, import_jsx_runtime30.jsx)(Text, {
        children: "Find the App on GitHub and add the repo."
      })
    })]
  });
}
function ForkRepoDialog(props) {
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const client = useClient();
  const [state, setState] = (0, import_react15.useState)({
    kind: "idle"
  });
  (0, import_react15.useEffect)(() => {
    const listener = async (event) => {
      if (event.key === "ks-refetch-installations" && event.newValue === "true") {
        localStorage.removeItem("ks-refetch-installations");
        try {
          var _res$data;
          const auth = await getAuth(props.config);
          if (!auth)
            throw new Error("Unauthorized");
          const res = await client.query(GitHubAppShellQuery, parseRepoConfig(props.config.storage.repo)).toPromise();
          if ((_res$data = res.data) !== null && _res$data !== void 0 && (_res$data = _res$data.repository) !== null && _res$data !== void 0 && (_res$data = _res$data.forks.nodes) !== null && _res$data !== void 0 && _res$data.some((x2) => (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "ADMIN" || (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "WRITE" || (x2 === null || x2 === void 0 ? void 0 : x2.viewerPermission) === "MAINTAIN")) {
            await new Promise((resolve) => setTimeout(resolve, 100));
            props.onCreate();
          }
        } catch (err) {
          setState({
            kind: "error",
            error: err
          });
        }
      }
    };
    addEventListener("storage", listener);
    return () => removeEventListener("storage", listener);
  }, [client, props]);
  const appSlug = (0, import_react15.useContext)(AppSlugContext);
  return (0, import_jsx_runtime30.jsxs)(Dialog, {
    size: "small",
    isDismissable: true,
    onDismiss: () => {
      props.onDismiss();
    },
    children: [(0, import_jsx_runtime30.jsx)(Heading, {
      children: "Fork Repo"
    }), state.kind === "error" ? (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
      children: [(0, import_jsx_runtime30.jsx)(Content, {
        children: (0, import_jsx_runtime30.jsx)(Notice, {
          tone: "critical",
          children: state.error.message
        })
      }), (0, import_jsx_runtime30.jsx)(ButtonGroup, {
        children: (0, import_jsx_runtime30.jsx)(Button, {
          onPress: props.onDismiss,
          children: stringFormatter.format("cancel")
        })
      })]
    }) : (0, import_jsx_runtime30.jsx)(import_jsx_runtime30.Fragment, {
      children: (0, import_jsx_runtime30.jsx)(Content, {
        children: (0, import_jsx_runtime30.jsxs)(Flex, {
          gap: "large",
          direction: "column",
          marginBottom: "large",
          children: [(0, import_jsx_runtime30.jsx)(Text, {
            children: "You don't have permission to write to this repo so to save your changes, you need to fork the repo."
          }), (0, import_jsx_runtime30.jsxs)(Text, {
            children: ["To start,", " ", (0, import_jsx_runtime30.jsx)(TextLink, {
              href: `https://github.com/${serializeRepoConfig(props.config.storage.repo)}/fork`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "fork the repo on GitHub"
            }), ". Then, come back to this page and", " ", (0, import_jsx_runtime30.jsx)(TextLink, {
              href: `https://github.com/apps/${appSlug === null || appSlug === void 0 ? void 0 : appSlug.value}/installations/new?state=close`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "install the Keystatic GitHub App on your fork."
            })]
          })]
        })
      })
    })]
  });
}
var _onGet;
var TrackedMap = class extends Map {
  constructor(onGet, entries) {
    super(entries);
    __privateAdd(this, _onGet, void 0);
    __privateSet(this, _onGet, onGet);
  }
  get(key) {
    __privateGet(this, _onGet).call(this, key);
    return super.get(key);
  }
};
_onGet = new WeakMap();
function parseEntry(args, files) {
  const dataFilepath = getEntryDataFilepath(args.dirpath, args.format);
  const data = files.get(dataFilepath);
  if (!data) {
    throw new Error(`Could not find data file at ${dataFilepath}`);
  }
  const {
    loaded,
    extraFakeFile
  } = loadDataFile(data, args.format);
  const filesWithFakeFile = new Map(files);
  if (extraFakeFile) {
    filesWithFakeFile.set(`${args.dirpath}/${extraFakeFile.path}`, extraFakeFile.contents);
  }
  const usedFiles = /* @__PURE__ */ new Set([dataFilepath]);
  const rootSchema = object(args.schema);
  let initialState;
  const getFile = (filepath) => {
    usedFiles.add(filepath);
    return filesWithFakeFile.get(filepath);
  };
  try {
    initialState = parseProps(rootSchema, loaded, [], [], (schema2, value, path, pathWithArrayFieldSlugs) => {
      var _args$slug;
      if (path.length === 1 && path[0] === ((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field)) {
        if (schema2.formKind !== "slug") {
          throw new Error(`slugField is not a slug field`);
        }
        return schema2.parse(value, {
          slug: args.slug.slug
        });
      }
      if (schema2.formKind === "asset") {
        var _args$slug2, _args$slug3, _args$slug4;
        const suggestedFilenamePrefix = pathWithArrayFieldSlugs.join("/");
        const filepath = schema2.filename(value, {
          suggestedFilenamePrefix,
          slug: (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.slug
        });
        const asset = filepath ? getFile(`${schema2.directory ? `${schema2.directory}${((_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.slug) === void 0 ? "" : `/${args.slug.slug}`}` : args.dirpath}/${filepath}`) : void 0;
        return schema2.parse(value, {
          asset,
          slug: (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.slug
        });
      }
      if (schema2.formKind === "content") {
        var _args$slug7;
        const rootPath = `${args.dirpath}/${pathWithArrayFieldSlugs.join("/")}`;
        const mainFilepath = rootPath + schema2.contentExtension;
        const mainContents = getFile(mainFilepath);
        const otherFiles = new TrackedMap((key) => {
          usedFiles.add(`${rootPath}/${key}`);
        });
        const otherDirectories = /* @__PURE__ */ new Map();
        for (const [filename] of filesWithFakeFile) {
          if (filename.startsWith(rootPath + "/")) {
            const relativePath = filename.slice(rootPath.length + 1);
            otherFiles.set(relativePath, filesWithFakeFile.get(filename));
          }
        }
        for (const dir of (_schema$directories = schema2.directories) !== null && _schema$directories !== void 0 ? _schema$directories : []) {
          var _schema$directories, _args$slug5, _args$slug6;
          const dirFiles = new TrackedMap((relativePath) => usedFiles.add(start + relativePath));
          const start = `${dir}${((_args$slug5 = args.slug) === null || _args$slug5 === void 0 ? void 0 : _args$slug5.slug) === void 0 ? "" : `/${(_args$slug6 = args.slug) === null || _args$slug6 === void 0 ? void 0 : _args$slug6.slug}`}/`;
          for (const [filename, val] of filesWithFakeFile) {
            if (filename.startsWith(start)) {
              const relativePath = filename.slice(start.length);
              dirFiles.set(relativePath, val);
            }
          }
          if (dirFiles.size) {
            otherDirectories.set(dir, dirFiles);
          }
        }
        return schema2.parse(value, {
          content: mainContents,
          other: otherFiles,
          external: otherDirectories,
          slug: (_args$slug7 = args.slug) === null || _args$slug7 === void 0 ? void 0 : _args$slug7.slug
        });
      }
      return schema2.parse(value, void 0);
    }, false);
  } catch (err) {
    throw toFormattedFormDataError(err);
  }
  if (extraFakeFile) {
    usedFiles.delete(`${args.dirpath}/${extraFakeFile.path}`);
  }
  return {
    initialState,
    initialFiles: [...usedFiles]
  };
}
function getAllFilesInTree(tree) {
  return [...tree.values()].flatMap((val) => val.children ? getAllFilesInTree(val.children) : [val.entry]);
}
function useItemData(args) {
  var _args$slug9;
  const {
    current: currentBranch
  } = useTree();
  const baseCommit = useBaseCommit();
  const isRepoPrivate = useIsRepoPrivate();
  const branchInfo = useBranchInfo();
  const rootTree = currentBranch.kind === "loaded" ? currentBranch.data.tree : void 0;
  const locationsForTreeKey = (0, import_react15.useMemo)(() => {
    var _args$slug8;
    return getDirectoriesForTreeKey(object(args.schema), args.dirpath, (_args$slug8 = args.slug) === null || _args$slug8 === void 0 ? void 0 : _args$slug8.slug, args.format);
  }, [args.dirpath, args.format, args.schema, (_args$slug9 = args.slug) === null || _args$slug9 === void 0 ? void 0 : _args$slug9.slug]);
  const localTreeKey = (0, import_react15.useMemo)(() => getTreeKey(locationsForTreeKey, rootTree !== null && rootTree !== void 0 ? rootTree : /* @__PURE__ */ new Map()), [locationsForTreeKey, rootTree]);
  const tree = (0, import_react15.useMemo)(() => {
    return rootTree !== null && rootTree !== void 0 ? rootTree : /* @__PURE__ */ new Map();
  }, [localTreeKey, locationsForTreeKey]);
  const hasLoaded = currentBranch.kind === "loaded";
  return useData((0, import_react15.useCallback)(() => {
    var _getTreeNodeAtPath;
    if (!hasLoaded)
      return LOADING;
    const dataFilepathSha = (_getTreeNodeAtPath = getTreeNodeAtPath(tree, getEntryDataFilepath(args.dirpath, args.format))) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
    if (dataFilepathSha === void 0) {
      return "not-found";
    }
    const _args = {
      config: args.config,
      dirpath: args.dirpath,
      format: args.format,
      schema: args.schema,
      slug: args.slug
    };
    const allBlobs = locationsForTreeKey.flatMap((dir) => {
      const node = getTreeNodeAtPath(tree, dir);
      if (!node)
        return [];
      return node.children ? getAllFilesInTree(node.children) : [node.entry];
    }).map((entry) => {
      const blob = fetchBlob(args.config, entry.sha, entry.path, baseCommit, isRepoPrivate, {
        owner: branchInfo.mainOwner,
        name: branchInfo.mainRepo
      });
      if (blob instanceof Uint8Array) {
        return [entry.path, blob];
      }
      return blob.then((blob2) => [entry.path, blob2]);
    });
    if (allBlobs.every((x2) => Array.isArray(x2))) {
      const {
        initialFiles,
        initialState
      } = parseEntry(_args, new Map(allBlobs));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    }
    return Promise.all(allBlobs).then(async (data) => {
      const {
        initialState,
        initialFiles
      } = parseEntry(_args, new Map(data));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    });
  }, [hasLoaded, tree, args.dirpath, args.format, args.config, args.schema, args.slug, locationsForTreeKey, baseCommit, isRepoPrivate, branchInfo.mainOwner, branchInfo.mainRepo, localTreeKey]));
}
var blobCache = new lru_cache_default({
  max: 200
});
async function hydrateBlobCache(contents) {
  const sha = await blobSha(contents);
  blobCache.set(sha, contents);
  return sha;
}
async function fetchGitHubBlob(config, oid, filepath, commitSha, isRepoPrivate, repo) {
  if (!isRepoPrivate) {
    var _getPathPrefix;
    return fetch(`https://raw.githubusercontent.com/${serializeRepoConfig(repo)}/${commitSha}/${(_getPathPrefix = getPathPrefix(config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : ""}${filepath}`);
  }
  const auth = await getAuth(config);
  return fetch(config.storage.kind === "github" ? `https://api.github.com/repos/${serializeRepoConfig(config.storage.repo)}/git/blobs/${oid}` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/blob/${oid}`, {
    headers: {
      Authorization: `Bearer ${auth.accessToken}`,
      Accept: "application/vnd.github.raw",
      ...config.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
    }
  });
}
function fetchBlob(config, oid, filepath, commitSha, isRepoPrivate, repo) {
  if (blobCache.has(oid))
    return blobCache.get(oid);
  const promise = (isGitHubConfig(config) || config.storage.kind === "cloud" ? fetchGitHubBlob(config, oid, filepath, commitSha, isRepoPrivate, repo) : fetch(`/api/keystatic/blob/${oid}/${filepath}`, {
    headers: {
      "no-cors": "1"
    }
  })).then((x2) => x2.arrayBuffer()).then((x2) => {
    const array = new Uint8Array(x2);
    blobCache.set(oid, array);
    return array;
  }).catch((err) => {
    blobCache.delete(oid);
    throw err;
  });
  blobCache.set(oid, promise);
  return promise;
}
var ThemeContext = (0, import_react15.createContext)({
  theme: "auto",
  setTheme: () => {
    throw new Error("ThemeContext was not initialized.");
  }
});
var ThemeProvider = ThemeContext.Provider;
var STORAGE_KEY = "keystatic-color-scheme";
function useTheme() {
  let [theme, setThemeValue] = (0, import_react15.useState)(() => {
    let storedValue = localStorage.getItem(STORAGE_KEY);
    if (storedValue === "light" || storedValue === "dark") {
      return storedValue;
    }
    return "auto";
  });
  let setTheme = (theme2) => {
    localStorage.setItem(STORAGE_KEY, theme2);
    setThemeValue(theme2);
  };
  return {
    theme,
    setTheme
  };
}
function useThemeContext() {
  return (0, import_react15.useContext)(ThemeContext);
}
injectGlobal({
  body: {
    overflow: "hidden"
  }
});
function createUrqlClient(config) {
  const repo = config.storage.kind === "github" ? parseRepoConfig(config.storage.repo) : {
    owner: "repo-owner",
    name: "repo-name"
  };
  return j({
    url: config.storage.kind === "github" ? "https://api.github.com/graphql" : `${KEYSTATIC_CLOUD_API_URL}/v1/github/graphql`,
    requestPolicy: "cache-and-network",
    exchanges: [authExchange(async (utils) => {
      let authState = await getAuth(config);
      return {
        addAuthToOperation(operation) {
          authState = getSyncAuth(config);
          if (!authState) {
            return operation;
          }
          return utils.appendHeaders(operation, {
            Authorization: `Bearer ${authState.accessToken}`,
            ...config.storage.kind === "cloud" ? KEYSTATIC_CLOUD_HEADERS : {}
          });
        },
        didAuthError() {
          return false;
        },
        willAuthError(operation) {
          var _operation$query$defi;
          authState = getSyncAuth(config);
          if (operation.query.definitions[0].kind === "OperationDefinition" && (_operation$query$defi = operation.query.definitions[0].name) !== null && _operation$query$defi !== void 0 && _operation$query$defi.value.includes("AppShell") && !authState) {
            if (config.storage.kind === "github") {
              window.location.href = "/api/keystatic/github/login";
            } else {
              redirectToCloudAuth("", config);
            }
            return true;
          }
          if (!authState) {
            return true;
          }
          return false;
        },
        async refreshAuth() {
          authState = await getAuth(config);
        }
      };
    }), cacheExchange({
      updates: {
        Mutation: {
          createRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, (data) => {
              var _data$repository;
              if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && (_data$repository = _data$repository.refs) !== null && _data$repository !== void 0 && _data$repository.nodes && result.createRef && typeof result.createRef === "object" && "ref" in result.createRef) {
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: [...data.repository.refs.nodes, result.createRef.ref]
                    }
                  }
                };
              }
              return data;
            });
          },
          deleteRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === "github" ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, (data) => {
              var _data$repository2;
              if (data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && (_data$repository2 = _data$repository2.refs) !== null && _data$repository2 !== void 0 && _data$repository2.nodes && result.deleteRef && typeof result.deleteRef === "object" && "__typename" in result.deleteRef && typeof args.input === "object" && args.input !== null && "refId" in args.input && typeof args.input.refId === "string") {
                const refId = args.input.refId;
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: data.repository.refs.nodes.filter((x2) => (x2 === null || x2 === void 0 ? void 0 : x2.id) !== refId)
                    }
                  }
                };
              }
              return data;
            });
          }
        }
      }
    }), ...config.storage.kind === "github" ? [] : [persistedExchange({
      enableForMutation: true,
      enforcePersistedQueries: true
    })], fetchExchange]
  });
}
function Provider({
  children,
  config
}) {
  const themeContext = useTheme();
  const {
    push: navigate
  } = useRouter();
  const keystarRouter = (0, import_react15.useMemo)(() => ({
    navigate
  }), [navigate]);
  return (0, import_jsx_runtime30.jsx)(ThemeProvider, {
    value: themeContext,
    children: (0, import_jsx_runtime30.jsxs)(KeystarProvider, {
      locale: config.locale || "en-US",
      colorScheme: themeContext.theme,
      router: keystarRouter,
      children: [(0, import_jsx_runtime30.jsx)(ClientSideOnlyDocumentElement, {}), (0, import_jsx_runtime30.jsx)("link", {
        href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap",
        rel: "stylesheet"
      }), (0, import_jsx_runtime30.jsx)(f, {
        value: (0, import_react15.useMemo)(() => createUrqlClient(config), [config]),
        children
      }), (0, import_jsx_runtime30.jsx)(Toaster, {})]
    })
  });
}
var textEncoder2 = new TextEncoder();
var frontmatterSplit = textEncoder2.encode("---\n");
function combineFrontmatterAndContents(frontmatter, contents) {
  const array = new Uint8Array(frontmatter.byteLength + contents.byteLength + frontmatterSplit.byteLength * 2);
  array.set(frontmatterSplit);
  array.set(frontmatter, frontmatterSplit.byteLength);
  array.set(frontmatterSplit, frontmatterSplit.byteLength + frontmatter.byteLength);
  array.set(contents, frontmatterSplit.byteLength * 2 + frontmatter.byteLength);
  return array;
}
function serializeEntryToFiles(args) {
  var _args$slug, _args$slug2;
  let {
    value: stateWithExtraFilesRemoved,
    extraFiles
  } = serializeProps(args.state, object(args.schema), (_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field, (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.value, true);
  const dataFormat = args.format.data;
  let dataContent = textEncoder2.encode(dataFormat === "json" ? JSON.stringify(stateWithExtraFilesRemoved, null, 2) + "\n" : dump(stateWithExtraFilesRemoved));
  if (args.format.contentField) {
    const filename = `${args.format.contentField.key}${args.format.contentField.config.contentExtension}`;
    let contents;
    extraFiles = extraFiles.filter((x2) => {
      if (x2.path !== filename)
        return true;
      contents = x2.contents;
      return false;
    });
    assert(contents !== void 0, "Expected content field to be present");
    dataContent = combineFrontmatterAndContents(dataContent, contents);
  }
  return [{
    path: getEntryDataFilepath(args.basePath, args.format),
    contents: dataContent
  }, ...extraFiles.map((file) => ({
    path: `${file.parent ? args.slug ? `${file.parent}/${args.slug.value}` : file.parent : args.basePath}/${file.path}`,
    contents: file.contents
  }))];
}
function useUpsertItem(args) {
  const [state, setState] = (0, import_react15.useState)({
    kind: "idle"
  });
  const baseCommit = useBaseCommit();
  const branchInfo = (0, import_react15.useContext)(BranchInfoContext);
  const setTreeSha = useSetTreeSha();
  const [, mutate] = useMutation(createCommitMutation);
  const repoWithWriteAccess = (0, import_react15.useContext)(RepoWithWriteAccessContext);
  const appSlug = (0, import_react15.useContext)(AppSlugContext);
  const unscopedTreeData = useCurrentUnscopedTree();
  return [state, async (override) => {
    try {
      var _getPathPrefix, _args$initialFiles;
      const unscopedTree = unscopedTreeData.kind === "loaded" ? unscopedTreeData.data.tree : void 0;
      if (!unscopedTree)
        return false;
      if (repoWithWriteAccess === null && args.config.storage.kind === "github" && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: "needs-fork"
        });
        return false;
      }
      setState({
        kind: "loading"
      });
      const pathPrefix = (_getPathPrefix = getPathPrefix(args.config.storage)) !== null && _getPathPrefix !== void 0 ? _getPathPrefix : "";
      let additions = serializeEntryToFiles({
        basePath: args.basePath,
        config: args.config,
        schema: args.schema,
        format: args.format,
        state: args.state,
        slug: args.slug
      }).map((addition) => ({
        ...addition,
        path: pathPrefix + addition.path
      }));
      const additionPathToSha = new Map(await Promise.all(additions.map(async (addition) => [addition.path, await hydrateBlobCache(addition.contents)])));
      const filesToDelete = new Set((_args$initialFiles = args.initialFiles) === null || _args$initialFiles === void 0 ? void 0 : _args$initialFiles.map((x2) => pathPrefix + x2));
      for (const file of additions) {
        filesToDelete.delete(file.path);
      }
      additions = additions.filter((addition) => {
        const sha = additionPathToSha.get(addition.path);
        const existing = getTreeNodeAtPath(unscopedTree, addition.path);
        return (existing === null || existing === void 0 ? void 0 : existing.entry.sha) !== sha;
      });
      const deletions = [...filesToDelete].map((path) => ({
        path
      }));
      const updatedTree = await updateTreeWithChanges(unscopedTree, {
        additions,
        deletions: [...filesToDelete]
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.config.storage.kind === "github" || args.config.storage.kind === "cloud") {
        var _override$branch, _override$sha, _result$error, _result$data;
        const branch = {
          branchName: (_override$branch = override === null || override === void 0 ? void 0 : override.branch) !== null && _override$branch !== void 0 ? _override$branch : branchInfo.currentBranch,
          repositoryNameWithOwner: `${repoWithWriteAccess.owner}/${repoWithWriteAccess.name}`
        };
        const runMutation = (expectedHeadOid) => mutate({
          input: {
            branch,
            expectedHeadOid,
            message: {
              headline: `Update ${args.basePath}`
            },
            fileChanges: {
              additions: additions.map((addition) => ({
                ...addition,
                contents: fromUint8Array(addition.contents)
              })),
              deletions
            }
          }
        });
        let result = await runMutation((_override$sha = override === null || override === void 0 ? void 0 : override.sha) !== null && _override$sha !== void 0 ? _override$sha : baseCommit);
        const gqlError = (_result$error = result.error) === null || _result$error === void 0 || (_result$error = _result$error.graphQLErrors[0]) === null || _result$error === void 0 ? void 0 : _result$error.originalError;
        if (gqlError && "type" in gqlError) {
          if (gqlError.type === "BRANCH_PROTECTION_RULE_VIOLATION") {
            setState({
              kind: "needs-new-branch",
              reason: "Changes must be made via pull request to this branch. Create a new branch to save changes."
            });
            return false;
          }
          if (gqlError.type === "STALE_DATA") {
            var _refData$data, _args$slug3;
            const refData = await createUrqlClient(args.config).query(FetchRef, {
              owner: repoWithWriteAccess.owner,
              name: repoWithWriteAccess.name,
              ref: `refs/heads/${branchInfo.currentBranch}`
            }).toPromise();
            if (!((_refData$data = refData.data) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.repository) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.ref) !== null && _refData$data !== void 0 && _refData$data.target)) {
              throw new Error("Branch not found");
            }
            const tree = scopeEntriesWithPathPrefix(await fetchGitHubTreeData(refData.data.repository.ref.target.oid, args.config), args.config);
            const treeKey = getTreeKey(getDirectoriesForTreeKey(object(args.schema), args.basePath, (_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.value, args.format), tree.tree);
            if (treeKey === args.currentLocalTreeKey) {
              result = await runMutation(refData.data.repository.ref.target.oid);
            } else {
              setState({
                kind: "needs-new-branch",
                reason: "This entry has been updated since it was opened. Create a new branch to save changes."
              });
              return false;
            }
          }
        }
        if (result.error) {
          throw result.error;
        }
        const target = (_result$data = result.data) === null || _result$data === void 0 || (_result$data = _result$data.createCommitOnBranch) === null || _result$data === void 0 || (_result$data = _result$data.ref) === null || _result$data === void 0 ? void 0 : _result$data.target;
        if (target) {
          setState({
            kind: "updated"
          });
          return true;
        }
        throw new Error("Failed to update");
      } else {
        const res = await fetch("/api/keystatic/update", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "no-cors": "1"
          },
          body: JSON.stringify({
            additions: additions.map((addition) => ({
              ...addition,
              contents: fromUint8Array(addition.contents)
            })),
            deletions
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: "updated"
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: "error",
        error: err
      });
      return false;
    }
  }, () => {
    setState({
      kind: "idle"
    });
  }];
}
var createCommitMutation = lib_default`
  mutation CreateCommit($input: CreateCommitOnBranchInput!) {
    createCommitOnBranch(input: $input) {
      ref {
        id
        target {
          id
          oid
          ... on Commit {
            tree {
              id
              oid
            }
          }
        }
      }
    }
  }
`;
function useDeleteItem(args) {
  const [state, setState] = (0, import_react15.useState)({
    kind: "idle"
  });
  const baseCommit = useBaseCommit();
  const branchInfo = (0, import_react15.useContext)(BranchInfoContext);
  const [, mutate] = useMutation(createCommitMutation);
  const setTreeSha = useSetTreeSha();
  const repoWithWriteAccess = (0, import_react15.useContext)(RepoWithWriteAccessContext);
  const appSlug = (0, import_react15.useContext)(AppSlugContext);
  const unscopedTreeData = useCurrentUnscopedTree();
  return [state, async () => {
    try {
      const unscopedTree = unscopedTreeData.kind === "loaded" ? unscopedTreeData.data.tree : void 0;
      if (!unscopedTree)
        return false;
      if (repoWithWriteAccess === null && args.storage.kind === "github" && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: "needs-fork"
        });
        return false;
      }
      setState({
        kind: "loading"
      });
      const deletions = args.initialFiles.map((x2) => {
        var _getPathPrefix2;
        return ((_getPathPrefix2 = getPathPrefix(args.storage)) !== null && _getPathPrefix2 !== void 0 ? _getPathPrefix2 : "") + x2;
      });
      const updatedTree = await updateTreeWithChanges(unscopedTree, {
        additions: [],
        deletions
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.storage.kind === "github" || args.storage.kind === "cloud") {
        const {
          error
        } = await mutate({
          input: {
            branch: {
              repositoryNameWithOwner: `${repoWithWriteAccess.owner}/${repoWithWriteAccess.name}`,
              branchName: branchInfo.currentBranch
            },
            message: {
              headline: `Delete ${args.basePath}`
            },
            expectedHeadOid: baseCommit,
            fileChanges: {
              deletions: deletions.map((path) => ({
                path
              }))
            }
          }
        });
        if (error) {
          throw error;
        }
        setState({
          kind: "updated"
        });
        return true;
      } else {
        const res = await fetch("/api/keystatic/update", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "no-cors": "1"
          },
          body: JSON.stringify({
            additions: [],
            deletions: deletions.map((path) => ({
              path
            }))
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: "updated"
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: "error",
        error: err
      });
    }
  }, () => {
    setState({
      kind: "idle"
    });
  }];
}
var FetchRef = lib_default`
  query FetchRef($owner: String!, $name: String!, $ref: String!) {
    repository(owner: $owner, name: $name) {
      id
      ref(qualifiedName: $ref) {
        id
        target {
          id
          oid
        }
      }
    }
  }
`;
function useHasChanged(args) {
  const serialize = (0, import_react15.useCallback)((state) => {
    const slug = args.slugField ? getSlugFromState({
      schema: args.schema.fields,
      slugField: args.slugField
    }, state) : void 0;
    return {
      slug,
      state: serializeProps(state, args.schema, args.slugField, slug, true)
    };
  }, [args.schema, args.slugField]);
  const initialFilesForUpdate = (0, import_react15.useMemo)(() => args.initialState === null ? null : serialize(args.initialState), [args.initialState, serialize]);
  const filesForUpdate = (0, import_react15.useMemo)(() => serialize(args.state), [serialize, args.state]);
  return (0, import_react15.useMemo)(() => {
    return !(0, import_fast_deep_equal.default)(initialFilesForUpdate, filesForUpdate);
  }, [initialFilesForUpdate, filesForUpdate]);
}
function useSlugFieldInfo(collection, slugToExclude) {
  const config = useConfig();
  const allSlugs = useSlugsInCollection(collection);
  return (0, import_react15.useMemo)(() => {
    const slugs = new Set(allSlugs);
    if (slugToExclude) {
      slugs.delete(slugToExclude);
    }
    const collectionConfig = config.collections[collection];
    return {
      field: collectionConfig.slugField,
      slugs,
      glob: getSlugGlobForCollection(config, collection)
    };
  }, [allSlugs, collection, config, slugToExclude]);
}
var units = {
  seconds: 60,
  minutes: 60,
  hours: 24,
  days: 7,
  weeks: 4,
  months: 12,
  years: Infinity
};
function formatTimeAgo(targetDate, currentDate, formatter) {
  let duration = (targetDate.getTime() - currentDate.getTime()) / 1e3;
  for (const [name, amount] of Object.entries(units)) {
    if (Math.abs(duration) < amount) {
      return formatter.format(Math.round(duration), name);
    }
    duration /= amount;
  }
  return "unknown";
}
function RelativeTime(props) {
  const {
    locale
  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();
  const [now] = (0, import_react15.useState)(() => /* @__PURE__ */ new Date());
  const formatted = (0, import_react15.useMemo)(() => {
    const formatter = new Intl.RelativeTimeFormat(locale);
    formatter.format(props.date.getTime() - now.getTime(), "second");
    return formatTimeAgo(props.date, now, formatter);
  }, [locale, now, props.date]);
  return (0, import_jsx_runtime30.jsx)("time", {
    dateTime: props.date.toISOString(),
    children: formatted
  });
}
function showDraftRestoredToast(savedAt, hasChangedSince) {
  toastQueue.info((0, import_jsx_runtime30.jsxs)(Text, {
    children: ["Restored draft from ", (0, import_jsx_runtime30.jsx)(RelativeTime, {
      date: savedAt
    }), ".", " ", hasChangedSince && (0, import_jsx_runtime30.jsx)(Text, {
      color: "accent",
      children: "Other changes have been made to this entry since the draft. You may want to discard the draft changes."
    })]
  }), {
    timeout: 8e3
  });
}
var store;
function getStore() {
  if (!store) {
    store = createStore("keystatic", "items");
  }
  return store;
}
function setDraft(key, val) {
  return set2(key, val, getStore());
}
function delDraft(key) {
  return del(key, getStore());
}
function getDraft(key) {
  return get(key, getStore());
}
var storedValSchema$1 = z.object({
  version: z.literal(1),
  savedAt: z.date(),
  slug: z.string(),
  beforeTreeKey: z.string(),
  files: z.map(z.string(), z.instanceof(Uint8Array))
});
function ItemPage(props) {
  var _draft$state;
  const {
    collection,
    config,
    itemSlug,
    initialFiles,
    initialState,
    localTreeKey,
    draft
  } = props;
  const router = useRouter();
  const [forceValidation, setForceValidation] = (0, import_react15.useState)(false);
  const collectionConfig = config.collections[collection];
  const schema2 = (0, import_react15.useMemo)(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const [{
    state,
    localTreeKey: localTreeKeyInState
  }, setState] = (0, import_react15.useState)({
    state: (_draft$state = draft === null || draft === void 0 ? void 0 : draft.state) !== null && _draft$state !== void 0 ? _draft$state : initialState,
    localTreeKey
  });
  (0, import_react15.useEffect)(() => {
    if (draft && state === draft.state) {
      showDraftRestoredToast(draft.savedAt, localTreeKey !== draft.treeKey);
    }
  }, [draft]);
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      state: initialState,
      localTreeKey
    });
  }
  const previewProps = (0, import_react15.useMemo)(() => createGetPreviewProps(schema2, (stateUpdater) => {
    setState((state2) => ({
      localTreeKey: state2.localTreeKey,
      state: stateUpdater(state2.state)
    }));
  }, () => void 0), [schema2])(state);
  const hasChanged = useHasChanged({
    initialState,
    schema: schema2,
    state,
    slugField: collectionConfig.slugField
  });
  const baseCommit = useBaseCommit();
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(config, collection);
  const currentBasePath = getCollectionItemPath(config, collection, itemSlug);
  const futureBasePath = getCollectionItemPath(config, collection, slug);
  const branchInfo = useBranchInfo();
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: collectionConfig.schema,
    basePath: futureBasePath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  (0, import_react15.useEffect)(() => {
    const key = ["collection", collection, props.itemSlug];
    if (hasChanged) {
      const serialized = serializeEntryToFiles({
        basePath: futureBasePath,
        config,
        format: getCollectionFormat(config, collection),
        schema: collectionConfig.schema,
        slug: {
          field: collectionConfig.slugField,
          value: slug
        },
        state
      });
      const files = new Map(serialized.map((x2) => [x2.path, x2.contents]));
      const data = {
        beforeTreeKey: localTreeKey,
        slug,
        files,
        savedAt: /* @__PURE__ */ new Date(),
        version: 1
      };
      setDraft(key, data);
    } else {
      delDraft(key);
    }
  }, [collection, collectionConfig, config, futureBasePath, localTreeKey, props.itemSlug, slug, state, hasChanged]);
  const update = useEventCallback(_update);
  const [deleteResult, deleteItem, resetDeleteItem] = useDeleteItem({
    initialFiles,
    storage: config.storage,
    basePath: currentBasePath
  });
  const onReset = () => {
    setState({
      state: initialState,
      localTreeKey
    });
  };
  const viewHref = config.storage.kind !== "local" ? `${getRepoUrl(branchInfo)}${formatInfo.dataLocation === "index" ? `/tree/${branchInfo.currentBranch}/${getPathPrefix(config.storage)}${currentBasePath}` : `/blob/${branchInfo.currentBranch}/${getPathPrefix(config.storage)}${currentBasePath}${getDataFileExtension(formatInfo)}`}` : void 0;
  const previewHref = (0, import_react15.useMemo)(() => {
    return collectionConfig.previewUrl ? collectionConfig.previewUrl.replace("{slug}", props.itemSlug).replace("{branch}", branchInfo.currentBranch) : void 0;
  }, [branchInfo.currentBranch, collectionConfig.previewUrl, props.itemSlug]);
  const onDelete = async () => {
    if (await deleteItem()) {
      router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
    }
  };
  const onDuplicate = async () => {
    let hasUpdated = true;
    if (hasChanged) {
      hasUpdated = await onUpdate();
    }
    if (hasUpdated) {
      router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}/create?duplicate=${slug}`);
    }
  };
  const slugInfo = useSlugFieldInfo(collection, itemSlug);
  const onUpdate = (0, import_react15.useCallback)(async () => {
    if (!clientSideValidateProp(schema2, state, slugInfo)) {
      setForceValidation(true);
      return false;
    }
    const slug2 = getSlugFromState(collectionConfig, state);
    const hasUpdated = await update();
    if (hasUpdated && slug2 !== itemSlug) {
      router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug2)}`);
    }
    return hasUpdated;
  }, [collection, collectionConfig, itemSlug, props.basePath, router, schema2, slugInfo, state, update]);
  const formID = "item-edit-form";
  (0, import_react15.useEffect)(() => {
    const listener = (event) => {
      if (updateResult.kind === "loading") {
        return;
      }
      if ((0, import_is_hotkey.default)("mod+s", event)) {
        event.preventDefault();
        onUpdate();
      }
    };
    document.addEventListener("keydown", listener);
    return () => document.removeEventListener("keydown", listener);
  }, [updateResult.kind, onUpdate]);
  return (0, import_jsx_runtime30.jsx)(import_jsx_runtime30.Fragment, {
    children: (0, import_jsx_runtime30.jsxs)(ItemPageShell, {
      headerActions: (0, import_jsx_runtime30.jsx)(HeaderActions, {
        formID,
        isLoading: updateResult.kind === "loading",
        hasChanged,
        onDelete,
        onDuplicate,
        onReset,
        viewHref,
        previewHref
      }),
      ...props,
      children: [updateResult.kind === "error" && (0, import_jsx_runtime30.jsx)(Notice, {
        tone: "critical",
        children: updateResult.error.message
      }), deleteResult.kind === "error" && (0, import_jsx_runtime30.jsx)(Notice, {
        tone: "critical",
        children: deleteResult.error.message
      }), (0, import_jsx_runtime30.jsx)(Box, {
        id: formID,
        height: "100%",
        minHeight: 0,
        minWidth: 0,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget)
            return;
          event.preventDefault();
          onUpdate();
        },
        children: (0, import_jsx_runtime30.jsx)(FormForEntry, {
          previewProps,
          forceValidation,
          entryLayout: collectionConfig.entryLayout,
          formatInfo,
          slugField: slugInfo
        })
      }), (0, import_jsx_runtime30.jsx)(
        DialogContainer,
        {
          onDismiss: resetUpdateItem,
          children: updateResult.kind === "needs-new-branch" && (0, import_jsx_runtime30.jsx)(CreateBranchDuringUpdateDialog, {
            branchOid: baseCommit,
            onCreate: async (newBranch) => {
              const itemBasePath = `/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(collection)}/item/`;
              router.push(itemBasePath + encodeURIComponent(itemSlug));
              const slug2 = getSlugFromState(collectionConfig, state);
              const hasUpdated = await update({
                branch: newBranch,
                sha: baseCommit
              });
              if (hasUpdated && slug2 !== itemSlug) {
                router.replace(itemBasePath + encodeURIComponent(slug2));
              }
            },
            reason: updateResult.reason,
            onDismiss: resetUpdateItem
          })
        }
      ), (0, import_jsx_runtime30.jsx)(
        DialogContainer,
        {
          onDismiss: resetUpdateItem,
          children: updateResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime30.jsx)(ForkRepoDialog, {
            onCreate: async () => {
              const slug2 = getSlugFromState(collectionConfig, state);
              const hasUpdated = await update();
              if (hasUpdated && slug2 !== itemSlug) {
                router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug2)}`);
              }
            },
            onDismiss: resetUpdateItem,
            config: props.config
          })
        }
      ), (0, import_jsx_runtime30.jsx)(
        DialogContainer,
        {
          onDismiss: resetDeleteItem,
          children: deleteResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime30.jsx)(ForkRepoDialog, {
            onCreate: async () => {
              await deleteItem();
              router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
            },
            onDismiss: resetDeleteItem,
            config: props.config
          })
        }
      )]
    })
  });
}
function HeaderActions(props) {
  let {
    formID,
    hasChanged,
    isLoading,
    onDelete,
    onDuplicate,
    onReset,
    previewHref,
    viewHref
  } = props;
  const isBelowTablet = useMediaQuery(breakpointQueries$1.below.tablet);
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const [deleteAlertIsOpen, setDeleteAlertOpen] = (0, import_react15.useState)(false);
  const [duplicateAlertIsOpen, setDuplicateAlertOpen] = (0, import_react15.useState)(false);
  const menuActions = (0, import_react15.useMemo)(() => {
    let items = [{
      key: "reset",
      label: "Reset changes",
      // TODO: l10n
      icon: historyIcon
    }, {
      key: "delete",
      label: "Delete entry…",
      // TODO: l10n
      icon: trash2Icon
    }, {
      key: "duplicate",
      label: "Duplicate entry…",
      // TODO: l10n
      icon: copyPlusIcon
    }];
    if (previewHref) {
      items.push({
        key: "preview",
        label: "Preview",
        icon: externalLinkIcon,
        href: previewHref,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    if (viewHref) {
      items.push({
        key: "view",
        label: "View on GitHub",
        icon: githubIcon,
        href: viewHref,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    return items;
  }, [previewHref, viewHref]);
  const indicatorElement = (() => {
    if (isLoading) {
      return (0, import_jsx_runtime30.jsx)(ProgressCircle, {
        "aria-label": "Saving changes",
        isIndeterminate: true,
        size: "small",
        alignSelf: "center"
      });
    }
    if (hasChanged) {
      return isBelowTablet ? (0, import_jsx_runtime30.jsx)(Box, {
        backgroundColor: "pendingEmphasis",
        height: "scale.75",
        width: "scale.75",
        borderRadius: "full",
        children: (0, import_jsx_runtime30.jsx)(Text, {
          visuallyHidden: true,
          children: "Unsaved"
        })
      }) : (0, import_jsx_runtime30.jsx)(Badge, {
        tone: "pending",
        children: "Unsaved"
      });
    }
    return null;
  })();
  return (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
    children: [indicatorElement, (0, import_jsx_runtime30.jsx)(_ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: isBelowTablet ? "element.regular" : void 0,
      items: menuActions,
      disabledKeys: hasChanged ? [] : ["reset"],
      onAction: (key) => {
        switch (key) {
          case "reset":
            onReset();
            break;
          case "delete":
            setDeleteAlertOpen(true);
            break;
          case "duplicate":
            if (hasChanged) {
              setDuplicateAlertOpen(true);
            } else {
              onDuplicate();
            }
            break;
        }
      },
      children: (item) => (0, import_jsx_runtime30.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: item.label,
        href: item.href,
        target: item.target,
        rel: item.rel,
        children: [(0, import_jsx_runtime30.jsx)(Icon, {
          src: item.icon
        }), (0, import_jsx_runtime30.jsx)(Text, {
          children: item.label
        })]
      }, item.key)
    }), (0, import_jsx_runtime30.jsx)(Button, {
      form: formID,
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      children: stringFormatter.format("save")
    }), (0, import_jsx_runtime30.jsx)(DialogContainer, {
      onDismiss: () => setDeleteAlertOpen(false),
      children: deleteAlertIsOpen && (0, import_jsx_runtime30.jsx)(AlertDialog, {
        title: "Delete entry",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: onDelete,
        children: "Are you sure? This action cannot be undone."
      })
    }), (0, import_jsx_runtime30.jsx)(DialogContainer, {
      onDismiss: () => setDuplicateAlertOpen(false),
      children: duplicateAlertIsOpen && (0, import_jsx_runtime30.jsx)(AlertDialog, {
        title: "Save and duplicate entry",
        tone: "neutral",
        cancelLabel: "Cancel",
        primaryActionLabel: "Save and duplicate",
        autoFocusButton: "primary",
        onPrimaryAction: onDuplicate,
        children: "You have unsaved changes. Save this entry to duplicate it."
      })
    })]
  });
}
function CreateBranchDuringUpdateDialog(props) {
  var _data$createRef;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const repositoryId = useRepositoryId();
  const [branchName, setBranchName] = (0, import_react15.useState)("");
  const [{
    error,
    fetching,
    data
  }, createBranch] = useCreateBranchMutation();
  const isLoading = fetching || !!(data !== null && data !== void 0 && (_data$createRef = data.createRef) !== null && _data$createRef !== void 0 && _data$createRef.__typename);
  const config = useConfig();
  const branchPrefix = getBranchPrefix(config);
  const propsForBranchPrefix = branchPrefix ? {
    UNSAFE_className: css({
      "& input": {
        paddingInlineStart: tokenSchema.size.space.xsmall
      }
    }),
    startElement: (0, import_jsx_runtime30.jsx)(Flex, {
      alignItems: "center",
      paddingStart: "regular",
      justifyContent: "center",
      pointerEvents: "none",
      children: (0, import_jsx_runtime30.jsx)(Text, {
        color: "neutralSecondary",
        children: branchPrefix
      })
    })
  } : {};
  return (0, import_jsx_runtime30.jsx)(Dialog, {
    children: (0, import_jsx_runtime30.jsxs)("form", {
      style: {
        display: "contents"
      },
      onSubmit: async (event) => {
        var _result$data;
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        const fullBranchName = (branchPrefix !== null && branchPrefix !== void 0 ? branchPrefix : "") + branchName;
        const name = `refs/heads/${fullBranchName}`;
        const result = await createBranch({
          input: {
            name,
            oid: props.branchOid,
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(fullBranchName);
        }
      },
      children: [(0, import_jsx_runtime30.jsx)(Heading, {
        children: stringFormatter.format("newBranch")
      }), (0, import_jsx_runtime30.jsx)(Content, {
        children: (0, import_jsx_runtime30.jsx)(Flex, {
          gap: "large",
          direction: "column",
          children: (0, import_jsx_runtime30.jsx)(TextField, {
            value: branchName,
            onChange: setBranchName,
            label: "Branch name",
            description: props.reason,
            autoFocus: true,
            errorMessage: error === null || error === void 0 ? void 0 : error.message,
            ...propsForBranchPrefix
          })
        })
      }), (0, import_jsx_runtime30.jsxs)(ButtonGroup, {
        children: [isLoading && (0, import_jsx_runtime30.jsx)(ProgressCircle, {
          isIndeterminate: true,
          size: "small",
          "aria-label": "Creating Branch"
        }), (0, import_jsx_runtime30.jsx)(Button, {
          isDisabled: isLoading,
          onPress: props.onDismiss,
          children: stringFormatter.format("cancel")
        }), (0, import_jsx_runtime30.jsx)(Button, {
          isDisabled: isLoading,
          prominence: "high",
          type: "submit",
          children: "Create branch and save"
        })]
      })]
    })
  });
}
function ItemPageWrapper(props) {
  var _props$config$collect;
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig)
    notFound();
  const format = (0, import_react15.useMemo)(() => getCollectionFormat(props.config, props.collection), [props.config, props.collection]);
  const slugInfo = (0, import_react15.useMemo)(() => {
    return {
      slug: props.itemSlug,
      field: collectionConfig.slugField
    };
  }, [collectionConfig.slugField, props.itemSlug]);
  const draftData = useData((0, import_react15.useCallback)(async () => {
    const raw = await getDraft(["collection", props.collection, props.itemSlug]);
    if (!raw)
      throw new Error("No draft found");
    const stored = storedValSchema$1.parse(raw);
    const parsed = parseEntry({
      config: props.config,
      dirpath: getCollectionItemPath(props.config, props.collection, stored.slug),
      format,
      schema: collectionConfig.schema,
      slug: {
        field: collectionConfig.slugField,
        slug: stored.slug
      }
    }, stored.files);
    return {
      state: parsed.initialState,
      savedAt: stored.savedAt,
      treeKey: stored.beforeTreeKey
    };
  }, [collectionConfig, format, props.collection, props.config, props.itemSlug]));
  const itemData = useItemData({
    config: props.config,
    dirpath: getCollectionItemPath(props.config, props.collection, props.itemSlug),
    schema: collectionConfig.schema,
    format,
    slug: slugInfo
  });
  if (itemData.kind === "error") {
    return (0, import_jsx_runtime30.jsx)(ItemPageShell, {
      ...props,
      children: (0, import_jsx_runtime30.jsx)(PageBody, {
        children: (0, import_jsx_runtime30.jsx)(Notice, {
          tone: "critical",
          children: itemData.error.message
        })
      })
    });
  }
  if (itemData.kind === "loading" || draftData.kind === "loading") {
    return (0, import_jsx_runtime30.jsx)(ItemPageShell, {
      ...props,
      children: (0, import_jsx_runtime30.jsx)(Flex, {
        alignItems: "center",
        justifyContent: "center",
        minHeight: "scale.3000",
        children: (0, import_jsx_runtime30.jsx)(ProgressCircle, {
          "aria-label": "Loading Item",
          isIndeterminate: true,
          size: "large"
        })
      })
    });
  }
  if (itemData.data === "not-found") {
    return (0, import_jsx_runtime30.jsx)(ItemPageShell, {
      ...props,
      children: (0, import_jsx_runtime30.jsx)(PageBody, {
        children: (0, import_jsx_runtime30.jsx)(Notice, {
          tone: "caution",
          children: "Entry not found."
        })
      })
    });
  }
  const loadedDraft = draftData.kind === "loaded" ? draftData.data : void 0;
  return (0, import_jsx_runtime30.jsx)(ItemPage, {
    collection: props.collection,
    basePath: props.basePath,
    config: props.config,
    itemSlug: props.itemSlug,
    initialState: itemData.data.initialState,
    initialFiles: itemData.data.initialFiles,
    draft: loadedDraft,
    localTreeKey: itemData.data.localTreeKey
  });
}
var ItemPageShell = (props) => {
  const router = useRouter();
  const collectionConfig = props.config.collections[props.collection];
  return (0, import_jsx_runtime30.jsxs)(PageRoot, {
    containerWidth: containerWidthForEntryLayout(collectionConfig),
    children: [(0, import_jsx_runtime30.jsxs)(PageHeader, {
      children: [(0, import_jsx_runtime30.jsxs)(_Breadcrumbs, {
        flex: true,
        size: "medium",
        minWidth: 0,
        onAction: (key) => {
          if (key === "collection") {
            router.push(`${props.basePath}/collection/${encodeURIComponent(props.collection)}`);
          }
        },
        children: [(0, import_jsx_runtime30.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          children: collectionConfig.label
        }, "collection"), (0, import_jsx_runtime30.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          children: props.itemSlug
        }, "item")]
      }), props.headerActions]
    }), props.children]
  });
};
function CreateItemWrapper(props) {
  var _props$config$collect;
  const router = useRouter();
  const duplicateSlug = (0, import_react15.useMemo)(() => {
    const url = new URL(router.href, "http://localhost");
    return url.searchParams.get("duplicate");
  }, [router.href]);
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig)
    notFound();
  const format = (0, import_react15.useMemo)(() => getCollectionFormat(props.config, props.collection), [props.config, props.collection]);
  const slug = (0, import_react15.useMemo)(() => {
    if (duplicateSlug) {
      return {
        field: collectionConfig.slugField,
        slug: duplicateSlug
      };
    }
  }, [duplicateSlug, collectionConfig.slugField]);
  const itemData = useItemData({
    config: props.config,
    dirpath: getCollectionItemPath(props.config, props.collection, duplicateSlug !== null && duplicateSlug !== void 0 ? duplicateSlug : ""),
    schema: collectionConfig.schema,
    format,
    slug
  });
  const duplicateInitalState = duplicateSlug && itemData.kind === "loaded" && itemData.data !== "not-found" ? itemData.data.initialState : void 0;
  const duplicateInitalStateWithUpdatedSlug = (0, import_react15.useMemo)(() => {
    if (duplicateInitalState) {
      let slugFieldValue = duplicateInitalState[collectionConfig.slugField];
      try {
        const slugFieldSchema = collectionConfig.schema[collectionConfig.slugField];
        if (slugFieldSchema.kind !== "form" || slugFieldSchema.formKind !== "slug") {
          throw new Error("not slug field");
        }
        const serialized = slugFieldSchema.serializeWithSlug(slugFieldValue);
        slugFieldValue = slugFieldSchema.parse(serialized.value, {
          slug: `${serialized.slug}-copy`
        });
      } catch {
      }
      return {
        ...duplicateInitalState,
        [collectionConfig.slugField]: slugFieldValue
      };
    }
  }, [collectionConfig.schema, collectionConfig.slugField, duplicateInitalState]);
  if (duplicateSlug && itemData.kind === "error") {
    return (0, import_jsx_runtime30.jsx)(PageBody, {
      children: (0, import_jsx_runtime30.jsx)(Notice, {
        tone: "critical",
        children: itemData.error.message
      })
    });
  }
  if (duplicateSlug && itemData.kind === "loading") {
    return (0, import_jsx_runtime30.jsx)(Flex, {
      alignItems: "center",
      justifyContent: "center",
      minHeight: "scale.3000",
      children: (0, import_jsx_runtime30.jsx)(ProgressCircle, {
        "aria-label": "Loading Item",
        isIndeterminate: true,
        size: "large"
      })
    });
  }
  if (duplicateSlug && itemData.kind === "loaded" && itemData.data === "not-found") {
    return (0, import_jsx_runtime30.jsx)(PageBody, {
      children: (0, import_jsx_runtime30.jsx)(Notice, {
        tone: "caution",
        children: "Entry not found."
      })
    });
  }
  return (0, import_jsx_runtime30.jsx)(CreateItem, {
    collection: props.collection,
    config: props.config,
    basePath: props.basePath,
    initialState: duplicateInitalStateWithUpdatedSlug
  });
}
function CreateItem(props) {
  var _props$config$collect2;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const router = useRouter();
  const collectionConfig = (_props$config$collect2 = props.config.collections) === null || _props$config$collect2 === void 0 ? void 0 : _props$config$collect2[props.collection];
  if (!collectionConfig)
    notFound();
  const [forceValidation, setForceValidation] = (0, import_react15.useState)(false);
  const schema2 = (0, import_react15.useMemo)(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const [state, setState] = (0, import_react15.useState)(() => {
    var _props$initialState;
    return (_props$initialState = props.initialState) !== null && _props$initialState !== void 0 ? _props$initialState : getInitialPropsValue(schema2);
  });
  const previewProps = (0, import_react15.useMemo)(() => createGetPreviewProps(schema2, setState, () => void 0), [schema2])(state);
  const baseCommit = useBaseCommit();
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(props.config, props.collection);
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem({
    state,
    basePath: getCollectionItemPath(props.config, props.collection, slug),
    initialFiles: void 0,
    config: props.config,
    schema: collectionConfig.schema,
    format: formatInfo,
    currentLocalTreeKey: void 0,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  const createItem = useEventCallback(_createItem);
  let collectionPath = `${props.basePath}/collection/${encodeURIComponent(props.collection)}`;
  const currentSlug = createResult.kind === "updated" || createResult.kind === "loading" ? slug : void 0;
  const slugInfo = useSlugFieldInfo(props.collection, currentSlug);
  const onCreate = async () => {
    if (!clientSideValidateProp(schema2, state, slugInfo)) {
      setForceValidation(true);
      return;
    }
    if (await createItem()) {
      const slug2 = getSlugFromState(collectionConfig, state);
      router.push(`${collectionPath}/item/${encodeURIComponent(slug2)}`);
      toastQueue.positive("Entry created", {
        timeout: 5e3
      });
    }
  };
  const isLoading = createResult.kind === "loading" || createResult.kind === "updated";
  const formID = "item-create-form";
  return (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
    children: [(0, import_jsx_runtime30.jsxs)(PageRoot, {
      containerWidth: containerWidthForEntryLayout(collectionConfig),
      children: [(0, import_jsx_runtime30.jsxs)(PageHeader, {
        children: [(0, import_jsx_runtime30.jsxs)(_Breadcrumbs, {
          size: "medium",
          flex: true,
          minWidth: 0,
          onAction: (key) => {
            if (key === "collection") {
              router.push(collectionPath);
            }
          },
          children: [(0, import_jsx_runtime30.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
            children: collectionConfig.label
          }, "collection"), (0, import_jsx_runtime30.jsx)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
            children: stringFormatter.format("add")
          }, "current")]
        }), isLoading && (0, import_jsx_runtime30.jsx)(ProgressCircle, {
          "aria-label": "Creating entry",
          isIndeterminate: true,
          size: "small"
        }), (0, import_jsx_runtime30.jsx)(Button, {
          isDisabled: isLoading,
          prominence: "high",
          type: "submit",
          form: formID,
          marginStart: "auto",
          children: stringFormatter.format("create")
        })]
      }), (0, import_jsx_runtime30.jsxs)(Flex, {
        id: formID,
        elementType: "form",
        onSubmit: (event) => {
          if (event.target !== event.currentTarget)
            return;
          event.preventDefault();
          onCreate();
        },
        direction: "column",
        gap: "xxlarge",
        height: "100%",
        minHeight: 0,
        minWidth: 0,
        children: [createResult.kind === "error" && (0, import_jsx_runtime30.jsx)(Notice, {
          tone: "critical",
          children: createResult.error.message
        }), (0, import_jsx_runtime30.jsx)(FormForEntry, {
          previewProps,
          forceValidation,
          entryLayout: collectionConfig.entryLayout,
          formatInfo,
          slugField: slugInfo
        })]
      })]
    }), (0, import_jsx_runtime30.jsx)(
      DialogContainer,
      {
        onDismiss: resetCreateItemState,
        children: createResult.kind === "needs-new-branch" && (0, import_jsx_runtime30.jsx)(CreateBranchDuringUpdateDialog, {
          branchOid: baseCommit,
          onCreate: async (newBranch) => {
            router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/create`);
            if (await createItem({
              branch: newBranch,
              sha: baseCommit
            })) {
              const slug2 = getSlugFromState(collectionConfig, state);
              router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/item/${encodeURIComponent(slug2)}`);
            }
          },
          reason: createResult.reason,
          onDismiss: resetCreateItemState
        })
      }
    ), (0, import_jsx_runtime30.jsx)(
      DialogContainer,
      {
        onDismiss: resetCreateItemState,
        children: createResult.kind === "needs-fork" && isGitHubConfig(props.config) && (0, import_jsx_runtime30.jsx)(ForkRepoDialog, {
          onCreate: async () => {
            if (await createItem()) {
              const slug2 = getSlugFromState(collectionConfig, state);
              router.push(`${collectionPath}/item/${encodeURIComponent(slug2)}`);
            }
          },
          onDismiss: resetCreateItemState,
          config: props.config
        })
      }
    )]
  });
}
var DashboardSection = ({
  children,
  title
}) => {
  return (0, import_jsx_runtime30.jsxs)(Flex, {
    elementType: "section",
    direction: "column",
    gap: "medium",
    children: [(0, import_jsx_runtime30.jsx)(Text, {
      casing: "uppercase",
      color: "neutralTertiary",
      size: "small",
      weight: "bold",
      elementType: "h2",
      children: title
    }), children]
  });
};
var FILL_COLS = "fill";
var DashboardGrid = (props) => {
  return (0, import_jsx_runtime30.jsx)("div", {
    className: css({
      display: "grid",
      gap: tokenSchema.size.space.large,
      gridAutoRows: tokenSchema.size.element.xlarge,
      gridTemplateColumns: `[${FILL_COLS}-start] 1fr [${FILL_COLS}-end]`,
      [containerQueries.above.mobile]: {
        gridTemplateColumns: `[${FILL_COLS}-start] 1fr 1fr [${FILL_COLS}-end]`
      },
      [containerQueries.above.tablet]: {
        gridTemplateColumns: `[${FILL_COLS}-start] 1fr 1fr 1fr [${FILL_COLS}-end]`
      }
    }),
    ...props
  });
};
var DashboardCard = (props) => {
  const ref = (0, import_react15.useRef)(null);
  const {
    linkProps
  } = $298d61e98472621b$export$dcf14c9974fe2767(props, ref);
  return (0, import_jsx_runtime30.jsxs)(Flex, {
    alignItems: "center",
    backgroundColor: "canvas",
    padding: "large",
    position: "relative",
    children: [(0, import_jsx_runtime30.jsxs)(Flex, {
      direction: "column",
      gap: "medium",
      flex: true,
      children: [(0, import_jsx_runtime30.jsx)(Heading, {
        elementType: "h3",
        size: "small",
        truncate: true,
        children: (0, import_jsx_runtime30.jsx)("a", {
          ref,
          href: props.href,
          ...linkProps,
          className: classNames(css({
            color: tokenSchema.color.foreground.neutral,
            outline: "none",
            "&:hover": {
              color: tokenSchema.color.foreground.neutralEmphasis,
              "::before": {
                backgroundColor: tokenSchema.color.alias.backgroundIdle,
                borderColor: tokenSchema.color.border.neutral
              }
            },
            "&:active": {
              "::before": {
                backgroundColor: tokenSchema.color.alias.backgroundHovered,
                borderColor: tokenSchema.color.alias.borderHovered
              }
            },
            "&:focus-visible::before": {
              outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`,
              outlineOffset: tokenSchema.size.alias.focusRingGap
            },
            // fill the available space so that the card is clickable
            "::before": {
              border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`,
              borderRadius: tokenSchema.size.radius.medium,
              content: '""',
              position: "absolute",
              inset: 0,
              transition: transition(["background-color", "border-color"])
            }
          })),
          children: props.label
        })
      }), props.children]
    }), props.endElement]
  });
};
function useLocalizedString() {
  let stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  return stringFormatter;
}
function BranchSection(props) {
  let branchInfo = useBranchInfo();
  let router = useRouter();
  let localizedString = useLocalizedString();
  if (isLocalConfig(props.config)) {
    return null;
  }
  let repoURL = getRepoUrl(branchInfo);
  let isDefaultBranch = branchInfo.currentBranch === branchInfo.defaultBranch;
  return (0, import_jsx_runtime30.jsxs)(DashboardSection, {
    title: localizedString.format("currentBranch"),
    children: [(0, import_jsx_runtime30.jsxs)(Flex, {
      alignItems: "center",
      gap: "regular",
      border: "muted",
      borderRadius: "medium",
      backgroundColor: "canvas",
      padding: "large",
      children: [(0, import_jsx_runtime30.jsx)(Icon, {
        src: gitBranchIcon,
        color: "neutralTertiary"
      }), (0, import_jsx_runtime30.jsx)(Text, {
        size: "medium",
        weight: "semibold",
        children: branchInfo.currentBranch
      })]
    }), (0, import_jsx_runtime30.jsxs)(Flex, {
      gap: "regular",
      wrap: true,
      children: [(0, import_jsx_runtime30.jsxs)(_DialogTrigger, {
        children: [(0, import_jsx_runtime30.jsxs)(ActionButton, {
          children: [(0, import_jsx_runtime30.jsx)(Icon, {
            src: gitBranchPlusIcon
          }), (0, import_jsx_runtime30.jsx)(Text, {
            children: localizedString.format("newBranch")
          })]
        }), (close) => (0, import_jsx_runtime30.jsx)(CreateBranchDialog, {
          onDismiss: close,
          onCreate: (branchName) => {
            close();
            router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(branchName)));
          }
        })]
      }), !isDefaultBranch && (branchInfo.pullRequestNumber === void 0 ? (0, import_jsx_runtime30.jsxs)(ActionButton, {
        href: `${repoURL}/pull/new/${branchInfo.currentBranch}`,
        target: "_blank",
        children: [(0, import_jsx_runtime30.jsx)(Icon, {
          src: gitPullRequestIcon
        }), (0, import_jsx_runtime30.jsx)(Text, {
          children: localizedString.format("createPullRequest")
        })]
      }) : (0, import_jsx_runtime30.jsxs)(ActionButton, {
        href: `${repoURL}/pull/${branchInfo.pullRequestNumber}`,
        target: "_blank",
        children: [(0, import_jsx_runtime30.jsx)(Icon, {
          src: gitPullRequestIcon
        }), (0, import_jsx_runtime30.jsxs)(Text, {
          children: ["Pull request #", branchInfo.pullRequestNumber]
        })]
      }))]
    })]
  });
}
function DashboardCards() {
  const navItems = useNavItems();
  const hasSections = navItems.some((item) => "children" in item);
  const items = navItems.map((item) => renderItemOrGroup(item));
  return hasSections ? (0, import_jsx_runtime30.jsx)(import_jsx_runtime30.Fragment, {
    children: items
  }) : (0, import_jsx_runtime30.jsx)(DashboardSection, {
    title: "Content",
    children: (0, import_jsx_runtime30.jsx)(DashboardGrid, {
      children: items
    })
  });
}
var dividerCount = 0;
function renderItemOrGroup(itemOrGroup) {
  if ("isDivider" in itemOrGroup) {
    return (0, import_jsx_runtime30.jsx)(Flex, {
      gridColumn: FILL_COLS,
      children: (0, import_jsx_runtime30.jsx)(Divider, {
        alignSelf: "center",
        size: "medium",
        width: "alias.singleLineWidth"
      })
    }, dividerCount++);
  }
  if ("children" in itemOrGroup) {
    return (0, import_jsx_runtime30.jsx)(DashboardSection, {
      title: itemOrGroup.title,
      children: (0, import_jsx_runtime30.jsx)(DashboardGrid, {
        children: itemOrGroup.children.map((child) => renderItemOrGroup(child))
      })
    }, itemOrGroup.title);
  }
  let changeElement = (() => {
    if (!itemOrGroup.changed) {
      return void 0;
    }
    return typeof itemOrGroup.changed === "number" ? (0, import_jsx_runtime30.jsx)(Badge, {
      tone: "accent",
      marginStart: "auto",
      children: pluralize(itemOrGroup.changed, {
        singular: "change",
        plural: "changes"
      })
    }) : (0, import_jsx_runtime30.jsx)(Badge, {
      tone: "accent",
      children: "Changed"
    });
  })();
  let endElement = (() => {
    if (typeof itemOrGroup.entryCount !== "number") {
      return changeElement;
    }
    return (0, import_jsx_runtime30.jsxs)(Flex, {
      gap: "medium",
      alignItems: "center",
      children: [changeElement, (0, import_jsx_runtime30.jsx)(ActionButton, {
        "aria-label": "Add",
        href: `${itemOrGroup.href}/create`,
        children: (0, import_jsx_runtime30.jsx)(Icon, {
          src: plusIcon
        })
      })]
    });
  })();
  return (0, import_jsx_runtime30.jsx)(DashboardCard, {
    label: itemOrGroup.label,
    href: itemOrGroup.href,
    endElement,
    children: typeof itemOrGroup.entryCount === "number" ? (0, import_jsx_runtime30.jsx)(Text, {
      color: "neutralSecondary",
      children: pluralize(itemOrGroup.entryCount, {
        singular: "entry",
        plural: "entries"
      })
    }) : null
  }, itemOrGroup.key);
}
function DashboardPage(props) {
  var _viewer$name;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const viewer = useViewer();
  const cloudInfo = useCloudInfo();
  const user = viewer ? {
    name: (_viewer$name = viewer.name) !== null && _viewer$name !== void 0 ? _viewer$name : viewer.login,
    avatarUrl: viewer.avatarUrl
  } : cloudInfo === null || cloudInfo === void 0 ? void 0 : cloudInfo.user;
  return (0, import_jsx_runtime30.jsxs)(PageRoot, {
    containerWidth: "large",
    children: [(0, import_jsx_runtime30.jsx)(PageHeader, {
      children: (0, import_jsx_runtime30.jsx)(Heading, {
        elementType: "h1",
        id: "page-title",
        size: "small",
        children: stringFormatter.format("dashboard")
      })
    }), (0, import_jsx_runtime30.jsx)(PageBody, {
      isScrollable: true,
      children: (0, import_jsx_runtime30.jsxs)(Flex, {
        direction: "column",
        gap: "xxlarge",
        children: [user && (0, import_jsx_runtime30.jsx)(UserInfo, {
          user,
          manageAccount: !!cloudInfo
        }), (0, import_jsx_runtime30.jsx)(BranchSection, {
          config: props.config
        }), (0, import_jsx_runtime30.jsx)(DashboardCards, {})]
      })
    })]
  });
}
function UserInfo({
  user,
  manageAccount
}) {
  return (0, import_jsx_runtime30.jsxs)(Flex, {
    alignItems: "center",
    gap: "medium",
    isHidden: {
      below: "tablet"
    },
    children: [(0, import_jsx_runtime30.jsx)(Avatar, {
      src: user.avatarUrl,
      name: user.name,
      size: "large"
    }), (0, import_jsx_runtime30.jsxs)(VStack, {
      gap: "medium",
      children: [(0, import_jsx_runtime30.jsxs)(Heading, {
        size: "medium",
        elementType: "p",
        UNSAFE_style: {
          fontWeight: tokenSchema.typography.fontWeight.bold
        },
        children: ["Hello, ", user.name, "!"]
      }), manageAccount && (0, import_jsx_runtime30.jsx)(TextLink, {
        href: "https://keystatic.cloud/account",
        children: "Manage Account"
      })]
    })]
  });
}
var TopBar = () => {
  let config = useConfig();
  if (isCloudConfig(config)) {
    return (0, import_jsx_runtime30.jsx)(CloudHeader, {});
  }
  if (isGitHubConfig(config)) {
    return (0, import_jsx_runtime30.jsx)(GithubHeader, {});
  }
  if (isLocalConfig(config)) {
    return (0, import_jsx_runtime30.jsx)(LocalHeader, {});
  }
  throw new Error("Unknown config type.");
};
function CloudHeader() {
  const cloudInfo = useCloudInfo();
  return (0, import_jsx_runtime30.jsxs)(HeaderOuter, {
    children: [(0, import_jsx_runtime30.jsx)(BrandButton, {}), (0, import_jsx_runtime30.jsx)(BranchPicker, {}), (0, import_jsx_runtime30.jsx)(GitMenu, {}), (0, import_jsx_runtime30.jsx)(Box, {
      flex: "1"
    }), (0, import_jsx_runtime30.jsx)(ImageLibraryButton, {}), (0, import_jsx_runtime30.jsx)(ThemeMenu, {}), (0, import_jsx_runtime30.jsx)(UserMenu, {
      user: cloudInfo ? {
        name: cloudInfo.user.name,
        login: cloudInfo.user.email,
        avatarUrl: cloudInfo.user.avatarUrl
      } : void 0
    })]
  });
}
function ImageLibraryButton() {
  const cloudInfo = useCloudInfo();
  const imageLibraryUrl = useImageLibraryURL();
  if (!(cloudInfo !== null && cloudInfo !== void 0 && cloudInfo.team.images)) {
    return null;
  }
  return (0, import_jsx_runtime30.jsxs)(ActionButton, {
    prominence: "low",
    href: imageLibraryUrl,
    target: "_blank",
    children: [(0, import_jsx_runtime30.jsx)(Icon, {
      src: imageIcon
    }), (0, import_jsx_runtime30.jsx)(Text, {
      visuallyHidden: {
        below: "tablet"
      },
      children: "Image library"
    })]
  });
}
function GithubHeader() {
  var _user$name;
  const user = useViewer();
  return (0, import_jsx_runtime30.jsxs)(HeaderOuter, {
    children: [(0, import_jsx_runtime30.jsx)(BrandButton, {}), (0, import_jsx_runtime30.jsx)(BranchPicker, {}), (0, import_jsx_runtime30.jsx)(GitMenu, {}), (0, import_jsx_runtime30.jsx)(Box, {
      flex: "1"
    }), (0, import_jsx_runtime30.jsx)(ThemeMenu, {}), (0, import_jsx_runtime30.jsx)(UserMenu, {
      user: user ? {
        login: user.login,
        name: (_user$name = user.name) !== null && _user$name !== void 0 ? _user$name : user.login,
        avatarUrl: user.avatarUrl
      } : void 0
    })]
  });
}
function LocalHeader() {
  const config = useConfig();
  const rawCloudInfo = useRawCloudInfo();
  const router = useRouter();
  return (0, import_jsx_runtime30.jsxs)(HeaderOuter, {
    children: [(0, import_jsx_runtime30.jsx)(BrandButton, {}), (0, import_jsx_runtime30.jsx)(Box, {
      flex: "1"
    }), (0, import_jsx_runtime30.jsx)(ImageLibraryButton, {}), (0, import_jsx_runtime30.jsx)(ThemeMenu, {}), rawCloudInfo ? rawCloudInfo === "unauthorized" ? (0, import_jsx_runtime30.jsx)(ActionButton, {
      onPress: () => {
        redirectToCloudAuth(router.params.join("/"), config);
      },
      prominence: "low",
      children: "Sign in"
    }) : (0, import_jsx_runtime30.jsx)(UserMenu, {
      user: rawCloudInfo ? {
        name: rawCloudInfo.user.name,
        login: rawCloudInfo.user.email,
        avatarUrl: rawCloudInfo.user.avatarUrl
      } : void 0
    }) : null]
  });
}
function BrandButton() {
  let {
    basePath
  } = useAppState();
  let {
    brandMark,
    brandName
  } = useBrand();
  return (0, import_jsx_runtime30.jsxs)(ActionButton, {
    "aria-label": "dashboard",
    prominence: "low",
    href: basePath,
    UNSAFE_style: {
      marginInlineStart: `calc(${tokenSchema.size.space.regular} * -1)`
    },
    children: [brandMark, (0, import_jsx_runtime30.jsx)(Text, {
      color: "neutralEmphasis",
      weight: "medium",
      visuallyHidden: {
        below: "desktop"
      },
      children: brandName
    })]
  });
}
function HeaderOuter({
  children
}) {
  return (0, import_jsx_runtime30.jsx)(Flex, {
    elementType: "header",
    alignItems: "center",
    borderBottom: "muted",
    flexShrink: 0,
    gap: "small",
    height: {
      mobile: "element.large",
      tablet: "scale.700"
    },
    paddingX: {
      mobile: "medium",
      tablet: "xlarge"
    },
    paddingEnd: {
      desktop: "xxlarge"
    },
    children
  });
}
var THEME_MODE = {
  light: {
    icon: sunIcon,
    label: "Light"
  },
  dark: {
    icon: moonIcon,
    label: "Dark"
  },
  auto: {
    icon: monitorIcon,
    label: "System"
  }
};
var themeItems = Object.entries(THEME_MODE).map(([id, {
  icon,
  label
}]) => ({
  id,
  icon,
  label
}));
function ThemeMenu() {
  let {
    theme,
    setTheme
  } = useThemeContext();
  let matchesDark = useMediaQuery("(prefers-color-scheme: dark)");
  let icon = THEME_MODE[theme].icon;
  if (theme === "auto") {
    icon = matchesDark ? moonIcon : sunIcon;
  }
  return (0, import_jsx_runtime30.jsxs)(MenuTrigger, {
    children: [(0, import_jsx_runtime30.jsx)(ActionButton, {
      "aria-label": "Theme",
      prominence: "low",
      UNSAFE_className: css({
        borderRadius: "50%",
        padding: 0
      }),
      children: (0, import_jsx_runtime30.jsx)(Icon, {
        src: icon
      })
    }), (0, import_jsx_runtime30.jsx)(_Menu, {
      items: themeItems,
      onSelectionChange: ([key]) => setTheme(key),
      disallowEmptySelection: true,
      selectedKeys: [theme],
      selectionMode: "single",
      children: (item) => (0, import_jsx_runtime30.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
        textValue: item.label,
        children: [(0, import_jsx_runtime30.jsx)(Icon, {
          src: item.icon
        }), (0, import_jsx_runtime30.jsx)(Text, {
          children: item.label
        })]
      })
    })]
  });
}
function UserMenu({
  user
}) {
  var _user$name2, _user$name3;
  let config = useConfig();
  const menuItems = (0, import_react15.useMemo)(() => {
    var _config$cloud;
    let items = [{
      key: "logout",
      label: "Log out",
      icon: logOutIcon
    }];
    if ((_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
      items.unshift({
        key: "manage",
        label: "Account",
        icon: userIcon,
        href: "https://keystatic.cloud/account",
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    return items;
  }, [config]);
  if (!user) {
    return null;
  }
  return (0, import_jsx_runtime30.jsxs)(MenuTrigger, {
    children: [(0, import_jsx_runtime30.jsx)(ActionButton, {
      "aria-label": "User menu",
      prominence: "low",
      UNSAFE_className: css({
        borderRadius: "50%",
        padding: 0
      }),
      children: (0, import_jsx_runtime30.jsx)(Avatar, {
        src: user.avatarUrl,
        name: (_user$name2 = user.name) !== null && _user$name2 !== void 0 ? _user$name2 : void 0,
        size: "small"
      })
    }), (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
      children: [(0, import_jsx_runtime30.jsxs)(Flex, {
        borderBottom: "muted",
        gap: "regular",
        marginX: "regular",
        paddingY: "regular",
        paddingEnd: "xxlarge",
        alignItems: "center",
        UNSAFE_className: css({
          userSelect: "none"
        }),
        "aria-hidden": true,
        children: [(0, import_jsx_runtime30.jsx)(Avatar, {
          src: user.avatarUrl,
          name: (_user$name3 = user.name) !== null && _user$name3 !== void 0 ? _user$name3 : void 0,
          size: "small"
        }), (0, import_jsx_runtime30.jsxs)(Flex, {
          direction: "column",
          gap: "small",
          children: [(0, import_jsx_runtime30.jsx)(Text, {
            size: "small",
            weight: "semibold",
            color: "neutralEmphasis",
            children: user.name
          }), (0, import_jsx_runtime30.jsx)(Text, {
            size: "small",
            color: "neutralTertiary",
            children: user.login
          })]
        })]
      }), (0, import_jsx_runtime30.jsx)(_Menu, {
        items: menuItems,
        minWidth: "scale.2400",
        onAction: (key) => {
          switch (key) {
            case "logout":
              switch (config.storage.kind) {
                case "github":
                  window.location.href = "/api/keystatic/github/logout";
                  break;
                case "cloud":
                case "local":
                  localStorage.removeItem("keystatic-cloud-access-token");
                  window.location.reload();
                  break;
              }
          }
        },
        children: (item) => (0, import_jsx_runtime30.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item.label,
          href: item.href,
          rel: item.rel,
          target: item.target,
          children: [(0, import_jsx_runtime30.jsx)(Icon, {
            src: item.icon
          }), (0, import_jsx_runtime30.jsx)(Text, {
            children: item.label
          })]
        }, item.key)
      })]
    })]
  });
}
function GitMenu() {
  var _appShellData$data, _appShellData$data$re;
  const stringFormatter = $fca6afa0e843324b$export$f12b703ca79dfbb1(localizedMessages);
  const data = (0, import_react15.useContext)(BranchInfoContext);
  const [newBranchDialogVisible, toggleNewBranchDialog] = (0, import_react15.useReducer)((v) => !v, false);
  const [deleteBranchDialogVisible, toggleDeleteBranchDialog] = (0, import_react15.useReducer)((v) => !v, false);
  const [, deleteBranch] = useMutation(lib_default`
      mutation DeleteBranch($refId: ID!) {
        deleteRef(input: { refId: $refId }) {
          __typename
        }
      }
    `);
  const repoURL = getRepoUrl(data);
  const appShellData = (0, import_react15.useContext)(GitHubAppShellDataContext);
  const fork = (appShellData === null || appShellData === void 0 || (_appShellData$data = appShellData.data) === null || _appShellData$data === void 0 ? void 0 : _appShellData$data.repository) && "forks" in appShellData.data.repository && ((_appShellData$data$re = appShellData.data.repository.forks.nodes) === null || _appShellData$data$re === void 0 ? void 0 : _appShellData$data$re[0]);
  const gitMenuItems = (0, import_react15.useMemo)(() => {
    let isDefaultBranch = data.currentBranch === data.defaultBranch;
    let items = [];
    let branchSection = [{
      key: "new-branch",
      icon: gitBranchPlusIcon,
      label: stringFormatter.format("newBranch")
    }];
    let prSection = [];
    let repoSection = [{
      key: "repo",
      icon: githubIcon,
      href: repoURL,
      target: "_blank",
      rel: "noopener noreferrer",
      label: "Github repo"
      // TODO: l10n
    }];
    if (!isDefaultBranch) {
      if (data.pullRequestNumber === void 0) {
        prSection.push({
          key: "create-pull-request",
          icon: gitPullRequestIcon,
          href: `${repoURL}/pull/new/${data.currentBranch}`,
          target: "_blank",
          rel: "noopener noreferrer",
          label: stringFormatter.format("createPullRequest")
        });
      } else {
        prSection.push({
          key: "view-pull-request",
          icon: gitPullRequestIcon,
          href: `${repoURL}/pull/${data.pullRequestNumber}`,
          target: "_blank",
          rel: "noopener noreferrer",
          label: `Pull Request #${data.pullRequestNumber}`
        });
      }
      if (data.pullRequestNumber === void 0) {
        branchSection.push({
          key: "delete-branch",
          icon: trash2Icon,
          label: stringFormatter.format("deleteBranch")
        });
      }
    }
    if (fork) {
      repoSection.push({
        key: "fork",
        icon: gitForkIcon,
        href: `https://github.com/${fork.owner.login}/${fork.name}`,
        target: "_blank",
        rel: "noopener noreferrer",
        label: "View fork"
        // TODO: l10n
      });
    }
    if (branchSection.length) {
      items.push({
        key: "branch-section",
        label: stringFormatter.format("branches"),
        children: branchSection
      });
    }
    if (prSection.length) {
      items.push({
        key: "pr-section",
        label: stringFormatter.format("pullRequests"),
        children: prSection
      });
    }
    if (repoSection.length) {
      items.push({
        key: "repo-section",
        label: "Repository",
        // TODO: l10n
        children: repoSection
      });
    }
    return items;
  }, [fork, data.currentBranch, data.defaultBranch, data.pullRequestNumber, repoURL, stringFormatter]);
  const router = useRouter();
  return (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, {
    children: [(0, import_jsx_runtime30.jsx)(_ActionMenu, {
      "aria-label": "git actions",
      prominence: "low",
      items: gitMenuItems,
      onAction: (key) => {
        switch (key) {
          case "new-branch":
            toggleNewBranchDialog();
            break;
          case "delete-branch": {
            toggleDeleteBranchDialog();
            break;
          }
        }
      },
      children: (item) => (0, import_jsx_runtime30.jsx)($9fc4852771d079eb$export$6e2c8f0811a474ce, {
        items: item.children,
        "aria-label": item.label,
        children: (item2) => (0, import_jsx_runtime30.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item2.label,
          href: item2.href,
          rel: item2.rel,
          target: item2.target,
          children: [(0, import_jsx_runtime30.jsx)(Icon, {
            src: item2.icon
          }), (0, import_jsx_runtime30.jsx)(Text, {
            children: item2.label
          })]
        }, item2.key)
      }, item.key)
    }), (0, import_jsx_runtime30.jsx)(DialogContainer, {
      onDismiss: toggleNewBranchDialog,
      children: newBranchDialogVisible && (0, import_jsx_runtime30.jsx)(CreateBranchDialog, {
        onDismiss: toggleNewBranchDialog,
        onCreate: (branchName) => {
          toggleNewBranchDialog();
          router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(branchName)));
        }
      })
    }), (0, import_jsx_runtime30.jsx)(DialogContainer, {
      onDismiss: toggleDeleteBranchDialog,
      children: deleteBranchDialogVisible && (0, import_jsx_runtime30.jsxs)(AlertDialog, {
        title: "Delete branch",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: async () => {
          await deleteBranch({
            refId: data.branchNameToId.get(data.currentBranch)
          });
          router.push(router.href.replace(/\/branch\/[^/]+/, "/branch/" + encodeURIComponent(data.defaultBranch)));
        },
        children: ['Are you sure you want to delete the "', data.currentBranch, '" branch? This cannot be undone.']
      })
    })]
  });
}
var MainPanelLayout = (props) => {
  let {
    basePath,
    children,
    config
  } = props;
  let isBelowDesktop = useMediaQuery(breakpointQueries$1.below.desktop);
  let sidebarState = useSidebar();
  let ref = (0, import_react15.useRef)(null);
  let context = useContentPanelState(ref);
  return (0, import_jsx_runtime30.jsx)(ContentPanelProvider, {
    value: context,
    children: (0, import_jsx_runtime30.jsxs)(SplitView, {
      autoSaveId: "keystatic-app-split-view",
      isCollapsed: isBelowDesktop || !sidebarState.isOpen,
      onCollapseChange: sidebarState.toggle,
      defaultSize: 260,
      minSize: 180,
      maxSize: 400,
      flex: true,
      children: [isBelowDesktop ? (0, import_jsx_runtime30.jsx)(SidebarDialog, {
        hrefBase: basePath,
        config
      }) : (0, import_jsx_runtime30.jsx)(SplitPanePrimary, {
        children: (0, import_jsx_runtime30.jsx)(SidebarPanel, {
          hrefBase: basePath,
          config
        })
      }), (0, import_jsx_runtime30.jsx)(SplitPaneSecondary, {
        ref,
        children
      })]
    })
  });
};
var AppShell = (props) => {
  const content = (0, import_jsx_runtime30.jsx)(AppShellErrorContext.Consumer, {
    children: (error) => error && !(error !== null && error !== void 0 && error.graphQLErrors.some((err) => {
      var _err$originalError;
      return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === "NOT_FOUND";
    })) ? (0, import_jsx_runtime30.jsx)(EmptyState, {
      icon: alertCircleIcon,
      title: "Failed to load shell",
      message: error.message
    }) : props.children
  });
  const inner = (0, import_jsx_runtime30.jsx)(ConfigContext.Provider, {
    value: props.config,
    children: (0, import_jsx_runtime30.jsx)(AppStateContext.Provider, {
      value: {
        basePath: props.basePath
      },
      children: (0, import_jsx_runtime30.jsx)(SidebarProvider, {
        children: (0, import_jsx_runtime30.jsxs)(Flex, {
          direction: "column",
          height: "100vh",
          children: [(0, import_jsx_runtime30.jsx)(TopBar, {}), (0, import_jsx_runtime30.jsx)(MainPanelLayout, {
            basePath: props.basePath,
            config: props.config,
            children: content
          })]
        })
      })
    })
  });
  if (isGitHubConfig(props.config) || props.config.storage.kind === "cloud") {
    return (0, import_jsx_runtime30.jsx)(GitHubAppShellProvider, {
      currentBranch: props.currentBranch,
      config: props.config,
      children: inner
    });
  }
  if (isLocalConfig(props.config)) {
    return (0, import_jsx_runtime30.jsx)(LocalAppShellProvider, {
      config: props.config,
      children: inner
    });
  }
  return null;
};
function SingletonPage({
  singleton,
  initialFiles,
  initialState,
  localTreeKey,
  config,
  draft
}) {
  const [forceValidation, setForceValidation] = (0, import_react15.useState)(false);
  const singletonConfig = config.singletons[singleton];
  const schema2 = (0, import_react15.useMemo)(() => object(singletonConfig.schema), [singletonConfig.schema]);
  const singletonPath = getSingletonPath(config, singleton);
  const router = useRouter();
  const [{
    state,
    localTreeKey: localTreeKeyInState
  }, setState] = (0, import_react15.useState)(() => {
    var _draft$state;
    return {
      localTreeKey,
      state: (_draft$state = draft === null || draft === void 0 ? void 0 : draft.state) !== null && _draft$state !== void 0 ? _draft$state : initialState === null ? getInitialPropsValue(schema2) : initialState
    };
  });
  (0, import_react15.useEffect)(() => {
    if (draft && state === draft.state) {
      showDraftRestoredToast(draft.savedAt, localTreeKey !== draft.treeKey);
    }
  }, [draft]);
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      localTreeKey,
      state: initialState === null ? getInitialPropsValue(schema2) : initialState
    });
  }
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema: schema2,
    slugField: void 0
  }) || isCreating;
  (0, import_react15.useEffect)(() => {
    const key = ["singleton", singleton];
    if (hasChanged) {
      const serialized = serializeEntryToFiles({
        basePath: singletonPath,
        config,
        format: getSingletonFormat(config, singleton),
        schema: singletonConfig.schema,
        slug: void 0,
        state
      });
      const files = new Map(serialized.map((x2) => [x2.path, x2.contents]));
      const data = {
        beforeTreeKey: localTreeKey,
        files,
        savedAt: /* @__PURE__ */ new Date(),
        version: 1
      };
      setDraft(key, data);
    } else {
      delDraft(key);
    }
  }, [config, localTreeKey, state, hasChanged, singleton, singletonPath, singletonConfig]);
  const previewProps = (0, import_react15.useMemo)(() => createGetPreviewProps(schema2, (stateUpdater) => {
    setState((state2) => ({
      localTreeKey: state2.localTreeKey,
      state: stateUpdater(state2.state)
    }));
  }, () => void 0), [schema2])(state);
  const baseCommit = useBaseCommit();
  const formatInfo = getSingletonFormat(config, singleton);
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: singletonConfig.schema,
    basePath: singletonPath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    slug: void 0
  });
  const update = useEventCallback(_update);
  const onCreate = async () => {
    if (!clientSideValidateProp(schema2, state, void 0)) {
      setForceValidation(true);
      return;
    }
    await update();
  };
  const formID = "singleton-form";
  const onReset = () => setState({
    localTreeKey,
    state: initialState === null ? getInitialPropsValue(schema2) : initialState
  });
  const isBelowTablet = useMediaQuery(breakpointQueries$1.below.tablet);
  const branchInfo = useBranchInfo();
  const previewHref = (0, import_react15.useMemo)(() => {
    if (!singletonConfig.previewUrl)
      return void 0;
    return singletonConfig.previewUrl.replace("{branch}", branchInfo.currentBranch);
  }, [branchInfo.currentBranch, singletonConfig.previewUrl]);
  const isGitHub = isGitHubConfig(config) || isCloudConfig(config);
  const singletonExists = !!initialState;
  const viewHref = isGitHub && singletonExists ? `${getRepoUrl(branchInfo)}${formatInfo.dataLocation === "index" ? `/tree/${branchInfo.currentBranch}/${getPathPrefix(config.storage)}${singletonPath}` : `/blob/${getPathPrefix(config.storage)}${branchInfo.currentBranch}/${singletonPath}${getDataFileExtension(formatInfo)}`}` : void 0;
  const menuActions = (0, import_react15.useMemo)(() => {
    const actions = [{
      key: "reset",
      label: "Reset",
      icon: historyIcon
    }];
    if (previewHref) {
      actions.push({
        key: "preview",
        label: "Preview",
        icon: externalLinkIcon,
        href: previewHref,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    if (viewHref) {
      actions.push({
        key: "view",
        label: "View on GitHub",
        icon: githubIcon,
        href: viewHref,
        target: "_blank",
        rel: "noopener noreferrer"
      });
    }
    return actions;
  }, [previewHref, viewHref]);
  return (0, import_jsx_runtime30.jsxs)(PageRoot, {
    containerWidth: containerWidthForEntryLayout(singletonConfig),
    children: [(0, import_jsx_runtime30.jsxs)(PageHeader, {
      children: [(0, import_jsx_runtime30.jsxs)(Flex, {
        flex: true,
        alignItems: "center",
        gap: "regular",
        children: [(0, import_jsx_runtime30.jsx)(Heading, {
          elementType: "h1",
          id: "page-title",
          size: "small",
          children: singletonConfig.label
        }), updateResult.kind === "loading" ? (0, import_jsx_runtime30.jsx)(ProgressCircle, {
          "aria-label": `Updating ${singletonConfig.label}`,
          isIndeterminate: true,
          size: "small",
          alignSelf: "center"
        }) : hasChanged && (0, import_jsx_runtime30.jsx)(Badge, {
          tone: "pending",
          children: "Unsaved"
        })]
      }), (0, import_jsx_runtime30.jsx)(_ActionGroup, {
        buttonLabelBehavior: "hide",
        overflowMode: "collapse",
        prominence: "low",
        density: "compact",
        maxWidth: isBelowTablet ? "element.regular" : void 0,
        items: menuActions,
        disabledKeys: hasChanged ? [] : ["reset"],
        onAction: (key) => {
          switch (key) {
            case "reset":
              onReset();
              break;
          }
        },
        children: (item) => (0, import_jsx_runtime30.jsxs)($c1d7fb2ec91bae71$export$6d08773d2e66f8f2, {
          textValue: item.label,
          href: item.href,
          target: item.target,
          rel: item.rel,
          children: [(0, import_jsx_runtime30.jsx)(Icon, {
            src: item.icon
          }), (0, import_jsx_runtime30.jsx)(Text, {
            children: item.label
          })]
        }, item.key)
      }), (0, import_jsx_runtime30.jsx)(Button, {
        form: formID,
        isDisabled: updateResult.kind === "loading",
        prominence: "high",
        type: "submit",
        children: isCreating ? "Create" : "Save"
      })]
    }), (0, import_jsx_runtime30.jsxs)(Flex, {
      elementType: "form",
      id: formID,
      onSubmit: (event) => {
        if (event.target !== event.currentTarget)
          return;
        event.preventDefault();
        onCreate();
      },
      direction: "column",
      gap: "xxlarge",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children: [updateResult.kind === "error" && (0, import_jsx_runtime30.jsx)(Notice, {
        tone: "critical",
        children: updateResult.error.message
      }), (0, import_jsx_runtime30.jsx)(FormForEntry, {
        previewProps,
        forceValidation,
        entryLayout: singletonConfig.entryLayout,
        formatInfo,
        slugField: void 0
      }), (0, import_jsx_runtime30.jsx)(
        DialogContainer,
        {
          onDismiss: resetUpdateItem,
          children: updateResult.kind === "needs-new-branch" && (0, import_jsx_runtime30.jsx)(CreateBranchDuringUpdateDialog, {
            branchOid: baseCommit,
            onCreate: async (newBranch) => {
              router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/singleton/${encodeURIComponent(singleton)}`);
              update({
                branch: newBranch,
                sha: baseCommit
              });
            },
            reason: updateResult.reason,
            onDismiss: resetUpdateItem
          })
        }
      ), (0, import_jsx_runtime30.jsx)(
        DialogContainer,
        {
          onDismiss: resetUpdateItem,
          children: updateResult.kind === "needs-fork" && isGitHubConfig(config) && (0, import_jsx_runtime30.jsx)(ForkRepoDialog, {
            onCreate: async () => {
              update();
            },
            onDismiss: resetUpdateItem,
            config
          })
        }
      )]
    })]
  });
}
var storedValSchema = z.object({
  version: z.literal(1),
  savedAt: z.date(),
  beforeTreeKey: z.string().optional(),
  files: z.map(z.string(), z.instanceof(Uint8Array))
});
function SingletonPageWrapper(props) {
  var _props$config$singlet;
  const singletonConfig = (_props$config$singlet = props.config.singletons) === null || _props$config$singlet === void 0 ? void 0 : _props$config$singlet[props.singleton];
  if (!singletonConfig)
    notFound();
  const header = (0, import_jsx_runtime30.jsx)(PageHeader, {
    children: (0, import_jsx_runtime30.jsx)(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      children: singletonConfig.label
    })
  });
  const format = (0, import_react15.useMemo)(() => getSingletonFormat(props.config, props.singleton), [props.config, props.singleton]);
  const dirpath = getSingletonPath(props.config, props.singleton);
  const draftData = useData((0, import_react15.useCallback)(async () => {
    const raw = await getDraft(["singleton", props.singleton]);
    if (!raw)
      throw new Error("No draft found");
    const stored = storedValSchema.parse(raw);
    const parsed = parseEntry({
      config: props.config,
      dirpath,
      format,
      schema: singletonConfig.schema,
      slug: void 0
    }, stored.files);
    return {
      state: parsed.initialState,
      savedAt: stored.savedAt,
      treeKey: stored.beforeTreeKey
    };
  }, [dirpath, format, props.config, props.singleton, singletonConfig.schema]));
  const itemData = useItemData({
    config: props.config,
    dirpath,
    schema: singletonConfig.schema,
    format,
    slug: void 0
  });
  if (itemData.kind === "error") {
    return (0, import_jsx_runtime30.jsxs)(PageRoot, {
      children: [header, (0, import_jsx_runtime30.jsx)(PageBody, {
        children: (0, import_jsx_runtime30.jsx)(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: itemData.error.message
        })
      })]
    });
  }
  if (itemData.kind === "loading" || draftData.kind === "loading") {
    return (0, import_jsx_runtime30.jsxs)(PageRoot, {
      children: [header, (0, import_jsx_runtime30.jsx)(PageBody, {
        children: (0, import_jsx_runtime30.jsx)(Flex, {
          alignItems: "center",
          justifyContent: "center",
          minHeight: "scale.3000",
          children: (0, import_jsx_runtime30.jsx)(ProgressCircle, {
            "aria-label": `Loading ${singletonConfig.label}`,
            isIndeterminate: true,
            size: "large"
          })
        })
      })]
    });
  }
  return (0, import_jsx_runtime30.jsx)(SingletonPage, {
    singleton: props.singleton,
    config: props.config,
    initialState: itemData.data === "not-found" ? null : itemData.data.initialState,
    initialFiles: itemData.data === "not-found" ? [] : itemData.data.initialFiles,
    localTreeKey: itemData.data === "not-found" ? void 0 : itemData.data.localTreeKey,
    draft: draftData.kind === "loaded" ? draftData.data : void 0
  });
}
function CreatedGitHubApp(props) {
  return (0, import_jsx_runtime30.jsx)(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: (0, import_jsx_runtime30.jsxs)(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [(0, import_jsx_runtime30.jsx)(Heading, {
        children: "You've installed Keystatic! 🎉"
      }), (0, import_jsx_runtime30.jsx)(Text, {
        children: "To start using Keystatic, you need to install the GitHub app you've created."
      }), (0, import_jsx_runtime30.jsxs)(Text, {
        children: ["Make sure to add the App to the", " ", (0, import_jsx_runtime30.jsx)("code", {
          children: serializeRepoConfig(props.config.storage.repo)
        }), " ", "repository."]
      }), (0, import_jsx_runtime30.jsx)(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}
function KeystaticSetup(props) {
  const [deployedURL, setDeployedURL] = (0, import_react15.useState)("");
  const [organization, setOrganization] = (0, import_react15.useState)("");
  return (0, import_jsx_runtime30.jsx)(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: (0, import_jsx_runtime30.jsxs)(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      elementType: "form",
      action: `https://github.com${organization ? `/organizations/${organization}` : ""}/settings/apps/new`,
      method: "post",
      children: [(0, import_jsx_runtime30.jsx)(Flex, {
        justifyContent: "center",
        children: (0, import_jsx_runtime30.jsx)(Heading, {
          children: "Keystatic Setup"
        })
      }), (0, import_jsx_runtime30.jsx)(Text, {
        children: "Keystatic doesn't have the required config."
      }), (0, import_jsx_runtime30.jsx)(Text, {
        children: "If you've already created your GitHub app, make sure to add the following environment variables:"
      }), (0, import_jsx_runtime30.jsxs)(Box, {
        elementType: "ul",
        children: [(0, import_jsx_runtime30.jsx)("li", {
          children: (0, import_jsx_runtime30.jsx)("code", {
            children: "KEYSTATIC_GITHUB_CLIENT_ID"
          })
        }), (0, import_jsx_runtime30.jsx)("li", {
          children: (0, import_jsx_runtime30.jsx)("code", {
            children: "KEYSTATIC_GITHUB_CLIENT_SECRET"
          })
        }), (0, import_jsx_runtime30.jsx)("li", {
          children: (0, import_jsx_runtime30.jsx)("code", {
            children: "KEYSTATIC_SECRET"
          })
        })]
      }), (0, import_jsx_runtime30.jsx)(Text, {
        children: "If you haven't created your GitHub app for Keystatic, you can create one below."
      }), (0, import_jsx_runtime30.jsx)(TextField, {
        label: "Deployed App URL",
        description: "This should the root of your domain. If you're not sure where Keystatic will be deployed, leave this blank and you can update the GitHub app later.",
        value: deployedURL,
        onChange: setDeployedURL
      }), (0, import_jsx_runtime30.jsx)(TextField, {
        label: "GitHub organization (if any)",
        description: "You must be an owner or GitHub App manager in the organization to create the GitHub App. Leave this blank to create the app in your personal account.",
        value: organization,
        onChange: setOrganization
      }), (0, import_jsx_runtime30.jsxs)(Text, {
        children: ["After visiting GitHub to create the GitHub app, you'll be redirected back here and secrets generated from GitHub will be written to your", " ", (0, import_jsx_runtime30.jsx)("code", {
          children: ".env"
        }), " file."]
      }), (0, import_jsx_runtime30.jsx)("input", {
        type: "text",
        name: "manifest",
        className: css({
          display: "none"
        }),
        value: JSON.stringify({
          name: `${parseRepoConfig(props.config.storage.repo).owner} Keystatic`,
          url: deployedURL ? `${deployedURL}/keystatic` : `${window.location.origin}/keystatic`,
          public: true,
          redirect_url: `${window.location.origin}/api/keystatic/github/created-app`,
          callback_urls: [`${window.location.origin}/api/keystatic/github/oauth/callback`, `http://127.0.0.1/api/keystatic/github/oauth/callback`, ...deployedURL ? [`${deployedURL}/api/keystatic/github/oauth/callback`] : []],
          request_oauth_on_install: true,
          default_permissions: {
            contents: "write",
            metadata: "read",
            pull_requests: "read"
          }
        })
      }), (0, import_jsx_runtime30.jsx)(Button, {
        prominence: "high",
        type: "submit",
        children: "Create GitHub App"
      })]
    })
  });
}
function RepoNotFound(props) {
  const repo = serializeRepoConfig(props.config.storage.repo);
  return (0, import_jsx_runtime30.jsx)(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: (0, import_jsx_runtime30.jsxs)(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [(0, import_jsx_runtime30.jsx)(Flex, {
        justifyContent: "center",
        children: (0, import_jsx_runtime30.jsx)(Heading, {
          children: "Repo not found"
        })
      }), (0, import_jsx_runtime30.jsxs)(Text, {
        children: ["Keystatic is configured for the", " ", (0, import_jsx_runtime30.jsx)("a", {
          href: `https://github.com/${repo}`,
          children: repo
        }), " GitHub repo but Keystatic isn't able to access this repo. This is either because you don't have access to this repo or you haven't added the GitHub app to it."]
      }), (0, import_jsx_runtime30.jsx)(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}
var storedStateSchema = z.object({
  state: z.string(),
  from: z.string(),
  code_verifier: z.string()
});
var tokenResponseSchema = z.object({
  access_token: z.string(),
  token_type: z.string(),
  expires_in: z.number()
});
function KeystaticCloudAuthCallback({
  config
}) {
  var _config$cloud2;
  const router = useRouter();
  const url = new URL(window.location.href);
  const code = url.searchParams.get("code");
  const state = url.searchParams.get("state");
  const storedState = (0, import_react15.useMemo)(() => {
    const _storedState = localStorage.getItem("keystatic-cloud-state");
    const storedState2 = storedStateSchema.safeParse((() => {
      try {
        return JSON.parse(_storedState || "");
      } catch {
        return null;
      }
    })());
    return storedState2;
  }, []);
  const [error, setError] = (0, import_react15.useState)(null);
  (0, import_react15.useEffect)(() => {
    var _config$cloud;
    if (code && state && storedState.success && (_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
      const {
        project
      } = config.cloud;
      (async () => {
        const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/oauth/token`, {
          method: "POST",
          body: new URLSearchParams({
            code,
            client_id: project,
            redirect_uri: `${window.location.origin}/keystatic/cloud/oauth/callback`,
            code_verifier: storedState.data.code_verifier,
            grant_type: "authorization_code"
          }).toString(),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            ...KEYSTATIC_CLOUD_HEADERS
          }
        });
        if (!res.ok) {
          throw new Error(`Bad response: ${res.status} ${res.statusText}

${await res.text()}`);
        }
        const data = await res.json();
        const parsed = tokenResponseSchema.parse(data);
        localStorage.setItem("keystatic-cloud-access-token", JSON.stringify({
          token: parsed.access_token,
          project,
          validUntil: Date.now() + parsed.expires_in * 1e3
        }));
        router.push(`/keystatic/${storedState.data.from}`);
      })().catch((error2) => {
        setError(error2);
      });
    }
  }, [code, state, router, storedState, config]);
  if (!((_config$cloud2 = config.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project)) {
    return (0, import_jsx_runtime30.jsx)(Text, {
      children: "Missing Keystatic Cloud config"
    });
  }
  if (!code || !state) {
    return (0, import_jsx_runtime30.jsx)(Text, {
      children: "Missing code or state"
    });
  }
  if (storedState.success === false || state !== storedState.data.state) {
    return (0, import_jsx_runtime30.jsx)(Text, {
      children: "Invalid state"
    });
  }
  if (error) {
    return (0, import_jsx_runtime30.jsx)(Text, {
      children: error.message
    });
  }
  return (0, import_jsx_runtime30.jsx)(Flex, {
    justifyContent: "center",
    alignItems: "center",
    height: "100vh",
    children: (0, import_jsx_runtime30.jsx)(ProgressCircle, {
      size: "large",
      isIndeterminate: true,
      "aria-label": "Authenticating"
    })
  });
}
function parseParamsWithoutBranch(params) {
  if (params.length === 0) {
    return {};
  }
  if (params.length === 2 && params[0] === "singleton") {
    return {
      singleton: params[1]
    };
  }
  if (params.length < 2 || params[0] !== "collection")
    return null;
  const collection = params[1];
  if (params.length === 2) {
    return {
      collection
    };
  }
  if (params.length === 3 && params[2] === "create") {
    return {
      collection,
      kind: "create"
    };
  }
  if (params.length === 4 && params[2] === "item") {
    const slug = params[3];
    return {
      collection,
      kind: "edit",
      slug
    };
  }
  return null;
}
function RedirectToBranch(props) {
  const {
    push
  } = useRouter();
  const {
    data,
    error
  } = (0, import_react15.useContext)(GitHubAppShellDataContext);
  (0, import_react15.useEffect)(() => {
    var _error$response, _data$repository, _data$repository2, _error$graphQLErrors, _error$graphQLErrors2;
    if ((error === null || error === void 0 || (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
      if (props.config.storage.kind === "github") {
        window.location.href = "/api/keystatic/github/login";
      } else {
        redirectToCloudAuth("", props.config);
      }
    }
    if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && _data$repository.defaultBranchRef) {
      push(`/keystatic/branch/${encodeURIComponent(data.repository.defaultBranchRef.name)}`);
    }
    if (props.config.storage.kind === "github" && !(data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && _data$repository2.id) && (error === null || error === void 0 || (_error$graphQLErrors = error.graphQLErrors) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors[0]) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors.originalError) === null || _error$graphQLErrors === void 0 ? void 0 : _error$graphQLErrors.type) === "NOT_FOUND" || (error === null || error === void 0 || (_error$graphQLErrors2 = error.graphQLErrors) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2[0]) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2.originalError) === null || _error$graphQLErrors2 === void 0 ? void 0 : _error$graphQLErrors2.type) === "FORBIDDEN") {
      window.location.href = "/api/keystatic/github/repo-not-found";
    }
  }, [data, error, push, props.config]);
  return null;
}
function PageInner({
  config
}) {
  var _config$cloud;
  const {
    params
  } = useRouter();
  let branch = null, parsedParams, basePath;
  if (params.join("/") === "cloud/oauth/callback") {
    return (0, import_jsx_runtime30.jsx)(KeystaticCloudAuthCallback, {
      config
    });
  }
  let wrapper = (x2) => x2;
  if (isCloudConfig(config) || isLocalConfig(config) && (_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) {
    wrapper = (element) => (0, import_jsx_runtime30.jsx)(CloudInfoProvider, {
      config,
      children: element
    });
  }
  if (isGitHubConfig(config) || isCloudConfig(config)) {
    const origWrapper = wrapper;
    wrapper = (element) => (0, import_jsx_runtime30.jsx)(AuthWrapper, {
      config,
      children: (0, import_jsx_runtime30.jsx)(GitHubAppShellDataProvider, {
        config,
        children: origWrapper(element)
      })
    });
    if (params.length === 0) {
      return wrapper((0, import_jsx_runtime30.jsx)(RedirectToBranch, {
        config
      }));
    }
    if (params.length === 1 && isGitHubConfig(config)) {
      if (params[0] === "setup")
        return (0, import_jsx_runtime30.jsx)(KeystaticSetup, {
          config
        });
      if (params[0] === "repo-not-found") {
        return (0, import_jsx_runtime30.jsx)(RepoNotFound, {
          config
        });
      }
      if (params[0] === "created-github-app") {
        return (0, import_jsx_runtime30.jsx)(CreatedGitHubApp, {
          config
        });
      }
    }
    if (params[0] !== "branch" || params.length < 2) {
      return (0, import_jsx_runtime30.jsx)(Text, {
        children: "Not found"
      });
    }
    branch = params[1];
    basePath = `/keystatic/branch/${encodeURIComponent(branch)}`;
    parsedParams = parseParamsWithoutBranch(params.slice(2));
  } else {
    parsedParams = parseParamsWithoutBranch(params);
    basePath = "/keystatic";
  }
  return wrapper((0, import_jsx_runtime30.jsx)(AppShell, {
    config,
    currentBranch: branch || "",
    basePath,
    children: (0, import_jsx_runtime30.jsx)(NotFoundBoundary, {
      fallback: (0, import_jsx_runtime30.jsx)(PageRoot, {
        children: (0, import_jsx_runtime30.jsx)(PageBody, {
          children: (0, import_jsx_runtime30.jsx)(EmptyState, {
            icon: fileX2Icon,
            title: "Not found",
            message: "This page could not be found."
          })
        })
      }),
      children: parsedParams === null ? (0, import_jsx_runtime30.jsx)(AlwaysNotFound, {}) : parsedParams.collection ? parsedParams.kind === "create" ? (0, import_jsx_runtime30.jsx)(CreateItemWrapper, {
        collection: parsedParams.collection,
        config,
        basePath
      }, parsedParams.collection) : parsedParams.kind === "edit" ? (0, import_jsx_runtime30.jsx)(ItemPageWrapper, {
        collection: parsedParams.collection,
        basePath,
        config,
        itemSlug: parsedParams.slug
      }, parsedParams.collection) : (0, import_jsx_runtime30.jsx)(CollectionPage, {
        basePath,
        collection: parsedParams.collection,
        config
      }, parsedParams.collection) : parsedParams.singleton ? (0, import_jsx_runtime30.jsx)(SingletonPageWrapper, {
        config,
        singleton: parsedParams.singleton
      }, parsedParams.singleton) : (0, import_jsx_runtime30.jsx)(DashboardPage, {
        config,
        basePath
      })
    })
  }));
}
function AlwaysNotFound() {
  notFound();
}
function AuthWrapper(props) {
  const [state, setState] = (0, import_react15.useState)("unknown");
  const router = useRouter();
  (0, import_react15.useEffect)(() => {
    getAuth(props.config).then((auth) => {
      if (auth) {
        setState("valid");
        return;
      }
      setState("explicit-auth");
    });
  }, [props.config]);
  if (state === "valid") {
    return props.children;
  }
  if (state === "explicit-auth") {
    if (props.config.storage.kind === "github") {
      return (0, import_jsx_runtime30.jsx)(Flex, {
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        children: (0, import_jsx_runtime30.jsxs)(Button, {
          href: `/api/keystatic/github/login${router.params.length ? `?${new URLSearchParams({
            from: router.params.join("/")
          })}` : ""}`,
          target: "_top",
          children: [(0, import_jsx_runtime30.jsx)(Icon, {
            src: githubIcon
          }), (0, import_jsx_runtime30.jsx)(Text, {
            children: "Log in with GitHub"
          })]
        })
      });
    }
    if (props.config.storage.kind === "cloud") {
      return (0, import_jsx_runtime30.jsx)(Flex, {
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        children: (0, import_jsx_runtime30.jsx)(Button, {
          onPress: () => {
            redirectToCloudAuth(router.params.join("/"), props.config);
          },
          children: (0, import_jsx_runtime30.jsx)(Text, {
            children: "Log in with Keystatic Cloud"
          })
        })
      });
    }
  }
  return null;
}
function RedirectToLoopback(props) {
  (0, import_react15.useEffect)(() => {
    if (window.location.hostname === "localhost") {
      window.location.href = window.location.href.replace("localhost", "127.0.0.1");
    }
  }, []);
  if (window.location.hostname === "localhost") {
    return null;
  }
  return props.children;
}
function Keystatic(props) {
  if (props.config.storage.kind === "github") {
    assertValidRepoConfig(props.config.storage.repo);
  }
  return (0, import_jsx_runtime30.jsx)(ClientOnly, {
    children: (0, import_jsx_runtime30.jsx)(RedirectToLoopback, {
      children: (0, import_jsx_runtime30.jsx)(AppSlugProvider, {
        value: props.appSlug,
        children: (0, import_jsx_runtime30.jsx)(RouterProvider, {
          children: (0, import_jsx_runtime30.jsx)(Provider, {
            config: props.config,
            children: (0, import_jsx_runtime30.jsx)(PageInner, {
              config: props.config
            })
          })
        })
      })
    })
  });
}
function ClientOnly(props) {
  const [mounted, setMounted] = (0, import_react15.useState)(false);
  (0, import_react15.useEffect)(() => {
    setMounted(true);
  }, []);
  if (!mounted)
    return null;
  return props.children;
}

export {
  Keystatic
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
//# sourceMappingURL=chunk-6S3QZ47K.js.map
