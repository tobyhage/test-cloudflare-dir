import { stringifyVariables as e, formatDocument as r, createRequest as t, makeOperation as i, stringifyDocument as a } from "@urql/core";

import { Kind as n, valueFromASTUntyped as o } from "@0no-co/graphql.web";

import { share as s, map as l, filter as v, merge as d, mergeMap as u, empty as c, fromArray as p, makeSubject as f, onPush as y } from "wonka";

var h = "\nhttps://bit.ly/2XbVrpR#";

var m = new Set;

var g = [];

var popDebugNode = () => g.pop();

var pushDebugNode = (e, r) => {
  var t = "";
  if (r.kind === n.INLINE_FRAGMENT) {
    t = e ? `Inline Fragment on "${e}"` : "Inline Fragment";
  } else if (r.kind === n.OPERATION_DEFINITION) {
    t = `${r.name ? `"${r.name.value}"` : "Unnamed"} ${r.operation}`;
  } else if (r.kind === n.FRAGMENT_DEFINITION) {
    t = `"${r.name.value}" Fragment`;
  }
  if (t) {
    g.push(t);
  }
};

var getDebugOutput = () => g.length ? "\n(Caused At: " + g.join(", ") + ")" : "";

function invariant(e, r, t) {
  if (!e) {
    var i = r || "Minfied Error #" + t + "\n";
    if ("production" !== process.env.NODE_ENV) {
      i += getDebugOutput();
    }
    var a = new Error(i + h + t);
    a.name = "Graphcache Error";
    throw a;
  }
}

function warn(e, r, t) {
  if (!m.has(e)) {
    if (t) {
      t("warn", e + getDebugOutput() + h + r);
    } else {
      console.warn(e + getDebugOutput() + h + r);
    }
    m.add(e);
  }
}

var N = {};

var getDirectives = e => e._directives || N;

var getName = e => e.name.value;

var getFragmentTypeName = e => e.typeCondition.name.value;

var getFieldAlias = e => e.alias ? e.alias.value : e.name.value;

var _ = [];

var getSelectionSet = e => e.selectionSet ? e.selectionSet.selections : _;

var getTypeCondition = e => e.typeCondition ? e.typeCondition.name.value : null;

var getFieldArguments = (e, r) => {
  var t = null;
  if (e.arguments) {
    for (var i = 0, a = e.arguments.length; i < a; i++) {
      var n = e.arguments[i];
      var s = o(n.value, r);
      if (null != s) {
        if (!t) {
          t = {};
        }
        t[getName(n)] = s;
      }
    }
  }
  return t;
};

var filterVariables = (e, r) => {
  if (!r || !e.variableDefinitions) {
    return;
  }
  var t = {};
  for (var i = 0, a = e.variableDefinitions.length; i < a; i++) {
    var n = getName(e.variableDefinitions[i].variable);
    t[n] = r[n];
  }
  return t;
};

var normalizeVariables = (e, r) => {
  var t = {};
  if (!r) {
    return t;
  }
  if (e.variableDefinitions) {
    for (var i = 0, a = e.variableDefinitions.length; i < a; i++) {
      var n = e.variableDefinitions[i];
      var s = getName(n.variable);
      t[s] = void 0 === r[s] && n.defaultValue ? o(n.defaultValue, r) : r[s];
    }
  }
  for (var l in r) {
    if (!(l in t)) {
      t[l] = r[l];
    }
  }
  return t;
};

function getMainOperation(e) {
  for (var r = 0; r < e.definitions.length; r++) {
    if (e.definitions[r].kind === n.OPERATION_DEFINITION) {
      return e.definitions[r];
    }
  }
  invariant(!1, "production" !== process.env.NODE_ENV ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
}

var getFragments = e => {
  var r = {};
  for (var t = 0; t < e.definitions.length; t++) {
    var i = e.definitions[t];
    if (i.kind === n.FRAGMENT_DEFINITION) {
      r[getName(i)] = i;
    }
  }
  return r;
};

var shouldInclude = (e, r) => {
  var t = getDirectives(e);
  if (t.include || t.skip) {
    for (var i in t) {
      var a = t[i];
      if (a && ("include" === i || "skip" === i) && a.arguments && a.arguments[0] && "if" === getName(a.arguments[0])) {
        var n = o(a.arguments[0].value, r);
        return "include" === i ? !!n : !n;
      }
    }
  }
  return !0;
};

var isDeferred = (e, r) => {
  var {defer: t} = getDirectives(e);
  if (t) {
    for (var i of t.arguments || []) {
      if ("if" === getName(i)) {
        return !!o(i.value, r);
      }
    }
    return !0;
  }
  return !1;
};

var k = "__";

var isFieldNullable = (e, r, t, i) => {
  var a = getField(e, r, t, i);
  return !!a && "NON_NULL" !== a.type.kind;
};

var isListNullable = (e, r, t, i) => {
  var a = getField(e, r, t, i);
  if (!a) {
    return !1;
  }
  var n = "NON_NULL" === a.type.kind ? a.type.ofType : a.type;
  return "LIST" === n.kind && "NON_NULL" !== n.ofType.kind;
};

var isFieldAvailableOnType = (e, r, t, i) => 0 === t.indexOf(k) || 0 === r.indexOf(k) || !!getField(e, r, t, i);

var isInterfaceOfType = (e, r, t) => {
  if (!t) {
    return !1;
  }
  var i = getTypeCondition(r);
  if (!i || t === i) {
    return !0;
  } else if (e.types.has(i) && "OBJECT" === e.types.get(i).kind) {
    return i === t;
  }
  !function expectAbstractType(e, r) {
    invariant(e.types.has(r) && ("INTERFACE" === e.types.get(r).kind || "UNION" === e.types.get(r).kind), "production" !== process.env.NODE_ENV ? "Invalid Abstract type: The type `" + r + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5);
  }(e, i);
  expectObjectType(e, t);
  return e.isSubType(i, t);
};

var getField = (e, r, t, i) => {
  if (0 === t.indexOf(k) || 0 === r.indexOf(k)) {
    return;
  }
  expectObjectType(e, r);
  var a = e.types.get(r).fields()[t];
  if ("production" !== process.env.NODE_ENV) {
    if (!a) {
      warn("Invalid field: The field `" + t + "` does not exist on `" + r + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4, i);
    }
  }
  return a;
};

function expectObjectType(e, r) {
  invariant(e.types.has(r) && "OBJECT" === e.types.get(r).kind, "production" !== process.env.NODE_ENV ? "Invalid Object type: The type `" + r + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}

function warnAboutResolver(e, r) {
  "production" !== process.env.NODE_ENV && warn(`Invalid resolver: \`${e}\` is not in the defined schema, but the \`resolvers\` option is referencing it.`, 23, r);
}

function warnAboutAbstractResolver(e, r, t) {
  "production" !== process.env.NODE_ENV && warn(`Invalid resolver: \`${e}\` does not match to a concrete type in the schema, but the \`resolvers\` option is referencing it. Implement the resolver for the types that ${"UNION" === r ? "make up the union" : "implement the interface"} instead.`, 26, t);
}

var keyOfField = (r, t) => t ? `${r}(${e(t)})` : r;

var joinKeys = (e, r) => `${e}.${r}`;

var fieldInfoOfKey = e => {
  var r = e.indexOf("(");
  if (r > -1) {
    return {
      fieldKey: e,
      fieldName: e.slice(0, r),
      arguments: JSON.parse(e.slice(r + 1, -1))
    };
  } else {
    return {
      fieldKey: e,
      fieldName: e,
      arguments: null
    };
  }
};

var deserializeKeyInfo = e => {
  var r = e.indexOf(".");
  return {
    entityKey: e.slice(0, r).replace(/%2e/g, "."),
    fieldKey: e.slice(r + 1)
  };
};

var E = null;

var O = null;

var w = null;

var b = null;

var D = null;

var x = null;

var V = !1;

var I = !1;

function makeData(e, r) {
  var t;
  if (e) {
    if (E.has(e)) {
      return e;
    }
    t = O.get(e);
  }
  if (null == t) {
    t = r ? [] : {};
  }
  if (e) {
    O.set(e, t);
  }
  E.add(t);
  return t;
}

var ownsData = e => !!e && E.has(e);

var initDataState = (e, r, t, i, a) => {
  E = new WeakSet;
  O = new WeakMap;
  D = e;
  w = r;
  x = new Set;
  I = !!i;
  V = !!a;
  if ("production" !== process.env.NODE_ENV) {
    g.length = 0;
  }
  if (!t) {
    b = null;
  } else if ("read" === D) {
    b = t;
  } else if (i || r.hydrating || r.optimisticOrder.length > 1) {
    if (!i && !r.commutativeKeys.has(t)) {
      reserveLayer(r, t);
    } else if (i) {
      if (-1 !== r.optimisticOrder.indexOf(t) && !r.commutativeKeys.has(t)) {
        r.optimisticOrder.splice(r.optimisticOrder.indexOf(t), 1);
      }
      r.commutativeKeys.delete(t);
    }
    b = t;
    createLayer(r, t);
  } else {
    b = null;
    deleteLayer(r, t);
  }
};

var clearDataState = () => {
  if ("production" !== process.env.NODE_ENV) {
    getCurrentDependencies();
  }
  var e = w;
  var r = b;
  I = !1;
  b = null;
  if (!e.hydrating && r && e.optimisticOrder.indexOf(r) > -1) {
    var t = e.optimisticOrder.length;
    while (--t >= 0 && e.dirtyKeys.has(e.optimisticOrder[t]) && e.commutativeKeys.has(e.optimisticOrder[t])) {
      squashLayer(e.optimisticOrder[t]);
    }
  }
  E = null;
  O = null;
  D = null;
  w = null;
  x = null;
  if ("production" !== process.env.NODE_ENV) {
    g.length = 0;
  }
  if ("test" !== process.env.NODE_ENV) {
    if (!e.defer && (e.storage || !e.optimisticOrder.length)) {
      e.defer = !0;
      setTimeout((() => {
        initDataState("read", e, null);
        gc();
        persistData();
        clearDataState();
        e.defer = !1;
      }));
    }
  }
};

var noopDataState = (e, r, t) => {
  if (r && !t) {
    e.deferredKeys.delete(r);
  }
  initDataState("write", e, r, t);
  clearDataState();
};

var getCurrentDependencies = () => {
  invariant(null !== x, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return x;
};

var setNode = (e, r, t, i) => {
  if ("production" !== process.env.NODE_ENV) {
    invariant("read" !== D, "production" !== process.env.NODE_ENV ? "Invalid Cache write: You may not write to the cache during cache reads.  Accesses to `cache.writeFragment`, `cache.updateQuery`, and `cache.link` may  not be made inside `resolvers` for instance." : "", 27);
  }
  var a = b ? e.optimistic.get(b) : e.base;
  var n = a.get(r);
  if (void 0 === n) {
    a.set(r, n = Object.create(null));
  }
  if (void 0 === i && !b) {
    delete n[t];
  } else {
    n[t] = i;
  }
};

var getNode = (e, r, t) => {
  var i;
  var a = !I && "read" === D && b && w.commutativeKeys.has(b);
  for (var n = 0, o = w.optimisticOrder.length; n < o; n++) {
    var s = w.optimisticOrder[n];
    var l = e.optimistic.get(s);
    a = a && s !== b;
    if (l && (!a || !w.commutativeKeys.has(s)) && (!I || "write" === D || w.commutativeKeys.has(s)) && void 0 !== (i = l.get(r)) && t in i) {
      return i[t];
    }
  }
  return void 0 !== (i = e.base.get(r)) ? i[t] : void 0;
};

var updateRCForLink = (e, r) => {
  if (Array.isArray(e)) {
    for (var t = 0, i = e.length; t < i; t++) {
      updateRCForLink(e[t], r);
    }
  } else if ("string" == typeof e) {
    ((e, r) => {
      var t = w.refCount.get(e) || 0;
      var i = t + r > 0 ? t + r : 0;
      w.refCount.set(e, i);
      if (!i) {
        w.gc.add(e);
      } else if (!t && i) {
        w.gc.delete(e);
      }
    })(e, r);
  }
};

var extractNodeFields = (e, r, t) => {
  if (void 0 !== t) {
    for (var i in t) {
      if (!r.has(i)) {
        e.push(fieldInfoOfKey(i));
        r.add(i);
      }
    }
  }
};

var extractNodeMapFields = (e, r, t, i) => {
  extractNodeFields(e, r, i.base.get(t));
  for (var a = 0, n = w.optimisticOrder.length; a < n; a++) {
    var o = i.optimistic.get(w.optimisticOrder[a]);
    if (void 0 !== o) {
      extractNodeFields(e, r, o.get(t));
    }
  }
};

var gc = () => {
  if (w.optimisticOrder.length) {
    return;
  }
  for (var e of w.gc.keys()) {
    w.gc.delete(e);
    if ((w.refCount.get(e) || 0) > 0) {
      continue;
    }
    w.refCount.delete(e);
    w.records.base.delete(e);
    var r = w.links.base.get(e);
    if (r) {
      w.links.base.delete(e);
      for (var t in r) {
        updateRCForLink(r[t], -1);
      }
    }
  }
};

var updateDependencies = (e, r) => {
  if (e !== w.queryRootKey) {
    x.add(e);
  } else if (void 0 !== r && "__typename" !== r) {
    x.add(joinKeys(e, r));
  }
};

var updatePersist = (e, r) => {
  if (!I && w.storage) {
    w.persist.add(((e, r) => `${e.replace(/\./g, "%2e")}.${r}`)(e, r));
  }
};

var readRecord = (e, r) => {
  updateDependencies(e, r);
  return getNode(w.records, e, r);
};

var readLink = (e, r) => {
  updateDependencies(e, r);
  return getNode(w.links, e, r);
};

var writeRecord = (e, r, t) => {
  updateDependencies(e, r);
  updatePersist(e, r);
  setNode(w.records, e, r, t);
};

var hasField = (e, r) => void 0 !== readRecord(e, r) || void 0 !== readLink(e, r);

var writeLink = (e, r, t) => {
  var i = b ? w.links.optimistic.get(b) : w.links.base;
  if (!b) {
    var a = i && i.get(e);
    updateRCForLink(a && a[r], -1);
    updateRCForLink(t, 1);
  }
  updateDependencies(e, r);
  updatePersist(e, r);
  setNode(w.links, e, r, t);
};

var reserveLayer = (e, r, t) => {
  var i = e.optimisticOrder.indexOf(r);
  if (i > -1) {
    e.optimisticOrder.splice(i, 1);
  }
  if (t) {
    e.deferredKeys.add(r);
    for (i = i > -1 ? i : 0; i < e.optimisticOrder.length && !e.deferredKeys.has(e.optimisticOrder[i]) && (!e.dirtyKeys.has(e.optimisticOrder[i]) || !e.commutativeKeys.has(e.optimisticOrder[i])); i++) {}
  } else {
    e.deferredKeys.delete(r);
    if (i > -1 && !e.commutativeKeys.has(r)) {
      clearLayer(e, r);
    }
    i = 0;
  }
  e.optimisticOrder.splice(i, 0, r);
  e.commutativeKeys.add(r);
};

var createLayer = (e, r) => {
  if (-1 === e.optimisticOrder.indexOf(r)) {
    e.optimisticOrder.unshift(r);
  }
  if (!e.dirtyKeys.has(r)) {
    e.dirtyKeys.add(r);
    e.links.optimistic.set(r, new Map);
    e.records.optimistic.set(r, new Map);
  }
};

var clearLayer = (e, r) => {
  if (e.dirtyKeys.has(r)) {
    e.dirtyKeys.delete(r);
    e.records.optimistic.delete(r);
    e.links.optimistic.delete(r);
    e.deferredKeys.delete(r);
  }
};

var deleteLayer = (e, r) => {
  var t = e.optimisticOrder.indexOf(r);
  if (t > -1) {
    e.optimisticOrder.splice(t, 1);
    e.commutativeKeys.delete(r);
  }
  clearLayer(e, r);
};

var squashLayer = e => {
  var r = x;
  x = new Set;
  D = "write";
  var t = w.links.optimistic.get(e);
  if (t) {
    for (var i of t.entries()) {
      var a = i[0];
      var n = i[1];
      for (var o in n) {
        writeLink(a, o, n[o]);
      }
    }
  }
  var s = w.records.optimistic.get(e);
  if (s) {
    for (var l of s.entries()) {
      var v = l[0];
      var d = l[1];
      for (var u in d) {
        writeRecord(v, u, d[u]);
      }
    }
  }
  x = r;
  deleteLayer(w, e);
};

var inspectFields = e => {
  var {links: r, records: t} = w;
  var i = [];
  var a = new Set;
  updateDependencies(e);
  extractNodeMapFields(i, a, e, r);
  extractNodeMapFields(i, a, e, t);
  return i;
};

var persistData = () => {
  if (w.storage) {
    I = !0;
    D = "read";
    var r = {};
    for (var t of w.persist.keys()) {
      var {entityKey: i, fieldKey: a} = deserializeKeyInfo(t);
      var n = void 0;
      if (void 0 !== (n = readLink(i, a))) {
        r[t] = `:${e(n)}`;
      } else if (void 0 !== (n = readRecord(i, a))) {
        r[t] = e(n);
      } else {
        r[t] = void 0;
      }
    }
    I = !1;
    w.storage.writeData(r);
    w.persist.clear();
  }
};

var q = null;

var T = !1;

var getFieldError = e => e.__internal.path.length > 0 && e.__internal.errorMap ? e.__internal.errorMap[e.__internal.path.join(".")] : void 0;

var makeContext = (e, r, t, i, a, n) => {
  var o = {
    store: e,
    variables: r,
    fragments: t,
    parent: {
      __typename: i
    },
    parentTypeName: i,
    parentKey: a,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: !1,
    hasNext: !1,
    optimistic: I,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (n && n.graphQLErrors) {
    for (var s = 0; s < n.graphQLErrors.length; s++) {
      var l = n.graphQLErrors[s];
      if (l.path && l.path.length) {
        if (!o.__internal.errorMap) {
          o.__internal.errorMap = Object.create(null);
        }
        o.__internal.errorMap[l.path.join(".")] = l;
      }
    }
  }
  return o;
};

var updateContext = (e, r, t, i, a, n) => {
  q = e;
  e.parent = r;
  e.parentTypeName = t;
  e.parentKey = i;
  e.parentFieldKey = a;
  e.fieldName = n;
  e.error = getFieldError(e);
};

var isFragmentHeuristicallyMatching = (e, r, t, i, a) => {
  if (!r) {
    return !1;
  }
  var o = getTypeCondition(e);
  if (!o || r === o) {
    return !0;
  }
  "production" !== process.env.NODE_ENV && warn("Heuristic Fragment Matching: A fragment is trying to match against the `" + r + "` type, but the type condition is `" + o + "`. Since GraphQL allows for interfaces `" + o + "` may be an interface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16, a);
  return "write" === D || !getSelectionSet(e).some((e => {
    if (e.kind !== n.FIELD) {
      return !1;
    }
    var r = keyOfField(getName(e), getFieldArguments(e, i));
    return !hasField(t, r);
  }));
};

var makeSelectionIterator = (e, r, t, i, a) => {
  var o;
  var s = 0;
  return function next() {
    var l;
    while (o || s < i.length) {
      l = void 0;
      T = t;
      if (o) {
        if (l = o()) {
          return l;
        } else {
          o = void 0;
          if ("production" !== process.env.NODE_ENV) {
            popDebugNode();
          }
        }
      } else {
        var v = i[s++];
        if (!shouldInclude(v, a.variables)) {} else if (v.kind !== n.FIELD) {
          var d = v.kind !== n.INLINE_FRAGMENT ? a.fragments[getName(v)] : v;
          if (d) {
            if (!d.typeCondition || (a.store.schema ? isInterfaceOfType(a.store.schema, d, e) : isFragmentHeuristicallyMatching(d, e, r, a.variables, a.store.logger))) {
              if ("production" !== process.env.NODE_ENV) {
                pushDebugNode(e, d);
              }
              o = makeSelectionIterator(e, r, t || isDeferred(v, a.variables), getSelectionSet(d), a);
            }
          }
        } else if ("write" === D || !v._generated) {
          return v;
        }
      }
    }
  };
};

var ensureData = e => null == e ? null : e;

var ensureLink = (e, r) => {
  if (!r) {
    return r || null;
  } else if (Array.isArray(r)) {
    var t = new Array(r.length);
    for (var i = 0, a = t.length; i < a; i++) {
      t[i] = ensureLink(e, r[i]);
    }
    return t;
  }
  var n = e.keyOfEntity(r);
  if ("production" !== process.env.NODE_ENV) {
    if (!n && r && "object" == typeof r) {
      warn("Can't generate a key for link(...) item.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + r.__typename + "`.", 12, e.logger);
    }
  }
  return n;
};

var _query = (e, t, i, a) => {
  var n = r(t.query);
  var o = getMainOperation(n);
  var s = e.rootFields[o.operation];
  var l = getSelectionSet(o);
  var v = makeContext(e, normalizeVariables(o, t.variables), getFragments(n), s, s, a);
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(s, o);
  }
  var d = s !== v.store.rootFields.query ? readRoot(v, s, l, i || makeData()) : readSelection(v, s, l, i || makeData());
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
    getCurrentDependencies();
  }
  return {
    dependencies: x,
    partial: v.partial || !d,
    hasNext: v.hasNext,
    data: d || null
  };
};

var readRoot = (e, r, t, i) => {
  if ("string" != typeof (e.store.rootNames[r] ? r : i.__typename)) {
    return i;
  }
  var a = makeSelectionIterator(r, r, T, t, e);
  var n;
  var o = V;
  var s = makeData(i);
  while (n = a()) {
    var l = getFieldAlias(n);
    var v = i[l];
    e.__internal.path.push(l);
    var d = void 0;
    if (n.selectionSet && null !== v) {
      d = readRootField(e, getSelectionSet(n), ensureData(v));
    } else {
      d = v;
    }
    o = o || d !== v;
    if (void 0 !== d) {
      s[l] = d;
    }
    e.__internal.path.pop();
  }
  return o ? s : i;
};

var readRootField = (e, r, t) => {
  if (Array.isArray(t)) {
    var i = new Array(t.length);
    var a = V;
    for (var n = 0, o = t.length; n < o; n++) {
      e.__internal.path.push(n);
      i[n] = readRootField(e, r, t[n]);
      a = a || i[n] !== t[n];
      e.__internal.path.pop();
    }
    return a ? i : t;
  } else if (null === t) {
    return null;
  }
  var s = e.store.keyOfEntity(t);
  if (null !== s) {
    return readSelection(e, s, r, t) || null;
  } else {
    return readRoot(e, t.__typename, r, t);
  }
};

function getFieldResolver(e, r, t, i) {
  var a = i.store.resolvers[r];
  var n = a && a[t];
  var o;
  for (var s in e) {
    var l = e[s];
    if (l && "include" !== s && "skip" !== s && i.store.directives[s]) {
      o = i.store.directives[s](getFieldArguments(l, i.variables));
      if ("production" === process.env.NODE_ENV) {
        return o;
      }
      break;
    }
  }
  if ("production" !== process.env.NODE_ENV) {
    if (n && o) {
      warn(`A resolver and directive is being used at "${r}.${t}" simultaneously. Only the directive will apply.`, 28, i.store.logger);
    }
  }
  return o || n;
}

var readSelection = (e, r, t, i, a) => {
  var {store: n} = e;
  var o = r === n.rootFields.query;
  var s = a && n.keyOfEntity(a) || r;
  if ("production" !== process.env.NODE_ENV) {
    if (!o && e.store.rootNames[s]) {
      warn("Invalid root traversal: A selection was being read on `" + s + "` which is an uncached root type.\nThe `" + e.store.rootFields.mutation + "` and `" + e.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25, n.logger);
    }
  }
  var l = !o ? readRecord(s, "__typename") || a && a.__typename : r;
  if ("string" != typeof l) {
    return;
  } else if (a && l !== a.__typename) {
    "production" !== process.env.NODE_ENV && warn("Invalid resolver data: The resolver at `" + s + "` returned an invalid typename that could not be reconciled with the cache.", 8, n.logger);
    return;
  }
  var v = makeSelectionIterator(l, s, T, t, e);
  var d = !1;
  var u = !1;
  var c = V;
  var p;
  var f = e.partial;
  var y = makeData(i);
  while (void 0 !== (p = v())) {
    var h = getName(p);
    var m = getFieldArguments(p, e.variables);
    var g = getFieldAlias(p);
    var N = getDirectives(p);
    var _ = getFieldResolver(N, l, h, e);
    var k = keyOfField(h, m);
    var E = joinKeys(s, k);
    var O = readRecord(s, k);
    var w = a ? a[h] : void 0;
    if ("production" !== process.env.NODE_ENV && n.schema && l) {
      isFieldAvailableOnType(n.schema, l, h, e.store.logger);
    }
    e.__internal.path.push(g);
    var b = void 0;
    if ("__typename" === h) {
      b = l;
    } else if (void 0 !== w && void 0 === p.selectionSet) {
      b = w;
    } else if ("read" === D && _) {
      var x = y;
      if (void 0 === p.selectionSet && void 0 !== O) {
        x = {
          ...y,
          [g]: O,
          [h]: O
        };
      }
      updateContext(e, x, l, s, k, h);
      b = _(x, m || {}, n, e);
      if (p.selectionSet) {
        b = resolveResolverResult(e, l, h, E, getSelectionSet(p), void 0 !== y[g] ? y[g] : i[g], b, ownsData(i));
      }
      if (n.schema && null === b && !isFieldNullable(n.schema, l, h, e.store.logger)) {
        return;
      }
    } else if (!p.selectionSet) {
      b = O;
    } else if (void 0 !== w) {
      b = resolveResolverResult(e, l, h, E, getSelectionSet(p), void 0 !== y[g] ? y[g] : i[g], w, ownsData(i));
    } else {
      var I = readLink(s, k);
      if (void 0 !== I) {
        b = resolveLink(e, I, l, h, getSelectionSet(p), void 0 !== y[g] ? y[g] : i[g], ownsData(i));
      } else if ("object" == typeof O && null !== O) {
        b = O;
      }
    }
    if (!T && void 0 === b && (N.optional || getFieldError(e) || n.schema && isFieldNullable(n.schema, l, h, e.store.logger))) {
      e.partial = !0;
      b = null;
    } else if (null === b && N.required) {
      if (e.store.logger && "production" !== process.env.NODE_ENV && "read" === D) {
        e.store.logger("debug", `Got value "null" for required field "${h}"${m ? ` with args ${JSON.stringify(m)}` : ""} on entity "${s}"`);
      }
      b = void 0;
    } else {
      d = d || "__typename" !== h;
    }
    e.__internal.path.pop();
    c = c || b !== i[g];
    if (void 0 !== b) {
      y[g] = b;
    } else if (T) {
      u = !0;
    } else {
      if (e.store.logger && "production" !== process.env.NODE_ENV && "read" === D) {
        e.store.logger("debug", `No value for field "${h}"${m ? ` with args ${JSON.stringify(m)}` : ""} on entity "${s}"`);
      }
      e.partial = f;
      return;
    }
  }
  e.partial = e.partial || f;
  e.hasNext = e.hasNext || u;
  return o && e.partial && !d ? void 0 : c ? y : i;
};

var resolveResolverResult = (e, r, t, i, a, n, o, s) => {
  if (Array.isArray(o)) {
    var {store: l} = e;
    var v = l.schema ? isListNullable(l.schema, r, t, e.store.logger) : !1;
    var d = e.partial;
    var u = makeData(n, !0);
    var c = V || !Array.isArray(n) || o.length !== n.length;
    for (var p = 0, f = o.length; p < f; p++) {
      e.__internal.path.push(p);
      var y = resolveResolverResult(e, r, t, joinKeys(i, `${p}`), a, null != n ? n[p] : void 0, o[p], s);
      e.__internal.path.pop();
      if (void 0 === y && !v) {
        e.partial = d;
        return;
      } else {
        e.partial = e.partial || void 0 === y && v;
        u[p] = null != y ? y : null;
        c = c || u[p] !== n[p];
      }
    }
    return c ? u : n;
  } else if (null == o) {
    return o;
  } else if (s && null === n) {
    return null;
  } else if (isDataOrKey(o)) {
    var h = n || makeData(n);
    return "string" == typeof o ? readSelection(e, o, a, h) : readSelection(e, i, a, h, o);
  } else {
    "production" !== process.env.NODE_ENV && warn("Invalid resolver value: The field at `" + i + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9, e.store.logger);
    return;
  }
};

var resolveLink = (e, r, t, i, a, n, o) => {
  if (Array.isArray(r)) {
    var {store: s} = e;
    var l = s.schema ? isListNullable(s.schema, t, i, e.store.logger) : !1;
    var v = makeData(n, !0);
    var d = e.partial;
    var u = V || !Array.isArray(n) || r.length !== n.length;
    for (var c = 0, p = r.length; c < p; c++) {
      e.__internal.path.push(c);
      var f = resolveLink(e, r[c], t, i, a, null != n ? n[c] : void 0, o);
      e.__internal.path.pop();
      if (void 0 === f && !l) {
        e.partial = d;
        return;
      } else {
        e.partial = e.partial || void 0 === f && l;
        v[c] = f || null;
        u = u || v[c] !== n[c];
      }
    }
    return u ? v : n;
  } else if (null === r || null === n && o) {
    return null;
  }
  return readSelection(e, r, a, n || makeData(n));
};

var isDataOrKey = e => "string" == typeof e || "object" == typeof e && "string" == typeof e.__typename;

var _write = (e, t, i, a) => {
  if ("production" !== process.env.NODE_ENV) {
    getCurrentDependencies();
  }
  var n = r(t.query);
  var o = getMainOperation(n);
  var s = {
    data: i || makeData(),
    dependencies: x
  };
  var l = e.rootFields[o.operation];
  var v = makeContext(e, normalizeVariables(o, t.variables), getFragments(n), l, l, a);
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(l, o);
  }
  writeSelection(v, l, getSelectionSet(o), s.data);
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
  }
  return s;
};

var writeSelection = (e, r, t, i) => {
  var a = e.store.rootNames[r] || "query";
  var n = !!e.store.rootNames[r];
  var o = n ? r : i.__typename;
  if (!o && r && e.optimistic) {
    o = readRecord(r, "__typename");
  }
  if (!o) {
    "production" !== process.env.NODE_ENV && warn("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14, e.store.logger);
    return;
  } else if (!n && r) {
    writeRecord(r, "__typename", o);
  }
  var s = e.store.updates[o];
  var l = makeSelectionIterator(o, r || o, T, t, e);
  var v;
  while (v = l()) {
    var d = getName(v);
    var u = getFieldArguments(v, e.variables);
    var c = keyOfField(d, u);
    var p = getFieldAlias(v);
    var f = i[e.optimistic ? d : p];
    if ("__typename" === d || void 0 === f && (T || e.optimistic && "query" === a)) {
      continue;
    }
    if ("production" !== process.env.NODE_ENV) {
      if (e.store.schema && o && "__typename" !== d) {
        isFieldAvailableOnType(e.store.schema, o, d, e.store.logger);
      }
    }
    e.__internal.path.push(p);
    var y = void 0;
    if (e.optimistic && "mutation" === a) {
      if (!(y = e.store.optimisticMutations[d])) {
        continue;
      }
    } else if (e.optimistic && "function" == typeof f) {
      y = f;
    }
    if (y) {
      updateContext(e, i, o, r || o, c, d);
      f = ensureData(y(u || {}, e.store, e));
    }
    if (void 0 === f) {
      if ("production" !== process.env.NODE_ENV) {
        if (!r || !hasField(r, c) || e.optimistic && !readRecord(r, "__typename")) {
          "production" !== process.env.NODE_ENV && warn("Invalid undefined: The field at `" + c + "` is `undefined`, but the GraphQL query expects a " + (void 0 === v.selectionSet ? "scalar (number, boolean, etc)" : "selection set") + " for this field.", 13, e.store.logger);
        }
      }
      continue;
    }
    if (v.selectionSet) {
      if (r && "query" === a) {
        var h = joinKeys(r, c);
        var m = writeField(e, getSelectionSet(v), ensureData(f), h, e.optimistic ? readLink(r || o, c) : void 0);
        writeLink(r || o, c, m);
      } else {
        writeField(e, getSelectionSet(v), ensureData(f));
      }
    } else if (r && "query" === a) {
      writeRecord(r || o, c, null !== f || !getFieldError(e) ? f : void 0);
    }
    var g = s && s[d];
    if (g) {
      updateContext(e, i, o, r || o, c, d);
      i[d] = f;
      g(i, u || {}, e.store, e);
    }
    e.__internal.path.pop();
  }
};

var A = /^__|PageInfo|(Connection|Edge)$/;

var writeField = (e, r, t, i, a) => {
  if (Array.isArray(t)) {
    var n = new Array(t.length);
    for (var o = 0, s = t.length; o < s; o++) {
      e.__internal.path.push(o);
      var l = i ? joinKeys(i, `${o}`) : void 0;
      var v = writeField(e, r, t[o], l, null != a ? a[o] : void 0);
      n[o] = v;
      e.__internal.path.pop();
    }
    return n;
  } else if (null === t) {
    return getFieldError(e) ? void 0 : null;
  }
  var d = e.store.keyOfEntity(t) || ("string" == typeof a ? a : null);
  var u = t.__typename;
  if ("production" !== process.env.NODE_ENV) {
    if (i && !e.store.keys[t.__typename] && null === d && "string" == typeof u && !A.test(u)) {
      warn("Invalid key: The GraphQL query at the field at `" + i + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + u + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + u + "` that always returns null.", 15, e.store.logger);
    }
  }
  var c = d || i;
  writeSelection(e, c, r, t);
  return c || null;
};

class Store {
  constructor(e) {
    if (!e) {
      e = {};
    }
    this.logger = e.logger;
    this.resolvers = e.resolvers || {};
    this.directives = e.directives || {};
    this.optimisticMutations = e.optimistic || {};
    this.keys = e.keys || {};
    this.globalIDs = Array.isArray(e.globalIDs) ? new Set(e.globalIDs) : !!e.globalIDs;
    var r = "Query";
    var t = "Mutation";
    var i = "Subscription";
    if (e.schema) {
      var a = (({__schema: e}) => {
        var r = new Map;
        var buildNameMap = e => {
          var r;
          return () => {
            if (!r) {
              r = {};
              for (var t = 0; t < e.length; t++) {
                r[e[t].name] = e[t];
              }
            }
            return r;
          };
        };
        var buildType = e => {
          switch (e.kind) {
           case "OBJECT":
           case "INTERFACE":
            return {
              name: e.name,
              kind: e.kind,
              interfaces: buildNameMap(e.interfaces || []),
              fields: buildNameMap(e.fields.map((e => ({
                name: e.name,
                type: e.type,
                args: buildNameMap(e.args)
              }))))
            };

           case "UNION":
            return {
              name: e.name,
              kind: e.kind,
              types: buildNameMap(e.possibleTypes || [])
            };
          }
        };
        var t = {
          query: e.queryType ? e.queryType.name : null,
          mutation: e.mutationType ? e.mutationType.name : null,
          subscription: e.subscriptionType ? e.subscriptionType.name : null,
          types: void 0,
          isSubType(e, t) {
            var i = r.get(e);
            var a = r.get(t);
            if (!i || !a) {
              return !1;
            } else if ("UNION" === i.kind) {
              return !!i.types()[t];
            } else if ("OBJECT" !== i.kind && "OBJECT" === a.kind) {
              return !!a.interfaces()[e];
            } else {
              return e === t;
            }
          }
        };
        if (e.types) {
          t.types = r;
          for (var i = 0; i < e.types.length; i++) {
            var a = e.types[i];
            if (a && a.name) {
              var n = buildType(a);
              if (n) {
                r.set(a.name, n);
              }
            }
          }
        }
        return t;
      })(e.schema);
      r = a.query || r;
      t = a.mutation || t;
      i = a.subscription || i;
      if (a.types) {
        this.schema = a;
      }
    }
    this.updates = e.updates || {};
    this.rootFields = {
      query: r,
      mutation: t,
      subscription: i
    };
    this.rootNames = {
      [r]: "query",
      [t]: "mutation",
      [i]: "subscription"
    };
    this.data = (n = r, {
      hydrating: !1,
      defer: !1,
      gc: new Set,
      persist: new Set,
      queryRootKey: n,
      refCount: new Map,
      links: {
        optimistic: new Map,
        base: new Map
      },
      records: {
        optimistic: new Map,
        base: new Map
      },
      deferredKeys: new Set,
      commutativeKeys: new Set,
      dirtyKeys: new Set,
      optimisticOrder: [],
      storage: null
    });
    var n;
    if (this.schema && "production" !== process.env.NODE_ENV) {
      !function expectValidKeyingConfig(e, r, t) {
        if ("production" !== process.env.NODE_ENV) {
          for (var i in r) {
            if ("production" !== process.env.NODE_ENV) {
              if (!e.types.has(i)) {
                warn("Invalid Object type: The type `" + i + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20, t);
              }
            }
          }
        }
      }(this.schema, this.keys, this.logger);
      !function expectValidUpdatesConfig(e, r, t) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        for (var i in r) {
          if (!r[i]) {
            continue;
          } else if (!e.types.has(i)) {
            var a = "";
            if ("Mutation" === i && e.mutation && "Mutation" !== e.mutation) {
              a += "\nMaybe your config should reference `" + e.mutation + "`?";
            } else if ("Subscription" === i && e.subscription && "Subscription" !== e.subscription) {
              a += "\nMaybe your config should reference `" + e.subscription + "`?";
            }
            return "production" !== process.env.NODE_ENV ? warn("Invalid updates type: The type `" + i + "` is not an object in the defined schema, but the `updates` config is referencing it." + a, 21, t) : void 0;
          }
          var n = e.types.get(i).fields();
          for (var o in r[i]) {
            if ("production" !== process.env.NODE_ENV) {
              if (!n[o]) {
                warn("Invalid updates field: `" + o + "` on `" + i + "` is not in the defined schema, but the `updates` config is referencing it.", 22, t);
              }
            }
          }
        }
      }(this.schema, this.updates, this.logger);
      !function expectValidResolversConfig(e, r, t) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        for (var i in r) {
          if ("Query" === i) {
            if (e.query) {
              var a = e.types.get(e.query).fields();
              for (var n in r.Query || {}) {
                if (!a[n]) {
                  warnAboutResolver("Query." + n, t);
                }
              }
            } else {
              warnAboutResolver("Query", t);
            }
          } else if (!e.types.has(i)) {
            warnAboutResolver(i, t);
          } else if ("INTERFACE" === e.types.get(i).kind || "UNION" === e.types.get(i).kind) {
            warnAboutAbstractResolver(i, e.types.get(i).kind, t);
          } else {
            var o = e.types.get(i).fields();
            for (var s in r[i] || {}) {
              if (!o[s]) {
                warnAboutResolver(i + "." + s, t);
              }
            }
          }
        }
      }(this.schema, this.resolvers, this.logger);
      !function expectValidOptimisticMutationsConfig(e, r, t) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        if (e.mutation) {
          var i = e.types.get(e.mutation).fields();
          for (var a in r) {
            if ("production" !== process.env.NODE_ENV) {
              if (!i[a]) {
                warn(`Invalid optimistic mutation field: \`${a}\` is not a mutation field in the defined schema, but the \`optimistic\` option is referencing it.`, 24, t);
              }
            }
          }
        }
      }(this.schema, this.optimisticMutations, this.logger);
    }
  }
  keyOfField(e, r) {
    return keyOfField(e, r);
  }
  keyOfEntity(e) {
    if (q && e === q.parent) {
      return q.parentKey;
    } else if (null == e || "string" == typeof e) {
      return e || null;
    } else if (!e.__typename) {
      return null;
    } else if (this.rootNames[e.__typename]) {
      return e.__typename;
    }
    var r = null;
    if (this.keys[e.__typename]) {
      r = this.keys[e.__typename](e) || null;
    } else if (null != e.id) {
      r = `${e.id}`;
    } else if (null != e._id) {
      r = `${e._id}`;
    }
    var t = e.__typename;
    return !0 === this.globalIDs || this.globalIDs && this.globalIDs.has(t) || !r ? r : `${t}:${r}`;
  }
  resolve(e, r, t) {
    var i = null;
    var a = this.keyOfEntity(e);
    if (a) {
      var n = keyOfField(r, t);
      if (void 0 === (i = readRecord(a, n))) {
        i = readLink(a, n);
      }
    }
    return i;
  }
  resolveFieldByKey(e, r, t) {
    return this.resolve(e, r, t);
  }
  invalidate(e, r, t) {
    var i = this.keyOfEntity(e);
    invariant(i, "production" !== process.env.NODE_ENV ? "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + ("object" == typeof e ? e.__typename : e + "`.") : "", 19);
    ((e, r, t) => {
      var i = r ? [ {
        fieldKey: keyOfField(r, t)
      } ] : inspectFields(e);
      for (var a = 0, n = i.length; a < n; a++) {
        var {fieldKey: o} = i[a];
        if (void 0 !== readLink(e, o)) {
          writeLink(e, o, void 0);
        } else {
          writeRecord(e, o, void 0);
        }
      }
    })(i, r, t);
  }
  inspectFields(e) {
    var r = this.keyOfEntity(e);
    return r ? inspectFields(r) : [];
  }
  updateQuery(e, r) {
    var i = t(e.query, e.variables);
    var a = r(this.readQuery(i));
    if (null !== a) {
      _write(this, i, a, void 0);
    }
  }
  readQuery(e) {
    var r = t(e.query, e.variables);
    return _query(this, r, void 0, void 0).data;
  }
  readFragment(e, t, i, a) {
    return ((e, r, t, i, a) => {
      var n = getFragments(r);
      var o;
      if (a) {
        if (!(o = n[a])) {
          "production" !== process.env.NODE_ENV && warn("readFragment(...) was called with a fragment name that does not exist.\nYou provided " + a + " but could only find " + Object.keys(n).join(", ") + ".", 6, e.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        "production" !== process.env.NODE_ENV && warn("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6, e.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      if ("string" != typeof t && !t.__typename) {
        t.__typename = s;
      }
      var l = e.keyOfEntity(t);
      if (!l) {
        "production" !== process.env.NODE_ENV && warn("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 7, e.logger);
        return null;
      }
      if ("production" !== process.env.NODE_ENV) {
        pushDebugNode(s, o);
      }
      var v = makeContext(e, i || {}, n, s, l, void 0);
      var d = readSelection(v, l, getSelectionSet(o), makeData()) || null;
      if ("production" !== process.env.NODE_ENV) {
        popDebugNode();
      }
      return d;
    })(this, r(e), t, i, a);
  }
  writeFragment(e, t, i, a) {
    ((e, r, t, i, a) => {
      var n = getFragments(r);
      var o;
      if (a) {
        if (!(o = n[a])) {
          "production" !== process.env.NODE_ENV && warn("writeFragment(...) was called with a fragment name that does not exist.\nYou provided " + a + " but could only find " + Object.keys(n).join(", ") + ".", 11, e.logger);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        "production" !== process.env.NODE_ENV && warn("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11, e.logger);
        return null;
      }
      var s = getFragmentTypeName(o);
      var l = {
        __typename: s,
        ...t
      };
      var v = e.keyOfEntity(l);
      if (!v) {
        return "production" !== process.env.NODE_ENV ? warn("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 12, e.logger) : void 0;
      }
      if ("production" !== process.env.NODE_ENV) {
        pushDebugNode(s, o);
      }
      var d = makeContext(e, i || {}, n, s, v, void 0);
      writeSelection(d, v, getSelectionSet(o), l);
      if ("production" !== process.env.NODE_ENV) {
        popDebugNode();
      }
    })(this, r(e), t, i, a);
  }
  link(e, r, ...t) {
    var i = 2 === t.length ? t[0] : null;
    var a = 2 === t.length ? t[1] : t[0];
    var n = this.keyOfEntity(e);
    if (n) {
      writeLink(n, keyOfField(r, i), ensureLink(this, a));
    }
  }
}

var addMetadata = (e, r) => i(e.kind, e, {
  ...e.context,
  meta: {
    ...e.context.meta,
    ...r
  }
});

var toRequestPolicy = (e, r) => i(e.kind, e, {
  ...e.context,
  requestPolicy: r
});

var cacheExchange = e => ({forward: t, client: a, dispatchDebug: n}) => {
  var o = new Store(e);
  if (e && e.storage) {
    o.data.hydrating = !0;
    e.storage.readData().then((r => {
      ((e, r, t) => {
        initDataState("write", e, null);
        for (var i in t) {
          var a = t[i];
          if (void 0 !== a) {
            var {entityKey: n, fieldKey: o} = deserializeKeyInfo(i);
            if (":" === a[0]) {
              if (void 0 === readLink(n, o)) {
                writeLink(n, o, JSON.parse(a.slice(1)));
              }
            } else if (void 0 === readRecord(n, o)) {
              writeRecord(n, o, JSON.parse(a));
            }
          }
        }
        e.storage = r;
        e.hydrating = !1;
        clearDataState();
      })(o.data, e.storage, r);
      if (e.storage.onCacheHydrated) {
        e.storage.onCacheHydrated();
      }
    }));
  }
  var f = new Map;
  var y = [];
  var h = new Map;
  var m = new Map;
  var g = new Set;
  var N = new Set;
  var _ = new Map;
  var k = new Set;
  var E = new Set;
  var isBlockedByOptimisticUpdate = e => {
    for (var r of e.values()) {
      if (g.has(r)) {
        return !0;
      }
    }
    return !1;
  };
  var collectPendingOperations = (e, r) => {
    if (r) {
      for (var t of r.values()) {
        var i = _.get(t);
        if (i) {
          for (var a of i.values()) {
            e.add(a);
          }
        }
      }
    }
  };
  var executePendingOperations = (e, r, t) => {
    for (var i of r.values()) {
      if (i !== e.key) {
        var n = h.get(i);
        if (n) {
          if ("query" === e.kind) {
            E.add(i);
          }
          var o = "cache-first";
          if (N.has(i)) {
            N.delete(i);
            o = "cache-and-network";
          }
          a.reexecuteOperation(toRequestPolicy(n, o));
        }
      }
    }
    if (!t) {
      var s = k;
      if ("query" === e.kind) {
        (k = E).add(e.key);
      }
      (E = s).clear();
    }
  };
  var prepareForwardedOperation = e => {
    var t = !1;
    if ("query" === e.kind) {
      reserveLayer(o.data, e.key);
      h.set(e.key, e);
    } else if ("teardown" === e.kind) {
      h.delete(e.key);
      m.delete(e.key);
      k.delete(e.key);
      noopDataState(o.data, e.key);
      return e;
    } else if ("mutation" === e.kind && "network-only" !== e.context.requestPolicy) {
      h.set(e.key, e);
      initDataState("write", o.data, e.key, !0, !1);
      var {dependencies: a} = _write(o, e, void 0, void 0);
      clearDataState();
      if (a.size) {
        for (var n of a.values()) {
          g.add(n);
        }
        f.set(e.key, a);
        var s = new Set;
        collectPendingOperations(s, a);
        executePendingOperations(e, s, !0);
        t = !0;
      }
    }
    return i(e.kind, {
      key: e.key,
      query: r(e.query),
      variables: e.variables ? filterVariables(getMainOperation(e.query), e.variables) : e.variables
    }, {
      ...e.context,
      optimistic: t
    });
  };
  var updateDependencies = (e, r) => {
    for (var t of r.values()) {
      var i = _.get(t);
      if (!i) {
        _.set(t, i = new Set);
      }
      i.add(e.key);
    }
  };
  var operationResultFromCache = e => {
    initDataState("read", o.data, void 0, !1, !1);
    var r = _query(o, e, m.get(e.key), void 0);
    clearDataState();
    var t = r.data ? !r.partial && !r.hasNext ? "hit" : "partial" : "miss";
    m.set(e.key, r.data);
    h.set(e.key, e);
    updateDependencies(e, r.dependencies);
    return {
      outcome: t,
      operation: e,
      data: r.data,
      dependencies: r.dependencies,
      hasNext: r.hasNext
    };
  };
  var updateCacheWithResult = (e, r) => {
    var t = h.get(e.operation.key) || e.operation;
    if ("mutation" === t.kind) {
      var i = f.get(t.key);
      collectPendingOperations(r, i);
      f.delete(t.key);
    }
    if ("subscription" === t.kind || e.hasNext) {
      reserveLayer(o.data, t.key, !0);
    }
    var a;
    var n = e.data;
    if (n) {
      initDataState("write", o.data, t.key, !1, !1);
      var s = _write(o, t, n, e.error).dependencies;
      clearDataState();
      collectPendingOperations(r, s);
      var l = "query" === t.kind ? m.get(t.key) : null;
      initDataState("read", o.data, t.key, !1, l !== n);
      var v = _query(o, t, l || n, e.error);
      clearDataState();
      n = v.data;
      if ("query" === t.kind) {
        collectPendingOperations(r, a = v.dependencies);
        m.set(t.key, n);
      }
    } else {
      noopDataState(o.data, t.key);
    }
    if (a) {
      updateDependencies(e.operation, a);
    }
    return {
      operation: t,
      data: n,
      error: e.error,
      extensions: e.extensions,
      hasNext: e.hasNext,
      stale: e.stale
    };
  };
  return e => {
    var r = s(l(operationResultFromCache)(v((e => "query" === e.kind && "network-only" !== e.context.requestPolicy))(e)));
    var i = v((e => "query" !== e.kind || "network-only" === e.context.requestPolicy))(e);
    var m = l((e => {
      "production" !== process.env.NODE_ENV && n({
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache",
        operation: e.operation,
        source: "cacheExchange"
      });
      return "production" !== process.env.NODE_ENV ? addMetadata(e.operation, {
        cacheOutcome: "miss"
      }) : e.operation;
    }))(v((e => "miss" === e.outcome && "cache-only" !== e.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e.dependencies) && !k.has(e.operation.key)))(r));
    var _ = l((e => {
      var {requestPolicy: r} = e.operation.context;
      var t = "cache-only" !== r && (e.hasNext || "cache-and-network" === r || "cache-first" === r && "partial" === e.outcome && !k.has(e.operation.key));
      var i = {
        operation: "production" !== process.env.NODE_ENV ? addMetadata(e.operation, {
          cacheOutcome: e.outcome
        }) : e.operation,
        data: e.data,
        error: e.error,
        extensions: e.extensions,
        stale: t && !e.hasNext,
        hasNext: t && e.hasNext
      };
      if (!t) {} else if (!isBlockedByOptimisticUpdate(e.dependencies)) {
        a.reexecuteOperation(toRequestPolicy(h.get(e.operation.key) || e.operation, "network-only"));
      } else if ("cache-and-network" === r) {
        N.add(e.operation.key);
      }
      "production" !== process.env.NODE_ENV && n({
        type: "cacheHit",
        message: "A requested operation was found and returned from the cache.",
        operation: e.operation,
        data: {
          value: i
        },
        source: "cacheExchange"
      });
      return i;
    }))(v((e => "miss" !== e.outcome || "cache-only" === e.operation.context.requestPolicy))(r));
    var E = t(l(prepareForwardedOperation)(d([ i, m ])));
    var O = l((e => {
      var r = new Set;
      var t = updateCacheWithResult(e, r);
      executePendingOperations(e.operation, r, !1);
      return t;
    }))(v((e => !f.has(e.operation.key)))(E));
    var w = u((e => {
      if (y.push(e) < f.size) {
        return c;
      }
      for (var r = 0; r < y.length; r++) {
        reserveLayer(o.data, y[r].operation.key);
      }
      g.clear();
      var t = [];
      var i = new Set;
      var a;
      while (a = y.shift()) {
        t.push(updateCacheWithResult(a, i));
      }
      executePendingOperations(e.operation, i, !1);
      return p(t);
    }))(v((e => f.has(e.operation.key)))(E));
    return d([ O, w, _ ]);
  };
};

var K = {
  "cache-only": 0,
  "cache-first": 1,
  "network-only": 2,
  "cache-and-network": 3
};

var offlineExchange = e => r => {
  var {storage: n} = e;
  var o = e.isOfflineError || (e => e && e.networkError && !e.response && ("undefined" != typeof navigator && !1 === navigator.onLine || /request failed|failed to fetch|network\s?error/i.test(e.networkError.message)));
  if (n && n.onOnline && n.readMetadata && n.writeMetadata) {
    var {forward: l, client: u, dispatchDebug: c} = r;
    var {source: p, next: h} = f();
    var m = [];
    var g = !1;
    var N = !1;
    var updateMetadata = () => {
      if (g) {
        var e = [];
        for (var r = 0; r < m.length; r++) {
          var t = m[r];
          if ("mutation" === t.kind) {
            e.push({
              query: a(t.query),
              variables: t.variables,
              extensions: t.extensions
            });
          }
        }
        n.writeMetadata(e);
      }
    };
    var filterQueue = e => {
      for (var r = m.length - 1; r >= 0; r--) {
        if (m[r].key === e) {
          m.splice(r, 1);
        }
      }
    };
    var flushQueue = () => {
      if (!N) {
        var e = new Set;
        N = !0;
        for (var r = 0; r < m.length; r++) {
          var t = m[r];
          if ("mutation" === t.kind || !e.has(t.key)) {
            e.add(t.key);
            if ("subscription" !== t.kind) {
              h(i("teardown", t));
              var a = "cache-first";
              for (var n = 0; n < m.length; n++) {
                var {requestPolicy: o} = m[n].context;
                if (K[o] > K[a]) {
                  a = o;
                }
              }
              h(toRequestPolicy(t, a));
            } else {
              h(toRequestPolicy(t, "cache-first"));
            }
          }
        }
        N = !1;
        m.length = 0;
        updateMetadata();
      }
    };
    var _ = cacheExchange({
      ...e,
      storage: {
        ...n,
        readData() {
          var e = n.readData();
          return {
            async then(r) {
              var i = await n.readMetadata();
              for (var a = 0; i && a < i.length; a++) {
                m.push(u.createRequestOperation("mutation", t(i[a].query, i[a].variables), i[a].extensions));
              }
              r(await e);
              n.onOnline(flushQueue);
              g = !0;
              flushQueue();
            }
          };
        }
      }
    })({
      client: u,
      dispatchDebug: c,
      forward: e => s(v((e => {
        if (g && "mutation" === e.operation.kind && e.operation.context.optimistic && o(e.error, e)) {
          m.push(e.operation);
          updateMetadata();
          return !1;
        }
        return !0;
      }))(l(e)))
    });
    return e => {
      var r = d([ p, y((e => {
        if ("query" === e.kind && !g) {
          m.push(e);
        } else if ("teardown" === e.kind) {
          filterQueue(e.key);
        }
      }))(e) ]);
      return v((e => {
        if ("query" === e.operation.kind) {
          if (o(e.error, e)) {
            h(toRequestPolicy(e.operation, "cache-only"));
            m.push(e.operation);
            return !1;
          } else if (!g) {
            filterQueue(e.operation.key);
          }
        }
        return !0;
      }))(_(r));
    };
  }
  return cacheExchange(e)(r);
};

export { Store, cacheExchange, offlineExchange };
//# sourceMappingURL=urql-exchange-graphcache.mjs.map
